Index: trunk/src/plugins/org/pathvisio/visualization/plugins/ExpressionImagePlugin.java
===================================================================
--- trunk/src/plugins/org/pathvisio/visualization/plugins/ExpressionImagePlugin.java	(revision 976)
+++ trunk/src/plugins/org/pathvisio/visualization/plugins/ExpressionImagePlugin.java	(revision 977)
@@ -72,9 +72,8 @@
 import org.pathvisio.data.Gex;
 import org.pathvisio.data.Gdb.IdCodePair;
 import org.pathvisio.data.Gex.Sample;
-import org.pathvisio.gui.swt.SwtEngine;
 import org.pathvisio.util.ColorConverter;
-import org.pathvisio.util.SwtUtils;
+import org.pathvisio.util.swt.SwtUtils;
 import org.pathvisio.view.Graphics;
 import org.pathvisio.visualization.Visualization;
 import org.pathvisio.visualization.colorset.ColorSet;
Index: trunk/src/plugins/org/pathvisio/visualization/plugins/ExpressionAsTextPlugin.java
===================================================================
--- trunk/src/plugins/org/pathvisio/visualization/plugins/ExpressionAsTextPlugin.java	(revision 976)
+++ trunk/src/plugins/org/pathvisio/visualization/plugins/ExpressionAsTextPlugin.java	(revision 977)
@@ -57,7 +57,7 @@
 import org.pathvisio.data.CachedData.Data;
 import org.pathvisio.data.Gdb.IdCodePair;
 import org.pathvisio.data.Gex.Sample;
-import org.pathvisio.util.SwtUtils;
+import org.pathvisio.util.swt.SwtUtils;
 import org.pathvisio.view.GeneProduct;
 import org.pathvisio.view.Graphics;
 import org.pathvisio.visualization.Visualization;
Index: trunk/src/plugins/org/pathvisio/visualization/plugins/PluginWithColoredSamples.java
===================================================================
--- trunk/src/plugins/org/pathvisio/visualization/plugins/PluginWithColoredSamples.java	(revision 976)
+++ trunk/src/plugins/org/pathvisio/visualization/plugins/PluginWithColoredSamples.java	(revision 977)
@@ -67,8 +67,8 @@
 import org.pathvisio.data.Gex;
 import org.pathvisio.data.Gdb.IdCodePair;
 import org.pathvisio.data.Gex.Sample;
-import org.pathvisio.util.SwtUtils;
-import org.pathvisio.util.TableColumnResizer;
+import org.pathvisio.util.swt.SwtUtils;
+import org.pathvisio.util.swt.TableColumnResizer;
 import org.pathvisio.view.GeneProduct;
 import org.pathvisio.view.Graphics;
 import org.pathvisio.view.swt.SWTGraphics2D;
Index: trunk/src/plugins/org/pathvisio/visualization/plugins/ExpressionColorPlugin.java
===================================================================
--- trunk/src/plugins/org/pathvisio/visualization/plugins/ExpressionColorPlugin.java	(revision 976)
+++ trunk/src/plugins/org/pathvisio/visualization/plugins/ExpressionColorPlugin.java	(revision 977)
@@ -48,7 +48,7 @@
 import org.pathvisio.data.Gdb.IdCodePair;
 import org.pathvisio.data.Gex.Sample;
 import org.pathvisio.util.ColorConverter;
-import org.pathvisio.util.SwtUtils;
+import org.pathvisio.util.swt.SwtUtils;
 import org.pathvisio.view.Graphics;
 import org.pathvisio.visualization.Visualization;
 import org.pathvisio.visualization.colorset.ColorSet;
Index: trunk/src/plugins/org/pathvisio/visualization/plugins/LabelPlugin.java
===================================================================
--- trunk/src/plugins/org/pathvisio/visualization/plugins/LabelPlugin.java	(revision 976)
+++ trunk/src/plugins/org/pathvisio/visualization/plugins/LabelPlugin.java	(revision 977)
@@ -41,8 +41,8 @@
 import org.jdom.Element;
 import org.pathvisio.Engine;
 import org.pathvisio.util.ColorConverter;
-import org.pathvisio.util.SwtUtils;
 import org.pathvisio.util.Utils;
+import org.pathvisio.util.swt.SwtUtils;
 import org.pathvisio.view.GeneProduct;
 import org.pathvisio.view.Graphics;
 import org.pathvisio.visualization.Visualization;
Index: trunk/src/v2/org/pathvisio/R/wizard/RWizard.java
===================================================================
--- trunk/src/v2/org/pathvisio/R/wizard/RWizard.java	(revision 976)
+++ trunk/src/v2/org/pathvisio/R/wizard/RWizard.java	(revision 977)
@@ -29,7 +29,7 @@
 import org.pathvisio.R.RDataIn;
 import org.pathvisio.R.RCommands.RException;
 import org.pathvisio.R.RCommands.RObjectContainer;
-import org.pathvisio.util.SwtUtils.SimpleRunnableWithProgress;
+import org.pathvisio.util.swt.SwtUtils.SimpleRunnableWithProgress;
 
 
 public class RWizard extends Wizard {
Index: trunk/src/v2/org/pathvisio/R/wizard/PageStats.java
===================================================================
--- trunk/src/v2/org/pathvisio/R/wizard/PageStats.java	(revision 976)
+++ trunk/src/v2/org/pathvisio/R/wizard/PageStats.java	(revision 977)
@@ -40,7 +40,7 @@
 import org.pathvisio.R.RCommands.RException;
 import org.pathvisio.R.RFunctionLoader.RFunction;
 import org.pathvisio.gui.swt.SwtEngine;
-import org.pathvisio.util.SwtUtils.SimpleRunnableWithProgress;
+import org.pathvisio.util.swt.SwtUtils.SimpleRunnableWithProgress;
 
 public class PageStats extends WizardPage {
 	String resultVar;
Index: trunk/src/v2/org/pathvisio/R/RCommands.java
===================================================================
--- trunk/src/v2/org/pathvisio/R/RCommands.java	(revision 976)
+++ trunk/src/v2/org/pathvisio/R/RCommands.java	(revision 977)
@@ -25,13 +25,12 @@
 import java.util.Set;
 import java.util.TreeSet;
 
+import org.pathvisio.R.RDataOut.RObject;
+import org.pathvisio.util.Utils;
+import org.pathvisio.util.swt.SwtUtils.SimpleRunnableWithProgress;
 import org.rosuda.JRI.REXP;
 import org.rosuda.JRI.Rengine;
 
-import org.pathvisio.util.Utils;
-import org.pathvisio.util.SwtUtils.SimpleRunnableWithProgress;
-import org.pathvisio.R.RDataOut.RObject;
-
 /**
  * This class contains static wrappers for commands to be evaluated in R
  * @author thomas
Index: trunk/src/v2/org/pathvisio/R/RDataOut.java
===================================================================
--- trunk/src/v2/org/pathvisio/R/RDataOut.java	(revision 976)
+++ trunk/src/v2/org/pathvisio/R/RDataOut.java	(revision 977)
@@ -40,7 +40,7 @@
 import org.pathvisio.util.FileUtils;
 import org.pathvisio.util.PathwayParser;
 import org.pathvisio.util.PathwayParser.Gene;
-import org.pathvisio.util.SwtUtils.SimpleRunnableWithProgress;
+import org.pathvisio.util.swt.SwtUtils.SimpleRunnableWithProgress;
 import org.pathvisio.visualization.colorset.Criterion;
 import org.rosuda.JRI.REXP;
 import org.rosuda.JRI.RVector;
Index: trunk/src/v2/org/pathvisio/R/RFunctionLoader.java
===================================================================
--- trunk/src/v2/org/pathvisio/R/RFunctionLoader.java	(revision 976)
+++ trunk/src/v2/org/pathvisio/R/RFunctionLoader.java	(revision 977)
@@ -56,7 +56,7 @@
 import org.pathvisio.R.wizard.RWizard;
 import org.pathvisio.util.JarUtils;
 import org.pathvisio.util.Utils;
-import org.pathvisio.util.SwtUtils.SimpleRunnableWithProgress;
+import org.pathvisio.util.swt.SwtUtils.SimpleRunnableWithProgress;
 import org.pathvisio.visualization.colorset.Criterion;
 import org.pathvisio.visualization.colorset.CriterionComposite;
 
Index: trunk/src/v2/org/pathvisio/gui/swt/MainWindow.java
===================================================================
--- trunk/src/v2/org/pathvisio/gui/swt/MainWindow.java	(revision 976)
+++ trunk/src/v2/org/pathvisio/gui/swt/MainWindow.java	(revision 977)
@@ -26,15 +26,10 @@
 import org.eclipse.jface.action.ToolBarContributionItem;
 import org.eclipse.jface.action.ToolBarManager;
 import org.eclipse.jface.dialogs.MessageDialog;
-import org.eclipse.jface.dialogs.ProgressMonitorDialog;
 import org.eclipse.jface.resource.ImageDescriptor;
 import org.eclipse.jface.wizard.WizardDialog;
 import org.eclipse.swt.SWT;
-import org.eclipse.swt.custom.SashForm;
-import org.eclipse.swt.custom.ScrolledComposite;
-import org.eclipse.swt.layout.FillLayout;
 import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Control;
 import org.eclipse.swt.widgets.FileDialog;
 import org.eclipse.swt.widgets.Shell;
 import org.pathvisio.Engine;
@@ -42,16 +37,15 @@
 import org.pathvisio.R.RDataIn;
 import org.pathvisio.R.RCommands.RException;
 import org.pathvisio.R.wizard.RWizard;
-import org.pathvisio.data.DBConnector;
+import org.pathvisio.data.DBConnectorSwt;
 import org.pathvisio.data.Gdb;
 import org.pathvisio.data.Gex;
 import org.pathvisio.data.GexImportWizard;
+import org.pathvisio.data.GexSwt;
 import org.pathvisio.data.Gex.ExpressionDataEvent;
 import org.pathvisio.data.Gex.ExpressionDataListener;
-import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.data.GexSwt.ProgressWizardDialog;
 import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
-import org.pathvisio.search.PathwaySearchComposite;
-import org.pathvisio.visualization.LegendPanel;
 import org.pathvisio.visualization.VisualizationDialog;
 import org.pathvisio.visualization.VisualizationManager;
 
@@ -77,7 +71,7 @@
 		
 		public void run () {
 			try {
-				DBConnector dbcon = Gex.getDBConnector();
+				DBConnectorSwt dbcon = GexSwt.getDBConnector();
 				String dbName = dbcon.openChooseDbDialog(getShell());
 				
 				if(dbName == null) return;
@@ -117,7 +111,7 @@
 						"select gene database before creating a new expression dataset");
 				return;
 			}
-			WizardDialog dialog = new WizardDialog(getShell(), new GexImportWizard());
+			ProgressWizardDialog dialog = new ProgressWizardDialog(getShell(), new GexImportWizard());
 			dialog.setBlockOnOpen(true);
 			dialog.open();
 		}
@@ -125,126 +119,6 @@
 	private CreateGexAction createGexAction = new CreateGexAction(this);
 	
 	/**
-	 *{@link Action} to start conversion of a GenMAPP gex to an expression database in
-	 * pgex format
-	 */
-	private class ConvertGexAction extends Action
-	{
-		MainWindow window;
-		public ConvertGexAction(MainWindow w)
-		{
-			window = w;
-			setText("&Gex to PathVisio");
-			setToolTipText("Convert from GenMAPP 2 Gex to PathVisio Expression Data");
-		}
-		
-		public void run () {
-			File gexFile = null;
-			File gmGexFile = null;
-			
-			// Initialize filedialog to open GenMAPP gex
-			FileDialog fileDialog = new FileDialog(getShell(), SWT.OPEN);
-			fileDialog.setText("Select Expression Dataset to convert");
-			fileDialog.setFilterPath("C:\\GenMAPP 2 Data\\Expression Datasets");
-			fileDialog.setFilterExtensions(new String[] {"*.gex","*.*"});
-			fileDialog.setFilterNames(new String[] {"Expression Dataset (*.gex)","All files (*.*)"});
-			String file = fileDialog.open();
-			// Only proceed if user selected a file
-			if(file == null) return;
-			gmGexFile = new File(file);
-			
-			String dbName = null;
-			try {
-				DBConnector dbcon = Gex.getDBConnector();
-				dbName = dbcon.openNewDbDialog(getShell(), 
-						gmGexFile.getName().replace(".gex", ".properties"));
-			} catch(Exception e) {
-				String msg = "Failed to get database connector" + e.getMessage();
-				MessageDialog.openError (window.getShell(), "Error", 
-						"Error: " + msg + "\n\n" + 
-						"See the error log for details.");
-				Engine.log.error(msg, e);
-			}
-			
-			// Only proceed if user selected a file
-			if(dbName != null) {
-				Gex.setDbName(dbName);
-				Gex.setGmGexFile(gmGexFile);
-				ProgressMonitorDialog dialog = new ProgressMonitorDialog(getShell());
-				try {
-					dialog.run(true, true, Gex.convertRunnable);
-				} catch(Exception e) {
-					String msg = "While converting GenMAPP GEX: " + e.getMessage();
-					MessageDialog.openError (window.getShell(), "Error", 
-							"Error: " + msg + "\n\n" + 
-							"See the error log for details.");
-					Engine.log.error(msg, e);
-				}
-				
-			}
-		}
-	}
-	private ConvertGexAction convertGexAction = new ConvertGexAction(this);
-	
-	/**
-	 * {@link Action} to start conversion of a GenMAPP Gene database to a gene database 
-	 * in hsqldb format
-	 */
-	private class ConvertGdbAction extends Action
-	{
-		MainWindow window;
-		public ConvertGdbAction(MainWindow w)
-		{
-			window = w;
-			setText("&Gdb to PathVisio");
-			setToolTipText("Convert from GenMAPP 2 Gene database to PathVisio Gene database");
-		}
-		
-		public void run () {
-			String dbName = null;
-			File gmGdbFile = null;
-			// Initialize filedialog to open GenMAPP gdb
-			FileDialog fileDialog = new FileDialog(getShell(), SWT.OPEN);
-			fileDialog.setText("Select Gene database to convert");
-			fileDialog.setFilterPath("C:\\GenMAPP 2 Data\\Gene Databases");
-			fileDialog.setFilterExtensions(new String[] {"*.gdb","*.*"});
-			fileDialog.setFilterNames(new String[] {"Gene database (*.gdb)","All files (*.*)"});
-			String file = fileDialog.open();
-			// Only proceed if user selected a file
-			if(file == null) return;
-			gmGdbFile = new File(file);
-
-			try {
-				DBConnector dbcon = Gex.getDBConnector();
-				dbName = dbcon.openNewDbDialog(getShell(), 
-						gmGdbFile.getName().replace(".gdb", ".properties"));
-			} catch(Exception e) {
-				MessageDialog.openError(getShell(), 
-						"Error", "Unable to create database connector, " +
-						"see error log for details");
-				Engine.log.error("Unable to create database connector", e);	
-			}
-			
-			// Only proceed if user selected a database name
-			if(dbName != null) {
-				Gdb.setConvertGdbName(dbName);
-				Gdb.setConvertGmGdbFile(gmGdbFile);
-				ProgressMonitorDialog dialog = new ProgressMonitorDialog(getShell());
-				try {
-					dialog.run(true, true, Gdb.getConvertRunnable());
-				} catch(Exception e) {
-					String msg = "While converting GenMAPP gene database: "+ e.getMessage();
-					MessageDialog.openError (window.getShell(), "Error", 
-							"Error: " + msg + "\n\n" + 
-					"See the error log for details.");
-					Engine.log.error(msg, e);
-				}
-			}
-		}
-	}
-	private ConvertGdbAction convertGdbAction = new ConvertGdbAction(this);
-	
-	/**
 	 * {@link Action} to open the {@link ColorSetWindow}
 	 */
 	private class ColorSetManagerAction extends Action implements ExpressionDataListener
@@ -420,10 +294,6 @@
 			statsMenu.add(rLoadStatsAction);
 		}
 		dataMenu.add(new CommonActions.BiopaxAction(this));
-		MenuManager convertMenu = new MenuManager("&Convert from GenMAPP 2");
-		convertMenu.add(convertGexAction);
-		convertMenu.add(convertGdbAction);
-		dataMenu.add(convertMenu);
 		
 		MenuManager helpMenu = new MenuManager ("&Help");
 		helpMenu.add(aboutAction);
Index: trunk/src/core/org/pathvisio/Engine.java
===================================================================
--- trunk/src/core/org/pathvisio/Engine.java	(revision 976)
+++ trunk/src/core/org/pathvisio/Engine.java	(revision 977)
@@ -24,7 +24,7 @@
 import java.util.HashMap;
 import java.util.List;
 
-import org.pathvisio.data.DBConnector;
+import org.pathvisio.data.DBConnectorSwt;
 import org.pathvisio.debug.Logger;
 import org.pathvisio.model.ConverterException;
 import org.pathvisio.model.Pathway;
@@ -241,14 +241,14 @@
 		return importers;
 	}
 	
-	public static DBConnector getDbConnector(int type) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
-		DBConnector connector = null;
+	public static DBConnectorSwt getDbConnector(int type) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
+		DBConnectorSwt connector = null;
 		String className = null;
 		switch(type) {
-		case DBConnector.TYPE_GDB:
+		case DBConnectorSwt.TYPE_GDB:
 			className = SwtPreference.SWT_DB_ENGINE_GDB.getValue();
 			break;
-		case DBConnector.TYPE_GEX:
+		case DBConnectorSwt.TYPE_GEX:
 			className = SwtPreference.SWT_DB_ENGINE_GDB.getValue();
 			break;
 		}
@@ -256,8 +256,8 @@
 		
 		Class dbc = Class.forName(className);
 		
-		if(Utils.isSubClass(dbc, DBConnector.class)) {
-			connector = (DBConnector)dbc.newInstance();
+		if(Utils.isSubClass(dbc, DBConnectorSwt.class)) {
+			connector = (DBConnectorSwt)dbc.newInstance();
 			connector.setDbType(type);
 		}
 	
Index: trunk/src/core/org/pathvisio/debug/Sleak.java
===================================================================
--- trunk/src/core/org/pathvisio/debug/Sleak.java	(revision 976)
+++ trunk/src/core/org/pathvisio/debug/Sleak.java	(revision 977)
@@ -1,310 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-/*
- * Copyright (c) 2000, 2002 IBM Corp.  All rights reserved.
- * This file is made available under the terms of the Common Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/cpl-v10.html
- */
-package org.pathvisio.debug;
-
-import java.io.ByteArrayOutputStream;
-import java.io.PrintStream;
-
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.graphics.Color;
-import org.eclipse.swt.graphics.Cursor;
-import org.eclipse.swt.graphics.DeviceData;
-import org.eclipse.swt.graphics.Font;
-import org.eclipse.swt.graphics.FontData;
-import org.eclipse.swt.graphics.GC;
-import org.eclipse.swt.graphics.Image;
-import org.eclipse.swt.graphics.Point;
-import org.eclipse.swt.graphics.Rectangle;
-import org.eclipse.swt.graphics.Region;
-import org.eclipse.swt.widgets.Button;
-import org.eclipse.swt.widgets.Canvas;
-import org.eclipse.swt.widgets.Display;
-import org.eclipse.swt.widgets.Event;
-import org.eclipse.swt.widgets.Label;
-import org.eclipse.swt.widgets.List;
-import org.eclipse.swt.widgets.Listener;
-import org.eclipse.swt.widgets.MessageBox;
-import org.eclipse.swt.widgets.Shell;
-import org.eclipse.swt.widgets.Text;
-
-/**
-   Debugging helper. Sleak can check if all SWT resources are properly disposed, to help
-   avoid resource leaks.
-*/
-public class Sleak
-{
-	Display display;
-	Shell shell;
-	List list;
-	Canvas canvas;
-	Button start, stop, check;
-	Text text;
-	Label label;
-	
-	Object [] oldObjects = new Object [0];
-	Error [] oldErrors = new Error [0];
-	Object [] objects = new Object [0];
-	Error [] errors = new Error [0];
-	
-public void open () {
-	display = Display.getCurrent ();
-	shell = new Shell (display);
-	shell.setText ("S-Leak");
-	list = new List (shell, SWT.BORDER | SWT.V_SCROLL);
-	list.addListener (SWT.Selection, new Listener () {
-		public void handleEvent (Event event) {
-			refreshObject ();
-		}
-	});
-	text = new Text (shell, SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
-	canvas = new Canvas (shell, SWT.BORDER);
-	canvas.addListener (SWT.Paint, new Listener () {
-		public void handleEvent (Event event) {
-			paintCanvas (event);
-		}
-	});
-	check = new Button (shell, SWT.CHECK);
-	check.setText ("Stack");
-	check.addListener (SWT.Selection, new Listener () {
-		public void handleEvent (Event e) {
-			toggleStackTrace ();
-		}
-	});
-	start = new Button (shell, SWT.PUSH);
-	start.setText ("Snap");
-	start.addListener (SWT.Selection, new Listener () {
-		public void handleEvent (Event event) {
-			refreshAll ();
-		}
-	});
-	stop = new Button (shell, SWT.PUSH);
-	stop.setText ("Diff");
-	stop.addListener (SWT.Selection, new Listener () {
-		public void handleEvent (Event event) {
-			refreshDifference ();
-		}
-	});
-	label = new Label (shell, SWT.BORDER);
-	label.setText ("0 object(s)");
-	shell.addListener (SWT.Resize, new Listener () {
-		public void handleEvent (Event e) {
-			layout ();
-		}
-	});
-	check.setSelection (false);
-	text.setVisible (false);
-	Point size = shell.getSize ();
-	shell.setSize (size.x / 2, size.y / 2);
-	shell.open ();
-}
-
-void refreshLabel () {
-	int colors = 0, cursors = 0, fonts = 0, gcs = 0, images = 0, regions = 0;
-	for (int i=0; i<objects.length; i++) {
-		Object object = objects [i];
-		if (object instanceof Color) colors++;
-		if (object instanceof Cursor) cursors++;
-		if (object instanceof Font) fonts++;
-		if (object instanceof GC) gcs++;
-		if (object instanceof Image) images++;
-		if (object instanceof Region) regions++;
-	}
-	String string = "";
-	if (colors != 0) string += colors + " Color(s)\n";
-	if (cursors != 0) string += cursors + " Cursor(s)\n";
-	if (fonts != 0) string += fonts + " Font(s)\n";
-	if (gcs != 0) string += gcs + " GC(s)\n";
-	if (images != 0) string += images + " Image(s)\n";
-	/* Currently regions are not counted. */
-//	if (regions != 0) string += regions + " Region(s)\n";
-	if (string.length () != 0) {
-		string = string.substring (0, string.length () - 1);
-	}
-	label.setText (string);
-}
-
-void refreshDifference () {
-	DeviceData info = display.getDeviceData ();
-	if (!info.tracking) {
-		MessageBox dialog = new MessageBox (shell, SWT.ICON_WARNING | SWT.OK);
-		dialog.setText (shell.getText ());
-		dialog.setMessage ("Warning: Device is not tracking resource allocation");
-		dialog.open ();
-	}
-	Object [] newObjects = info.objects;
-	Error [] newErrors = info.errors;
-	Object [] diffObjects = new Object [newObjects.length];
-	Error [] diffErrors = new Error [newErrors.length];
-	int count = 0;
-	for (int i=0; i<newObjects.length; i++) {
-		int index = 0;
-		while (index < oldObjects.length) {
-			if (newObjects [i] == oldObjects [index]) break;
-			index++;
-		}
-		if (index == oldObjects.length) {
-			diffObjects [count] = newObjects [i];
-			diffErrors [count] = newErrors [i];
-			count++;
-		}
-	}
-	objects = new Object [count];
-	errors = new Error [count];
-	System.arraycopy (diffObjects, 0, objects, 0, count);
-	System.arraycopy (diffErrors, 0, errors, 0, count);
-	list.removeAll ();
-	text.setText ("");
-	canvas.redraw ();
-	for (int i=0; i<objects.length; i++) {
-		list.add (objectName (objects [i]));
-	}
-	refreshLabel ();
-	layout ();
-}
-
-String objectName (Object object) {
-	String string = object.toString ();
-	int index = string.lastIndexOf ('.');
-	if (index == -1) return string;
-	return string.substring (index + 1, string.length ());
-}
-
-void toggleStackTrace () {
-	refreshObject ();
-	layout ();
-}
-
-void paintCanvas (Event event) {
-	canvas.setCursor (null);
-	int index = list.getSelectionIndex ();
-	if (index == -1) return;
-	GC gc = event.gc;
-	Object object = objects [index];
-	if (object instanceof Color) {
-		if (((Color)object).isDisposed ()) return;
-		gc.setBackground ((Color) object);
-		gc.fillRectangle (canvas.getClientArea());
-		return;
-	}
-	if (object instanceof Cursor) {
-		if (((Cursor)object).isDisposed ()) return;
-		canvas.setCursor ((Cursor) object);
-		return;
-	}
-	if (object instanceof Font) {
-		if (((Font)object).isDisposed ()) return;
-		gc.setFont ((Font) object);
-		FontData [] array = gc.getFont ().getFontData ();
-		String string = "";
-		String lf = text.getLineDelimiter ();
-		for (int i=0; i<array.length; i++) {
-			FontData data = array [i];
-			String style = "NORMAL";
-			int bits = data.getStyle ();
-			if (bits != 0) {
-				if ((bits & SWT.BOLD) != 0) style = "BOLD ";
-				if ((bits & SWT.ITALIC) != 0) style += "ITALIC";
-			}
-			string += data.getName () + " " + data.getHeight () + " " + style + lf;
-		}
-		gc.drawString (string, 0, 0);
-		return;
-	}
-	//NOTHING TO DRAW FOR GC
-//	if (object instanceof GC) {
-//		return;
-//	}
-	if (object instanceof Image) {
-		if (((Image)object).isDisposed ()) return;
-		gc.drawImage ((Image) object, 0, 0);
-		return;
-	}
-	if (object instanceof Region) {
-		if (((Region)object).isDisposed ()) return;
-		String string = ((Region)object).getBounds().toString();
-		gc.drawString (string, 0, 0);
-		return;
-	}
-}
-
-void refreshObject () {
-	int index = list.getSelectionIndex ();
-	if (index == -1) return;
-	if (check.getSelection ()) {
-		ByteArrayOutputStream stream = new ByteArrayOutputStream ();
-		PrintStream s = new PrintStream (stream);
-		errors [index].printStackTrace (s);
-		text.setText (stream.toString ());
-		text.setVisible (true);
-		canvas.setVisible (false);
-	} else {
-		canvas.setVisible (true);
-		text.setVisible (false);
-		canvas.redraw ();
-	}
-}
-
-void refreshAll () {
-	oldObjects = new Object [0];
-	oldErrors = new Error [0];
-	refreshDifference ();
-	oldObjects = objects;
-	oldErrors = errors;
-}
-
-void layout () {
-	Rectangle rect = shell.getClientArea ();
-	int width = 0;
-	String [] items = list.getItems ();
-	GC gc = new GC (list);
-	for (int i=0; i<objects.length; i++) {
-		width = Math.max (width, gc.stringExtent (items [i]).x);
-	}
-	gc.dispose ();
-	Point size1 = start.computeSize (SWT.DEFAULT, SWT.DEFAULT);
-	Point size2 = stop.computeSize (SWT.DEFAULT, SWT.DEFAULT);
-	Point size3 = check.computeSize (SWT.DEFAULT, SWT.DEFAULT);
-	Point size4 = label.computeSize (SWT.DEFAULT, SWT.DEFAULT);
-	width = Math.max (size1.x, Math.max (size2.x, Math.max (size3.x, width)));
-	width = Math.max (64, Math.max (size4.x, list.computeSize (width, SWT.DEFAULT).x));
-	start.setBounds (0, 0, width, size1.y);
-	stop.setBounds (0, size1.y, width, size2.y);
-	check.setBounds (0, size1.y + size2.y, width, size3.y);
-	label.setBounds (0, rect.height - size4.y, width, size4.y);
-	int height = size1.y + size2.y + size3.y;
-	list.setBounds (0, height, width, rect.height - height - size4.y);
-	text.setBounds (width, 0, rect.width - width, rect.height);
-	canvas.setBounds (width, 0, rect.width - width, rect.height);
-}
-
-public static void main (String [] args) {
-	Display display = new Display ();
-	Sleak sleak = new Sleak ();
-	sleak.open ();
-	while (!sleak.shell.isDisposed ()) {
-		if (!display.readAndDispatch ()) display.sleep ();
-	}
-	display.dispose ();
-}
-		
-}
Index: trunk/src/core/org/pathvisio/data/GexImportWizard.java
===================================================================
--- trunk/src/core/org/pathvisio/data/GexImportWizard.java	(revision 976)
+++ trunk/src/core/org/pathvisio/data/GexImportWizard.java	(revision 977)
@@ -1,557 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.data;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.IOException;
-
-import org.eclipse.jface.dialogs.MessageDialog;
-import org.eclipse.jface.wizard.IWizardPage;
-import org.eclipse.jface.wizard.Wizard;
-import org.eclipse.jface.wizard.WizardPage;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.events.ControlAdapter;
-import org.eclipse.swt.events.ControlEvent;
-import org.eclipse.swt.events.ModifyEvent;
-import org.eclipse.swt.events.ModifyListener;
-import org.eclipse.swt.events.SelectionAdapter;
-import org.eclipse.swt.events.SelectionEvent;
-import org.eclipse.swt.graphics.Point;
-import org.eclipse.swt.graphics.Rectangle;
-import org.eclipse.swt.layout.FillLayout;
-import org.eclipse.swt.layout.GridData;
-import org.eclipse.swt.layout.GridLayout;
-import org.eclipse.swt.widgets.Button;
-import org.eclipse.swt.widgets.Combo;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.FileDialog;
-import org.eclipse.swt.widgets.Group;
-import org.eclipse.swt.widgets.Label;
-import org.eclipse.swt.widgets.List;
-import org.eclipse.swt.widgets.Spinner;
-import org.eclipse.swt.widgets.Table;
-import org.eclipse.swt.widgets.TableColumn;
-import org.eclipse.swt.widgets.TableItem;
-import org.eclipse.swt.widgets.Text;
-import org.pathvisio.Engine;
-import org.pathvisio.Globals;
-import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
-import org.pathvisio.util.TableColumnResizer;
-
-/**
- * This class is a {@link Wizard} that guides the user trough the process to
- * create an expression dataset from a delimited text file
- */
-public class GexImportWizard extends Wizard {
-	ImportInformation importInformation;
-
-	public GexImportWizard() {
-		importInformation = new ImportInformation();
-
-		setWindowTitle("Create an expression dataset");
-		setNeedsProgressMonitor(true);
-	}
-
-	public void addPages() {
-		addPage(new FilePage());
-		addPage(new HeaderPage());
-		addPage(new ColumnPage());
-		addPage(new ImportPage());
-	}
-
-	boolean importFinished;
-
-	public boolean performFinish() {
-		if (!importFinished) {
-			ImportPage ip = (ImportPage) getPage("ImportPage");
-			getContainer().showPage(ip);
-			try {
-				// Start import process
-				getContainer().run(true, true,
-						new Gex.ImportRunnableWithProgress(
-								importInformation,
-								(ImportPage) getPage("ImportPage")));
-			} catch (Exception e) {
-				Engine.log.error("while running expression data import process: " + e.getMessage(), e);
-			} // TODO: handle exception
-			ip.setTitle("Import finished");
-			ip.setDescription("Press finish to return to " + Globals.APPLICATION_VERSION_NAME);
-			importFinished = true;
-			return false;
-		}
-		if (importFinished
-				&& getContainer().getCurrentPage().getName().equals(
-						"ImportPage")) {
-			return true;
-		}
-		return false;
-	}
-
-	public boolean performCancel() {
-		return true; // Do nothing, just close wizard
-	}
-
-	/**
-	 * This is the wizard page to specify the location of the text file
-	 * containing expression data and the location to store the new expression
-	 * dataset
-	 */
-	public class FilePage extends WizardPage {
-		boolean txtFileComplete;
-
-		boolean gexFileComplete;
-
-		public FilePage() {
-			super("FilePage");
-			setTitle("File locations");
-			setDescription("Specify the locations of the file containing the expression data "
-					+ "and where to store the expression dataset");
-			setPageComplete(false);
-		}
-
-		public void createControl(Composite parent) {
-			final FileDialog fileDialog = new FileDialog(getShell(), SWT.OPEN);
-
-			Composite composite = new Composite(parent, SWT.NULL);
-			composite.setLayout(new GridLayout(2, false));
-
-			GridData labelGrid = new GridData(GridData.FILL_HORIZONTAL);
-			labelGrid.horizontalSpan = 2;
-
-			Label txtLabel = new Label(composite, SWT.FLAT);
-			txtLabel
-					.setText("Specify location of text file containing expression data");
-			txtLabel.setLayoutData(labelGrid);
-
-			final Text txtText = new Text(composite, SWT.SINGLE | SWT.BORDER);
-			txtText.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
-			Button txtButton = new Button(composite, SWT.PUSH);
-			txtButton.setText("Browse");
-
-			Label gexLabel = new Label(composite, SWT.FLAT);
-			gexLabel.setText("Specify location to save the expression dataset");
-			gexLabel.setLayoutData(labelGrid);
-
-			final Text gexText = new Text(composite, SWT.SINGLE | SWT.BORDER);
-			gexText.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
-			Button gexButton = new Button(composite, SWT.PUSH);
-			gexButton.setText("Browse");
-
-			txtButton.addSelectionListener(new SelectionAdapter() {
-				public void widgetSelected(SelectionEvent e) {
-					fileDialog
-							.setText("Select tab delimited text file containing expression data");
-					fileDialog.setFilterExtensions(new String[] { "*.txt",
-							"*.*" });
-					fileDialog.setFilterNames(new String[] { "Text file",
-							"All files" });
-					fileDialog.setFilterPath(SwtPreference.SWT_DIR_EXPR.getValue());
-					String file = fileDialog.open();
-					if (file != null) {
-						txtText.setText(file);
-						gexText.setText(file.replace(file.substring(file
-								.lastIndexOf(".")), ""));
-					}
-				}
-			});
-
-			gexButton.addSelectionListener(new SelectionAdapter() {
-				public void widgetSelected(SelectionEvent e) {
-					try {
-						DBConnector dbcon = Gex.getDBConnector();
-						String dbName = dbcon.openNewDbDialog(getShell(), gexText.getText());
-						if(dbName != null) gexText.setText(dbName);
-						
-					} catch(Exception ex) {
-						MessageDialog.openError(getShell(), "Error", "Unable to open connection dialog");
-						Engine.log.error("", ex);
-					}
-				}
-			});
-
-			txtText.addModifyListener(new ModifyListener() {
-				public void modifyText(ModifyEvent e) {
-					setTxtFile(new File(txtText.getText()));
-					setPageComplete(txtFileComplete && gexFileComplete);
-				}
-			});
-
-			gexText.addModifyListener(new ModifyListener() {
-				public void modifyText(ModifyEvent e) {
-					setDbName(gexText.getText());
-					setPageComplete(txtFileComplete && gexFileComplete);
-				}
-			});
-
-			composite.pack();
-			setControl(composite);
-		}
-
-		/**
-		 * Stores the given {@link File} pointing to the file containing the expresssion
-		 * data in text form to the {@link ImportInformation} object
-		 * @param file
-		 */
-		private void setTxtFile(File file) {
-			if (!file.exists()) {
-				setErrorMessage("Specified file to import does not exist");
-				txtFileComplete = false;
-				return;
-			}
-			if (!file.canRead()) {
-				setErrorMessage("Can't access specified file containing expression data");
-				txtFileComplete = false;
-				return;
-			}
-			importInformation.setTxtFile(file);
-			setErrorMessage(null);
-			txtFileComplete = true;
-		}
-
-		/**
-		 * Sets the name of the database to save the
-		 * expression database to the {@link ImportInformation} object
-		 * @param file
-		 */
-		private void setDbName(String name) {
-			importInformation.dbName = name;
-			setMessage("Expression dataset location: " + name);
-			gexFileComplete = true;
-		}
-
-		public IWizardPage getNextPage() {
-			setPreviewTableContent(previewTable); //Content of previewtable depends on file locations
-			return super.getNextPage();
-		}
-	}
-
-	Table previewTable;
-	
-	/**
-	 * This {@link WizardPage} is used to ask the user information about on which line the
-	 * column headers are and on which line the data starts
-	 */
-	public class HeaderPage extends WizardPage {
-
-		public HeaderPage() {
-			super("HeaderPage");
-			setTitle("Header information");
-			setDescription("Specify the line with the column headers and from where the data starts");
-			setPageComplete(true);
-		}
-		
-		Spinner startSpinner;
-		Spinner headerSpinner;
-		public void createControl(Composite parent) {
-			Composite composite = new Composite(parent, SWT.NULL);
-			composite.setLayout(new GridLayout(2, false));
-
-			Label headerLabel = new Label(composite, SWT.FLAT);
-			headerLabel.setText("Column headers at line: ");
-			headerSpinner = new Spinner(composite, SWT.BORDER);
-			headerSpinner.setMinimum(1);
-			headerSpinner.setSelection(importInformation.headerRow);
-
-			Label startLabel = new Label(composite, SWT.FLAT);
-			startLabel.setText("Data starts at line: ");
-			startSpinner = new Spinner(composite, SWT.BORDER);
-			startSpinner.setMinimum(1);
-			startSpinner.setSelection(importInformation.firstDataRow);
-
-			Group tableGroup = new Group(composite, SWT.SHADOW_ETCHED_IN);
-			GridData groupGrid = new GridData(GridData.FILL_BOTH);
-			groupGrid.horizontalSpan = 2;
-			groupGrid.widthHint = 300;
-			tableGroup.setLayoutData(groupGrid);
-			tableGroup.setLayout(new FillLayout());
-			tableGroup.setText("Preview of file to import");
-
-			previewTable = new Table(tableGroup, SWT.SINGLE | SWT.BORDER);
-			previewTable.setLinesVisible(true);
-			previewTable.setHeaderVisible(true);
-			TableColumn nrCol = new TableColumn(previewTable, SWT.LEFT);
-			nrCol.setText("line");
-			TableColumn txtCol = new TableColumn(previewTable, SWT.LEFT);
-			txtCol.setText("data");
-			nrCol.setWidth(40);
-			nrCol.setResizable(false);
-			previewTable.addControlListener(new TableColumnResizer(previewTable, tableGroup, new int[] {0, 100}));
-
-			composite.pack();
-			setControl(composite);
-		}
-
-		public IWizardPage getNextPage() {
-			importInformation.headerRow = headerSpinner.getSelection();
-			importInformation.firstDataRow = startSpinner.getSelection();
-			setColumnTableContent(columnTable);
-			setColumnControlsContent();
-			return super.getNextPage();
-		}
-	}
-
-	Table columnTable;
-	List columnList;
-	Combo codeCombo;
-	Combo idCombo;
-
-	/**
-	 * This is the wizard page to specify column information, e.g. which
-	 * are the gene id and systemcode columns
-	 */
-	public class ColumnPage extends WizardPage {
-
-		public ColumnPage() {
-			super("ColumnPage");
-			setTitle("Column information");
-			setDescription("Specify which columns contain the gene information and "
-					+ "which columns should not be treated as numeric data");
-			setPageComplete(true);
-		}
-
-		public void createControl(Composite parent) {
-			Composite composite = new Composite(parent, SWT.NULL);
-			composite.setLayout(new GridLayout(1, false));
-
-			Label idLabel = new Label(composite, SWT.FLAT);
-			idLabel.setText("Select column with gene identifiers");
-			idCombo = new Combo(composite, SWT.READ_ONLY);
-			idCombo.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
-			
-			Label sysLabel = new Label(composite, SWT.FLAT);
-			sysLabel.setText("Select column with Systemcode");
-			codeCombo = new Combo(composite, SWT.READ_ONLY);
-			codeCombo.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
-			
-			Label columnLabel = new Label(composite, SWT.FLAT | SWT.WRAP);
-			columnLabel
-					.setText("Select the columns containing data that should NOT be treated"
-							+ " as NUMERIC from the list below");
-
-			columnList = new List(composite, SWT.BORDER | SWT.MULTI
-					| SWT.V_SCROLL);
-			GridData listGrid = new GridData(GridData.FILL_HORIZONTAL);
-			listGrid.heightHint = 150;
-			columnList.setLayoutData(listGrid);
-			columnList.addSelectionListener(new SelectionAdapter() {
-				public void widgetSelected(SelectionEvent e) {
-					importInformation.setStringCols(columnList
-							.getSelectionIndices());
-				}
-			});
-			idCombo.addSelectionListener(new SelectionAdapter() {
-				public void widgetSelected(SelectionEvent e) {
-					importInformation.idColumn = idCombo.getSelectionIndex();
-				}
-			});
-			codeCombo.addSelectionListener(new SelectionAdapter() {
-				public void widgetSelected(SelectionEvent e) {
-					importInformation.codeColumn = codeCombo
-							.getSelectionIndex();
-				}
-			});
-
-			Group tableGroup = new Group(composite, SWT.SHADOW_ETCHED_IN);
-			GridData tableGrid = new GridData(GridData.FILL_BOTH);
-			tableGrid.heightHint = 100;
-			tableGroup.setLayoutData(tableGrid);
-			tableGroup.setLayout(new FillLayout());
-			tableGroup.setText("Preview of file to import");
-
-			columnTable = new Table(tableGroup, SWT.SINGLE | SWT.BORDER);
-			columnTable.setLinesVisible(true);
-			columnTable.setHeaderVisible(true);
-			columnTable.addControlListener(new TableColumnResizer(columnTable, tableGroup));
-
-			composite.pack();
-			setControl(composite);
-		}
-	}
-
-	/**
-	 * Sets the content of the Controls on the {@link ColumnPage}
-	 */
-	public void setColumnControlsContent() {
-		columnList.setItems(importInformation.getColNames());
-		columnList.setSelection(importInformation.getStringCols());
-		idCombo.setItems(importInformation.getColNames());
-		idCombo.select(importInformation.idColumn);
-		codeCombo.setItems(importInformation.getColNames());
-		codeCombo.select(importInformation.codeColumn);
-	}
-
-	/**
-	 * Sets the content of the given preview table (containing 2 columns: linenumber and textdata)
-	 * @param previewTable
-	 */
-	public void setPreviewTableContent(Table previewTable) {
-		previewTable.removeAll();
-		try {
-			int n = 50; // nr of lines to include in the preview
-			BufferedReader in = importInformation.getBufferedReader();
-			String line;
-			int i = 1;
-			while ((line = in.readLine()) != null && i <= n) {
-				TableItem ti = new TableItem(previewTable, SWT.NULL);
-				ti.setText(0, Integer.toString(i++));
-				ti.setText(1, line);
-			}
-		} catch (IOException e) { // TODO: handle IOException
-			Engine.log.error("while generating preview for importing expression data: " + e.getMessage(), e);
-		}
-		previewTable.pack();
-	}
-
-	/**
-	 * Sets teh content of the given columnTable (previews how the data will be divided in columns)
-	 * @param columnTable
-	 */
-	public void setColumnTableContent(Table columnTable) {
-		columnTable.removeAll();
-		for (TableColumn col : columnTable.getColumns())
-			col.dispose();
-		for (String colName : importInformation.getColNames()) {
-			TableColumn tc = new TableColumn(columnTable, SWT.NONE);
-			tc.setText(colName);
-		}
-		try {
-			int n = 50; // nr of lines to include in the preview
-			BufferedReader in = importInformation.getBufferedReader();
-			String line;
-			for (int i = 0; i < importInformation.firstDataRow - 1; i++)
-				in.readLine(); // Go to line where data starts
-			int j = 1;
-			while ((line = in.readLine()) != null && j++ < n) {
-				TableItem ti = new TableItem(columnTable, SWT.NULL);
-				ti.setText(line.split(ImportInformation.DELIMITER));
-			}
-		} catch (IOException e) { // TODO: handle IOException
-			Engine.log.error("while generating preview for importing expression data: " + e.getMessage(), e);
-		}
-		columnTable.pack();
-	}
-
-	/**
-	 * This page shows the progress and status of the import process
-	 */
-	public class ImportPage extends WizardPage {
-		Text progressText;
-
-		public ImportPage() {
-			super("ImportPage");
-			setTitle("Create expression dataset");
-			setDescription("Press finish button to create the expression dataset");
-			setPageComplete(true);
-
-		}
-
-		public void createControl(Composite parent) {
-			Composite composite = new Composite(parent, SWT.NULL);
-			composite.setLayout(new FillLayout());
-
-			progressText = new Text(composite, SWT.READ_ONLY | SWT.BORDER
-					| SWT.WRAP);
-			progressText.setText("Ready to import data" + Text.DELIMITER);
-			progressText.append("> Using gene database: "
-					+ Gdb.getDbName()
-					+ Text.DELIMITER);
-			progressText
-					.append("> If this is not the correct gene database, close this window"
-							+ " and change the gene database in the menu 'data' -> 'choose gene database'\n");
-			setControl(composite);
-		}
-
-		public void println(String text) {
-			appendProgressText(text, true);
-		}
-
-		public void print(String text) {
-			appendProgressText(text, false);
-		}
-		
-		public void appendProgressText(final String updateText,
-				final boolean newLine) {
-			if (progressText != null && !progressText.isDisposed())
-				progressText.getDisplay().asyncExec(new Runnable() {
-					public void run() {
-						progressText.append(updateText
-								+ (newLine ? progressText.getLineDelimiter()
-										: ""));
-					}
-				});
-		}
-
-		public IWizardPage getPreviousPage() {
-			// User pressed back, probably to change settings and redo the
-			// importing, so set importFinished to false
-			importFinished = false;
-			return super.getPreviousPage();
-		}
-	}
-
-	/**
-	 * {@link ControlAdapter} to fit the size of the table columns (for both previewTable and
-	 * columnTable) to the size of its parent composite
-	 */
-	class TableControlAdapter extends ControlAdapter {
-		Table table;
-
-		public TableControlAdapter(Table table) {
-			this.table = table;
-		}
-
-		public void controlResized(ControlEvent e) {
-			TableColumn[] cols = table.getColumns();
-			Rectangle area = table.getParent().getClientArea();
-			Point preferredSize = table.computeSize(SWT.DEFAULT, SWT.DEFAULT);
-			int width = area.width - 2 * table.getBorderWidth();
-			if (preferredSize.y > area.height + table.getHeaderHeight()) {
-				// Subtract the scrollbar width from the total column width
-				// if a vertical scrollbar will be required
-				Point vBarSize = table.getVerticalBar().getSize();
-				width -= vBarSize.x;
-			}
-			Point oldSize = table.getSize();
-			if (oldSize.x > area.width) {
-				// table is getting smaller so make the columns
-				// smaller first and then resize the table to
-				// match the client area width
-				if (cols.length == 2) { // This is the previewTable
-					cols[1].setWidth(width - cols[0].getWidth());
-				} else { // This is the columnTable
-					for (TableColumn col : cols) {
-						col.setWidth(width / cols.length);
-					}
-				}
-				table.setSize(area.width, area.height);
-			} else {
-				// table is getting bigger so make the table
-				// bigger first and then make the columns wider
-				// to match the client area width
-				table.setSize(area.width, area.height);
-				if (cols.length == 2) { // This is the previewTable
-					cols[1].setWidth(width - cols[0].getWidth());
-				} else { // This is the columnTable
-					for (TableColumn col : cols) {
-						col.setWidth(width / cols.length);
-					}
-				}
-			}
-		}
-	}
-}
\ No newline at end of file
Index: trunk/src/core/org/pathvisio/data/DBConnector.java
===================================================================
--- trunk/src/core/org/pathvisio/data/DBConnector.java	(revision 976)
+++ trunk/src/core/org/pathvisio/data/DBConnector.java	(revision 977)
@@ -1,259 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.data;
-
-import java.sql.Connection;
-import java.sql.SQLException;
-import java.sql.Statement;
-
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.widgets.DirectoryDialog;
-import org.eclipse.swt.widgets.FileDialog;
-import org.eclipse.swt.widgets.Shell;
-import org.pathvisio.Engine;
-import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
-
-/**
- * This class provides the connection for the databases (annotation and expression database) used
- * in PathVisio. Implement the abstract methods when you want to add support for a new database engine.
- * @author Thomas
- */
-public abstract class DBConnector {
-	protected final int PROP_NONE = 0;
-	protected static final int PROP_RECREATE = 4;
-	protected static final int PROP_FINALIZE = 8;
-	
-	/**
-	 * Type for gene database
-	 */
-	public static final int TYPE_GDB = 0;
-	/**
-	 * Type for expression database
-	 */
-	public static final int TYPE_GEX = 1;
-	
-	private int dbType;
-	
-	public abstract Connection createConnection(String dbName) throws Exception;
-	public abstract Connection createConnection(String dbName, int props) throws Exception;	
-	
-	/**
-	 * Close the given connection
-	 * @param con The connection to be closed
-	 * @throws Exception
-	 */
-	public void closeConnection(Connection con) throws Exception {
-		closeConnection(con, PROP_NONE);
-	}
-	
-	/**
-	 * Close the given connection, and optionally finalize it after creation (using {@link #PROP_FINALIZE})
-	 * @param con The connection to be closed
-	 * @param props Close properties (one of {@link #PROP_NONE}, {@link #PROP_FINALIZE} or {@link #PROP_RECREATE})
-	 * @throws Exception
-	 */
-	void closeConnection(Connection con, int props) throws Exception {
-		con.close();
-	}
-	
-	/**
-	 * Create a new database with the given name. This includes creating tables.
-	 * @param dbName The name of the database to create
-	 * @return A connection to the newly created database
-	 * @throws Exception
-	 */
-	protected final Connection createNewDatabase(String dbName) throws Exception {
-		Connection con = createNewDatabaseConnection(dbName);
-		createTables(con);
-		return con;
-	}
-	
-	private Connection createNewDatabaseConnection(String dbName) throws Exception {
-		return createConnection(dbName, PROP_RECREATE);
-	}
-	
-	/**
-	 * This method is called to finalize the given database after creation
-	 * (e.g. set read-only, archive files). The database name needs to returned, this
-	 * may change when finalizing the database modifies the storage type (e.g. from directory
-	 * to single file).
-	 * @param dbName The name of the database to finalize	
-	 * @throws Exception
-	 * @return The name of the finalized database
-	 */
-	protected abstract String finalizeNewDatabase(String dbName) throws Exception;
-	
-	/**
-	 * This method will be called when the user
-	 * needs to select a database. Open a dialog (e.g. FileDialog) in this
-	 * method to let the user select the database and return the database name.
-	 * @param shell The shell to create the dialog
-	 * @return The database name that was selected by the user, or null if no database was selected
-	 */
-	public abstract String openChooseDbDialog(Shell shell);
-	
-	/**
-	 * This method will be called when the user
-	 * needs to select a database to create. Open a dialog (e.g. FileDialog) in this
-	 * method to let the user select the new database name/file/directory and return the database name.
-	 * @param shell The shell to create the dialog
-	 * @return The database name to create, or null if no database was specified
-	 */
-	public abstract String openNewDbDialog(Shell shell, String defaultName);
-	
-	/**
-	 * Set the database type (one of {@link #TYPE_GDB} or {@link #TYPE_GEX})
-	 * @param type The type of the database that will be used for this class
-	 */
-	public void setDbType(int type) { dbType = type; }
-	/**
-	 * Get the database type (one of {@link #TYPE_GDB} or {@link #TYPE_GEX})
-	 * return The type of the database that is used for this class
-	 */
-	public int getDbType() { return dbType; }
-	
-	/**
-	 * Excecutes several SQL statements to create the tables and indexes for storing 
-	 * the expression data
-	 */
-	protected static void createTables(Connection con) throws Exception {	
-			con.setReadOnly(false);
-			Statement sh = con.createStatement();
-			try { sh.execute("DROP TABLE info"); } catch(SQLException e) { Engine.log.error("Error: unable to drop expression data tables: "+e.getMessage(), e); }
-			try { sh.execute("DROP TABLE samples"); } catch(SQLException e) { Engine.log.error("Error: unable to drop expression data tables: "+e.getMessage(), e); }
-			try { sh.execute("DROP TABLE expression"); } catch(SQLException e) { Engine.log.error("Error: unable to drop expression data tables: "+e.getMessage(), e); }
-			
-			sh.execute(
-					"CREATE TABLE					" +
-					"		info							" +
-					"(	  version INTEGER PRIMARY KEY		" +
-					")");
-			sh.execute( //Add compatibility version of GEX
-					"INSERT INTO info VALUES ( " + Gex.COMPAT_VERSION + ")");
-			sh.execute(
-					"CREATE TABLE                    " +
-					"		samples							" +
-					" (   idSample INTEGER PRIMARY KEY,		" +
-					"     name VARCHAR(50),					" +
-					"	  dataType INTEGER					" +
-			" )										");
-			
-			sh.execute(
-					"CREATE TABLE					" +
-					"		expression						" +
-					" (   id VARCHAR(50),					" +
-					"     code VARCHAR(50),					" +
-					"	  ensId VARCHAR(50),				" +
-					"     idSample INTEGER,					" +
-					"     data VARCHAR(50),					" +
-					"	  groupId INTEGER 					" +
-//					"     PRIMARY KEY (id, code, idSample, data)	" +
-					")										");
-	}
-	
-	/**
-	 * Creates indices for a newly created expression database.
-	 * @param con The connection to the expression database
-	 * @throws SQLException
-	 */
-	protected void createIndices(Connection con) throws SQLException {
-		con.setReadOnly(false);
-		Statement sh = con.createStatement();
-		sh.execute(
-				"CREATE INDEX i_expression_id " +
-		"ON expression(id)			 ");
-		sh.execute(
-				"CREATE INDEX i_expression_ensId " +
-		"ON expression(ensId)			 ");
-		sh.execute(
-				"CREATE INDEX i_expression_idSample " +
-		"ON expression(idSample)	 ");
-		sh.execute(
-				"CREATE INDEX i_expression_data " +
-		"ON expression(data)	     ");
-		sh.execute(
-				"CREATE INDEX i_expression_code " +
-		"ON expression(code)	 ");
-		sh.execute(
-				"CREATE INDEX i_expression_groupId" +
-		" ON expression(groupId)	");
-	}
-	
-	/**
-	 * This method may be implemented when the database files need to be
-	 * compacted or defragmented after creation of a new database. It will be called
-	 * after all data is added to the database.
-	 * @param con A connection to the database
-	 * @throws SQLException
-	 */
-	protected void compact(Connection con) throws SQLException {
-		//May be implemented by subclasses
-	}
-	
-	/**
-	 * Shortcut for creating a file dialog that has the right default directories for
-	 * the database type of this connector
-	 * @param shell
-	 * @param type
-	 * @param filterExtensions
-	 * @param filterNames
-	 * @return A file dialog with the default directories set
-	 */
-	protected FileDialog createFileDialog(Shell shell, int type, String[] filterExtensions, String[] filterNames) {
-		FileDialog fileDialog = new FileDialog(shell, type);
-		fileDialog.setText("Select database file");
-		
-		String filterPath = null;
-		switch(getDbType()) {
-		case TYPE_GDB: 
-			filterPath = SwtPreference.SWT_DIR_GDB.getValue();
-			break;
-		case TYPE_GEX:
-			filterPath = SwtPreference.SWT_DIR_EXPR.getValue();
-			break;
-		}
-		if(filterPath != null) fileDialog.setFilterPath(filterPath);
-		if(filterExtensions != null) fileDialog.setFilterExtensions(filterExtensions);
-		if(filterNames != null) fileDialog.setFilterNames(filterNames);
-		
-		return fileDialog;
-	}
-	
-	/**
-	 * Shortcut for creating a directory dialog that has the right default directories for
-	 * the database type of this connector
-	 * @param shell
-	 * @return A directory dialog with the default directories set
-	 */
-	protected DirectoryDialog createDirectoryDialog(Shell shell) {
-		DirectoryDialog dirDialog = new DirectoryDialog(shell, SWT.NONE);
-		dirDialog.setText("Select database file");
-		
-		String filterPath = null;
-		switch(getDbType()) {
-		case TYPE_GDB: 
-			filterPath = SwtPreference.SWT_DIR_GDB.getValue();
-			break;
-		case TYPE_GEX:
-			filterPath = SwtPreference.SWT_DIR_EXPR.getValue();
-			break;
-		}
-		if(filterPath != null) dirDialog.setFilterPath(filterPath);
-		
-		return dirDialog;
-	}
-}
Index: trunk/src/core/org/pathvisio/data/ImportInformation.java
===================================================================
--- trunk/src/core/org/pathvisio/data/ImportInformation.java	(revision 976)
+++ trunk/src/core/org/pathvisio/data/ImportInformation.java	(revision 977)
@@ -1,186 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.data;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileReader;
-import java.io.IOException;
-
-import org.pathvisio.gui.swt.SwtEngine;
-import org.pathvisio.Engine;
-
-/**
- * This class contains the information needed to start importing a delimited
- * text file to an expression dataset. This information can be gathered using
- * the {@link GexImportWizard} or can be filled automatically
- */
-public class ImportInformation {
-	/**
-	 * Points to the text file containing the expression data
-	 */
-	private File txtFile;
-	/**
-	 * Sets the text file containing the expression data
-	 * @param txtFile {@link File} to set
-	 */
-	public void setTxtFile(File txtFile)
-	{
-		//Close the connection to the previous file if exist
-		if(in != null) {
-			try { in.close(); } catch(Exception e) { 
-				Engine.log.error("on closing file " + this.txtFile + ": " + e.getMessage(), e);
-			}
-			in = null;
-		}
-		this.txtFile = txtFile;
-	}
-	/**
-	 * Get the private {@link File} txtFile
-	 * @return {@link File} object pointing to the text file that contains the
-	 * expression data
-	 */
-	public File getTxtFile() { return txtFile; } 
-	
-	/**
-	 * The database name in which the expression data is saved
-	 */
-	public String dbName;
-
-	/**
-	 * linenumber (first line is 1) of the line where the data begins
-	 */
-	int firstDataRow;
-	/**
-	 * linenumber (first line is 1) of the line containing the column headers
-	 */
-	int headerRow;
-	/**
-	 * Column number (first column is 0) of the column containing the gene identifier
-	 */
-	int idColumn;
-
-	/**
-	 * Column number (first column is 0) of the column containing the systemcode
-	 */
-	int codeColumn;
-
-	/**
-	 * Delimiter used to seperate columns in the text file containing expression data
-	 * TODO: let the user specify a delimiter
-	 */
-	static final String DELIMITER = "\t";
-
-	/**
-	 * Column numbers (first column is 0) of the columns of which the data should not be treated
-	 * as numberic
-	 */
-	private int[] stringCols;
-
-	/**
-	 * Constructor for this class
-	 * Sets the default values
-	 */
-	public ImportInformation() {
-		// Set the defaults
-		firstDataRow = 2;
-		headerRow = 1;
-		idColumn = 0;
-		codeColumn = 1;
-	}
-
-	/**
-	 * {@link BufferedReader} to the text file, maintained while the wizard is open
-	 */
-	BufferedReader in;
-
-	/**
-	 * Get a {@link BufferedReader} to the text file containing the expression data
-	 * Creates a new one 
-	 * @return
-	 */
-	public BufferedReader getBufferedReader() {
-		try {
-			if (in == null) {
-				in = new BufferedReader(new FileReader(txtFile));
-				// changed readahead from 10000 to 50000
-				// see http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4616869
-				// TODO: this may still fail for long lines (more than 50000 bytes in 50 lines) 
-				in.mark(50000);
-			} else {
-				in.reset();
-			}
-		} catch (Exception e) {
-			Engine.log.error("Error reading file", e);
-		} // TODO: handle exception
-		return in;
-	}
-
-	/**
-	 * Sets the private property stringCols
-	 * @param cols	Column numbers (start with 0) of columns containing data that
-	 * should not be treated as numeric
-	 */
-	public void setStringCols(int[] cols) {
-		stringCols = cols;
-	}
-
-	/**
-	 * Sets the private property stringCols
-	 * @return	Column numbers (start with 0) of columns containing data that
-	 * should not be treated as numeric, or an empty String[]
-	 */
-	public int[] getStringCols() {
-		if (stringCols == null)
-			stringCols = new int[] {};
-		return stringCols;
-	}
-
-	/**
-	 * Checks if the column for the given column index is marked as 'string column' and
-	 * should not be treated as numeric
-	 * @param colIndex	the index of the column to check (start with 0)
-	 * @return true if the column is marked as 'string column', false if not
-	 */
-	public boolean isStringCol(int colIndex) {
-		if (stringCols == null)
-			return false;
-		for (int col : stringCols)
-			if (col == colIndex)
-				return true;
-		return false;
-	}
-
-	/**
-	 * Reads the column names from the text file containing the expression data at the
-	 * header row specified by the user
-	 * @return the column names
-	 */
-	public String[] getColNames() {
-		try {
-			BufferedReader in = getBufferedReader();
-			int i = 0;
-			while (i < headerRow - 1 && in.readLine() != null)
-				i++; // Go to headerline
-			return in.readLine().split(ImportInformation.DELIMITER);
-		} catch (IOException e) { // TODO: handle IOException
-			Engine.log.error("Unable to get column names for importing expression data: " + e.getMessage(), e);
-			return new String[] {};
-		}
-	}
-
-}
Index: trunk/src/core/org/pathvisio/data/DBConnHsqldb.java
===================================================================
--- trunk/src/core/org/pathvisio/data/DBConnHsqldb.java	(revision 976)
+++ trunk/src/core/org/pathvisio/data/DBConnHsqldb.java	(revision 977)
@@ -1,132 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.data;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.sql.Connection;
-import java.sql.DriverManager;
-import java.sql.SQLException;
-import java.sql.Statement;
-import java.util.Properties;
-
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.widgets.FileDialog;
-import org.eclipse.swt.widgets.Shell;
-import org.pathvisio.Engine;
-import org.pathvisio.debug.StopWatch;
-
-/**
-   DBConnector implementation using the hsqldb driver
-*/
-public class DBConnHsqldb extends DBConnector
-{
-	static final String DB_FILE_EXT = "properties";
-	static final String[] DB_EXT = new String[] { "*." + DB_FILE_EXT };
-	static final String[] DB_EXT_NAMES = new String[] { "Hsqldb Database" };
-	
-	public Connection createConnection(String dbName) throws Exception {
-		return createConnection(dbName, PROP_NONE);
-	}
-	
-	public Connection createConnection(String dbName, int props) throws Exception {
-		boolean recreate = (props & PROP_RECREATE) != 0;
-		if(recreate) {
-			File dbFile = dbName2File(dbName);
-			if(dbFile.exists()) dbFile.delete();
-		}
-		
-		dbName = file2DbName(dbName);
-		
-		Class.forName("org.hsqldb.jdbcDriver");
-		Properties prop = new Properties();
-		prop.setProperty("user","sa");
-		prop.setProperty("password","");
-		prop.setProperty("hsqldb.default_table_type", "cached");
-		prop.setProperty("ifexists", Boolean.toString(!recreate));
-		
-		StopWatch timer = new StopWatch();
-		timer.start();
-		Connection con = DriverManager.getConnection("jdbc:hsqldb:file:" + dbName, prop);
-		Engine.log.info("Connecting with hsqldb to " + dbName + ":\t" + timer.stop());
-		return con;
-	}
-
-	public void closeConnection(Connection con) throws SQLException {
-		closeConnection(con, PROP_NONE);
-	}
-	
-	public void closeConnection(Connection con, int props) throws SQLException {
-		boolean compact = (props & PROP_FINALIZE) != 0;
-		if(con != null) {
-			Statement sh = con.createStatement();
-			sh.executeQuery("SHUTDOWN" + (compact ? " COMPACT" : ""));
-			sh.close();
-			con.close();
-		}
-	}
-	
-	File dbName2File(String dbName) {
-		return new File(dbName + '.' + DB_FILE_EXT);
-	}
-	
-	String file2DbName(String fileName) {
-		String end = '.' + DB_FILE_EXT;
-		return fileName.endsWith(end) ? 
-				fileName.substring(0, fileName.length() -  end.length()) : fileName;
-	}
-	
-	public void setDatabaseReadonly(String dbName, boolean readonly) {
-		 setPropertyReadOnly(dbName, readonly);
-	}
-	
-	void setPropertyReadOnly(String dbName, boolean readonly) {
-    	Properties prop = new Properties();
-		try {
-			File propertyFile = dbName2File(dbName);
-			prop.load(new FileInputStream(propertyFile));
-			prop.setProperty("hsqldb.files_readonly", Boolean.toString(readonly));
-			prop.store(new FileOutputStream(propertyFile), "HSQL Database Engine");
-			} catch (Exception e) {
-				Engine.log.error("Unable to set database properties to readonly", e);
-			}
-	}
-
-	Connection newDbCon;
-	public Connection createNewDatabaseConnection(String dbName) throws Exception {
-		newDbCon = createConnection(dbName, PROP_RECREATE);
-		return newDbCon;
-	}
-
-	public String finalizeNewDatabase(String dbName) throws Exception {
-		if(newDbCon != null) closeConnection(newDbCon, PROP_FINALIZE);
-		setPropertyReadOnly(dbName, true);
-		return dbName;
-	}
-
-	public String openChooseDbDialog(Shell shell) {
-		FileDialog fd = createFileDialog(shell, SWT.OPEN, DB_EXT, DB_EXT_NAMES);
-		return fd.open();
-	}
-
-	public String openNewDbDialog(Shell shell, String defaultName) {
-		FileDialog fd = createFileDialog(shell, SWT.SAVE, DB_EXT, DB_EXT_NAMES);
-		if(defaultName != null) fd.setFileName(defaultName);
-		return fd.open();
-	}
-}
Index: trunk/src/core/org/pathvisio/data/GpmlTransfer.java
===================================================================
--- trunk/src/core/org/pathvisio/data/GpmlTransfer.java	(revision 976)
+++ trunk/src/core/org/pathvisio/data/GpmlTransfer.java	(revision 977)
@@ -1,118 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.data;
-
-import java.util.List;
-
-import org.eclipse.swt.dnd.ByteArrayTransfer;
-import org.eclipse.swt.dnd.TransferData;
-import org.jdom.Document;
-import org.jdom.Element;
-import org.jdom.Namespace;
-import org.jdom.output.Format;
-import org.jdom.output.XMLOutputter;
-import org.pathvisio.Engine;
-import org.pathvisio.model.GpmlFormat;
-import org.pathvisio.model.PathwayElement;
-import org.pathvisio.model.GpmlFormat;
-import org.pathvisio.gui.swt.SwtEngine;
-
-/**
-   Clipboard Transfer Object, for transferring Gpml fragments
-   between applications
-   TODO: unfinished
- */
-public class GpmlTransfer extends ByteArrayTransfer 
-{
-	private static final String TYPENAME = "gpml";
-	private static final int TYPEID = registerType(TYPENAME);
-	private static GpmlTransfer _instance = new GpmlTransfer();
-	
-	private GpmlTransfer() {} // prevent instantiation because it is private
-	
-	public static GpmlTransfer getInstance()
-	{
-		return _instance;
-	}
-	
-	public void javaToNative (Object data, TransferData transferData)
-	{
-		
-		if (!(data instanceof List)) { return; } // wrong type of data
-		
-		byte[] result = null;
-		List<PathwayElement> clipboard = (List<PathwayElement>)(data);
-		Document doc = new Document();
-		Namespace ns = Namespace.getNamespace("http://www.w3.org/2000/svg");
-
-		for (PathwayElement o : clipboard)
-		{
-			try
-			{
-				Element e = GpmlFormat.createJdomElement(o, ns);
-				doc.addContent(e);
-			}
-			catch (Exception e)
-			{
-				Engine.log.error ("Converter exception", e);
-			}
-
-			XMLOutputter xmlcode = new XMLOutputter(Format.getPrettyFormat());
-			Format f = xmlcode.getFormat();
-			f.setEncoding("ISO-8859-1");
-			f.setTextMode(Format.TextMode.PRESERVE);
-			xmlcode.setFormat(f);
-			
-			//Open a filewriter
-			try
-			{
-				result = xmlcode.outputString(doc).getBytes();				
-			}
-			catch (Exception e)
-			{
-				Engine.log.error ("Error?!?!", e);
-			}
-		}
-		super.javaToNative(result, transferData);
-	}
-	
-	public Object nativeToJava (TransferData transferData)
-	{
-		 if (isSupportedType(transferData)) 
-		 {
-			 byte[] buffer = (byte[]) super.nativeToJava(transferData);
-			 if (buffer == null)
-				 return null;
-
-			 //TODO
-			 String x = "" + buffer;
-			 Object result = null;
-			 return result;
-		}
-		 
-		return null;
-	}
-	
-	protected int[] getTypeIds() {
-		return new int[]{TYPEID};
-	}
-
-	protected String[] getTypeNames() {
-		return new String[]{TYPENAME};
-	}
-
-}
Index: trunk/src/core/org/pathvisio/data/DBConnDerby.java
===================================================================
--- trunk/src/core/org/pathvisio/data/DBConnDerby.java	(revision 976)
+++ trunk/src/core/org/pathvisio/data/DBConnDerby.java	(revision 977)
@@ -1,247 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.data;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.sql.CallableStatement;
-import java.sql.Connection;
-import java.sql.DriverManager;
-import java.sql.SQLException;
-import java.util.Properties;
-import java.util.zip.CRC32;
-import java.util.zip.CheckedInputStream;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipOutputStream;
-
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.widgets.FileDialog;
-import org.eclipse.swt.widgets.Shell;
-import org.pathvisio.Engine;
-import org.pathvisio.debug.StopWatch;
-import org.pathvisio.util.FileUtils;
-
-/**
-   DBConnector implementation using the Derby driver, with the database in a
-   single, uncompressed zip archive
-*/
-public class DBConnDerby extends DBConnector {
-	static final String DB_FILE_EXT_GDB = "pgdb";
-	static final String DB_FILE_EXT_GEX = "pgex";
-	static final String[] DB_EXTS_GEX = new String[] { "*." + DB_FILE_EXT_GEX, "*.*"};
-	static final String[] DB_EXTS_GDB = new String[] { "*." + DB_FILE_EXT_GDB, "*.*"};
-	static final String[] DB_EXT_NAMES_GEX = new String[] { "Expression dataset", "All files" };
-	static final String[] DB_EXT_NAMES_GDB = new String[] { "Gene database", "All files" };
-	
-	public static final String DB_NAME_IN_ZIP = "database";
-	String lastDbName;
-	
-	public Connection createConnection(String dbName) throws Exception {
-		return createConnection(dbName, PROP_NONE);
-	}
-	
-	public Connection createConnection(String dbName, int props) throws Exception {
-		boolean recreate = (props & PROP_RECREATE) != 0;
-		if(recreate) {
-			File dbFile = new File(dbName);
-			FileUtils.deleteRecursive(dbFile);
-		}
-		
-		Properties sysprop = System.getProperties();
-		sysprop.setProperty("derby.storage.tempDirectory", System.getProperty("java.io.tmpdir"));
-		sysprop.setProperty("derby.stream.error.file", File.createTempFile("derby",".log").toString());
-		
-		Class.forName("org.apache.derby.jdbc.EmbeddedDriver");
-		Properties prop = new Properties();
-		prop.setProperty("create", Boolean.toString(recreate));
-		
-		StopWatch timer = new StopWatch();
-		timer.start();
-		
-		String url = "jdbc:derby:";
-		File dbFile = new File(dbName);
-		if(dbFile.isDirectory() || recreate) {
-			url += dbName;
-		} else {
-			url += "jar:(" + dbFile.toString() + ")" + DB_NAME_IN_ZIP;
-		}
-		Connection con = DriverManager.getConnection(url, prop);
-		
-		Engine.log.info("Connecting with derby to " + dbName + ":\t" + timer.stop());
-		
-		lastDbName = dbName;
-		return con;
-	}
-	
-	public Connection createNewDatabaseConnection(String dbName) throws Exception {
-		return createConnection(FileUtils.removeExtension(dbName), PROP_RECREATE);
-	}
-	
-	public String finalizeNewDatabase(String dbName) throws Exception {
-		//Transfer db to zip and clear old dbfiles
-		File dbDir = new File(FileUtils.removeExtension(dbName));
-		try {
-			DriverManager.getConnection("jdbc:derby:" + FileUtils.removeExtension(dbName) + ";shutdown=true");
-		} catch(Exception e) {
-			Engine.log.error("Database closed", e);
-		}
-		File zipFile = new File(dbName.endsWith(getDbExt()) ? dbName : dbName + "." + getDbExt());
-		toZip(zipFile, dbDir);
-		
-		FileUtils.deleteRecursive(dbDir);
-		
-		//Return new database file
-		return zipFile.toString();
-	}
-	
-	public void closeConnection(Connection con) throws SQLException {
-		closeConnection(con, PROP_NONE);
-	}
-	
-	public void closeConnection(Connection con, int props) throws SQLException {
-		if(con != null) {
-			if(lastDbName != null) 
-				DriverManager.getConnection("jdbc:derby:" + lastDbName + ";shutdown=true");
-			con.close();
-		}
-	}
-	
-	public void compact(Connection con) throws SQLException {
-		con.setAutoCommit(true);
-
-		CallableStatement cs = con.prepareCall
-		("CALL SYSCS_UTIL.SYSCS_COMPRESS_TABLE(?, ?, ?)");
-		//Expression table
-		cs.setString(1, "APP");
-		cs.setString(2, "EXPRESSION");
-		cs.setShort(3, (short) 1);
-		cs.execute();
-		
-		con.commit(); //Just to be sure...
-	}
-		
-	void toZip(File zipFile, File dbDir) {
-		try {			
-			if(zipFile.exists()) zipFile.delete();
-			
-			zipFiles(zipFile, dbDir);
-			
-			String zipPath = zipFile.getAbsolutePath().replace(File.separatorChar, '/');
-			String url = "jdbc:derby:jar:(" + zipPath + ")" + DB_NAME_IN_ZIP;
-
-			DriverManager.getConnection(url);
-		
-		} catch(Exception e) {
-			e.printStackTrace();
-		}
-	}
-	
-	void zipFiles(File zipFile, File dir) throws Exception {
-		ZipOutputStream out = new ZipOutputStream(new FileOutputStream(zipFile));
-		out.setMethod(ZipOutputStream.STORED);
-		for(File f : dir.listFiles()) addFiles(f, DB_NAME_IN_ZIP + '/', out);
-		out.closeEntry();
-		out.close();
-	}
-	
-	byte[] buf = new byte[1024];
-	void addFiles(File file, String dir, ZipOutputStream out) throws Exception {
-		if(file.isDirectory()) {
-			if(file.getName().equals("tmp")) return; //Skip 'tmp' directory
-			
-			String newDir = dir + file.getName() + '/';
-			ZipEntry add = new ZipEntry(newDir);
-			setZipEntryAttributes(file, add);
-			out.putNextEntry(add);
-			
-			for(File f : file.listFiles()) addFiles(f, newDir,out);
-		} else {
-			if(file.getName().endsWith(".lck")) return; //Skip '*.lck' files
-			ZipEntry add = new ZipEntry(dir + file.getName());
-			
-			setZipEntryAttributes(file, add);
-			
-			out.putNextEntry(add);
-				        
-			FileInputStream in = new FileInputStream(file);
-			int len;
-			while ((len = in.read(buf)) > 0) {
-				out.write(buf, 0, len);
-			}
-			in.close();
-		}
-	}
-	
-	void setZipEntryAttributes(File f, ZipEntry z) throws IOException {
-		z.setTime(f.lastModified());
-		z.setMethod(ZipEntry.STORED);
-				
-		if(f.isDirectory()) {
-			z.setCrc(0);
-			z.setSize(0);
-			z.setCompressedSize(0);
-		} else {			
-			z.setSize(f.length());
-			z.setCompressedSize(f.length());
-			z.setCrc(computeCheckSum(f));
-		}
-	}
-	
-	long computeCheckSum(File f) throws IOException {
-		CheckedInputStream cis = new CheckedInputStream(
-				new FileInputStream(f), new CRC32());
-		byte[] tempBuf = new byte[128];
-		while (cis.read(tempBuf) >= 0) { }
-		return cis.getChecksum().getValue();
-	}
-	
-	String getDbExt() {
-		switch(getDbType()) {
-		case TYPE_GDB: return DB_FILE_EXT_GDB;
-		case TYPE_GEX: return DB_FILE_EXT_GEX;
-		default: return "";
-		}
-	}
-	String[] getDbExts() {
-		switch(getDbType()) {
-		case TYPE_GDB: return DB_EXTS_GDB;
-		case TYPE_GEX: return DB_EXTS_GEX;
-		default: return null;
-		}
-	}
-	
-	String[] getDbExtNames() {
-		switch(getDbType()) {
-		case TYPE_GDB: return DB_EXT_NAMES_GDB;
-		case TYPE_GEX: return DB_EXT_NAMES_GEX;
-		default: return null;
-		}
-	}
-	
-	public String openChooseDbDialog(Shell shell) {
-		FileDialog fd = createFileDialog(shell, SWT.OPEN, getDbExts(), getDbExtNames());
-		return fd.open();
-	}
-
-	public String openNewDbDialog(Shell shell, String defaultName) {
-		FileDialog fd = createFileDialog(shell, SWT.SAVE, getDbExts(), getDbExtNames());
-		if(defaultName != null) fd.setFileName(defaultName);
-		return fd.open();
-	}
-}
Index: trunk/src/core/org/pathvisio/data/DBConnDerbyDirectory.java
===================================================================
--- trunk/src/core/org/pathvisio/data/DBConnDerbyDirectory.java	(revision 976)
+++ trunk/src/core/org/pathvisio/data/DBConnDerbyDirectory.java	(revision 977)
@@ -1,52 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.data;
-
-import java.sql.DriverManager;
-
-import org.eclipse.swt.widgets.DirectoryDialog;
-import org.eclipse.swt.widgets.Shell;
-import org.pathvisio.Engine;
-import org.pathvisio.util.FileUtils;
-
-/**
-   Implementation of DBConnector using the Derby Driver,
-   with the database stored as multiple files in a directory
-*/
-public class DBConnDerbyDirectory extends DBConnDerby {	
-	String lastDbName;
-		
-	public String finalizeNewDatabase(String dbName) throws Exception {
-		try {
-			DriverManager.getConnection("jdbc:derby:" + FileUtils.removeExtension(dbName) + ";shutdown=true");
-		} catch(Exception e) {
-			Engine.log.error("Database closed", e);
-		}
-		return dbName;
-	}
-	
-	public String openChooseDbDialog(Shell shell) {
-		DirectoryDialog dd = createDirectoryDialog(shell);
-		return dd.open();
-	}
-
-	public String openNewDbDialog(Shell shell, String defaultName) {
-		DirectoryDialog dd = createDirectoryDialog(shell);
-		if(defaultName != null) dd.setFilterPath(defaultName);
-		return dd.open();
-	}
-}
Index: trunk/src/core/org/pathvisio/data/Gex.java
===================================================================
--- trunk/src/core/org/pathvisio/data/Gex.java	(revision 976)
+++ trunk/src/core/org/pathvisio/data/Gex.java	(revision 977)
@@ -27,7 +27,6 @@
 import java.io.OutputStream;
 import java.io.PrintStream;
 import java.io.PrintWriter;
-import java.lang.reflect.InvocationTargetException;
 import java.sql.Connection;
 import java.sql.DriverManager;
 import java.sql.PreparedStatement;
@@ -41,8 +40,6 @@
 import java.util.HashMap;
 import java.util.List;
 
-import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.jface.operation.IRunnableWithProgress;
 import org.jdom.Document;
 import org.jdom.Element;
 import org.jdom.input.SAXBuilder;
@@ -53,9 +50,9 @@
 import org.pathvisio.Engine.ApplicationEventListener;
 import org.pathvisio.data.CachedData.Data;
 import org.pathvisio.data.Gdb.IdCodePair;
-import org.pathvisio.data.GexImportWizard.ImportPage;
 import org.pathvisio.debug.StopWatch;
 import org.pathvisio.util.FileUtils;
+import org.pathvisio.util.ProgressKeeper;
 import org.pathvisio.visualization.VisualizationManager;
 import org.pathvisio.visualization.colorset.ColorSetManager;
 
@@ -66,7 +63,7 @@
  */
 public class Gex implements ApplicationEventListener {
 	public static final String XML_ELEMENT = "expression-data-visualizations";
-	static final int COMPAT_VERSION = 1;
+	public static final int COMPAT_VERSION = 1;
 	
 	private static Connection con;
 	
@@ -342,23 +339,12 @@
 	 * @param code	Systemcodes of the gene identifiers
 	 * (typically all genes in a pathway)
 	 */
-	private static void cacheData(ArrayList<String> ids, ArrayList<String> codes)
+	protected static void cacheData(ArrayList<String> ids, ArrayList<String> codes, ProgressKeeper p)
 	{	
 		cachedData = new CachedData();
 		StopWatch timer = new StopWatch();
 		timer.start();
-		
-//		PreparedStatement pstData = null;
-//		try {
-//			pstData = con.prepareStatement(
-//					"SELECT id, code, data, idSample FROM expression " +
-//			"WHERE ensId = ?");
-//		} catch(SQLException e) {
-//			Engine.log.error("Unable to prepare statement", e);
-//			return;
-//		}
-
-		
+			
 		for(int i = 0; i < ids.size(); i++)
 		{
 			String id = ids.get(i);
@@ -385,8 +371,6 @@
 					try {
 						ts.start();
 						
-//						pstData.setString(1, ensId);
-//						ResultSet r = pstData.executeQuery();
 						ResultSet r = con.createStatement().executeQuery(
 								"SELECT id, code, data, idSample, groupId FROM expression " +
 								" WHERE ensId = '" + ensId + "'");
@@ -414,165 +398,20 @@
 				
 				tt.stopToLog(id + ", " + code + ": adding data to cache\t\t");
 			}			
-			if(cacheThread.isInterrupted) //Check if the process is interrupted
+			if(p.isCancelled()) //Check if the process is interrupted
 			{
 				return;
 			}
-			cacheThread.progress += 100.0 / ids.size(); //Update the progress
+			p.worked(p.getTotalWork() / ids.size()); //Update the progress
 		}
-		cacheThread.progress = 100;
+		p.finished();
 		timer.stopToLog("Caching expression data\t\t\t");
 		Engine.log.trace("> Nr of ids queried:\t" + ids.size());
 	}
-	
-	/**
-	 * {@link CacheThread} to facilitate caching of Expression data of genes in a pathway in a
-	 * seperate {@link Thread}
-	 */
-	private static CacheThread cacheThread;
-	/**
-	 * This class is a {@link Thread} that is responsible for calling {@link #cacheData(ArrayList<String>, ArrayList<String>)}
-	 * and keeping the progress of its progress
-	 */
-	private static class CacheThread extends Thread
-	{
-		volatile double progress;
-		volatile boolean isInterrupted;
-		ArrayList<String> ids;
-		ArrayList<String> codes;
-		/**
-		 * Constructor for this class
-		 * @param ids	the gene ids that need to be passed on to {@link cacheData()}
-		 * @param codes	The systemcodes of the gene identifiers
-		 */
-		public CacheThread(ArrayList<String> ids, ArrayList<String> codes) 
-		{
-			this.ids = ids;
-			this.codes = codes;
-		}
 		
-		public void run()
-		{
-			progress = 0;
-			isInterrupted = false;
-			cacheData(ids, codes);
-		}
-		
-		public void interrupt()
-		{
-			isInterrupted = true;
-		}
-	}
+
 	
 	/**
-	 * Creates an {@link IRunnableWithProgress} responsible for starting the 
-	 * CacheThread and keeping track of the progress of this thread
-	 * @param mappIds	the gene ids to pass on to cacheData(ArrayList<String>, ArrayList<String>)
-	 * @param codes		the systemcodes of the gene identifiers
-	 */
-	public static IRunnableWithProgress createCacheRunnable(
-			final ArrayList<String> mappIds, 
-			final ArrayList<String> codes )
-	{
-		return new IRunnableWithProgress() {
-			public void run(IProgressMonitor monitor)
-			throws InvocationTargetException, InterruptedException {
-				monitor.beginTask("Caching expression data",100);
-				cacheThread = new CacheThread(mappIds, codes);
-				cacheThread.start();
-				int prevProgress = 0;
-				while(cacheThread.progress < 100) {
-					if(monitor.isCanceled()) {
-						cacheThread.interrupt();
-						break;
-					}
-					if(prevProgress < (int)cacheThread.progress) {
-						monitor.worked((int)cacheThread.progress - prevProgress);
-						prevProgress = (int)cacheThread.progress;
-					}
-				}
-				monitor.done();
-			}
-		};
-	}
-	
-	private static ConvertThread convertThread;
-	/**
-	 * This class is a {@link Thread} that converts a GenMAPP Expression dataset and keeps the progress
-	 * of the conversion
-	 */
-	private static class ConvertThread extends Thread
-	{
-		volatile double progress;
-		volatile boolean isInterrupted;
-		public ConvertThread() 
-		{
-			isInterrupted = false;
-		}
-		
-		public void run()
-		{
-			progress = 0;
-			convertGex();
-		}
-		
-		public void interrupt()
-		{
-			isInterrupted = true;
-		}
-	}
-	
-	/**
-	 * This {@link IRunnableWithProgress} starts the ConvertThread
-	 * and monitors the progress of the conversion
-	 */
-	public static IRunnableWithProgress convertRunnable = new IRunnableWithProgress() {
-		public void run(IProgressMonitor monitor)
-		throws InvocationTargetException, InterruptedException {
-			monitor.beginTask("Converting Gene Expression Dataset",100);
-			convertThread = new ConvertThread();
-			convertThread.start();
-			int prevProgress = 0;
-			while(convertThread.progress < 100) {
-				if(monitor.isCanceled()) {
-					convertThread.interrupt();
-					break;
-				}
-				if(prevProgress < (int)convertThread.progress) {
-					monitor.worked((int)convertThread.progress - prevProgress);
-					prevProgress = (int)convertThread.progress;
-				}
-			}
-			monitor.done();
-		}
-	};
-	
-	/**
-	 * This {@link IRunnableWithProgress} is responsible for running the import expression data
-	 * process and monitor the progress
-	 * See Gex.importFromTxt
-	 */
-	public static class ImportRunnableWithProgress implements IRunnableWithProgress {
-		static final int totalWork = (int)1E6;
-		ImportInformation info;
-		ImportPage page;
-		
-		public ImportRunnableWithProgress(ImportInformation info, ImportPage page) {
-			super();
-			this.info = info;
-			this.page = page;
-		}
-		
-		public void run(final IProgressMonitor monitor) 
-		throws InvocationTargetException, InterruptedException {
-			monitor.beginTask("Importing expression data", totalWork);
-			importFromTxt(info, page, monitor);
-					
-			monitor.done();
-		}
-	}
-	
-	/**
 	 * Imports expression data from a text file and saves it to an hsqldb expression database
 	 * @param info		{@link GexImportWizard.ImportInformation} object that contains the 
 	 * information needed to import the data
@@ -581,10 +420,10 @@
 	 * @param monitor	{@link IProgressMonitor} that reports the progress of the process and enables
 	 * the user to cancel
 	 */
-	private static void importFromTxt(ImportInformation info, ImportPage page, IProgressMonitor monitor)
+	protected static void importFromTxt(ImportInformation info, ProgressKeeper p)
 	{
-		int importWork = (int)(ImportRunnableWithProgress.totalWork * 0.8);
-		int finalizeWork = (int)(ImportRunnableWithProgress.totalWork * 0.2);
+		int importWork = (int)(p.getTotalWork() * 0.8);
+		int finalizeWork = (int)(p.getTotalWork() * 0.2);
 		
 //		Open a connection to the error file
 		String errorFile = info.dbName + ".ex.txt";
@@ -595,20 +434,20 @@
 			ef.getParentFile().mkdirs();
 			error = new PrintStream(errorFile);
 		} catch(IOException ex) {
-			page.println("Error: could not open exception file: " + ex.getMessage());
+			p.report("Error: could not open exception file: " + ex.getMessage());
 			error = System.out;
 		}
 		
 		StopWatch timer = new StopWatch();
 		try 
 		{
-			page.println("\nCreating expression dataset");
+			p.report("\nCreating expression dataset");
 						
 			//Create a new expression database (or overwrite existing)
 			connect(info.dbName, true, false);
 			
-			page.println("Importing data");
-			page.println("> Processing headers");
+			p.report("Importing data");
+			p.report("> Processing headers");
 			
 			timer.start();
 			
@@ -625,7 +464,7 @@
 			int sampleId = 0;
 			ArrayList<Integer> dataCols = new ArrayList<Integer>();
 			for(int i = 0; i < headers.length; i++) {
-				if(monitor.isCanceled()) { close(true); error.close(); return; } //User pressed cancel
+				if(p.isCancelled()) { close(true); error.close(); return; } //User pressed cancel
 				if(i != info.idColumn && i != info.codeColumn) { //skip the gene and systemcode column
 					try {
 						pstmt.setInt(1, sampleId++);
@@ -641,7 +480,7 @@
 				}
 			}
 			
-			page.println("> Processing lines");
+			p.report("> Processing lines");
 			
 			//Check ids and add expression data
 			for(int i = 1; i < info.firstDataRow; i++) in.readLine(); //Go to line where data starts
@@ -656,7 +495,7 @@
 			int worked = importWork / nrLines;
 			while((line = in.readLine()) != null) 
 			{
-				if(monitor.isCanceled()) { close(); error.close(); return; } //User pressed cancel
+				if(p.isCancelled()) { close(); error.close(); return; } //User pressed cancel
 				String[] data = line.split(ImportInformation.DELIMITER, headers.length);
 				n++;
 				if(n == info.headerRow) continue; //Don't add header row (very unlikely that this will happen)
@@ -666,7 +505,7 @@
 							errors);
 					continue;
 				}
-				monitor.setTaskName("Importing expression data - processing line " + n + "; " + errors + " exceptions");
+				p.setTaskName("Importing expression data - processing line " + n + "; " + errors + " exceptions");
 				//Check id and add data
 				String id = data[info.idColumn].trim();
 				String code = data[info.codeColumn].trim();
@@ -703,17 +542,17 @@
 					}
 					if(success) added++;
 				}
-				monitor.worked(worked);
+				p.worked(worked);
 			}
-			page.println(added + " genes were added succesfully to the expression dataset");
+			p.report(added + " genes were added succesfully to the expression dataset");
 			if(errors > 0) {
-				page.println(errors + " exceptions occured, see file '" + errorFile + "' for details");
+				p.report(errors + " exceptions occured, see file '" + errorFile + "' for details");
 			} else {
 				new File(errorFile).delete(); // If no errors were found, delete the error file
 			}
-			monitor.setTaskName("Closing database connection");
+			p.setTaskName("Closing database connection");
 			close(true);
-			monitor.worked(finalizeWork);
+			p.worked(finalizeWork);
 			
 			error.println("Time to create expression dataset: " + timer.stop());
 			error.close();
@@ -724,8 +563,9 @@
 				Engine.log.error("Exception on connecting expression dataset from import thread", e);
 			}
 			
+			p.finished();
 		} catch(Exception e) { 
-			page.println("Import aborted due to error: " + e.getMessage());
+			p.report("Import aborted due to error: " + e.getMessage());
 			Engine.log.error("Expression data import error", e);
 			close(true);
 			error.close();
@@ -758,7 +598,7 @@
 	 * in Hsqldb format as used by this program.
 	 * <BR><BR>This method reports all errors occured during the conversion to a file named 'convert_gex_error.txt'
 	 */
-	public static void convertGex()
+	public static void convertGex(ProgressKeeper p)
 	{
 		//Open a connection to the error file
 		PrintWriter error = null;
@@ -804,7 +644,7 @@
 			String id = "";
 			String code = "";
 			while(r.next()) { //Process all rows of the expression data
-				if(convertThread.isInterrupted) //Check if the user cancelled the conversion
+				if(p.isCancelled()) //Check if the user cancelled the conversion
 				{
 					closeGmGex();
 					close();
@@ -845,7 +685,7 @@
 				nq++;
 				if(nq % 1000 == 0) //Commit every 1000 queries
 					con.commit();
-				convertThread.progress += 100.0/nrRows; //Report progress
+				p.worked(p.getTotalWork()/nrRows); //Report progress
 			}
 			con.commit();	
 		} catch(Exception e) {
@@ -858,11 +698,11 @@
 		
 //		setGexReadOnly(true);
 		
-		convertThread.progress = 100;
+		p.finished();
 	}
 	
-	public static DBConnector getDBConnector() throws ClassNotFoundException, InstantiationException, IllegalAccessException {
-		return Engine.getDbConnector(DBConnector.TYPE_GEX);
+	public static DBConnectorSwt getDBConnector() throws ClassNotFoundException, InstantiationException, IllegalAccessException {
+		return Engine.getDbConnector(DBConnectorSwt.TYPE_GEX);
 	}
 	
 	/**
@@ -876,7 +716,7 @@
 		
 		if(dbName != null) setDbName(dbName);
 		
-		DBConnector connector = getDBConnector();
+		DBConnectorSwt connector = getDBConnector();
 		
 		if(create) {
 			con = connector.createNewDatabase(getDbName());
@@ -918,7 +758,7 @@
 			{
 				saveXML();
 				
-				DBConnector connector = getDBConnector();
+				DBConnectorSwt connector = getDBConnector();
 				if(finalize) {
 					connector.compact(con);
 					connector.createIndices(con);
Index: trunk/src/core/org/pathvisio/data/Gdb.java
===================================================================
--- trunk/src/core/org/pathvisio/data/Gdb.java	(revision 976)
+++ trunk/src/core/org/pathvisio/data/Gdb.java	(revision 977)
@@ -32,8 +32,6 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.jface.operation.IRunnableWithProgress;
 import org.pathvisio.Engine;
 import org.pathvisio.debug.StopWatch;
 import org.pathvisio.gui.swt.SwtEngine;
@@ -366,8 +364,8 @@
 		}
 	}
 	
-	public static DBConnector getDBConnector() throws ClassNotFoundException, InstantiationException, IllegalAccessException {
-		return Engine.getDbConnector(DBConnector.TYPE_GDB);
+	public static DBConnectorSwt getDBConnector() throws ClassNotFoundException, InstantiationException, IllegalAccessException {
+		return Engine.getDbConnector(DBConnectorSwt.TYPE_GDB);
 	}
 	
 	/**
@@ -379,7 +377,7 @@
 	{
 		if(dbName == null) dbName = getDbName();
 		
-		DBConnector connector = getDBConnector();
+		DBConnectorSwt connector = getDBConnector();
 		con = connector.createConnection(dbName);
 		con.setReadOnly(true);
 //		Utils.checkDbVersion(con, COMPAT_VERSION); NOT FOR NOW
@@ -393,7 +391,7 @@
 	{
 		if(con != null) {
 			try {
-				DBConnector connector = getDBConnector();
+				DBConnectorSwt connector = getDBConnector();
 				connector.closeConnection(con);
 			} catch(Exception e) {
 				Engine.log.error("Unable to close database connection", e);
@@ -422,7 +420,7 @@
 		{
 			close();
 			
-			DBConnector connector = null;
+			DBConnectorSwt connector = null;
 			Connection convertCon = null;
 			Connection conGdb = null;
 			
@@ -440,7 +438,7 @@
 			
 			//Create hsqldb gdb
 			connector = getDBConnector();
-			convertCon = connector.createConnection(dbName, DBConnector.PROP_RECREATE);
+			convertCon = connector.createConnection(dbName, DBConnectorSwt.PROP_RECREATE);
 			
 			// Fetch size of database to convert (for progress monitor)
 			Statement s = conGdb.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
@@ -641,32 +639,6 @@
 	}
 	
 	/**
-	 * Gets the {@link IRunnableWithProgress} for starting the {@link ConvertThread} 
-	 * and monitor the progress of the conversion
-	 */
-	public static IRunnableWithProgress getConvertRunnable() { return convertRunnable; }
-	
-	private static IRunnableWithProgress convertRunnable = new IRunnableWithProgress() {		
-		public void run(IProgressMonitor monitor) {
-			monitor.beginTask("Converting Gene Database",100);
-			convertThread = new ConvertThread();
-			convertThread.start();
-			int prevProgress = 0;
-			while(convertThread.progress < 100) {
-				if(monitor.isCanceled()) {
-					convertThread.interrupt();
-					break;
-				}
-				if(prevProgress < (int)convertThread.progress) {
-					monitor.worked((int)convertThread.progress - prevProgress);
-					prevProgress = (int)convertThread.progress;
-				}
-			}
-			monitor.done();
-		}
-	};
-	
-	/**
 	 * Excecutes several SQL statements to create the tables and indexes in the database the given
 	 * connection is connected to
 	 * @param convertCon	The connection to the database the tables are created in
Index: trunk/src/core/org/pathvisio/view/VPathway.java
===================================================================
--- trunk/src/core/org/pathvisio/view/VPathway.java	(revision 976)
+++ trunk/src/core/org/pathvisio/view/VPathway.java	(revision 977)
@@ -172,6 +172,7 @@
 			parent.setVSize(width, height);
 		}
 		data.fireObjectModifiedEvent(new PathwayEvent(null, PathwayEvent.MODIFIED_GENERAL));
+		fireVPathwayEvent(new VPathwayEvent(this, VPathwayEvent.MODEL_LOADED));
 		data.addListener(this);
 	}
 
Index: trunk/src/core/org/pathvisio/view/VPathwayEvent.java
===================================================================
--- trunk/src/core/org/pathvisio/view/VPathwayEvent.java	(revision 976)
+++ trunk/src/core/org/pathvisio/view/VPathwayEvent.java	(revision 977)
@@ -22,6 +22,7 @@
 	public static final int NEW_ELEMENT_ADDED = 0;
 	public static final int EDIT_MODE_ON = 1;
 	public static final int EDIT_MODE_OFF = 2;
+	public static final int MODEL_LOADED = 3;
 	
 	int type;
 	VPathwayElement affectedElement;
Index: trunk/src/core/org/pathvisio/view/swing/VPathwaySwing.java
===================================================================
--- trunk/src/core/org/pathvisio/view/swing/VPathwaySwing.java	(revision 976)
+++ trunk/src/core/org/pathvisio/view/swing/VPathwaySwing.java	(revision 977)
@@ -26,53 +26,59 @@
 import java.awt.event.MouseListener;
 import java.awt.event.MouseMotionListener;
 
-import javax.swing.JComponent;
+import javax.swing.JPanel;
 import javax.swing.JScrollPane;
 
+import org.pathvisio.ApplicationEvent;
 import org.pathvisio.view.VPathway;
+import org.pathvisio.view.VPathwayEvent;
+import org.pathvisio.view.VPathwayListener;
 import org.pathvisio.view.VPathwayWrapper;
 
-public class VPathwaySwing extends JComponent implements VPathwayWrapper, MouseMotionListener, MouseListener, KeyListener {
+public class VPathwaySwing extends JPanel implements VPathwayWrapper,
+		MouseMotionListener, MouseListener, KeyListener, VPathwayListener {
 	VPathway child;
+
 	JScrollPane container;
-	
+
 	public VPathwaySwing(JScrollPane parent) {
 		super();
-		if(parent == null) throw new IllegalArgumentException("parent is null");
+		if (parent == null)
+			throw new IllegalArgumentException("parent is null");
 		this.container = parent;
 		addMouseListener(this);
 		addMouseMotionListener(this);
 		addKeyListener(this);
 	}
-	
+
 	public void setChild(VPathway c) {
 		child = c;
+		child.addVPathwayListener(this);
 	}
-	
+
 	public Rectangle getVBounds() {
 		return getBounds();
 	}
 
 	public Dimension getVSize() {
-		System.out.println(getPreferredSize());
 		return getPreferredSize();
 	}
 
 	public Dimension getViewportSize() {
-		if(container instanceof JScrollPane) {
-			return ((JScrollPane)container).getViewport().getExtentSize();
+		if (container instanceof JScrollPane) {
+			return ((JScrollPane) container).getViewport().getExtentSize();
 		}
 		return getSize();
 	}
-	
+
 	public void redraw() {
 		repaint();
 	}
 
 	protected void paintComponent(Graphics g) {
-		child.draw((Graphics2D)g);
+		child.draw((Graphics2D) g);
 	}
-	
+
 	public void redraw(Rectangle r) {
 		repaint(r);
 	}
@@ -89,16 +95,16 @@
 	}
 
 	public void mouseClicked(MouseEvent arg0) {
-		//TODO: find out how to handle this one
+		// TODO: find out how to handle this one
 	}
 
 	public void mouseEntered(MouseEvent e) {
-		child.mouseEnter(new SwingMouseEvent(e));		
+		child.mouseEnter(new SwingMouseEvent(e));
 	}
 
 	public void mouseExited(MouseEvent e) {
 		child.mouseExit(new SwingMouseEvent(e));
-		
+
 	}
 
 	public void mousePressed(MouseEvent e) {
@@ -134,7 +140,16 @@
 
 	public VPathway createVPathway() {
 		setChild(new VPathway(this));
-		container.setViewportView(this);
 		return child;
 	}
+
+	public void vPathwayEvent(VPathwayEvent e) {
+		if(e.getType() == VPathwayEvent.MODEL_LOADED) {
+			if(e.getSource() == child) {
+				container.setViewportView(this);
+				revalidate();
+			}
+		}
+	}
+
 }
Index: trunk/src/core/org/pathvisio/util/SuggestCombo.java
===================================================================
--- trunk/src/core/org/pathvisio/util/SuggestCombo.java	(revision 976)
+++ trunk/src/core/org/pathvisio/util/SuggestCombo.java	(revision 977)
@@ -1,357 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.util;
-
-import java.util.ArrayList;
-
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.events.DisposeEvent;
-import org.eclipse.swt.events.DisposeListener;
-import org.eclipse.swt.events.ShellAdapter;
-import org.eclipse.swt.events.ShellEvent;
-import org.eclipse.swt.graphics.Point;
-import org.eclipse.swt.layout.FillLayout;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Control;
-import org.eclipse.swt.widgets.Event;
-import org.eclipse.swt.widgets.List;
-import org.eclipse.swt.widgets.Listener;
-import org.eclipse.swt.widgets.Shell;
-import org.eclipse.swt.widgets.Text;
-import org.pathvisio.util.SuggestCombo.SuggestionProvider.SuggestThread;
-
-public class SuggestCombo extends Composite {
-	protected boolean ignoreModify;
-	protected boolean ignoreFocusOut;
-
-	private SuggestThread currThread;
-	
-	private java.util.List<SuggestionListener> listeners;
-	private SuggestionProvider suggestionProvider;
-	
-	private int maxHeight = 100;
-	
-	private Text text;
-	private Shell suggestShell;
-	private List suggestList;
-	
-	public SuggestCombo(Composite parent, SuggestionProvider s) {
-		super(parent, SWT.NONE);
-		listeners = new ArrayList<SuggestionListener>();
-		suggestionProvider = s;
-		init(parent);
-	}
-	
-	public Control getControl() { 
-		return text;
-	}
-	
-	public SuggestionProvider getSuggestionProvider() { 
-		return suggestionProvider; 
-	}
-	
-	public boolean isFocusControl() {		
-		return 	text.isVisible() && text.isFocusControl() ||
-				isSuggestFocus();
-	}
-	
-	public boolean isSuggestFocus() {
-		return 	suggestShell.isVisible() && suggestShell.isFocusControl() ||
-				suggestList.isVisible() && suggestList.isFocusControl();
-	}
-	
-	public String getText() {
-		return text.getText();
-	}
-	
-	public void setText(String s) {
-		text.setText(s);
-	}
-	
-	public void setMaxHeight(int height) {
-		maxHeight = height;
-	}
-	
-	public int getMaxHeight() { return maxHeight; }
-	
-	void init(Composite parent) {
-		setLayout(new FillLayout());
-		
-		text = new Text(this, SWT.NONE);
-		Listener textListener = new Listener() {
-			public void handleEvent(Event e) {
-				switch(e.type) {
-				case SWT.Modify:
-					if(!ignoreModify) {
-						startSuggesting();
-						currThread.setText(text.getText());
-					} else {
-//						hideSuggestions();
-						ignoreModify = false;
-					}
-					break;
-				case SWT.KeyDown:
-					if(e.keyCode == SWT.ARROW_DOWN) {
-						if(suggestShell.isVisible()) {
-							suggestList.select(0);
-							suggestList.setFocus();
-						}
-					}
-					break;
-				case SWT.FocusOut:
-					if(!ignoreFocusOut) {
-						//Check if focus is on suggestShell/suggestList
-						if(!isSuggestFocus()) stopSuggesting();
-					}
-					break;
-				}
-			}
-		};
-		
-		text.addListener(SWT.Modify, textListener);
-		text.addListener(SWT.KeyDown, textListener);
-		text.addListener(SWT.FocusOut, textListener);
-
-		suggestShell = new Shell(getShell(), SWT.TOOL | SWT.ON_TOP);
-		suggestShell.setLayout(new FillLayout());
-		suggestList = new List(suggestShell, SWT.SINGLE | SWT.V_SCROLL | SWT.H_SCROLL);
-		
-		Listener listListener = new Listener() {
-			public void handleEvent(Event e) {
-				switch(e.type) {
-				case SWT.KeyDown:
-					if(e.keyCode != 13) break; //TODO:find proper SWT constant for return key
-				case SWT.DefaultSelection:
-				case SWT.MouseDown:
-					String[] selection = suggestList.getSelection();
-					if(selection.length > 0) 
-						suggestionSelected(suggestList.getSelection()[0]);
-					break;
-				case SWT.FocusOut:
-					if(!ignoreFocusOut) {
-						stopSuggesting();
-					}
-				}
-			}
-		};
-		suggestList.addListener(SWT.KeyDown, listListener);
-		suggestList.addListener(SWT.DefaultSelection, listListener);
-		suggestList.addListener(SWT.MouseDown, listListener);
-		suggestList.addListener(SWT.FocusOut, listListener);
-		
-		getShell().addShellListener(new ShellAdapter() {
-			public void shellDeactivated(ShellEvent e) {
-				stopSuggesting();
-			}
-		});
-		suggestShell.addShellListener(new ShellAdapter() {
-			public void shellActivated(ShellEvent arg0) {
-				showSuggestions();
-			}
-		});
-		// DisposeListener, in case user closes PathVisio while suggestShell is still active
-		suggestShell.addDisposeListener(new DisposeListener() {
-			public void widgetDisposed(DisposeEvent e) {
-				stopSuggesting();
-			}
-		});
-	}
-	
-	public void setVisible(boolean visible) {
-		stopSuggesting();
-		super.setVisible(visible);
-	}
-	
-	public void dispose() {
-		super.dispose();
-		suggestShell.dispose();
-	}
-	
-	void startSuggesting() {		
-		if(!suggestShell.isVisible()) {
-			initSuggestShell();
-		}
-		if(!isSuggesting()) {
-			currThread = new SuggestThread(text.getText(), this);
-			currThread.start();
-		}
-	}
-	
-	void stopSuggesting() {
-		doHideSuggestions();
-		if(currThread != null) {
-			currThread.interrupt();
-		}
-		currThread = null;
-	}
-	
-	boolean isSuggesting() {
-		return currThread != null && currThread.getState() != Thread.State.TERMINATED;
-	}
-	
-	public void addSuggestion(final String suggestion) {
-		getDisplay().asyncExec(new Runnable() {
-			public void run() {
-				doAddSuggestion(suggestion);
-			}
-		});
-}
-	
-	void doAddSuggestion(String suggestion) {
-			suggestList.add(suggestion);
-			showSuggestions();
-			resizeSuggestShell();
-	}
-	
-
-	
-	void initSuggestShell() {
-		Point location = text.getLocation();
-		location.y += text.getSize().y;
-		suggestShell.setLocation(text.toDisplay(location));
-		resizeSuggestShell();
-	}
-	
-	void resizeSuggestShell() {
-		Point listSize = suggestList.computeSize(SWT.DEFAULT, SWT.DEFAULT);
-		suggestShell.setSize(listSize.x, listSize.y < maxHeight ? listSize.y : maxHeight);
-	}
-	
-	public void setSuggestions(final String[] suggestions) {
-		getDisplay().asyncExec(new Runnable() {
-			public void run() {
-				doSetSuggestions(suggestions);
-			}
-		});
-	}
-	
-	void doSetSuggestions(String[] suggestions) {
-		suggestList.setItems(suggestions);
-		resizeSuggestShell();
-		showSuggestions();
-	}
-	
-	public void hideSuggestions() {
-		getDisplay().asyncExec(new Runnable() {
-			public void run() {
-				doHideSuggestions();
-			}
-		});
-	}
-	
-	void doHideSuggestions() {
-		if(!suggestShell.isDisposed()) 
-			suggestShell.setVisible(false);
-	}
-	
-	void showSuggestions() {
-		boolean restoreFocus = text.isFocusControl();
-		if(isFocusControl() && suggestList.getItemCount() > 0) {
-			suggestShell.setVisible(true);
-			
-			if(restoreFocus) {
-				ignoreFocusOut = true;
-				text.setFocus();
-				ignoreFocusOut = false;
-			}
-			
-		} else {
-			doHideSuggestions();
-		}
-	}
-	
-	void suggestionSelected(String suggestion) {
-		ignoreModify = true;
-		text.setText(suggestion);
-		doHideSuggestions();
-		for(SuggestionListener l : listeners) {
-			ignoreModify = true;
-			l.suggestionSelected(suggestion);
-		}
-	}
-	
-	public void addSuggetsionListener(SuggestionListener l) {
-		listeners.add(l);
-	}
-	
-	public interface SuggestionProvider {		
-		public String[] getSuggestions(String text, SuggestCombo suggestCombo);
-		
-		public class SuggestThread extends Thread {
-			protected SuggestCombo suggestCombo;
-			volatile protected String text;
-			volatile protected boolean textChange;
-			
-			private Thread doSuggestThread;
-			
-			public SuggestCombo getSuggestCombo() { return suggestCombo; }
-			public String getText() { return text; }
-			
-			public void setText(String newText) { 
-				text = newText;
-				textChange = true;
-			}
-			
-			public SuggestThread(String _text, SuggestCombo _suggestCombo) {
-				text = _text;
-				suggestCombo = _suggestCombo;
-			}
-			
-			public void start() {
-				if(suggestCombo == null || suggestCombo.isDisposed()) return;
-				super.start();
-			}
-
-			void setSuggestions(String[] suggestions) {
-				if(Thread.currentThread() == doSuggestThread) {
-					suggestCombo.setSuggestions(suggestions);
-				}
-			}
-			
-			public void run() {
-				while(!isInterrupted()) {
-					if(textChange) {
-						if(doSuggestThread != null) doSuggestThread.interrupt();
-						suggestCombo.hideSuggestions();
-						if(!text.equals("")) {
-							doSuggestThread = new Thread() {
-								public void run() {
-									SuggestionProvider sp = suggestCombo.getSuggestionProvider();
-									setSuggestions(sp.getSuggestions(text, suggestCombo));
-								}
-							};
-							doSuggestThread.start();
-						} else {
-							suggestCombo.hideSuggestions();
-						}
-						textChange = false;
-					} else {						
-						try {
-							Thread.sleep(300); //Wait for a while, in case user continues typing
-						} catch (InterruptedException e) {
-							return;
-						}
-					}
-				}
-			}
-		}
-	}
-		
-	public interface SuggestionListener {
-		public void suggestionSelected(String suggestion);
-	}
-}
Index: trunk/src/core/org/pathvisio/util/SuggestCellEditor.java
===================================================================
--- trunk/src/core/org/pathvisio/util/SuggestCellEditor.java	(revision 976)
+++ trunk/src/core/org/pathvisio/util/SuggestCellEditor.java	(revision 977)
@@ -1,78 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.util;
-
-import org.eclipse.jface.viewers.CellEditor;
-import org.eclipse.swt.events.FocusAdapter;
-import org.eclipse.swt.events.FocusEvent;
-import org.eclipse.swt.events.KeyAdapter;
-import org.eclipse.swt.events.KeyEvent;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Control;
-import org.pathvisio.util.SuggestCombo.SuggestionProvider;
-
-public abstract class SuggestCellEditor extends CellEditor {
-	protected SuggestCombo suggestCombo;
-	
-	public SuggestCellEditor() {
-		super();
-	}
-	
-	public SuggestCellEditor(Composite parent) {
-		super(parent);
-	}
-		
-	protected Control createControl(Composite parent) {
-		suggestCombo = new SuggestCombo(parent, getSuggestionProvider());
-
-		setKeyListeners();
-		setFocusListeners();
-
-		return suggestCombo;
-	}
-
-	protected void setKeyListeners() {
-		suggestCombo.getControl().addKeyListener(new KeyAdapter() {
-            public void keyPressed(KeyEvent e) {
-                keyReleaseOccured(e);
-            }
-		});
-	}
-	
-	protected void setFocusListeners() {
-        suggestCombo.getControl().addFocusListener(new FocusAdapter() {
-            public void focusLost(FocusEvent e) {
-            	if(!suggestCombo.isSuggestFocus()) {
-            		SuggestCellEditor.this.focusLost();
-            	}
-            }
-        });
-	}
-	public abstract SuggestionProvider getSuggestionProvider();
-		
-	protected Object doGetValue() {
-		return suggestCombo.getText();
-	}
-	
-	protected void doSetValue(Object value) {
-		suggestCombo.setText(value == null ? "" : value.toString());
-	}
-
-	protected void doSetFocus() {}
-
-
-}
Index: trunk/src/core/org/pathvisio/util/TableColumnResizer.java
===================================================================
--- trunk/src/core/org/pathvisio/util/TableColumnResizer.java	(revision 976)
+++ trunk/src/core/org/pathvisio/util/TableColumnResizer.java	(revision 977)
@@ -1,129 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.util;
-
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.events.ControlAdapter;
-import org.eclipse.swt.events.ControlEvent;
-import org.eclipse.swt.graphics.Point;
-import org.eclipse.swt.graphics.Rectangle;
-import org.eclipse.swt.layout.FillLayout;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Table;
-import org.eclipse.swt.widgets.TableColumn;
-
-/**
- * This class is responsible for resizing a table's column width to fit its parents width
- * Columns that are unresizable ({@link TableColumn#getResizable()} = false) are skipped
- * NOTE: Be sure the table's parent {@link Composite} contains only the table (no
- * other controls) and uses {@link FillLayout}.
- */
-public class TableColumnResizer extends ControlAdapter {
-	Table table;
-	Composite parent;
-	TableColumn[] cols;
-	double[] weights;
-	int[] widths;
-	
-	/**
-	 * Constructor for this class
-	 * @param table		The tables of which the columns have to be resized
-	 * @param parent	The parent composite to fill the column width
-	 * @param weights	The relative size of each column (when a column is unresizable, set this to 0)
-	 */
-	public TableColumnResizer(Table table, Composite parent, int[] weights) {
-		this.table = table;
-		this.parent = parent == null ? table.getParent() : parent;
-		cols = table.getColumns();
-		setWeights(weights);
-		initWidths();
-	}
-	
-	void initWidths() {
-		widths = new int[cols.length];
-		for(int i = 0; i < cols.length; i++)
-			widths[i] = cols[i].getWidth();
-	}
-	
-	public void setWeights(int[] intWeights) {
-		if(intWeights == null) {
-			weights = new double[cols.length];
-			int resizable = 0;
-			for(TableColumn c : cols) resizable += c.getResizable() ? 1 : 0;
-			for(int i = 0; i < weights.length; i++) weights[i] = 1.0 / resizable;
-		} else {
-			int sum = 0;
-			for(int i : intWeights) sum += i;
-			weights = new double[intWeights.length];
-			for(int i = 0; i < intWeights.length; i++) weights[i] = (double)intWeights[i] / sum;
-		}
-	}
-	public TableColumnResizer(Table table, Composite parent) {
-		this(table, parent, null);
-	}
-	
-	public void controlResized(ControlEvent e) {
-		doResize();
-	}
-	
-	public void doResize() {
-		//Check if number of columns is the same
-		if(table.getColumns().length != cols.length) {
-			cols = table.getColumns();
-			setWeights(null);
-		}
-		cols = table.getColumns();
-		
-		Rectangle area = parent.getClientArea();
-		Point preferredSize = table.computeSize(SWT.DEFAULT, SWT.DEFAULT);
-		int width = area.width - 2 * table.getBorderWidth();
-		if (preferredSize.y > area.height + table.getHeaderHeight()) {
-			// Subtract the scrollbar width from the total column width
-			// if a vertical scrollbar will be required
-			Point vBarSize = table.getVerticalBar().getSize();
-			width -= vBarSize.x * 2;
-		}
-		
-		//Subtract width of columns with fixed size from available width
-		for(int i = 0; i < cols.length; i++) width -= cols[i].getResizable() ? 0 : widths[i];
-		
-		Point oldSize = table.getSize();
-		if (oldSize.x > area.width) {
-			// table is getting smaller so make the columns
-			// smaller first and then resize the table to
-			// match the client area width
-			for (int i = 0; i < cols.length; i++) {
-				if(cols[i].getResizable()) {
-					cols[i].setWidth((int)(width * weights[i]));
-				}
-			}
-			
-			table.setSize(area.width, area.height);
-		} else {
-			// table is getting bigger so make the table
-			// bigger first and then make the columns wider
-			// to match the client area width
-			table.setSize(area.width, area.height);
-			
-			for (int i = 0; i < cols.length; i++) {
-				if(cols[i].getResizable())	{
-					cols[i].setWidth((int)(width * weights[i]));
-				}
-			}
-		}
-	}
-}
Index: trunk/src/core/org/pathvisio/util/SwtUtils.java
===================================================================
--- trunk/src/core/org/pathvisio/util/SwtUtils.java	(revision 976)
+++ trunk/src/core/org/pathvisio/util/SwtUtils.java	(revision 977)
@@ -1,537 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.util;
-
-import java.awt.image.BufferedImage;
-import java.awt.image.DirectColorModel;
-import java.awt.image.IndexColorModel;
-import java.awt.image.WritableRaster;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-
-import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.jface.dialogs.IInputValidator;
-import org.eclipse.jface.dialogs.InputDialog;
-import org.eclipse.jface.dialogs.MessageDialog;
-import org.eclipse.jface.operation.IRunnableWithProgress;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.events.SelectionAdapter;
-import org.eclipse.swt.events.SelectionEvent;
-import org.eclipse.swt.graphics.Color;
-import org.eclipse.swt.graphics.Font;
-import org.eclipse.swt.graphics.FontData;
-import org.eclipse.swt.graphics.GC;
-import org.eclipse.swt.graphics.Image;
-import org.eclipse.swt.graphics.ImageData;
-import org.eclipse.swt.graphics.PaletteData;
-import org.eclipse.swt.graphics.Point;
-import org.eclipse.swt.graphics.RGB;
-import org.eclipse.swt.graphics.Transform;
-import org.eclipse.swt.layout.GridData;
-import org.eclipse.swt.widgets.Button;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Control;
-import org.eclipse.swt.widgets.Display;
-import org.eclipse.swt.widgets.FileDialog;
-import org.eclipse.swt.widgets.Shell;
-import org.pathvisio.Engine;
-import org.pathvisio.gui.swt.SwtEngine;
-import org.pathvisio.model.Pathway;
-import org.pathvisio.view.VPathway;
-
-public class SwtUtils {
-
-	public static GridData getColorLabelGrid() {
-		GridData colorLabelGrid = new GridData(GridData.HORIZONTAL_ALIGN_BEGINNING);
-		colorLabelGrid.widthHint = colorLabelGrid.heightHint = 15;
-		return colorLabelGrid;
-	}
-	
-	/**
-	 * Change the given {@link Color}; this method disposes the old color for you
-	 * @param cOld	the old {@link Color}
-	 * @param rgbNew	the {@link RGB} to construct the new color
-	 * @param display	the display to assign the color to
-	 * @return	a brand new {@link Color}
-	 */
-	public static Color changeColor(Color cOld, RGB rgbNew, Display display)
-	{
-		if(cOld != null && !cOld.isDisposed())
-		{
-			cOld.dispose();
-			cOld = null;
-		}
-		if(rgbNew == null) rgbNew = new RGB(0,0,0);
-		return new Color(display, rgbNew);
-	}
-	
-	public static RGB color2rgb(java.awt.Color c) {
-		return new RGB(c.getRed(), c.getGreen(), c.getBlue());
-	}
-	
-	public static java.awt.Color rgb2color(RGB rgb) {
-		return new java.awt.Color(rgb.red, rgb.green, rgb.blue);
-	}
-	
-	/**
-	 * Change the given {@link Color}; this method disposes the old color for you
-	 * @param cOld	the old {@link Color}
-	 * @param rgbNew	the {@link Pathway.Color} to construct the new color
-	 * @param display	the display to assign the color to
-	 * @return	a brand new {@link Color}
-	 */
-	public static Color changeColor(Color cOld, java.awt.Color rgbNew, Display display)
-	{
-		if(cOld != null && !cOld.isDisposed())
-		{
-			cOld.dispose();
-			cOld = null;
-		}
-		if(rgbNew == null) rgbNew = new java.awt.Color(0,0,0);
-		return new Color(display, ColorConverter.toRGB(rgbNew));
-	}
-	
-	/**
-	 * Change the given {@link Font}; this method disposes the old font for you
-	 * @param fOld	the old {@link Font}
-	 * @param fd	the {@link FontData} to construct the font with
-	 * @param display	the display to assign the font to
-	 * @return	a brand new {@link Font}
-	 */
-	public static Font changeFont(Font fOld, FontData fd, Display display)
-	{
-		if(fOld != null && !fOld.isDisposed())
-		{
-			fOld.dispose();
-		}
-		return fd != null ? new Font(display, fd) : null;
-	}
-	
-	public static Image changeImage(Image iOld, ImageData iNew, Display display)
-	{
-		if(iOld != null && !iOld.isDisposed())
-		{
-			iOld.dispose();
-		}
-		return iNew != null ? new Image(display, iNew) : null;
-	}
-	
-	  public static ImageData convertImageToSWT(BufferedImage bufferedImage) {
-		    if (bufferedImage.getColorModel() instanceof DirectColorModel) {
-		      DirectColorModel colorModel = (DirectColorModel) bufferedImage
-		          .getColorModel();
-		      PaletteData palette = new PaletteData(colorModel.getRedMask(),
-		          colorModel.getGreenMask(), colorModel.getBlueMask());
-		      ImageData data = new ImageData(bufferedImage.getWidth(),
-		          bufferedImage.getHeight(), colorModel.getPixelSize(),
-		          palette);
-		      WritableRaster raster = bufferedImage.getRaster();
-		      int[] pixelArray = new int[4];
-		      for (int y = 0; y < data.height; y++) {
-		        for (int x = 0; x < data.width; x++) {
-		          raster.getPixel(x, y, pixelArray);
-		          int pixel = palette.getPixel(new RGB(pixelArray[0],
-		              pixelArray[1], pixelArray[2]));
-		          data.setPixel(x, y, pixel);
-		        }
-		      }
-		      return data;
-		    } else if (bufferedImage.getColorModel() instanceof IndexColorModel) {
-		      IndexColorModel colorModel = (IndexColorModel) bufferedImage
-		          .getColorModel();
-		      int size = colorModel.getMapSize();
-		      byte[] reds = new byte[size];
-		      byte[] greens = new byte[size];
-		      byte[] blues = new byte[size];
-		      colorModel.getReds(reds);
-		      colorModel.getGreens(greens);
-		      colorModel.getBlues(blues);
-		      RGB[] rgbs = new RGB[size];
-		      for (int i = 0; i < rgbs.length; i++) {
-		        rgbs[i] = new RGB(reds[i] & 0xFF, greens[i] & 0xFF,
-		            blues[i] & 0xFF);
-		      }
-		      PaletteData palette = new PaletteData(rgbs);
-		      ImageData data = new ImageData(bufferedImage.getWidth(),
-		          bufferedImage.getHeight(), colorModel.getPixelSize(),
-		          palette);
-		      data.transparentPixel = colorModel.getTransparentPixel();
-		      WritableRaster raster = bufferedImage.getRaster();
-		      int[] pixelArray = new int[1];
-		      for (int y = 0; y < data.height; y++) {
-		        for (int x = 0; x < data.width; x++) {
-		          raster.getPixel(x, y, pixelArray);
-		          data.setPixel(x, y, pixelArray[0]);
-		        }
-		      }
-		      return data;
-		    }
-		    return null;
-		  }
-	  
-	public static void setCompositeAndChildrenEnabled(Composite comp, boolean enable) {
-		comp.setEnabled(enable);
-		for(Control c : comp.getChildren()) {
-			c.setEnabled(enable);
-			if(c instanceof Composite)
-				setCompositeAndChildrenEnabled((Composite) c, enable);
-		}
-	}
-	
-	public static void setCompositeAndChildrenBackground(Composite comp, Color color) {
-		comp.setBackground(color);
-		for(Control c : comp.getChildren()) {
-			c.setBackground(color);
-			if(c instanceof Composite)
-				setCompositeAndChildrenBackground((Composite) c, color);
-		}
-	}
-	
-	static int[] incrs;
-	static int ii;
-	static int pixratio;
-	public static Font adjustFontSize(Font f, Point toFit, String text, GC gc, Display display) {
-		VPathway d = Engine.getActiveVPathway();
-		pixratio = (int)Math.ceil(3 * (d == null ? 1 : d.getZoomFactor()));
-		ii = 3;
-		incrs = new int[3];
-//		System.err.println(">>>>>>>>>>>> Starting adjust <<<<<<<<<<<<,");
-//		System.err.println("INITIAL: "+ f.getFontData()[0].getHeight());
-		f = setFontSize(f.getFontData()[0].getHeight(), f, gc, display);
-		return findFontSize(f, toFit, text, gc, display);		
-	}
-	
-	static int getIncrement(Point toFit, String text, GC gc) {	
-		int borderX = 3;
-		int borderY = 0;
-		
-		Point size = gc.textExtent(text);
-		
-		int dx = size.x - toFit.x + borderX;
-		int dy = size.y - toFit.y + borderY;
-		if(dx == 0 && dy == 0) return 0; //rare case
-		return add(pix2point(-Math.max(dx, dy)));
-	}
-	
-	static Font findFontSize(Font f, Point toFit, String text, GC gc, Display display) {
-		int incr = getIncrement(toFit, text, gc);
-//		System.err.println("incr: " + incr);
-		if(incr != 0 && checkIncrs()) {
-			int size = f.getFontData()[0].getHeight() + incr;
-//			System.err.println("Size: " + size);
-			if(size < 0) {
-				pixratio++;
-//				System.err.println("Increasing pixratio: " + pixratio);
-			} else {
-				f = setFontSize(size, f, gc,display);
-			}
-			f = findFontSize(f, toFit, text, gc, display);
-		}
-		return f;
-	}
-	
-	static boolean checkIncrs() {
-		//System.err.println(incrs[0] + " : " + incrs[1] + " : " + incrs[2]);
-		return !(incrs[0] == incrs[2]);
-	}
-	
-	static int add(int incr) {
-		incrs[0] = incrs[1];
-		incrs[1] = incrs[2];
-		incrs[2] = incr;
-		return incr;
-	}
-	
-	static int pix2point(int pix) { 
-		//System.err.println("pix: " + pix);
-		//System.err.println("point: " + (double)pix/pixratio);
-		return pix / pixratio; 
-	}
-	
-	public static FontData awtFont2FontData(java.awt.Font f) {
-		int style = SWT.NORMAL;
-		if(f.isBold()) style |= SWT.BOLD;
-		if(f.isItalic()) style |= SWT.ITALIC;
-		return new FontData(f.getName(), f.getSize(), style);
-	}
-	
-	public static java.awt.Font fontData2awtFont(FontData fd) {
-		int style = java.awt.Font.PLAIN;
-		if((fd.style & SWT.BOLD) != 0) style |= java.awt.Font.BOLD;
-		if((fd.style & SWT.ITALIC) != 0) style |= java.awt.Font.ITALIC;
-		return new java.awt.Font(fd.getName(), fd.getHeight(), style);		
-	}
-	
-	static Font setFontSize(int size, Font f, GC gc, Display display) {
-		FontData fd = f.getFontData()[0];
-		fd.setHeight(size);
-		f = changeFont(f, fd, display);
-		gc.setFont(f);
-		return f;
-	}
-	
-	public static int getAverageCharWidth(Display d) {
-		GC gc = new GC(d);
-		int w = gc.getFontMetrics().getAverageCharWidth();
-		gc.dispose();
-		return w;
-	}
-	
-	/**
-	 * Rotates the {@link GC} around the objects center
-	 * @param gc	the {@link GC} to rotate
-	 * @param tr	a {@link Transform} that can be used for rotation
-	 * @param rotation The rotation in degrees
-	 * @param x The x-coordinate of the rotation center
-	 * @param y The y-coordinate of the rotation center
-	 */
-	public static void rotateGC(GC gc, Transform tr, float rotation, int x, int y) {
-		tr.translate(x, y);
-		tr.rotate(rotation);	
-		tr.translate(-x, -y);
-		gc.setTransform(tr);
-	}
-	
-	public static class FileInputDialog extends InputDialog {
-		FileDialog fd;
-		public FileInputDialog(Shell parentShell, String dialogTitle, 
-				String dialogMessage, String initialValue, 
-				IInputValidator validator, FileDialog fileDialog) {
-			super(parentShell, dialogTitle, dialogMessage, initialValue, validator); 
-			fd = fileDialog;
-		}
-
-		protected Control createDialogArea(Composite parent) {
-			Composite composite = (Composite) super.createDialogArea(parent);
-			Button browse = new Button(parent, SWT.PUSH);
-			browse.setText("Browse");
-			browse.addSelectionListener(new SelectionAdapter() {
-				public void widgetSelected(SelectionEvent e) {
-					String fn = fd.open();
-					if(fn != null) getText().setText(fn);
-				}
-			});
-			return composite;
-		}
-	}
-	
-	/**
-	 * This class is a re-usable implementation of {@link IRunnableWithProgress} and can invoke
-	 * any given {@link Method} that needs to be runned in a seperate thread using a progress monitor
-	 * @author thomas
-	 *
-	 */
-	public static class SimpleRunnableWithProgress implements IRunnableWithProgress {
-		Method doMethod; 					//The method to perform
-		private Object[] args;				//The arguments to pass to the method
-		Object instance;					//The instance of the class that contains the method to be run
-		boolean runAsSyncExec;
-		
-		volatile static IProgressMonitor monitor;	//The progress monitor
-		
-		static final String INIT_TASKNAME = "";
-		static final int INIT_TOTALWORK = 1000;
-		static String taskName = INIT_TASKNAME;		//Taskname to display in the progress monitor
-		static int totalWork = INIT_TOTALWORK;		//Total work to be performed
-				
-		/**
-		 * Constructor for this class<BR>
-		 * Sets the signature of the method to be called and its argument values
-		 * @param fromClass the Class to which the method belongs that
-		 * has to be called. you can get this with instance.getClass()
-		 * or StaticClass.class
-		 * @param method	the method to be called
-		 * @param parameters	the classes of the method's arguments
-		 * @param args	the argument values to pass to the method
-		 * @param instance	an instance of the class to which the method belongs (null for static methods)
-		 */
-		public SimpleRunnableWithProgress(Class fromClass, String method, 
-				Class[] parameters,	Object[] args, Object instance) {
-			super();
-			this.args = args;
-			this.instance = instance;
-			try {
-				doMethod = fromClass.getMethod(method, parameters);
-			} catch(NoSuchMethodException e) {
-				openMessageDialog("Error: method not found", e.getMessage());
-			}
-		}
-		
-		/**
-		 * Constructor for this class<BR>
-		 * Sets the signature of the method to be called
-		 * @param fromClass	the Class to which the method belongs that has to be called
-		 * @param method	the method to be called
-		 * @param parameters	the classes of the method's arguments
-		 */
-		public SimpleRunnableWithProgress(Class fromClass, String method, Class[] parameters) {
-			this(fromClass, method, parameters, null, null);
-		}
-		
-		/**
-		 * Set the values of the to be called method's arguments
-		 * @param args
-		 */
-		public void setArgs(Object[] args) { this.args = args; }
-		
-		/**
-		 * Set an instance of the to be called method's class
-		 * @param obj
-		 */
-		public void setInstance(Object obj) { instance = obj; } 
-		
-		/**
-		 * Get the progress monitor currently used
-		 * @return the currently used progress monitor, or null if none is used
-		 */
-		public static IProgressMonitor getMonitor() { return monitor; }
-		
-		/**
-		 * Get the total work to be performed
-		 */
-		public static int getTotalWork() { return totalWork; }
-		
-		/**
-		 * Returns whether cancelation of current operation has been requested
-		 * @return true if the monitor is cancelled, false if running or null
-		 */
-		public static boolean isCancelled() {
-			if(monitor != null) return monitor.isCanceled();
-			else return false; //Not canceled if no monitor
-		}
-		
-		/**
-		 * Set the monitor information (before starting the process)
-		 * @param tn	the taskname to be displayed (may be changed while running)
-		 * @param tw	the total work to be performed
-		 */
-		public static void setMonitorInfo(String tn, int tw) {
-			taskName = tn;
-			totalWork = tw;
-		}
-		
-		/**
-		 * Set the total work to be performed
-		 */
-		public static void setTotalWork(int tw) {
-			totalWork = tw;
-		}
-		
-		/**
-		 * Set the task name that is displayed on the progress monitor
-		 */
-		public static void setTaskName(String tn) {
-			taskName = tn;
-		}
-		
-		public void setRunAsSyncExec(boolean useSyncExec) {
-			runAsSyncExec = useSyncExec;
-		}
-		
-		Throwable runException;
-		public void run(IProgressMonitor monitor) throws InterruptedException,
-			InvocationTargetException {
-			
-			SimpleRunnableWithProgress.monitor = monitor;
-			
-			if(args == null || doMethod == null) {
-				InterruptedException ex = new InterruptedException("missing method or arguments, see error log for details");
-				Engine.log.error("unable to invoke " + doMethod, ex);
-				throw ex;
-			}
-					
-			monitor.beginTask(taskName, totalWork);
-
-			runException = null;
-			if(runAsSyncExec) {//Invoke in syncExec, method may access widgets from this thread
-				SwtEngine.getWindow().getShell().getDisplay().syncExec(new Runnable() {
-					public void run() {
-						runException = doInvoke();
-					}
-				});
-			} else {
-				runException = doInvoke();
-			}
-			
-			monitor.done();
-			resetMonitor();
-			
-			if(runException != null) {
-				if		(runException instanceof IllegalAccessException)
-					throw new InvocationTargetException(runException, "Unable to invoke method " + doMethod);
-				else if	(runException instanceof IllegalArgumentException)
-					throw new InvocationTargetException(runException, "Unable to invoke method " + doMethod);
-				else if (runException instanceof InvocationTargetException)
-					throw (InvocationTargetException)runException;
-				else
-					throw new InvocationTargetException(runException);
-			}
-		}
-		
-		void resetMonitor() {
-			monitor = null;
-			totalWork = INIT_TOTALWORK;
-			taskName = INIT_TASKNAME;
-		}
-		
-		private Throwable doInvoke() {
-			try { doMethod.invoke(instance, args); } catch(Throwable t) { return t; }
-			return null;
-		}
-
-		/**
-		 * Notify the {@link IProgressMonitor} that given number of work has been performed<BR>
-		 * Equivalent to calling {@link IProgressMonitor#worked(int)} from an {@link Display#asyncExec(Runnable)}
-		 * @see IProgressMonitor#worked(int)
-		 * @param w
-		 */
-		public static void monitorWorked(final int w) {
-			SwtEngine.getWindow().getShell().getDisplay().asyncExec(new Runnable() {
-				public void run() {
-					if(monitor != null) monitor.worked(w);
-				}
-			});
-		}
-		
-		/**
-		 * Sets the task name of the progress monitor to the given value
-		 * * Equivalent to calling {@link IProgressMonitor#setTaskName(String)} from an {@link Display#asyncExec(Runnable)}
-		 * @see IProgressMonitor#setTaskName(String)
-		 */
-		public static void monitorSetTaskName(final String taskName) {
-			SwtEngine.getWindow().getShell().getDisplay().asyncExec(new Runnable() {
-				public void run() {
-					if(monitor != null) monitor.setTaskName(taskName);
-				}
-			});
-		}
-		
-		/**
-		 * Opens a message dialog from withing a {@link Display#asyncExec(Runnable)}
-		 * @param title	the title of the dialog
-		 * @param msg	the message to be displayed on the dialog
-		 * @see MessageDialog#openInformation(org.eclipse.swt.widgets.Shell, String, String)
-		 */
-		public void openMessageDialog(final String title, final String msg) {
-			SwtEngine.getWindow().getShell().getDisplay().asyncExec(new Runnable() {
-				public void run() {
-					MessageDialog.openInformation(SwtEngine.getWindow().getShell(), title, msg);
-				}
-			});
-		}
-	}
-}
Index: trunk/src/core/org/pathvisio/util/ColorConverter.java
===================================================================
--- trunk/src/core/org/pathvisio/util/ColorConverter.java	(revision 976)
+++ trunk/src/core/org/pathvisio/util/ColorConverter.java	(revision 977)
@@ -18,57 +18,24 @@
 
 import java.awt.Color;
 
-import org.eclipse.swt.graphics.RGB;
 import org.jdom.Element;
-import org.pathvisio.Engine;
 
 public abstract class ColorConverter
-{		    
-    /**
-	 * Creates a string representing a {@link RGB} object which is parsable by {@link #parseRgbString(String)}
-	 * @param rgb the {@link RGB} object to create a string from
-	 * @return the string representing the {@link RGB} object
-	 */
-	public static String getRgbString(RGB rgb)
-	{
-		return rgb.red + "," + rgb.green + "," + rgb.blue;
-	}
-	
-	public static String getRgbString(java.awt.Color c) {
+{		
+	/**
+	 * Returns a string representing a {@link Color} object.
+	 * @param c The {@link Color} to be converted to a string
+	 * @return a string representing the {@link Color} c
+	 */	
+	public static String getRgbString(Color c) {
 		return c.getRed() + "," + c.getGreen() + "," + c.getBlue();
 	}
-	
-	public static RGB toRGB(Color c) {
-		return new RGB(c.getRed(), c.getGreen(), c.getBlue());
-	}
-	
-	public static Color fromRGB(RGB rgb) {
-		return new Color(rgb.red, rgb.green, rgb.blue);
-	}
-	
+		
 	/**
-	 * Parses a string representing a {@link RGB} object created with {@link #getRgbString(RGB)}
+	 * Parses a string representing a {@link Color} object created with {@link #getRgbString(Color)}
 	 * @param rgbString the string to be parsed
-	 * @return the {@link RGB} object this string represented
-	 */
-	public static RGB parseRgbString(String rgbString)
-	{
-		String[] s = rgbString.split(",");
-		try 
-		{
-			return new RGB(
-					Integer.parseInt(s[0]), 
-					Integer.parseInt(s[1]), 
-					Integer.parseInt(s[2]));
-		}
-		catch(Exception e)
-		{
-			Engine.log.error("Unable to parse color '" + rgbString + 
-					"'stored in expression database", e);
-			return new RGB(0,0,0);
-		}
-	}
-	    
+	 * @return the {@link Color} object this string represented
+	 */	    
 	public static java.awt.Color parseColorString(String colorString)
 	{
 		String[] s = colorString.split(",");
Index: trunk/src/core/org/pathvisio/util/JarUtils.java
===================================================================
--- trunk/src/core/org/pathvisio/util/JarUtils.java	(revision 976)
+++ trunk/src/core/org/pathvisio/util/JarUtils.java	(revision 977)
@@ -32,7 +32,6 @@
 
 import org.pathvisio.Engine;
 import org.pathvisio.Globals;
-import org.pathvisio.gui.swt.SwtEngine;
 
 public class JarUtils {
 	static final String PREFIX_TMP = Globals.APPLICATION_NAME;
@@ -76,7 +75,7 @@
 	public static List<String> listResources(String path) throws IOException {
 		List<String> resNames = new ArrayList<String>();
 
-		URL url = SwtEngine.class.getClassLoader().getResource(path);
+		URL url = Engine.class.getClassLoader().getResource(path);
 		if(url != null) {
 			if(url.getProtocol().equals("jar")) {
 				JarURLConnection conn = (JarURLConnection)url.openConnection();
@@ -98,7 +97,7 @@
 	 * @return the URL pointing to the resource
 	 */
 	public static URL getResourceURL(String name) {
-		URL url = SwtEngine.class.getClassLoader().getResource(name);
+		URL url = Engine.class.getClassLoader().getResource(name);
 		if(url == null) Engine.log.error("Couldn't load resource '" + name + "'");
 		return url;
 	}
@@ -109,7 +108,7 @@
 	 * @return the URL pointing to the resource
 	 */
 	public static InputStream getResourceInputStream(String name) {
-		InputStream in = SwtEngine.class.getClassLoader().getResourceAsStream(name);
+		InputStream in = Engine.class.getClassLoader().getResourceAsStream(name);
 		if(in == null) Engine.log.error("Couldn't load resource '" + name + "'");
 		return in;
 	}
Index: trunk/src/swt/org/pathvisio/preferences/swt/SwtPreferences.java
===================================================================
--- trunk/src/swt/org/pathvisio/preferences/swt/SwtPreferences.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/preferences/swt/SwtPreferences.java	(revision 977)
@@ -0,0 +1,189 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.preferences.swt;
+
+import java.io.File;
+import java.io.IOException;
+
+import org.eclipse.jface.preference.PreferenceStore;
+import org.eclipse.jface.util.IPropertyChangeListener;
+import org.eclipse.jface.util.PropertyChangeEvent;
+import org.pathvisio.Engine;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.Preference;
+import org.pathvisio.preferences.PreferenceCollection;
+import org.pathvisio.util.ColorConverter;
+import org.pathvisio.view.Graphics;
+
+import com.sun.org.apache.xpath.internal.operations.Bool;
+
+/**
+ * This class contains all user preferences used in this application
+ */
+public class SwtPreferences extends PreferenceStore implements PreferenceCollection, IPropertyChangeListener {
+	private static final File preferenceFile = new File(SwtEngine.getApplicationDir(), ".PathVisio");
+	
+	public SwtPreferences() {
+		this(preferenceFile.toString());
+	}
+	
+	public SwtPreferences(String fileName) {
+		super(fileName);
+		loadPreferences();
+	}
+	
+	public Preference byName(String name) {
+		Preference p = null;
+		if(name.startsWith("SWT")) {
+			p = SwtPreference.valueOf(name);
+		} else {
+			p = GlobalPreference.valueOf(name);
+		}
+		return p;
+	}
+	
+	protected void toEnums(Preference[] enumPrefs) {
+		for(Preference p : enumPrefs) {
+			p.setValue(getString(p.name()));
+		}
+	}
+	
+	protected void toEnums() {
+		toEnums(SwtPreference.values());
+		toEnums(GlobalPreference.values());
+	}
+	
+	protected void fromEnums(Preference[] enumPrefs) {
+		for(Preference p : enumPrefs) {
+			setValue(p.name(), p.getValue());
+		}
+	}
+	
+	protected void fromEnums() {
+		fromEnums(SwtPreference.values());
+		fromEnums(GlobalPreference.values());
+	}
+	
+	public void save() throws IOException {
+		fromEnums();
+		super.save();
+	}
+	
+	/**
+	 * Loads all stored users preferences and set defaults
+	 */
+	private void loadPreferences()
+	{
+		addPropertyChangeListener(this);
+		
+		for(Preference p : GlobalPreference.values()) {
+			setDefault(p);
+		}
+		
+		for(Preference p : SwtPreference.values()) {
+			setDefault(p);
+		}
+		
+		try {
+			load();
+		} catch(Exception e) { 
+			Engine.log.error("Unable to load preferences", e);
+		}
+		
+		toEnums();
+		
+		createDataDirectories();
+		
+	}
+	
+	private void setDefault(Preference p) {
+		setDefault(p.name(), p.getDefault());
+	}
+	
+	private void createDataDirectories() {
+		// For the data directories: if not defined by user, create default directories
+		Preference[] dataProps = new Preference[] 
+		{ 
+			SwtPreference.SWT_DIR_EXPR, SwtPreference.SWT_DIR_GDB, 
+			SwtPreference.SWT_DIR_PWFILES, SwtPreference.SWT_DIR_RDATA 
+		};
+		
+		for(Preference prop : dataProps) {
+			File dir = new File(prop.getValue());
+			if(!dir.exists()) dir.mkdirs();
+		}
+	}
+	
+	public void propertyChange(PropertyChangeEvent e) {
+		Preference p = byName(e.getProperty());
+		if(p != null) {
+			p.setValue(e.getNewValue().toString());
+		}
+		
+		if(e.getProperty().equals(GlobalPreference.COLOR_SELECTED.name())) { 
+			//if(e.getNewValue() instanceof RGB) Graphics.selectColor = (RGB)e.getNewValue();
+			//else 
+				Graphics.selectColor = ColorConverter.parseColorString((String)e.getNewValue());
+			Engine.getActiveVPathway().redraw();
+		}
+		if(e.getProperty().startsWith("directories")) {
+			createDataDirectories();
+		}
+	}
+	
+	public enum SwtPreference implements Preference {
+		SWT_DIR_PWFILES(new File(SwtEngine.getDataDir().toString(), "pathways").toString()),
+		SWT_DIR_GDB(new File(SwtEngine.getDataDir().toString(), "gene databases").toString()),
+		SWT_DIR_EXPR(new File(SwtEngine.getDataDir().toString(), "expression datasets").toString()),
+		SWT_DIR_RDATA(new File(SwtEngine.getDataDir().toString(), "R data").toString()),
+
+		SWT_CURR_GDB("none"),
+		SWT_DB_ENGINE_GDB("org.pathvisio.data.DBConnDerby"),
+		SWT_DB_ENGINE_EXPR("org.pathvisio.data.DBConnDerby"),
+		SWT_SIDEPANEL_SIZE("30"),
+		
+		SWT_SHOW_ADVANCED_ATTR(Boolean.toString(false));
+		
+		SwtPreference(String defaultValue) {
+			this.defaultValue = defaultValue;
+		}
+
+		private String defaultValue;
+		private String value;
+		
+		public String getDefault() {
+			return defaultValue;
+		}
+		
+		public void setDefault(String defValue) {
+			defaultValue = defValue;
+		}
+		
+		public void setValue(String newValue) {
+			value = newValue;
+		}
+		
+		public String getValue() {
+			if(value != null) {
+				return value;
+			} else {
+				return defaultValue;
+			}
+		}
+	}
+}
\ No newline at end of file
Index: trunk/src/swt/org/pathvisio/preferences/swt/PreferenceDlg.java
===================================================================
--- trunk/src/swt/org/pathvisio/preferences/swt/PreferenceDlg.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/preferences/swt/PreferenceDlg.java	(revision 977)
@@ -0,0 +1,145 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.preferences.swt;
+
+import org.eclipse.jface.preference.BooleanFieldEditor;
+import org.eclipse.jface.preference.ColorFieldEditor;
+import org.eclipse.jface.preference.DirectoryFieldEditor;
+import org.eclipse.jface.preference.FieldEditorPreferencePage;
+import org.eclipse.jface.preference.FileFieldEditor;
+import org.eclipse.jface.preference.IntegerFieldEditor;
+import org.eclipse.jface.preference.PreferenceManager;
+import org.eclipse.jface.preference.PreferenceNode;
+import org.eclipse.jface.preference.StringFieldEditor;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+
+public class PreferenceDlg extends PreferenceManager {
+	
+	public PreferenceDlg() {
+		super();
+
+		PreferenceNode display = new PreferenceNode("display", new DisplayPage());
+	    PreferenceNode colors = new PreferenceNode("colors", new ColorsPage());
+	    PreferenceNode directories = new PreferenceNode("directories", new DirectoriesPage());
+	    PreferenceNode files = new PreferenceNode("files", new FilesPage());
+	    PreferenceNode database = new PreferenceNode("database", new DatabasePage());
+	    
+	    addToRoot(display);
+	    addTo("display", colors);
+	    addToRoot(directories);
+	    addToRoot(files);
+	    addToRoot(database);
+	}
+	
+	private class FilesPage extends FieldEditorPreferencePage {
+		public FilesPage() {
+			super("Files", GRID);
+		}
+		
+		protected void createFieldEditors() {
+			FileFieldEditor f1 = new FileFieldEditor(GlobalPreference.FILE_LOG.name(), "Log file:", getFieldEditorParent());
+			addField(f1);
+		}
+	}
+	
+	private class DirectoriesPage extends FieldEditorPreferencePage {
+		public DirectoriesPage() {
+			super("Directories", GRID);
+			noDefaultAndApplyButton();
+		}
+		
+		protected void createFieldEditors() {
+			DirectoryFieldEditor d1 = new DirectoryFieldEditor(SwtPreference.SWT_DIR_PWFILES.name(),
+					"Gpml pathways:", getFieldEditorParent());
+			addField(d1);
+			
+			DirectoryFieldEditor d2 = new DirectoryFieldEditor(SwtPreference.SWT_DIR_GDB.name(),
+					"Gene databases:", getFieldEditorParent());
+			addField(d2);
+			
+			DirectoryFieldEditor d3 = new DirectoryFieldEditor(SwtPreference.SWT_DIR_EXPR.name(),
+					"Expression datasets:", getFieldEditorParent());
+			addField(d3);
+
+			if(SwtEngine.isUseR()) {
+				DirectoryFieldEditor d4 = new DirectoryFieldEditor(SwtPreference.SWT_DIR_RDATA.name(),
+						"Results from pathway statistics:", getFieldEditorParent());
+				addField(d4);
+			}
+		}
+	}
+	
+	private class DisplayPage extends FieldEditorPreferencePage {
+		public DisplayPage() {
+			super("Display", GRID);
+		}
+		
+		protected void createFieldEditors() {
+			IntegerFieldEditor f = new IntegerFieldEditor(SwtPreference.SWT_SIDEPANEL_SIZE.name(),
+					"Initial side panel size (percent of window size):", getFieldEditorParent());
+			f.setValidRange(0, 100);
+			addField(f);
+			
+			BooleanFieldEditor f2 =	new BooleanFieldEditor (
+					SwtPreference.SWT_SHOW_ADVANCED_ATTR.name(),									   
+					"Show advanced attributes (e.g. references):", getFieldEditorParent());
+				addField (f2);
+		}
+	}
+	private class ColorsPage extends FieldEditorPreferencePage {
+		public ColorsPage() {
+			super("Colors", GRID);
+		}
+		
+		protected void createFieldEditors() {
+			ColorFieldEditor f1 = new ColorFieldEditor(GlobalPreference.COLOR_NO_CRIT_MET.name(), 
+					"Default color for 'no criteria met':", getFieldEditorParent());
+			addField(f1);
+			ColorFieldEditor f2 = new ColorFieldEditor(GlobalPreference.COLOR_NO_GENE_FOUND.name(), 
+					"Default color for 'gene not found':", getFieldEditorParent());
+			addField(f2);
+			ColorFieldEditor f3 = new ColorFieldEditor(GlobalPreference.COLOR_NO_DATA_FOUND.name(), 
+					"Default color for 'no data found':", getFieldEditorParent());
+			addField(f3);
+			ColorFieldEditor f4 = new ColorFieldEditor(GlobalPreference.COLOR_SELECTED.name(), 
+					"Line color for selected objects:", getFieldEditorParent());
+			addField(f4);
+			ColorFieldEditor f5 = new ColorFieldEditor(GlobalPreference.COLOR_HIGHLIGHTED.name(), 
+					"Line color for highlighted objects:", getFieldEditorParent());
+			addField(f5);
+			
+		}
+	}
+	
+	private class DatabasePage extends FieldEditorPreferencePage {
+		public DatabasePage() {
+			super("Database", GRID);
+		}
+		
+		protected void createFieldEditors() {
+			StringFieldEditor f1 = new StringFieldEditor(SwtPreference.SWT_DB_ENGINE_GDB.name(),
+					"Database connector class for gene database:", getFieldEditorParent());
+			addField(f1);
+			StringFieldEditor f2 = new StringFieldEditor(SwtPreference.SWT_DB_ENGINE_EXPR.name(),
+					"Database connector class for expression dataset:", getFieldEditorParent());
+			addField(f2);
+		}
+	}
+	
+}
\ No newline at end of file

Property changes on: trunk/src/swt/org/pathvisio/preferences/swt/PreferenceDlg.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/visualization/VisualizationDialog.java
===================================================================
--- trunk/src/swt/org/pathvisio/visualization/VisualizationDialog.java	(revision 976)
+++ trunk/src/swt/org/pathvisio/visualization/VisualizationDialog.java	(revision 977)
@@ -66,8 +66,8 @@
 import org.pathvisio.Engine;
 import org.pathvisio.data.Gex;
 import org.pathvisio.gui.swt.SwtEngine;
-import org.pathvisio.util.TableColumnResizer;
 import org.pathvisio.util.Utils;
+import org.pathvisio.util.swt.TableColumnResizer;
 import org.pathvisio.visualization.Visualization.PluginSet;
 import org.pathvisio.visualization.colorset.ColorSetComposite;
 import org.pathvisio.visualization.plugins.PluginManager;
Index: trunk/src/swt/org/pathvisio/visualization/plugins/VisualizationPlugin.java
===================================================================
--- trunk/src/swt/org/pathvisio/visualization/plugins/VisualizationPlugin.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/visualization/plugins/VisualizationPlugin.java	(revision 977)
@@ -0,0 +1,355 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.plugins;
+
+import java.awt.Graphics2D;
+import java.util.Collection;
+
+import org.eclipse.jface.window.ApplicationWindow;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Shell;
+import org.jdom.Element;
+import org.pathvisio.view.Graphics;
+import org.pathvisio.visualization.Visualization;
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+
+/**
+ * The VisualizationPlugin class can be extended to create a visualization plugin for
+ * the visualization of experimental data on GPML pathways
+ * @author Thomas
+ */
+public abstract class VisualizationPlugin implements Comparable {
+	public static String XML_ELEMENT = "plugin";
+	public static String XML_ATTR_CLASS = "class";
+	
+	protected static final int SIDEPANEL = 2;
+	protected static final int TOOLTIP = 4;
+	protected static final int DRAWING = 8;
+	
+	private int DISPLAY_OPT; //Where on the display cann this plugin be used (SIDEPANEL | TOOLTIP | DRAWING)
+	private boolean CONFIGURABLE; //Configurable (if true, override createConfigComposite)
+	private boolean GENERIC; //For generic use, or expression dataset specific
+	private boolean USE_PROVIDED_AREA; //Does this plugin use reserved region in GmmlGraphicsObject
+	
+	private boolean isActive;
+		
+	private Visualization visualization;
+	
+	/**
+	 * Constructor for this class. Create an instance of this {@link VisualizationPlugin}
+	 * @param v The {@link Visualization} the instance is part of
+	 */
+	public VisualizationPlugin(Visualization v) {
+		visualization = v;
+	}
+	
+	/**
+	 * Get the {@link Visualization} this instance belongs to
+	 * @return The {@link Visualization} this plugin belongs to
+	 */
+	protected final Visualization getVisualization() { return visualization; }
+	
+	/**
+	 * Gets the name of this visualization plugin class
+	 * @return the name of this visualization plugin class
+	 */
+	public abstract String getName();
+	
+	/**
+	 * Gets the description of this visualization plugin class
+	 * @return the description of this visualization plugin class
+	 */
+	public abstract String getDescription();
+	
+	//TODO: Update javadoc
+	/**
+	 * Create a visualization on the pathway drawing for the given {@link Graphics} object.
+	 * This method will only be called when the plugin display options contains {@link VisualizationPlugin#DRAWING}.
+	 * @param g	The {@link Graphics} object on which the visualization applies
+	 * @param e	{@link PaintEvent} containing information about the paint
+	 * @param gc Graphical context on which drawing operations can be performed
+	 * @see <a href=http://www.eclipse.org/articles/Article-SWT-graphics/SWT_graphics.html>
+	 * Introduction in SWT graphics</a>
+	 */
+	public abstract void visualizeOnDrawing(Graphics g, Graphics2D g2d);
+	
+	/**
+	 * Create a visualization on the side panel for the given {@link Graphics} objects
+	 * This method will only be called when the plugin display options contains {@link VisualizationPlugin#SIDEPANEL}.
+	 * @param objects List of {@link Graphics} objects to create the visualization for
+	 */
+	public abstract void visualizeOnSidePanel(Collection<Graphics> objects);
+	
+	/**
+	 * Create a visualization on the Tool Tip for the given {@link Graphics} object.
+	 * This method will only be called when the plugin display options contains {@link VisualizationPlugin#TOOLTIP}.
+	 * @param parent The parent of the {@link Composite} that will be displayed on the Tool Tip
+	 * @param g The {@link Graphics} object to create the visualization for
+	 * @return A {@link Composite} that will be displayed in the Tool Tip
+	 */
+	public abstract Composite visualizeOnToolTip(Composite parent, Graphics g);
+	
+	/**
+	 * Initialize a Composite for visualization on the side panel
+	 * This method will only be called when the plugin display options contains {@link VisualizationPlugin#SIDEPANEL}.
+	 * @param parent The parent of the new {@link Composite}
+	 */
+	public abstract void initSidePanel(Composite parent);
+	
+	/**
+	 * Create a {@link Composite} that is displayed in the legend for every plug-in that is
+	 * activated on the pathway drawing.
+	 * This method may be overridden if the plug-in needs to show a legend item when it is
+	 * active on the pathway drawing.
+	 * @param parent The parent of the new {@link Composite} to return
+	 * @return A {@link Composite} that displays the legend information for this plug-in
+	 */
+	public Composite createLegendComposite(Composite parent) {
+		return null;
+	}
+	
+	/**
+	 * Create a {@link Composite} that can be used to configure this visualization plugin
+	 * Override this method when the visualization plugin can be configured by the user
+	 * @see  VisualizationPlugin#isConfigurable() VisualizationPlugin#openConfigDialog(Shell)
+	 * @param parent The parent of the {@link Composite} to create
+	 * @return A {@link Composite} that will be displayed when the user wants to configure the plugin
+	 */
+	protected Composite createConfigComposite(Composite parent) {
+		return new Composite(parent, SWT.NULL); //Empty composite
+	}
+	
+	/**
+	 * Opens the configuration dialog (only when isConfigurable returnst true) that
+	 * will display the {@link Composite} created in {@link VisualizationPlugin#createConfigComposite(Composite)}.
+	 * @param shell The parent {@link Shell} of the dialog to open
+	 */
+	public final void openConfigDialog(Shell shell) {
+		if(!CONFIGURABLE) return; //Not configurable, so don't open config dialog
+		ApplicationWindow d = new ConfigurationDialog(shell);
+		d.open();
+	}
+	
+	
+	/**
+	 * Save the configuration of the current instance of this class to an XML element.<br>
+	 * Override this method to save custom configuration settings:<br>
+	 * <code>
+	 * public Element toXML() {								<br>
+	 * &nbsp;Element elm = super.toXML();					<br>
+	 * &nbsp;//Add custom attributes and elements to elm, e.g.:	<br>
+	 * &nbsp;elm.setAttribute("fontsize", fontsize)			<br>
+	 * <br>
+	 * &nbsp;return elm;									<br>
+	 * }
+	 * </code>
+	 */
+	public Element toXML() {
+		Element elm = new Element(XML_ELEMENT);
+		elm.setAttribute(XML_ATTR_CLASS, getClass().getCanonicalName());
+		return elm;
+	}
+	
+	/**
+	 * Load the configuration of the current instance of this class from an XML element.<br>
+	 * Override this method to load custom configuration settings:<br>
+	 * <code>
+	 * public Element loadXML(Element xml) {				<br>
+	 * &nbsp;super.loadXML(xml)								<br>
+	 * &nbsp;//Load custom attributes and elements to elm, e.g.:	<br>
+	 * &nbsp;fontSize = xml.getAttributeValue("fontsize")			<br>
+	 * }
+	 * </code>
+	 * @param xml The {@link Element} that contains the configuration for this plugin
+	 */
+	public void loadXML(Element xml) { }
+	
+	/**
+	 * Returns whether the current instance of this visualization plugin is activated or not
+	 * @return true if this instance is activated, false otherwise
+	 */
+	public final boolean isActive() { return isActive; }
+	
+	/**
+	 * Set the activation state of this instance. If set to active, the visualization methods
+	 * of this plugin will be called from the {@link Visualization} this instance belongs to.
+	 * @param active true to activate this instance, false to de-activate
+	 */
+	public final void setActive(boolean active) { 
+		if(isActive != active) {
+			isActive = active;
+			fireModifiedEvent();
+		}	
+	}
+	
+	/**
+	 * Returns whether this plugin can be displayed in the side panel
+	 * @return true when this plugin can be displayed in the side panel, false otherwise
+	 */
+	public final boolean canSidePanel() { return (DISPLAY_OPT & SIDEPANEL) != 0; }
+	
+	/**
+	 * Returns whether this plugin can be displayed in the Tool Tip
+	 * @return true when this plugin can be displayed in the Tool Tip, false otherwise
+	 */
+	public final boolean canToolTip() { return (DISPLAY_OPT & TOOLTIP) != 0; }
+	
+	/**
+	 * Returns whether this plugin can be displayed in the pathway drawing
+	 * @return true when this plugin can be displayed in the pathway drawing, false otherwise
+	 */
+	public final boolean canDrawing() { return (DISPLAY_OPT & DRAWING) != 0; }
+	
+	/**
+	 * Specify where this plugin can be displayed.
+	 * One of:<BR><UL>
+	 * <LI><CODE>DRAWING</CODE>: this plugin implements visualization on drawing objects
+	 * <LI><CODE>TOOLTIP</CODE>: this plugins implements visualization in the tooltip showed
+	 * when hovering over GeneProducts
+	 * <LI><CODE>SIDEPANEL</CODE>: this plugin implements visualization to be displayed in the side panel
+	 * </UL><BR>
+	 * When multiple visualization options are implemented, 
+	 * use bitwise OR (e.g. <CODE>SIDEPANEL | DRAWING</CODE>)
+	 * @param options
+	 */
+	protected void setDisplayOptions(int options) {
+		DISPLAY_OPT = options;
+	}
+	
+	/**
+	 * Specify whether the parent {@link Visualization} needs to provide an area on the 
+	 * {@link Graphics} objects.
+	 * When multiple visualization plugins apply visualizations on the same {@link Graphics}
+	 * object, the available space will be divided over the plugins for which this method is called
+	 * with true as argument.
+	 * The provided area can be obtained by calling {@link Visualization#provideDrawArea(VisualizationPlugin, Graphics)}
+	 * @param use	true if this plugin uses the provided area, false if not
+	 * @see Visualization#provideDrawArea(VisualizationPlugin, Graphics)
+	 */
+	protected void setUseProvidedArea(boolean use) {
+		USE_PROVIDED_AREA = use;
+	}
+	
+	/**
+	 * Specify whether this visualization plugin is configurable or not.
+	 * When the plugin is set to be configurable, override {@link VisualizationPlugin#createConfigComposite(Composite)}.
+	 * @param configurable
+	 * @see VisualizationPlugin#createConfigComposite(Composite)
+	 */
+	protected void setIsConfigurable(boolean configurable) {
+		CONFIGURABLE = configurable;
+	}
+	
+	/**
+	 * Specify whether this visualization plugin is generic or not.
+	 * Generic plugins are independent of expression data. Non-generic plugin configurations
+	 * depend on an expression dataset and will be loaded/saved together with this expression dataset.
+	 * @param generic true if this plugin is generic, false otherwise
+	 */
+	protected void setIsGeneric(boolean generic) {
+		GENERIC = generic;
+	}
+	
+	/**
+	 * Returns whether this visualiazation plugin is generic or not
+	 * Generic plugins are independent of expression data. Non-generic plugin configurations
+	 * depend on an expression dataset and will be loaded/saved together with this expression dataset.
+	 * @see VisualizationPlugin#setIsGeneric(boolean)
+	 * @return true if this plugin is generic, false otherwise
+	 */
+	public final boolean isGeneric() { return GENERIC; }
+	
+	/**
+	 * Returns whether this visualization plugin is configurable or not
+	 * @see VisualizationPlugin#setIsConfigurable(boolean)
+	 * @return true if this plugin is configurable, false otherwise
+	 */
+	public final boolean isConfigurable() { return CONFIGURABLE; }
+	
+	/**
+	 * Returns whether this visualization plugin uses the area provided by
+	 * the {@link Visualization} it belongs to.
+	 * @see VisualizationPlugin#setUseProvidedArea(boolean)
+	 * @return true if this plugin uses the provided area, false otherwise
+	 */
+	public final boolean isUseProvidedArea() { 
+		return USE_PROVIDED_AREA; 
+	}
+		
+	/**
+	 * Fire a {@link VisualizationEvent} with type {@link VisualizationEvent#PLUGIN_MODIFIED}
+	 */
+	protected final void fireModifiedEvent() {
+		VisualizationManager.fireVisualizationEvent(
+				new VisualizationEvent(this, VisualizationEvent.PLUGIN_MODIFIED));
+	}
+	
+	/**
+	 * The configuration dialog that displays the configuration settings for a 
+	 * visualization plugin
+	 * @author Thomas
+	 */
+	private class ConfigurationDialog extends ApplicationWindow {
+		public ConfigurationDialog(Shell shell) {
+			super(shell);
+			setBlockOnOpen(true);
+		}
+		
+		public Control createContents(Composite parent) {
+			Composite contents = new Composite(parent, SWT.NULL);
+			contents.setLayout(new GridLayout());
+			
+			Composite config = createConfigComposite(contents);
+			config.setLayoutData(new GridData(GridData.FILL_BOTH));
+			
+			Composite buttonComp = createButtonComposite(contents);
+			buttonComp.setLayoutData(new GridData(GridData.HORIZONTAL_ALIGN_END));
+			
+			return contents;
+		}
+		
+		public Composite createButtonComposite(Composite parent) {
+			Composite comp = new Composite(parent, SWT.NULL);
+			comp.setLayout(new GridLayout(2, false));
+			
+			Button ok = new Button(comp, SWT.PUSH);
+			ok.setText(" Ok ");
+			ok.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent arg0) {
+					close();
+				}
+			});
+			
+			return comp;
+		}
+	}
+	
+	public int compareTo(Object o) {
+		if(o instanceof VisualizationPlugin)
+			return getName().compareTo(((VisualizationPlugin)o).getName());
+		return -1;
+	}
+}

Property changes on: trunk/src/swt/org/pathvisio/visualization/plugins/VisualizationPlugin.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/visualization/plugins/PluginManager.java
===================================================================
--- trunk/src/swt/org/pathvisio/visualization/plugins/PluginManager.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/visualization/plugins/PluginManager.java	(revision 977)
@@ -0,0 +1,326 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.plugins;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.FilenameFilter;
+import java.io.IOException;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Modifier;
+import java.net.JarURLConnection;
+import java.net.URL;
+import java.net.URLDecoder;
+import java.util.Enumeration;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.jar.JarFile;
+import java.util.zip.ZipEntry;
+
+import org.jdom.Document;
+import org.jdom.Element;
+import org.jdom.input.SAXBuilder;
+import org.jdom.output.Format;
+import org.jdom.output.XMLOutputter;
+import org.pathvisio.Engine;
+import org.pathvisio.data.Gex;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.util.Utils;
+import org.pathvisio.visualization.Visualization;
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+
+public abstract class PluginManager {
+	//static final String PLUGIN_PKG = "org.pathvisio.visualization.plugins";
+	//static final String PKG_DIR = PLUGIN_PKG.replace('.', '/');
+	static final String FILE_ADD_PLUGINS = "visplugins.xml";
+	static final String XML_ELEMENT = "additional-plugins";
+	static final String XML_ELM_PLUGIN = "plugin";
+	static final String XML_ATTR_URL = "url";
+	
+	static Document addDoc;
+	static final Set<Class> plugins = new LinkedHashSet<Class>();
+	
+	public static VisualizationPlugin getInstance(Class pluginClass, Visualization v) throws Throwable {
+		Constructor c = pluginClass.getConstructor(new Class[] { Visualization.class });
+		return (VisualizationPlugin)c.newInstance(new Object[] { v });
+	}
+		
+	public static VisualizationPlugin instanceFromXML(Element xml, Visualization v) throws Throwable {
+		String className = xml.getAttributeValue(VisualizationPlugin.XML_ATTR_CLASS);
+		
+		if(className == null) throw new IllegalArgumentException(
+				"Element has no '" + VisualizationPlugin.XML_ATTR_CLASS + "' attribute");
+		
+		Class pluginClass = Class.forName(className);
+		VisualizationPlugin p = getInstance(pluginClass, v);
+		p.loadXML(xml);
+		return p;
+	}
+	
+	public static Class[] getPlugins() {
+		return Gex.isConnected() ?
+				plugins.toArray(new Class[plugins.size()]) :
+				getGenericPlugins();
+	}
+	
+	public static Class[] getGenericPlugins() {
+		Set<Class> generic = new LinkedHashSet<Class>();
+		for(Class pc : plugins) {
+			if(isGeneric(pc)) generic.add(pc);
+		}
+		return generic.toArray(new Class[generic.size()]);
+	}
+	
+	public static boolean isGeneric(Class pluginClass) {
+		try {
+			return getInstance(pluginClass, null).isGeneric();
+		} catch(Throwable e) { 
+			e.printStackTrace();
+			Engine.log.error("Unable to determine if plugin is generic", e);
+			return false; 
+		}
+	}
+	
+	public static String[] getPluginNames() {
+		String[] names = new String[plugins.size()];
+		int i = 0;
+		for(Class p : plugins) {
+			names[i++] = getPluginName(p);
+		}
+		return names;
+	}
+	
+	public static String getPluginName(Class pluginClass) {
+		try {
+			VisualizationPlugin p = getInstance(pluginClass, null);
+			return p.getName();
+		} catch(Throwable e) {
+			Engine.log.error("Unable to get plugin name for " + pluginClass, e);
+			return pluginClass.getName();
+		}
+	}
+
+	public static void loadPlugins() throws Throwable {	
+		Engine.log.trace("> Loading visualization plugins");
+		Enumeration<URL> resources = 
+			SwtEngine.class.getClassLoader().getResources(".");
+        while (resources.hasMoreElements()) {
+        	URL url = resources.nextElement();
+        	Engine.log.trace("visualization.plugins package found in: " + url);
+        	try {
+        		loadPlugin(url);
+        	} catch(Throwable e) {
+        		Engine.log.error("Error when loading plugins from " + url, e);
+        	}
+        }
+        loadAdditional();
+  	}
+	    
+	static void loadPlugin(File f) throws Throwable {
+			loadPlugin(f.toURL());
+	}
+	
+	public static void loadAdditionalPlugin(File file) throws Throwable {
+		loadPlugin(file);
+		saveAdditional(file.toURL());
+		VisualizationManager.fireVisualizationEvent(
+				new VisualizationEvent(PluginManager.class, VisualizationEvent.PLUGIN_ADDED));
+	}
+		
+	static void loadPlugin(URL url) throws Throwable {
+    	if(url.getProtocol().equals("jar")) {
+    		loadFromJar(url);
+    	} else if(url.getProtocol().equals("file")) {
+    		File f = new File(url.getFile());
+    		if(f.getName().endsWith(".jar")) 
+    			loadFromJar(url);
+    		else loadFromDir(url);
+    	}
+		else Engine.log.error("Unable to load additional plugin", new Exception("Unsupported URL protocol"));
+	}
+	
+	static Document getAdditionalXML() {
+		if(addDoc == null) {
+			File f = new File(SwtEngine.getApplicationDir(), FILE_ADD_PLUGINS);
+			if(!f.exists()) {
+				return createXML();
+			} else {
+				SAXBuilder parser = new SAXBuilder();
+				try {
+					Document doc = parser.build(f);
+					return doc;
+				} catch(Exception e) {
+					Engine.log.error("Unable to load additional plugins file", e);
+					return createXML();
+				}
+			}
+		} else return addDoc;
+		
+	}
+	
+	static Document createXML() {
+		Document doc = new Document();
+		doc.setRootElement(new Element(XML_ELEMENT));
+		return doc;
+	}
+
+	static void loadAdditional() {
+		Document doc = getAdditionalXML();
+		Element root = doc.getRootElement();
+		for(Object o : root.getChildren(XML_ELM_PLUGIN)) {
+			URL url = null;
+			try {
+				url = new URL(((Element)o).getAttributeValue(XML_ATTR_URL));
+				loadPlugin(new File(url.getFile()));
+			} catch(Throwable ex) {
+				Engine.log.error("Unable to load additional plugin", ex);
+				if(url != null) removeAdditional(url);
+			}
+		}
+	}
+	
+	static void saveAdditional(URL url) {
+		Document doc = getAdditionalXML();
+		Element root = doc.getRootElement();
+		
+		if(containsElement(root, url)) return;
+		
+		Element elm = new Element(XML_ELM_PLUGIN);
+		elm.setAttribute(XML_ATTR_URL, url.toString());
+		root.addContent(elm);
+		saveXML(doc);
+	}
+	
+	static void removeAdditional(URL url) {
+		Document doc = getAdditionalXML();
+		Element root = doc.getRootElement();
+		
+		Element toRemove = null;
+		for(Object o : root.getChildren(XML_ELM_PLUGIN)) {
+			Element e = (Element) o;
+			String url1 = e.getAttributeValue(XML_ATTR_URL);
+			if(url1.equals(url.toString())) {
+				toRemove = e;
+				break;
+			}
+		}
+		root.removeContent(toRemove);
+		saveXML(doc);
+	}
+	
+	static void saveXML(Document doc) {
+		XMLOutputter out = new XMLOutputter(Format.getPrettyFormat());
+		try {
+			FileWriter fw = new FileWriter(new File(SwtEngine.getApplicationDir(), FILE_ADD_PLUGINS));
+			out.output(doc, fw);
+			fw.close();
+		} catch(IOException e) {
+			Engine.log.error("Unable to save additional plugins", e);
+		}
+	}
+	
+	static boolean containsElement(Element root, URL url) {
+		for(Object o : root.getChildren(XML_ELM_PLUGIN)) {
+			String url1 = ((Element)o).getAttributeValue(XML_ATTR_URL);
+			if(url1.equals(url.toString())) return true;
+		}
+		return false;
+	}
+	
+	static void loadFromDir(URL url) throws Throwable {
+		Engine.log.trace("\tLoading from directory " + url);
+		File directory = new File(URLDecoder.decode(url.getPath(), "UTF-8"));
+		if (directory.exists()) {
+           processFile(directory, directory.toString());
+        }
+	}
+	
+	static private void processFile(File f, String base) throws Throwable {
+		if(f.isDirectory()) {
+			File[] files = f.listFiles();
+            for (File file : files)
+            	processFile(file, base);
+		} else {
+			String fn = f.toString();
+			if(fn.endsWith(".class") && !fn.contains("$")) { //Ignore inner classes for now
+				String cn = fn.substring(base.length() + 1);
+				cn = removeClassExt(cn.replace('/', '.'));
+				addPlugin(Class.forName(cn, false, SwtEngine.class.getClassLoader()));
+			}
+		}
+	}
+	static void loadFromJar(URL url) throws Throwable {
+		Engine.log.trace("\tLoading from jar connection " + url);
+		JarFile f = null;
+		if(url.getProtocol().equals("jar")) {
+			JarURLConnection conn = (JarURLConnection)url.openConnection();
+			f = conn.getJarFile();
+		} else {
+			f = new JarFile(url.getFile());
+		}
+		loadFromJar(f);
+	}
+		
+	static void loadFromJar(JarFile jfile) throws Throwable {
+		Throwable error = null;
+		Engine.log.trace("\tLoading from jar file " + jfile);
+		Enumeration e = jfile.entries();
+		while (e.hasMoreElements()) {
+			ZipEntry entry = (ZipEntry)e.nextElement();
+			Engine.log.trace("Checking " + entry);
+			String entryname = entry.getName();
+			if(entryname.endsWith(".class")) {
+				try {
+					String cn = removeClassExt(entryname.replace('/', '.').replace('$', '.'));
+					Class pluginClass = Class.forName(cn);
+					addPlugin(pluginClass);
+				} catch(Throwable ex) {
+					Engine.log.error("Unable to load plugin", ex);
+					error = ex;
+				}
+			}
+		}
+		if(error != null) throw error;
+	}
+	
+	static String removeClassExt(String fn) {
+		return fn.substring(0, fn.length() - 6);
+	}
+	
+	static void addPlugin(Class c) {
+		Engine.log.trace("\t\tTrying to add " + c);
+		if(isPlugin(c)) {
+			Engine.log.trace("\t\t\t!> Adding " + c);
+			plugins.add(c);
+		}
+	}
+	
+	static boolean isPlugin(Class c) {
+		if(Modifier.isAbstract(c.getModifiers())) {
+			Engine.log.trace("\t\t> Class " + c + " is not a visualization plugin (is abstract)");
+			return false;
+		}
+		return Utils.isSubClass(c, VisualizationPlugin.class);
+	}
+			
+	static  FilenameFilter classFilter = new FilenameFilter() {
+		public boolean accept(File f, String name) {
+			return name.endsWith(".class");
+		}
+    };
+}

Property changes on: trunk/src/swt/org/pathvisio/visualization/plugins/PluginManager.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/visualization/colorset/ColorGradient.java
===================================================================
--- trunk/src/swt/org/pathvisio/visualization/colorset/ColorGradient.java	(revision 976)
+++ trunk/src/swt/org/pathvisio/visualization/colorset/ColorGradient.java	(revision 977)
@@ -48,8 +48,8 @@
 import org.jdom.Element;
 import org.pathvisio.Engine;
 import org.pathvisio.util.ColorConverter;
-import org.pathvisio.util.SwtUtils;
-import org.pathvisio.util.TableColumnResizer;
+import org.pathvisio.util.swt.SwtUtils;
+import org.pathvisio.util.swt.TableColumnResizer;
 
 /**
  * This class represent a color gradient used for data visualization
Index: trunk/src/swt/org/pathvisio/visualization/colorset/ColorCriterion.java
===================================================================
--- trunk/src/swt/org/pathvisio/visualization/colorset/ColorCriterion.java	(revision 976)
+++ trunk/src/swt/org/pathvisio/visualization/colorset/ColorCriterion.java	(revision 977)
@@ -34,7 +34,7 @@
 import org.jdom.Element;
 import org.pathvisio.Engine;
 import org.pathvisio.util.ColorConverter;
-import org.pathvisio.util.SwtUtils;
+import org.pathvisio.util.swt.SwtUtils;
 
 public class ColorCriterion extends ColorSetObject {	
 	public static final String XML_ELEMENT_NAME = "ColorCriterion";
Index: trunk/src/swt/org/pathvisio/visualization/colorset/ColorSetComposite.java
===================================================================
--- trunk/src/swt/org/pathvisio/visualization/colorset/ColorSetComposite.java	(revision 976)
+++ trunk/src/swt/org/pathvisio/visualization/colorset/ColorSetComposite.java	(revision 977)
@@ -65,9 +65,9 @@
 import org.eclipse.swt.widgets.TableColumn;
 import org.eclipse.swt.widgets.TableItem;
 import org.eclipse.swt.widgets.Text;
-import org.pathvisio.util.SwtUtils;
-import org.pathvisio.util.TableColumnResizer;
 import org.pathvisio.util.Utils;
+import org.pathvisio.util.swt.SwtUtils;
+import org.pathvisio.util.swt.TableColumnResizer;
 import org.pathvisio.visualization.VisualizationManager;
 import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
 import org.pathvisio.visualization.VisualizationManager.VisualizationListener;
Index: trunk/src/swt/org/pathvisio/visualization/LegendPanel.java
===================================================================
--- trunk/src/swt/org/pathvisio/visualization/LegendPanel.java	(revision 976)
+++ trunk/src/swt/org/pathvisio/visualization/LegendPanel.java	(revision 977)
@@ -48,7 +48,7 @@
 import org.eclipse.swt.widgets.Group;
 import org.eclipse.swt.widgets.Label;
 import org.pathvisio.gui.swt.SwtEngine;
-import org.pathvisio.util.SwtUtils;
+import org.pathvisio.util.swt.SwtUtils;
 import org.pathvisio.visualization.LegendPanel.CollapseGroup.CollapseListener;
 import org.pathvisio.visualization.Visualization.PluginSet;
 import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
Index: trunk/src/swt/org/pathvisio/biopax/gui/BiopaxRefDialog.java
===================================================================
--- trunk/src/swt/org/pathvisio/biopax/gui/BiopaxRefDialog.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/biopax/gui/BiopaxRefDialog.java	(revision 977)
@@ -0,0 +1,152 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.biopax.gui;
+
+import org.biopax.paxtools.model.level2.BioPAXElement;
+import org.eclipse.jface.dialogs.Dialog;
+import org.eclipse.jface.dialogs.IDialogConstants;
+import org.eclipse.jface.viewers.ILabelProviderListener;
+import org.eclipse.jface.viewers.ISelection;
+import org.eclipse.jface.viewers.ISelectionChangedListener;
+import org.eclipse.jface.viewers.IStructuredContentProvider;
+import org.eclipse.jface.viewers.IStructuredSelection;
+import org.eclipse.jface.viewers.ITableLabelProvider;
+import org.eclipse.jface.viewers.SelectionChangedEvent;
+import org.eclipse.jface.viewers.StructuredSelection;
+import org.eclipse.jface.viewers.TableViewer;
+import org.eclipse.jface.viewers.Viewer;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Shell;
+import org.eclipse.swt.widgets.Table;
+import org.eclipse.swt.widgets.TableColumn;
+import org.eclipse.swt.widgets.Text;
+import org.pathvisio.biopax.BiopaxManager;
+
+public class BiopaxRefDialog extends Dialog {	
+	BiopaxManager biopax;
+	String ref;
+	
+	TableViewer tableViewer;
+
+	public BiopaxRefDialog(Shell shell, BiopaxManager bp, String ref) {
+		super(shell);
+		setShellStyle(SWT.DIALOG_TRIM | SWT.RESIZE);
+		biopax = bp;
+		this.ref = ref;
+	}
+		
+	protected void createButtonsForButtonBar(Composite parent) {
+		createButton(parent, IDialogConstants.OK_ID,
+				IDialogConstants.OK_LABEL, true);
+		createButton(parent, IDialogConstants.CANCEL_ID,
+				IDialogConstants.CANCEL_LABEL, false);
+	}
+
+	public String getRef() {
+		return ref;
+	}
+	
+	public void setRef(String r) {
+		ref = r;
+	}
+	
+	protected Control createDialogArea(Composite parent) {
+		 Composite comp = (Composite) super.createDialogArea(parent);
+		 comp.setLayout(new GridLayout());
+		 
+		 
+		 tableViewer = new TableViewer(comp, SWT.SINGLE | SWT.V_SCROLL | SWT.H_SCROLL);
+		 Table t = tableViewer.getTable();
+		 t.setHeaderVisible(true);
+		 TableColumn tcElm = new TableColumn(t, SWT.LEFT);
+		 tcElm.setText("Element");
+		 tcElm.setWidth(500);
+		 TableColumn tcID = new TableColumn(t, SWT.LEFT);
+		 tcID.setText("ID");
+		 tcID.setWidth(100);
+		 
+		 tableViewer.setContentProvider(new IStructuredContentProvider() {
+			public Object[] getElements(Object input) {
+				BiopaxManager bpm = (BiopaxManager)input;
+				if(bpm != null) {
+					return bpm.getModel().getObjects().toArray();
+				} else {
+					return new Object[] {};
+				}
+			}
+
+			public void dispose() { }
+
+			public void inputChanged(Viewer viewer, Object oldInput, Object newInput) {	}
+			 
+		 });
+		 tableViewer.setLabelProvider(new ITableLabelProvider() {
+			public void addListener(ILabelProviderListener l) { }
+			public void dispose() { }
+			public boolean isLabelProperty(Object value, String property) {
+				return false;
+			}
+			public void removeListener(ILabelProviderListener l) { }
+			public Image getColumnImage(Object value, int col) { return null; }
+			public String getColumnText(Object value, int col) {
+				BioPAXElement bpe = (BioPAXElement)value;
+				switch(col) {
+				case 0:
+					return bpe.getRDFId();
+				case 1:
+					return bpe.getClass().toString();
+				default: return "";
+				}
+			}
+		 });
+		 tableViewer.addSelectionChangedListener(new ISelectionChangedListener() {
+			public void selectionChanged(SelectionChangedEvent e) {
+				BioPAXElement selected = getSelectedObject(e.getSelection());
+				setRef(selected.getRDFId());
+			}	
+		 });
+		 
+		 init();
+		 
+		 return comp;
+	}
+	
+	BioPAXElement getSelectedObject(ISelection s) {
+		return (BioPAXElement)
+			((IStructuredSelection)s).getFirstElement();
+	}
+	
+	private void update() {
+		if(tableViewer != null) {
+			tableViewer.setInput(biopax);
+			tableViewer.refresh();
+		}
+	}
+	
+	private void init() {
+		tableViewer.setInput(biopax);
+		BioPAXElement pe = biopax.getModel().getIdMap().get(ref);
+		if(pe != null) {
+			tableViewer.setSelection(new StructuredSelection(pe));
+		}
+	}
+	
+}
\ No newline at end of file
Index: trunk/src/swt/org/pathvisio/biopax/gui/BiopaxDialog.java
===================================================================
--- trunk/src/swt/org/pathvisio/biopax/gui/BiopaxDialog.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/biopax/gui/BiopaxDialog.java	(revision 977)
@@ -0,0 +1,104 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.biopax.gui;
+
+import org.eclipse.jface.dialogs.Dialog;
+import org.eclipse.jface.dialogs.IDialogConstants;
+import org.eclipse.jface.dialogs.MessageDialog;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Shell;
+import org.eclipse.swt.widgets.Text;
+import org.pathvisio.biopax.BiopaxManager;
+import org.pathvisio.Engine;
+import org.pathvisio.model.ConverterException;
+import org.pathvisio.model.Pathway;
+
+public class BiopaxDialog extends Dialog {
+	Pathway pathway;
+	BiopaxManager biopax;
+	Text text;
+	
+	public BiopaxDialog(Shell shell) {
+		super(shell);
+		setShellStyle(SWT.DIALOG_TRIM | SWT.RESIZE);
+	}
+
+	public void setPathway(Pathway p) {
+		pathway = p;
+		biopax = new BiopaxManager(p.getBiopax().getBiopax());
+		update();
+	}
+	
+	protected String getBiopaxString() {
+		return text.getText();
+	}
+	
+	public void update() {
+		if(text != null && !text.isDisposed()) {
+			if(biopax != null) {
+				try {
+					text.setText(biopax.getXml());
+				} catch(ConverterException e) {
+					text.setText(e.toString());
+					Engine.log.error("Unable to set BioPAX text", e);
+				}
+			} else {
+				text.setText("");
+			}
+		}
+	}
+	
+    protected void createButtonsForButtonBar(Composite parent) {
+        createButton(parent, IDialogConstants.OK_ID,
+            IDialogConstants.OK_LABEL, true);
+        createButton(parent, IDialogConstants.CANCEL_ID,
+            IDialogConstants.CANCEL_LABEL, false);
+    }
+    
+	protected Control createDialogArea(Composite parent) {
+		 Composite comp = (Composite) super.createDialogArea(parent);
+		 comp.setLayout(new FillLayout());
+		 
+		 text = new Text(comp, SWT.MULTI | SWT.WRAP | SWT.V_SCROLL | SWT.H_SCROLL | SWT.BORDER);
+		 text.setSize(500, 500);
+		 update();		 
+		 return comp;
+	}
+
+	protected void updateBiopax() {
+		biopax.setModel(BiopaxManager.modelFromString(getBiopaxString()));
+	}
+	protected void updatePathway() throws ConverterException {
+		pathway.getBiopax().setBiopax(biopax.getDocument());
+	}
+	
+	protected void okPressed() {
+		try {
+			updateBiopax();
+			updatePathway();
+		} catch(Exception e) {
+			MessageDialog.openError(getShell(), 
+					"Invalid BioPAX code", 
+					"The BioPAX code is invalid:\n" + e.getMessage());
+			return;
+		}
+		super.okPressed();
+	}
+}
Index: trunk/src/swt/org/pathvisio/biopax/gui/BiopaxCellEditor.java
===================================================================
--- trunk/src/swt/org/pathvisio/biopax/gui/BiopaxCellEditor.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/biopax/gui/BiopaxCellEditor.java	(revision 977)
@@ -0,0 +1,43 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.biopax.gui;
+
+import org.eclipse.jface.viewers.DialogCellEditor;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.pathvisio.Engine;
+import org.pathvisio.biopax.BiopaxManager;
+
+public class BiopaxCellEditor extends DialogCellEditor {	
+	public BiopaxCellEditor(Composite parent, String label) {
+		super(parent);
+	}
+	
+	protected Button createButton(Composite parent) {
+		Button b = super.createButton(parent);
+		b.setText("...");
+		return b;
+	}
+
+	protected Object openDialogBox(Control cellEditorWindow) {
+		BiopaxManager bpm = new BiopaxManager(Engine.getActivePathway().getBiopax().getBiopax());
+		BiopaxRefDialog d = new BiopaxRefDialog(cellEditorWindow.getShell(), bpm, (String)getValue());
+		d.open();
+		return d.getRef();
+	}
+}
Index: trunk/src/swt/org/pathvisio/biopax/BiopaxManager.java
===================================================================
--- trunk/src/swt/org/pathvisio/biopax/BiopaxManager.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/biopax/BiopaxManager.java	(revision 977)
@@ -0,0 +1,91 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.biopax;
+
+import java.io.ByteArrayOutputStream;
+import java.io.Reader;
+import java.io.StringReader;
+
+import org.biopax.paxtools.impl.level2.BioPAXFactoryImpl;
+import org.biopax.paxtools.io.jena.JenaIOHandler;
+import org.biopax.paxtools.model.BioPAXLevel;
+import org.biopax.paxtools.model.level2.BioPAXFactory;
+import org.biopax.paxtools.model.level2.Model;
+import org.jdom.Document;
+import org.jdom.input.SAXBuilder;
+import org.jdom.output.Format;
+import org.jdom.output.XMLOutputter;
+import org.pathvisio.Engine;
+import org.pathvisio.model.ConverterException;
+import org.pathvisio.util.Utils;
+
+import com.hp.hpl.jena.ontology.OntModel;
+
+public class BiopaxManager {
+	Model model;
+	
+	/**
+	 * Create a Biopax object from the given JDOM element
+	 * @param e The element containing BioPAX code
+	 */
+	public BiopaxManager(Document doc) {
+		BioPAXFactory bpf = new BioPAXFactoryImpl();
+		if(doc == null) { //Create new model
+			model = bpf.createModel();
+		} else { //Parse jdom
+			String bpText = new XMLOutputter(Format.getPrettyFormat()).outputString(doc);
+			Engine.log.info(bpText);
+			model = modelFromString(bpText);
+		}
+	}
+	
+	public Document getDocument() throws ConverterException {
+		try {
+			String xml = getXml();
+			SAXBuilder saxBuilder=new SAXBuilder();
+			Reader stringReader=new StringReader(xml);
+			return saxBuilder.build(stringReader);
+		} catch(Exception e) {
+			throw new ConverterException(e);
+		}
+	}
+		
+	public static Model modelFromString(String xml) {
+		BioPAXFactory bpf = new BioPAXFactoryImpl();
+		JenaIOHandler ioh = new JenaIOHandler(bpf, BioPAXLevel.L2);
+		return ioh.convertFromOWL(Utils.stringToInputStream(xml));
+	}
+	
+	public String getXml() throws ConverterException {
+		try {
+			ByteArrayOutputStream out = new ByteArrayOutputStream();
+			JenaIOHandler ioh = new JenaIOHandler();
+			ioh.convertToOWL(model, out);
+			return out.toString();
+		} catch(Exception e) {
+			throw new ConverterException(e);
+		}
+	}
+	
+	public Model getModel() {
+		return model;
+	}
+	
+	public void setModel(Model m) {
+		model = m;
+	}
+}
Index: trunk/src/swt/org/pathvisio/gui/swt/AboutDlg.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/AboutDlg.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/gui/swt/AboutDlg.java	(revision 977)
@@ -0,0 +1,96 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Dialog;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Listener;
+import org.eclipse.swt.widgets.Shell;
+import org.pathvisio.Globals;
+import org.pathvisio.Revision;
+
+/**
+ * 
+ * A simple dialog box that shows about information
+ */
+public class AboutDlg extends Dialog
+{
+	private static final long serialVersionUID = 1L;
+
+	public AboutDlg(Shell parent) 
+	{
+		super (parent);
+	}
+
+	public AboutDlg(Shell parent, int style) 
+	{
+		super (parent, style);
+	}
+	
+	public void open()
+	{
+		Shell parent = getParent();
+		final Shell shell = new Shell (parent, SWT.TITLE | SWT.BORDER | SWT.APPLICATION_MODAL);
+
+		shell.setText ("About " + Globals.APPLICATION_VERSION_NAME);		
+		GridLayout ly = new GridLayout();
+		ly.numColumns = 2;
+		shell.setLayout (ly);
+		
+		Label lbl = new Label (shell, SWT.NULL);
+		lbl.setText (Globals.APPLICATION_VERSION_NAME + "\nRevision: " + Revision.REVISION);
+		GridData gd = new GridData (GridData.HORIZONTAL_ALIGN_CENTER);
+		gd.horizontalSpan = 2;		
+		lbl.setLayoutData (gd);
+		
+		lbl = new Label (shell, SWT.NULL);
+		lbl.setImage (SwtEngine.getImageRegistry().get("about.logo"));
+
+		lbl = new Label (shell, SWT.NULL);
+		lbl.setText ("R.M.H. Besseling\nS.P.M.Crijns\nI.Kaashoek\nM.M.Palm\n" +
+				"E.D Pelgrim\nT.A.J. Kelder\nM.P. van Iersel\nBiGCaT");
+		
+		final Button btnOk = new Button (shell, SWT.PUSH);
+		btnOk.setText ("OK");
+		gd = new GridData (GridData.HORIZONTAL_ALIGN_CENTER);
+		gd.horizontalSpan = 2;
+		gd.widthHint = 60;
+		btnOk.setLayoutData (gd);
+		
+		btnOk.addListener(SWT.Selection, new Listener() {
+			public void handleEvent (Event event) {
+					shell.dispose();
+			}
+		});
+			
+		shell.pack();
+		shell.open();
+		
+		Display display = parent.getDisplay();
+		while (!shell.isDisposed())
+		{
+			if (!display.readAndDispatch())
+				display.sleep();			
+		}
+	}
+}

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/AboutDlg.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/NewElementAction.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/NewElementAction.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/gui/swt/NewElementAction.java	(revision 977)
@@ -0,0 +1,225 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+
+package org.pathvisio.gui.swt;
+
+import java.net.URL;
+import java.util.Vector;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.action.ActionContributionItem;
+import org.eclipse.jface.action.IMenuCreator;
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Menu;
+import org.pathvisio.Engine;
+import org.pathvisio.view.VPathway;
+
+/**
+ * {@link Action} to add a new element to the gpml pathway
+ */
+public class NewElementAction extends Action
+{
+	MainWindow window;
+	int element;
+		
+	/**
+	 * Constructor for this class
+	 * @param e	type of element this action adds; a {@link VPathway} field constant
+	 */
+	public NewElementAction (int e)
+	{
+		// TODO: this should be moved to CommonActions, since it is both in v1 and v2
+		element = e;
+		
+		String toolTipText;
+		URL imageURL = null;
+		toolTipText = null;
+		switch(element) {
+		case VPathway.NEWLINE: 
+			toolTipText = "Draw new line";
+			imageURL = Engine.getResourceURL("icons/newline.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLINEARROW:
+			toolTipText = "Draw new arrow";
+			imageURL = Engine.getResourceURL("icons/newarrow.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLINEDASHED:
+			toolTipText = "Draw new dashed line";
+			imageURL = Engine.getResourceURL("icons/newdashedline.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLINEDASHEDARROW:
+			toolTipText = "Draw new dashed arrow";
+			imageURL = Engine.getResourceURL("icons/newdashedarrow.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLABEL:
+			toolTipText = "Draw new label";
+			imageURL = Engine.getResourceURL("icons/newlabel.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWARC:
+			toolTipText = "Draw new arc";
+			imageURL = Engine.getResourceURL("icons/newarc.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWBRACE:
+			toolTipText = "Draw new brace";
+			imageURL = Engine.getResourceURL("icons/newbrace.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWGENEPRODUCT:
+			toolTipText = "Draw new geneproduct";
+			imageURL = Engine.getResourceURL("icons/newgeneproduct.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWRECTANGLE:
+			imageURL = Engine.getResourceURL("icons/newrectangle.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWOVAL:
+			toolTipText = "Draw new oval";
+			imageURL = Engine.getResourceURL("icons/newoval.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWTBAR:
+			toolTipText = "Draw new TBar";
+			imageURL = Engine.getResourceURL("icons/newtbar.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWRECEPTORROUND:
+			toolTipText = "Draw new round receptor";
+			imageURL = Engine.getResourceURL("icons/newreceptorround.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWRECEPTORSQUARE:
+			toolTipText = "Draw new square receptor";
+			imageURL = Engine.getResourceURL("icons/newreceptorsquare.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLIGANDROUND:
+			toolTipText = "Draw new round ligand";
+			imageURL = Engine.getResourceURL("icons/newligandround.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLIGANDSQUARE:
+			toolTipText = "Draw new square ligand";
+			imageURL = Engine.getResourceURL("icons/newligandsquare.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLINEMENU:
+			setMenuCreator(new NewItemMenuCreator(VPathway.NEWLINEMENU));
+			imageURL = Engine.getResourceURL("icons/newlinemenu.gif");
+			toolTipText = "Draw new line or arrow";
+			break;
+		case VPathway.NEWLINESHAPEMENU:
+			setMenuCreator(new NewItemMenuCreator(VPathway.NEWLINESHAPEMENU));
+			imageURL = Engine.getResourceURL("icons/newlineshapemenu.gif");
+			toolTipText = "Draw new ligand or receptor";
+			break;
+		}
+		setToolTipText(toolTipText);
+		setId("newItemAction");
+		if(imageURL != null) setImageDescriptor(ImageDescriptor.createFromURL(imageURL));
+	}
+				
+	public void run () {
+		if(isChecked())
+		{
+			SwtEngine.getWindow().deselectNewItemActions();
+			setChecked(true);
+			Engine.getActiveVPathway().setNewGraphics(element);
+		}
+		else
+		{	
+			Engine.getActiveVPathway().setNewGraphics(VPathway.NEWNONE);
+		}
+	}
+
+	/**
+	 * {@link IMenuCreator} that creates the drop down menus for 
+	 * adding new line-type and -shape elements
+	 */
+	private class NewItemMenuCreator implements IMenuCreator
+	{
+		private Menu menu;
+		int element;
+		
+		/**
+		 * Constructor for this class
+		 * @param e	type of menu to create; one of {@link VPathway}.NEWLINEMENU
+		 * , {@link VPathway}.NEWLINESHAPEMENU
+		 */
+		public NewItemMenuCreator(int e) 
+		{
+			element = e;
+		}
+		
+		public Menu getMenu(Menu parent)
+		{
+			return null;
+		}
+
+		public Menu getMenu(Control parent)
+		{
+			if (menu != null)
+				menu.dispose();
+			
+			menu = new Menu(parent);
+			Vector<Action> actions = new Vector<Action>();
+			switch(element)
+			{
+			case VPathway.NEWLINEMENU:
+				actions.add(new NewElementAction(VPathway.NEWLINE));
+				actions.add(new NewElementAction(VPathway.NEWLINEARROW));
+				actions.add(new NewElementAction(VPathway.NEWLINEDASHED));
+				actions.add(new NewElementAction(VPathway.NEWLINEDASHEDARROW));
+				break;
+			case VPathway.NEWLINESHAPEMENU:
+				actions.add(new NewElementAction(VPathway.NEWLIGANDROUND));
+				actions.add(new NewElementAction(VPathway.NEWRECEPTORROUND));
+				actions.add(new NewElementAction(VPathway.NEWLIGANDSQUARE));
+				actions.add(new NewElementAction(VPathway.NEWRECEPTORSQUARE));
+			}
+			
+			for (Action act : actions)
+			{			
+				addActionToMenu(menu, act);
+			}
+
+			return menu;
+		}
+		
+		protected void addActionToMenu(Menu parent, Action a)
+		{
+			ActionContributionItem item = new ActionContributionItem(a);
+			item.fill(parent, -1);
+		}
+		
+		public void dispose() 
+		{
+			if (menu != null)  {
+				menu.dispose();
+				menu = null;
+			}
+		}
+	}
+
+}

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/NewElementAction.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/GdbCellEditor.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/GdbCellEditor.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/gui/swt/GdbCellEditor.java	(revision 977)
@@ -0,0 +1,262 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Statement;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.FocusAdapter;
+import org.eclipse.swt.events.FocusEvent;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Layout;
+import org.pathvisio.Engine;
+import org.pathvisio.data.DataSources;
+import org.pathvisio.data.Gdb;
+import org.pathvisio.gui.swt.PropertyPanel.AutoFillData;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.PropertyType;
+import org.pathvisio.util.swt.SuggestCellEditor;
+import org.pathvisio.util.swt.SuggestCombo;
+import org.pathvisio.util.swt.SuggestCombo.SuggestionListener;
+import org.pathvisio.util.swt.SuggestCombo.SuggestionProvider;
+
+public class GdbCellEditor extends SuggestCellEditor implements SuggestionProvider, SuggestionListener {
+	public static final int TYPE_IDENTIFIER = 0;
+	public static final int TYPE_SYMBOL = 1;
+	int type;
+	
+	public static final int NO_LIMIT = 0;
+	public static final int NO_TIMEOUT = 0;
+	public static int query_timeout = 5; //seconds
+	
+	HashMap<String, PropertyPanel.AutoFillData> suggested;
+	
+	Button button;
+	
+	GdbCellEditor(Composite parent, int type) {
+		super();
+		this.type = type;
+		create(parent); //Set type before creating contol
+		suggestCombo.addSuggetsionListener(this);
+		suggested = new HashMap<String, PropertyPanel.AutoFillData>();
+	}
+		
+	protected Control createControl(Composite parent) {
+		if(type == TYPE_IDENTIFIER) {
+			Composite comp = new Composite(parent, SWT.NULL);
+			super.createControl(comp);
+			button = new Button(comp, SWT.PUSH);
+			button.setText("Set Label");
+			button.setToolTipText("Set the Label property by looking up the gene symbol in the synonym database");
+			button.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					Object value = doGetValue();
+					if(value instanceof AutoFillData) {
+						AutoFillData afd = (AutoFillData) value;
+						afd.setDoGuessData(true);
+						fireApplyEditorValue();
+						afd.setDoGuessData(false);
+					}
+				}
+			});
+			comp.setLayout(new CellLayout());
+			return comp;
+		} else {
+			return super.createControl(parent);
+		}
+	}
+	
+	protected void setFocusListeners() {
+        suggestCombo.getControl().addFocusListener(new FocusAdapter() {
+            public void focusLost(FocusEvent e) {
+            	if(!suggestCombo.isSuggestFocus() &&
+            		(button != null && !button.isFocusControl())) { //Also check focus on button
+            		GdbCellEditor.this.focusLost();
+            	}
+            }
+        });
+	}
+	
+    private class CellLayout extends Layout {
+    	//Adapted from DialogCellEditor
+        public void layout(Composite editor, boolean force) {
+            Rectangle bounds = editor.getClientArea();
+            Point size = button.computeSize(SWT.DEFAULT, SWT.DEFAULT, force);
+			suggestCombo.setBounds(0, 0, bounds.width - size.x, bounds.height);
+            button.setBounds(bounds.width - size.x, 0, size.x, bounds.height);
+        }
+
+        public Point computeSize(Composite editor, int wHint, int hHint,
+                boolean force) {
+            if (wHint != SWT.DEFAULT && hHint != SWT.DEFAULT) {
+				return new Point(wHint, hHint);
+			}
+            Point contentsSize = suggestCombo.computeSize(SWT.DEFAULT, SWT.DEFAULT,
+                    force);
+            Point buttonSize = button.computeSize(SWT.DEFAULT, SWT.DEFAULT,
+            		force);
+            Point result = new Point(buttonSize.x, Math.max(contentsSize.y,
+            		buttonSize.y));
+            return result;
+        }
+    }
+
+    public String getLabel(AutoFillData adf) {
+    	String iddb = adf.getProperty(PropertyType.GENEID) + " (" +
+    	adf.getProperty(PropertyType.SYSTEMCODE) + ")";
+    	switch(type) {
+    	case TYPE_IDENTIFIER:
+    		return 	iddb;
+    	case TYPE_SYMBOL:
+    	default:
+    		return adf.getProperty(PropertyType.TEXTLABEL) + ": " + iddb;
+    	}
+				
+	}
+	
+	public SuggestionProvider getSuggestionProvider() {
+		return this;
+	}
+
+	public void suggestionSelected(String suggestion) {
+		suggestCombo.setText(suggestion);
+		fireApplyEditorValue();
+	}
+	
+	protected Object doGetValue() {
+		String text = suggestCombo.getText();
+		AutoFillData suggestion = suggested.get(text);
+		if(suggestion == null) {
+			suggested.put(text, suggestion = new GdbAutoFillData(getMainPropertyType(), text));
+		}
+		return suggestion;
+	}
+	
+	protected PropertyType getMainPropertyType() {
+		switch(type) {
+		case TYPE_IDENTIFIER:
+			return PropertyType.GENEID;
+		case TYPE_SYMBOL:
+		default:
+			return PropertyType.TEXTLABEL;
+		}
+	}
+	
+	public String[] getSuggestions(String text, SuggestCombo suggestCombo) {
+		int limit = getLimit();
+		
+		List<String> sugg = new ArrayList<String>();
+		try {
+			Statement s = Gdb.getCon().createStatement();
+			
+			s.setQueryTimeout(query_timeout);
+			if(limit > NO_LIMIT) s.setMaxRows(limit);
+			
+			String query = "";
+			switch(type) {
+			case TYPE_IDENTIFIER:
+				query =
+						"SELECT id, code FROM gene WHERE " +
+						"id LIKE '" + text + "%'";
+				break;
+			case TYPE_SYMBOL:
+			default:
+				query =
+						"SELECT id, code, backpageText FROM gene WHERE " +
+						"backpageText LIKE '%<TH>Gene Name:<TH>" + text + "%'";
+			}
+			
+			ResultSet r = s.executeQuery(query);
+	
+			while(r.next()) {
+				String sysCode = r.getString("code");
+				String sysName = DataSources.sysCode2Name.get(sysCode);
+				
+				AutoFillData adf = null;
+				switch(type) {
+				case TYPE_IDENTIFIER:
+					adf = new GdbAutoFillData(PropertyType.GENEID, r.getString("id"));
+					adf.setProperty(PropertyType.SYSTEMCODE, sysName);
+					break;
+				case TYPE_SYMBOL:
+				default:
+					String symbol = Gdb.parseGeneSymbol(r.getString("backpageText"));
+					adf = new GdbAutoFillData(PropertyType.TEXTLABEL, symbol);
+					adf.setProperty(PropertyType.SYSTEMCODE, sysName);
+					adf.setProperty(PropertyType.GENEID, r.getString("id"));
+					
+				}
+				
+				String label = getLabel(adf);
+				suggested.put(label, adf);
+				sugg.add(label);
+			}
+		} catch (SQLException e) {
+			Engine.log.error("Unable to query suggestions", e);
+		}
+		if(limit > NO_LIMIT && sugg.size() == limit) sugg.add("...results limited to " + limit);
+		return sugg.toArray(new String[sugg.size()]);
+	}
+
+	int getLimit() {
+		switch(type) {
+		case TYPE_IDENTIFIER:
+			return 100;
+		case TYPE_SYMBOL:
+		default:
+			return 100;
+		}
+	}
+
+	class GdbAutoFillData extends AutoFillData {
+		public GdbAutoFillData(PropertyType mainProperty, String mainValue) {
+			super(mainProperty, mainValue);
+		}
+		
+		protected void guessData(PathwayElement o) {
+			//Fetch info from self
+			String id = getProperty(PropertyType.GENEID);
+			String sysName = getProperty(PropertyType.SYSTEMCODE);
+			
+			//If null, fetch from dataobject
+			if(id == null) id = (String)o.getProperty(PropertyType.GENEID);
+			if(sysName == null) sysName = (String)o.getProperty(PropertyType.SYSTEMCODE);
+			
+			String code = sysName == null ? null : DataSources.sysName2Code.get(sysName);
+			
+			//Guess symbol
+			if(id != null && code != null) {
+				String symbol = Gdb.getGeneSymbol(id, code);
+				if(symbol != null) {
+					setProperty(PropertyType.TEXTLABEL, symbol);
+				}
+			}
+		}
+	}
+
+}
Index: trunk/src/swt/org/pathvisio/gui/swt/SwtEngine.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/SwtEngine.java	(revision 976)
+++ trunk/src/swt/org/pathvisio/gui/swt/SwtEngine.java	(revision 977)
@@ -32,13 +32,15 @@
 import org.eclipse.swt.widgets.Shell;
 import org.pathvisio.Engine;
 import org.pathvisio.Globals;
+import org.pathvisio.data.DBConnector;
+import org.pathvisio.data.DBConnectorSwt;
 import org.pathvisio.debug.Sleak;
 import org.pathvisio.model.ConverterException;
 import org.pathvisio.model.Pathway;
 import org.pathvisio.preferences.PreferenceCollection;
 import org.pathvisio.preferences.swt.SwtPreferences;
 import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
-import org.pathvisio.util.SwtUtils.SimpleRunnableWithProgress;
+import org.pathvisio.util.swt.SwtUtils.SimpleRunnableWithProgress;
 import org.pathvisio.view.VPathway;
 import org.pathvisio.view.VPathwayWrapper;
 import org.pathvisio.view.swt.VPathwaySwtAwt;
@@ -342,6 +344,14 @@
 		imageRegistry = _imageRegistry;
 	}
 			
+	public static DBConnectorSwt getSwtDbConnector(int type) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
+		DBConnector dbc = Engine.getDbConnector(type);
+		if(dbc instanceof DBConnectorSwt) {
+			return (DBConnectorSwt)dbc;
+		} else {
+			throw new IllegalArgumentException("Not an SWT database connector");
+		}
+	}
 	/**
 	 * Get the working directory of this application
 	 */
Index: trunk/src/swt/org/pathvisio/gui/swt/PropertyPanel.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/PropertyPanel.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/gui/swt/PropertyPanel.java	(revision 977)
@@ -0,0 +1,658 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.awt.Color;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Set;
+
+import org.eclipse.jface.viewers.ArrayContentProvider;
+import org.eclipse.jface.viewers.CellEditor;
+import org.eclipse.jface.viewers.ColorCellEditor;
+import org.eclipse.jface.viewers.ComboBoxCellEditor;
+import org.eclipse.jface.viewers.ICellModifier;
+import org.eclipse.jface.viewers.ILabelProviderListener;
+import org.eclipse.jface.viewers.IStructuredContentProvider;
+import org.eclipse.jface.viewers.ITableLabelProvider;
+import org.eclipse.jface.viewers.TableViewer;
+import org.eclipse.jface.viewers.TextCellEditor;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.graphics.RGB;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Table;
+import org.eclipse.swt.widgets.TableColumn;
+import org.eclipse.swt.widgets.TableItem;
+import org.pathvisio.Engine;
+import org.pathvisio.biopax.gui.BiopaxCellEditor;
+import org.pathvisio.data.DataSources;
+import org.pathvisio.model.DataNodeType;
+import org.pathvisio.model.LineStyle;
+import org.pathvisio.model.LineType;
+import org.pathvisio.model.MappFormat;
+import org.pathvisio.model.ObjectType;
+import org.pathvisio.model.OrientationType;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.PathwayEvent;
+import org.pathvisio.model.PathwayListener;
+import org.pathvisio.model.PropertyClass;
+import org.pathvisio.model.PropertyType;
+import org.pathvisio.model.ShapeType;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.util.ColorConverter;
+import org.pathvisio.util.swt.SuggestCellEditor;
+import org.pathvisio.util.swt.SwtUtils;
+import org.pathvisio.util.swt.TableColumnResizer;
+import org.pathvisio.view.Graphics;
+import org.pathvisio.view.SelectionBox;
+import org.pathvisio.view.SelectionBox.SelectionEvent;
+import org.pathvisio.view.SelectionBox.SelectionListener;
+
+/**
+ * This class implements the sidepanel where you can edit graphical properties
+ * of each object on the pathway.
+ */
+public class PropertyPanel extends Composite implements PathwayListener, SelectionListener {
+	public TableViewer tableViewer;
+	CellEditor[] cellEditors = new CellEditor[2];
+	TextCellEditor textEditor;
+	ColorCellEditor colorEditor;
+	ComboBoxCellEditor comboBoxEditor;
+	SuggestCellEditor identifierSuggestEditor;
+	SuggestCellEditor symbolSuggestEditor;
+	BiopaxCellEditor biopaxEditor;
+	
+	private List<PathwayElement> dataObjects;
+	
+	private List<PropertyType> attributes;
+	
+	final static int TYPES_DIFF = ObjectType.MIN_VALID -1;
+	final static Object VALUE_DIFF = new Object() {
+		public boolean equals(Object o) { return false; }
+		public String toString() { return "different values"; }
+	};
+
+	/**
+	 * Add a {@link PathwayElement} to the list of objects of which 
+	 * the properties are displayed
+	 * @param o
+	 */
+	public void addGmmlDataObject(PathwayElement o) {
+		if(!dataObjects.contains(o)) {
+			if(dataObjects.add(o)) {
+				o.addListener(this);
+				refresh();
+			}
+		}
+	}
+	
+	/**
+	 * Remove a {@link PathwayElement} from the list of objects of which 
+	 * the properties are displayed
+	 * @param o
+	 */
+	public void removeGmmlDataObject(PathwayElement o) {
+		if(dataObjects.remove(o)) {
+			o.removeListener(this);
+			refresh();
+		}
+	}
+	
+	/**
+	 * Clear the list of objects of which the properties are displayed
+	 */
+	public void clearGmmlDataObjects() {
+		for(PathwayElement o : dataObjects) o.removeListener(this);
+		dataObjects.clear();
+		refresh();
+	}
+	
+	/**
+	 * Refresh the table and attributes to display
+	 */
+	void refresh() {
+		setAttributes();
+		tableViewer.refresh();
+	}
+	
+	int getAggregateType() {
+		int type = TYPES_DIFF;
+		for(int i = 0; i < dataObjects.size(); i++) {
+			PathwayElement g = dataObjects.get(i);
+			
+			if(i != 0 && type != g.getObjectType()) return TYPES_DIFF;
+			
+			type = g.getObjectType();
+		}
+		return type;
+	}
+	
+	Object getAggregateValue(PropertyType key) {
+		Object value = VALUE_DIFF;
+		for(int i = 0; i < dataObjects.size(); i++) {
+			PathwayElement g = dataObjects.get(i);
+			Object o = g.getProperty(key);
+			if(i != 0 && (o == null || !o.equals(value))) return VALUE_DIFF;
+
+			value = o;
+		}
+		return value;
+	}
+		
+	/**
+	 * Sets the attributes for the selected objects
+	 * Only attributes that are present in all objects in the selection will be
+	 * added to the attributes list and shown in the property table
+	 */
+	public void setAttributes ()
+	{
+		HashMap<PropertyType, Integer> master = new HashMap<PropertyType, Integer>();
+		for (PathwayElement o : dataObjects)
+		{
+			// get attributes. Only get advanced attributes if the preferences say so.
+			for (PropertyType attr : o.getAttributes(
+					 GlobalPreference.getValueBoolean(SwtPreference.SWT_SHOW_ADVANCED_ATTR)))
+			{
+				if (master.containsKey(attr))
+				{
+					// increment
+					master.put(attr, master.get(attr) + 1);
+				}
+				else
+				{
+					// set to 1
+					master.put(attr, 1);
+				}
+			}
+		}
+		attributes.clear();
+		for (PropertyType attr : master.keySet())
+		{
+			if (master.get(attr) == dataObjects.size())
+			{
+				attributes.add(attr);
+			}
+		}
+		// sortAttributes();
+		Collections.sort (attributes);		
+	}
+	
+//	void sortAttributes() {
+//		Collections.sort(attributes, new Comparator() {
+//			public int compare(Object o1, Object o2) {
+//				return o1.ordinal() - o2.ordinal();
+//			}
+//		});
+//	}
+
+	final static String[] colNames = new String[] {"Property", "Value"};
+				
+	PropertyPanel(Composite parent, int style)
+	{
+		super(parent, style);
+		setLayout(new FillLayout());
+		Table t = new Table(this, style);
+		TableColumn tcName = new TableColumn(t, SWT.LEFT);
+		TableColumn tcValue = new TableColumn(t, SWT.LEFT);
+		tcName.setText(colNames[0]);
+		tcValue.setText(colNames[1]);
+		tcName.setWidth(80);
+		tcValue.setWidth(70);
+		tableViewer = new TableViewer(t);
+		tableViewer.getTable().setLinesVisible(true);
+		tableViewer.getTable().setHeaderVisible(true);
+		tableViewer.setContentProvider(tableContentProvider);
+		tableViewer.setLabelProvider(tableLabelProvider);
+		
+		cellEditors[1] = cellEditors[0] = textEditor = new TextCellEditor(tableViewer.getTable());
+		colorEditor = new ColorCellEditor(tableViewer.getTable());
+		comboBoxEditor = new ComboBoxCellEditor(tableViewer.getTable(), new String[] {""});
+		identifierSuggestEditor = new GdbCellEditor(tableViewer.getTable(), GdbCellEditor.TYPE_IDENTIFIER);
+		symbolSuggestEditor = new GdbCellEditor(tableViewer.getTable(), GdbCellEditor.TYPE_SYMBOL);
+		biopaxEditor = new BiopaxCellEditor(tableViewer.getTable(), "...");
+		
+		tableViewer.setCellEditors(cellEditors);
+		tableViewer.setColumnProperties(colNames);
+		tableViewer.setCellModifier(cellModifier);
+		
+		t.addControlListener(new TableColumnResizer(t, t.getParent()));
+		
+		dataObjects = new ArrayList<PathwayElement>();
+		attributes = new ArrayList<PropertyType>();
+		tableViewer.setInput(attributes);
+		
+		SelectionBox.addListener(this);
+	}
+	
+	/**
+	 * return the right cell editor for a certain object. Will return
+	 * one of existing editors. In the case of a list of possible values, 
+	 * a comboboxeditor will be set up with the proper values for
+	 * the drop down list.
+	 */
+	final static String[] orientation_names = OrientationType.getNames();
+	final static String[] linestyle_names = LineStyle.getNames();
+	final static String[] boolean_names = {"false", "true"};
+	final static String[] shape_names = ShapeType.getNames();
+	final static String[] linetype_names = LineType.getNames(); 
+	final static String[] genetype_names = DataNodeType.getNames();
+	
+	private CellEditor getCellEditor(Object element)
+	{
+		PropertyType key = (PropertyType)element;
+		PropertyClass type = key.type();
+		switch(type)
+		{
+			case FONT:				
+			case STRING:
+			case DOUBLE:
+			case ANGLE:
+			case INTEGER: 	return textEditor;
+			case COLOR: 	return colorEditor;
+			case LINETYPE:
+				comboBoxEditor.setItems(linetype_names);
+				return comboBoxEditor;
+			case SHAPETYPE:
+				comboBoxEditor.setItems(shape_names);
+				return comboBoxEditor;
+			case DATASOURCE:			
+				comboBoxEditor.setItems(DataSources.dataSources);
+				return comboBoxEditor;
+			case ORIENTATION:
+				comboBoxEditor.setItems(orientation_names);
+				return comboBoxEditor;
+			case LINESTYLE:
+				comboBoxEditor.setItems(linestyle_names);
+				return comboBoxEditor;
+			case BOOLEAN:
+				comboBoxEditor.setItems(boolean_names);
+				return comboBoxEditor;
+			case ORGANISM:
+				comboBoxEditor.setItems(MappFormat.organism_latin_name);
+				return comboBoxEditor;
+			case GENETYPE:
+				comboBoxEditor.setItems(genetype_names);
+				return comboBoxEditor;
+			case DB_ID:
+				return identifierSuggestEditor;
+			case DB_SYMBOL:
+				return textEditor;
+			case BIOPAXREF:
+				return biopaxEditor;
+				
+		}
+		return textEditor;
+	}
+	
+	private ICellModifier cellModifier = new ICellModifier()
+	{
+		public boolean canModify(Object element, String property) {
+			if (!colNames[1].equals(property))
+			{
+				return false;
+			}
+			
+			cellEditors[1] = getCellEditor(element);
+			return true;
+		}
+
+		/**
+		 * Getvalue is the value that is passed to the Cell Editor when it is 
+		 * activated.
+		 * It should return an Integer object for ComboboxCellEditors.
+		 */
+		public Object getValue(Object element, String property) 
+		{
+			PropertyType key = (PropertyType)element;
+			Object value = getAggregateValue(key);
+			if(value == VALUE_DIFF) {
+				return VALUE_DIFF.toString();
+			}
+			switch(key.type())
+			{
+				case ANGLE:
+				{
+					Double x = Math.round((Double)(value) * 1800.0 / Math.PI) / 10.0;
+					return x.toString();
+				}
+				case DOUBLE:
+				{
+					Double x = Math.round((Double)(value) * 100.0) / 100.0;
+					return x.toString();
+				}
+				case INTEGER: 
+					return value.toString();
+				case ORGANISM:
+					return Arrays.asList(MappFormat.organism_latin_name).indexOf((String)value);
+				case GENETYPE:
+					return Arrays.asList(genetype_names).indexOf((String)value);
+				case STRING:
+				case FONT:
+					return value == null ? "" : (String)value;
+				case DATASOURCE:
+					return DataSources.lDataSources.indexOf((String)value);				
+				// for all combobox types:
+				case BOOLEAN:
+					return ((Boolean)value) ? 1 : 0;
+				case SHAPETYPE:
+					return (((ShapeType)value).ordinal());
+				case LINETYPE:
+					return (((LineType)value).ordinal());
+				case COLOR:
+					if(value instanceof Color)
+						value = SwtUtils.color2rgb((Color)value);
+					return (RGB)value;
+				case ORIENTATION:
+				case LINESTYLE:
+				{
+//					try 
+//					{
+						return (Integer)value;
+//					}
+//					catch (ClassCastException e)
+//					{
+//						MessageDialog.openWarning(getShell(), "warning", "Can't cast " + value + " to Integer!");
+//					}
+				}
+				case DB_ID:
+				case DB_SYMBOL:
+					if(value instanceof String) return (String)value;
+					if(value instanceof PropertyPanel.AutoFillData) 
+						return ((PropertyPanel.AutoFillData)value).getMainValue();
+				case BIOPAXREF:
+					return value;
+					
+			}
+			return null;
+		}
+		
+		public void modify(Object element, String property, Object value) {
+			PropertyType key = (PropertyType)((TableItem)element).getData();
+			
+			if(value == VALUE_DIFF || value == VALUE_DIFF.toString()) {
+				return;
+			}
+			/*
+			 * Here, we transform the output of the cell editor
+			 * to a value understood by PathwayElement.SetProperty().
+			 * 
+			 * The output of a comboboxCellEditor is Integer.
+			 * The output of a textCellEditor is String.
+			 * 
+			 * For linetype and shapetype we go from Integer to Integer. easy
+			 * For boolean, we go from Integer to Boolean
+			 * For Double / Integer, we go from String to Double
+			 * For Datasource, we go from Integer to String.
+			 */
+			switch(key.type())
+			{
+			case ANGLE: 	
+				try 
+				{ 
+					// convert degrees (property editor) to radians (model)
+					value = Double.parseDouble((String)value) * Math.PI / 180;					
+					break;
+				} 
+				catch(Exception e) 
+				{
+					// invalid input, ignore
+					return; 
+				}
+			case DOUBLE: 	
+				try 
+				{ 
+					value = Double.parseDouble((String)value); 
+					break; 
+				} 
+				catch(Exception e) 
+				{
+					// invalid input, ignore
+					return; 
+				}
+			case INTEGER: 	
+				try 
+				{ 
+					value = Integer.parseInt((String)value); 
+					break; 
+				}
+				catch(Exception e) 
+				{ 
+					// invalid input, ignore 
+					return; 
+				}
+			case DATASOURCE:
+				if((Integer)value == -1) return; //Nothing selected
+				value = DataSources.lDataSources.get((Integer)value);
+				break;
+			case BOOLEAN:
+				if ((Integer)value == 0)
+				{
+					value = new Boolean (false);
+				}
+				else
+				{
+					value = new Boolean (true);
+				}
+				break;
+			case ORGANISM:
+				if((Integer)value == -1) return; //Nothing selected
+				value = MappFormat.organism_latin_name[(Integer)value];
+				break;
+			case GENETYPE:
+				if((Integer)value == -1) return; //Nothing selected
+				value = genetype_names[(Integer)value];
+				break;
+			case COLOR:
+				value = SwtUtils.rgb2color((RGB)value);
+			case DB_SYMBOL:
+			case DB_ID:
+				if(value instanceof PropertyPanel.AutoFillData) {
+					PropertyPanel.AutoFillData adf = (PropertyPanel.AutoFillData)value;
+					for(PathwayElement o : dataObjects) {
+						if(o.getObjectType() == ObjectType.DATANODE) {
+							adf.fillData(o);
+						}
+					}
+					value = adf.getMainValue();
+				}
+				break;
+			}
+			for(PathwayElement o : dataObjects) {
+				o.setProperty(key, value);
+			}
+			tableViewer.refresh();
+			Engine.getActiveVPathway().redrawDirtyRect();
+		}
+	};
+	
+	private IStructuredContentProvider tableContentProvider = new ArrayContentProvider();
+	
+	private ITableLabelProvider tableLabelProvider = new ITableLabelProvider() {
+		public Image getColumnImage(Object element, int columnIndex) {
+			return null;
+		}
+		public String getColumnText(Object element, int columnIndex) {
+			PropertyType key = (PropertyType)element;
+			switch(columnIndex) {
+				case 0:
+					return key.desc();					
+				case 1:
+					//TODO: prettier labels for different value types
+					if(attributes.contains(key))
+					{
+						Object value = getAggregateValue(key);
+						if (value == null)
+						{
+							return null;
+						}
+						else 
+						{
+							switch (key.type())
+							{
+								case ANGLE:
+								{
+									if (value instanceof Double)
+									{
+										Double x = Math.round((Double)(value) * 1800.0 / Math.PI) / 10.0;
+										return x.toString();
+									}
+									else
+										return value.toString();
+								}
+								case DOUBLE:								
+									if (value instanceof Double)
+									{
+										Double x = Math.round((Double)(value) * 10.0) / 10.0;
+										return x.toString();
+									}
+									else
+										return value.toString();
+										
+								case BOOLEAN:
+								{
+									if (value instanceof Boolean)
+									{
+										return (Boolean)(value) ? "true" : "false";
+									}
+									else
+										return value.toString();
+								}
+								case LINETYPE:
+								{
+									if (value instanceof Integer)
+										return linetype_names[(Integer)(value)];
+									else
+										return value.toString();
+								}
+								case LINESTYLE:
+								{
+									if (value instanceof Integer)
+										return linestyle_names[(Integer)(value)];
+									else
+										return value.toString();
+								}
+								case ORIENTATION:
+								{
+									if (value instanceof Integer)
+										return orientation_names[(Integer)(value)];
+									else
+										return value.toString();									
+								}
+								case SHAPETYPE:
+								{
+									if (value instanceof Integer)
+										return shape_names[(Integer)(value)];
+									else
+										return value.toString();
+								}
+								case COLOR:
+									if(value instanceof Color) {
+										return SwtUtils.color2rgb((Color)value).toString();
+									}
+								default:
+									return value.toString();
+							}
+						}
+					}
+			}
+			return null;
+			}
+		
+		public void addListener(ILabelProviderListener listener) { }
+		public void dispose() {}
+		public boolean isLabelProperty(Object element, String property) {
+			return false;
+		}
+		public void removeListener(ILabelProviderListener listener) { }
+	};
+
+	public void gmmlObjectModified(PathwayEvent e) {
+		tableViewer.refresh();
+	}
+
+	//TODO: implement all attribute types as subclasses of MyType.
+//	class MyType {
+//		abstract String getColumnText(Object value);
+//		abstract Object adjustedValue(Object value);
+//		abstract CellEditor getCellEditor()
+//	}
+	
+	public void drawingEvent(SelectionEvent e) {
+		switch(e.type) {
+		case SelectionEvent.OBJECT_ADDED:
+			if(e.affectedObject instanceof Graphics)
+				addGmmlDataObject(((Graphics)e.affectedObject).getGmmlData());
+			break;
+		case SelectionEvent.OBJECT_REMOVED:
+			if(e.affectedObject instanceof Graphics)
+				removeGmmlDataObject(((Graphics)e.affectedObject).getGmmlData());
+			break;
+		case SelectionEvent.SELECTION_CLEARED:
+			 clearGmmlDataObjects();
+			break;
+		}
+		
+	}
+
+	static class AutoFillData {
+		PropertyType mProp;
+		Object mValue;
+		HashMap<PropertyType, String> values;
+		
+		private boolean doGuess = false;
+		
+		public AutoFillData(PropertyType mainProperty, String mainValue) {
+			values = new HashMap<PropertyType, String>();
+			mProp = mainProperty;
+			mValue = mainValue;
+			setProperty(mainProperty, mainValue);
+		}
+		
+		public void setProperty(PropertyType property, String value) {
+			values.put(property, value);
+		}
+		
+		public PropertyType getMainProperty() { return mProp; }
+		public Object getMainValue() { return mValue; }
+		
+		public String getProperty(PropertyType property) { return values.get(property); }
+		
+		public Set<PropertyType> getProperties() { return values.keySet(); }
+		
+		public void fillData(PathwayElement o) {
+			if(doGuess) guessData(o);
+			for(PropertyType p : getProperties()) {
+				Object vNew = getProperty(p);
+				o.setProperty(p, vNew);
+			}
+		}
+		
+		public void setDoGuessData(boolean doGuessData) {
+			doGuess = doGuessData;
+		}
+		
+		protected void guessData(PathwayElement o) {
+		}
+	}
+}
+

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/PropertyPanel.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/SidePanel.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/SidePanel.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/gui/swt/SidePanel.java	(revision 977)
@@ -0,0 +1,212 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.SashForm;
+import org.eclipse.swt.custom.StackLayout;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Sash;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+
+/**
+ * This class can be extended to create a sidepanel with minimize button
+ * for use as component of a {@link SashForm}
+ */
+public class SidePanel extends Composite {
+	private SashForm parentSash;
+	private Composite contentComposite;
+	
+	/**
+	 * Constructor for this class
+	 * @param parent	The parent composite (needs to be an {@link SashForm} for the
+	 * minimize button to work
+	 * @param style
+	 */
+	public SidePanel(Composite parent, int style) {
+		super(parent, style);
+		if(parent instanceof SashForm) //Minimize button only works if parent is sashform
+			parentSash = (SashForm)parent;
+		createControls();
+	}
+
+	public Composite getContentComposite() { return contentComposite; }
+	
+	Composite buttonBar;
+	Composite stackComposite;
+	Composite emptyComposite;
+	StackLayout stackLayout;
+	Button minButton;
+	/**
+	 * Creates the button controls to minimize the sidepanel and a {@link Composite} for the contents
+	 */
+	public void createControls() {
+		GridLayout topLayout = new GridLayout();
+		topLayout.verticalSpacing = topLayout.marginTop = topLayout.marginWidth = 0;
+		setLayout(topLayout);
+		
+		if(parentSash != null) {
+			//Create minimize control on top of content
+			buttonBar = new Composite(this, SWT.NULL);
+			GridLayout barLayout = new GridLayout(2, true);
+			barLayout.marginBottom = barLayout.marginHeight = barLayout.marginWidth = 1;
+			buttonBar.setLayout(barLayout);
+						
+			minButton = new Button(buttonBar, SWT.TOGGLE);
+			minButton.setToolTipText("Minimize this sidepanel");
+			minButton.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					if(minButton.getSelection()) {
+						minimize();
+						minButton.setToolTipText("Restore this sidepanel");
+					}
+					else {
+						restore();
+						minButton.setToolTipText("Minimize this sidepanel");
+					}
+				}
+			});
+			minButton.setImage(SwtEngine.getImageRegistry().get("sidepanel.minimize"));
+			final Button hideButton = new Button(buttonBar, SWT.PUSH);
+			hideButton.setToolTipText("Close this sidepanel (use view menu to open again)");
+			hideButton.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					hide();
+					SwtEngine.getWindow().showRightPanelAction.setChecked(false);
+				}
+			});
+			hideButton.setImage(SwtEngine.getImageRegistry().get("sidepanel.hide"));
+			
+			GridData buttonGrid = new GridData();
+			buttonGrid.widthHint = 12;
+			buttonGrid.heightHint =  12;
+			hideButton.setLayoutData(buttonGrid);
+			minButton.setLayoutData(buttonGrid);
+			
+			buttonBar.pack();
+		}
+		stackComposite = new Composite(this, SWT.NULL);
+		stackComposite.setLayoutData(new GridData(GridData.FILL_BOTH));
+		stackLayout = new StackLayout();
+		stackComposite.setLayout(stackLayout);
+		emptyComposite = new Composite(stackComposite, SWT.NULL);
+		emptyComposite.setLayout(new FillLayout());
+		contentComposite = new Composite(stackComposite, SWT.NULL);
+		contentComposite.setLayout(new FillLayout());
+		
+		stackLayout.topControl = contentComposite;
+	}
+	
+	/**
+	 * Minimizes this panel, while the minimize button will still be visible
+	 */
+	public void minimize() {
+		parentSash.setWeights(calculateWeights(WEIGHTS_MINIMIZE));
+		stackLayout.topControl = emptyComposite;
+		stackComposite.layout();
+	}
+	
+	/**
+	 * Hides this panel, the minimize button will not be visible anymore
+	 */
+	public void hide() {
+		parentSash.setWeights(calculateWeights(WEIGHTS_HIDE));
+	}
+	
+	public void show() {
+		int sidePanelSize = GlobalPreference.getValueInt(SwtPreference.SWT_SIDEPANEL_SIZE);
+		if(sidePanelSize == 0) sidePanelSize = 10; //Force show if initial size = 0
+		parentSash.setWeights(calculateWeights(sidePanelSize));
+	}
+	
+	/**
+	 * Restores the size of the panel to its previous size
+	 */
+	public void restore() {
+		if(oldWeights == null) return;
+		parentSash.setWeights(oldWeights);
+		stackLayout.topControl = contentComposite;
+		stackComposite.layout();
+	}
+	
+	private int[] oldWeights;
+	private static final int WEIGHTS_HIDE = -1;
+	private static final int WEIGHTS_MINIMIZE = -2;
+	/**
+	 * Calculates weights that have to be passed to the parent {@link SashForm#setWeights(int[])}
+	 * to resize, minimize or hide this panel
+	 * @param percent percentage of total size for this panel or 
+	 * one of WEIGHTS_HIDE or WEIGHTS_MINIMIZE, in the first case the panel is hidden,
+	 * so its weight is set to zero, in the second case the panel is miminized in a way the minimize 
+	 * button is still visible
+	 * @return
+	 */
+	private int[] calculateWeights(int percent) {
+		Control[] controls = parentSash.getChildren();
+		int[] weights = parentSash.getWeights();
+		oldWeights = weights.clone();
+		//Get the index of this control in the sashform
+		int thisIndex = 0;
+		for(int i = 0; i < controls.length; i++) {
+			if(controls[i] == this) break;
+			if(!(controls[i] instanceof Sash)) thisIndex++; //Don't count sash controls
+		}
+		
+		int thisWeight = weights[thisIndex];
+		
+		//Get the index of the neighbouring composite
+		int neighbourIndex = -1;
+		if(thisIndex == weights.length - 1) neighbourIndex = thisIndex - 1;
+		else neighbourIndex = thisIndex + 1;
+		
+		//Calculate widths needed to calculate new weight 
+		int newWidth;
+		switch(percent) {
+		case WEIGHTS_MINIMIZE: newWidth = minButton.getSize().x; break;
+		case WEIGHTS_HIDE: newWidth = 0; break;
+		default:
+			//Calculate new weights
+			int percentLeft = 100 - percent;
+			int sum = 0;
+			for(int i = 0; i < weights.length; i++) {
+				sum += weights[i];
+				if(i == thisIndex) continue;
+				weights[i] = (int)(((double)weights[i] / 100) * percentLeft);
+			}
+			weights[thisIndex] = (int)(((double)percent / 100) * sum);
+			return weights;
+			}
+		
+		int thisWidth = getSize().x;
+		
+		//Calculate new weights
+		int newWeight = (int)(((double)newWidth / thisWidth) * thisWeight);
+		//Adjust the weight of this and the next control
+		weights[thisIndex] = newWeight;
+		weights[neighbourIndex] += thisWeight - newWeight;
+		return weights;
+	}
+
+}

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/SidePanel.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/TabbedSidePanel.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/TabbedSidePanel.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/gui/swt/TabbedSidePanel.java	(revision 977)
@@ -0,0 +1,175 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.util.HashMap;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.CTabFolder;
+import org.eclipse.swt.custom.CTabItem;
+import org.eclipse.swt.custom.SashForm;
+import org.eclipse.swt.events.DisposeEvent;
+import org.eclipse.swt.events.DisposeListener;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.TabFolder;
+import org.eclipse.swt.widgets.TabItem;
+
+/**
+ * This class represents a side panel with contents placed in different
+ * tabitems. Components to add needs to be children of the {@link TabFolder}
+ * returned by {@link #getTabFolder()}
+ */
+public class TabbedSidePanel extends SidePanel {
+	private CTabFolder tabFolder;
+	HashMap<String, Control> controls;
+	HashMap<String, CTabItem> tabItems;
+	
+	/**
+	 * Returns the {@link TabFolder} containing the different
+	 * tabItems of this sidepanel
+	 */
+	public CTabFolder getTabFolder() { return tabFolder; }
+	
+	public HashMap<String, CTabItem> getTabItemHash() { return tabItems; }
+	
+	/**
+	 * Constructor for this class
+	 * @param parent	The parent composite (needs to be an {@link SashForm} for the
+	 * minimize button to work
+	 * @param style		
+	 */
+	public TabbedSidePanel(Composite parent, int style) {
+		super(parent, style);
+		controls = new HashMap<String, Control>();
+		tabItems = new HashMap<String, CTabItem>();
+		
+		tabFolder = new CTabFolder(getContentComposite(), SWT.BORDER);
+		tabFolder.setSimple(false);
+	}
+	
+	/**
+	 * Add a TabItem containing the given Control.
+	 * @param content	{@link Control} that needs to be a child of the
+	 * TabFolder returned by {@link #getTabFolder()}
+	 * @param title		The title for the TabItem
+	 */
+	public void addTab(Control content, String title)
+	{		
+		createTabItem(content, title, false);
+		controls.put(title, content);
+	}
+	
+	public void addTab(Control content, String title, boolean close)
+	{		
+		createTabItem(content, title, close);
+		controls.put(title, content);
+	}
+	
+	/**
+	 * Creates an {@link TabItem} with the given control and title
+	 * @param content
+	 * @param title
+	 * @param close
+	 * @returns
+	 */
+	private CTabItem createTabItem(Control content, String title, boolean close)
+	{
+		return createTabItem(content, title, tabFolder.getItemCount(), close);
+	}
+	
+	/**
+	 * Creates an {@link TabItem} with the given control and title at the given index.
+	 * If the index is lower than the number of tabitems, the new tabitem is placed before the first,
+	 * otherwise it is placed after the last.
+	 * @param content
+	 * @param title
+	 * @returns
+	 * @param index
+	 * @return
+	 */
+	private CTabItem createTabItem(Control content, String title, int index, boolean close) {
+		int nrTabs = tabFolder.getItemCount();
+		
+		if(index > nrTabs) index = nrTabs; //If index is invalid, choose first or last tab
+		else if(index < 0) index = 0;
+		
+		final CTabItem ti = new CTabItem(tabFolder, close ? SWT.CLOSE : SWT.NULL, index);
+		ti.setText(title);
+		ti.setControl(content);
+		ti.addDisposeListener(new DisposeListener() {
+			public void widgetDisposed(DisposeEvent e) {
+				tabItems.remove(ti.getText());
+			}
+		});
+		tabItems.put(title, ti);
+		return ti;
+	}
+	
+	/**
+	 * Hides a tab (without disposing the containing {@link Control})
+	 * @param title The title of the tab
+	 */
+	public void hideTab(String title) {
+		if(!tabItems.containsKey(title)) return;
+		tabItems.get(title).dispose();
+		tabItems.remove(title);
+	}
+	
+	/**
+	 * Shows a tab if a control with the given title exists
+	 * @param title	The title of the tabitem, also serves to find the {@link Control} for the tabItem
+	 * @return true if the tab is added, false if not ({@link Control} not found)
+	 */
+	public boolean unhideTab(String title) {
+		return unhideTab(title, tabFolder.getItemCount());
+	}
+	
+	/**
+	 * Shows a tab if a control with the given title exists
+	 * @param title	The title of the tabitem, also serves to find the {@link Control} for the tabItem
+	 * @param position The index of the position to add the tab
+	 * @return true if the tab is added, false if not ({@link Control} not found)
+	 */
+	public boolean unhideTab(String title, int position) {
+		if(controls.containsKey(title)) {
+			createTabItem(controls.get(title), title, position, false);
+			return true;
+		}
+		return false;
+	}
+	
+	public void selectTab(String title) {
+		if(tabItems.containsKey(title)) 
+			tabFolder.setSelection(tabItems.get(title));
+	}
+	
+	/**
+	 * Checks whether a tabitem is visible
+	 */
+	public boolean isVisible(String title) {
+		return tabItems.containsKey(title) && controls.containsKey(title);
+	}
+	
+	/**
+	 * Check whether a tabitem with the given title exists
+	 * @param title
+	 */
+	public boolean hasTab(String title) {
+		return tabItems.containsKey(title);
+	}
+}

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/TabbedSidePanel.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/MainWindowBase.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/MainWindowBase.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/gui/swt/MainWindowBase.java	(revision 977)
@@ -0,0 +1,476 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.action.ActionContributionItem;
+import org.eclipse.jface.action.ControlContribution;
+import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.action.IContributionItem;
+import org.eclipse.jface.action.MenuManager;
+import org.eclipse.jface.action.ToolBarContributionItem;
+import org.eclipse.jface.action.ToolBarManager;
+import org.eclipse.jface.dialogs.MessageDialog;
+import org.eclipse.jface.window.ApplicationWindow;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.SashForm;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.widgets.Combo;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Shell;
+import org.pathvisio.ApplicationEvent;
+import org.pathvisio.Engine;
+import org.pathvisio.Engine.ApplicationEventListener;
+import org.pathvisio.data.DBConnector;
+import org.pathvisio.data.DBConnectorSwt;
+import org.pathvisio.data.Gdb;
+import org.pathvisio.data.Gex;
+import org.pathvisio.data.GexSwt;
+import org.pathvisio.data.Gex.ExpressionDataEvent;
+import org.pathvisio.data.Gex.ExpressionDataListener;
+import org.pathvisio.data.GexSwt.ProgressKeeperDialog;
+import org.pathvisio.gui.swt.awt.VPathwaySwingComposite;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.search.PathwaySearchComposite;
+import org.pathvisio.view.GeneProduct;
+import org.pathvisio.view.VPathway;
+import org.pathvisio.view.VPathwayEvent;
+import org.pathvisio.view.VPathwayListener;
+import org.pathvisio.visualization.LegendPanel;
+
+/**
+ * MainWindowBase is an abstract and incomplete Main Window that contains some
+ * core functionality. This way we can create different flavours of the main window
+ * without having too much duplicate code. Descendants should at least provide
+ * a constructor, and override createCoolBarManager and createMenuManager.
+ */
+public abstract class MainWindowBase extends ApplicationWindow implements 
+	ApplicationEventListener, ExpressionDataListener, VPathwayListener
+{
+	private static final long serialVersionUID = 1L;
+	static int ZOOM_TO_FIT = -1;
+		
+	protected CommonActions.UndoAction undoAction = new CommonActions.UndoAction(this);	
+	protected CommonActions.NewAction newAction = new CommonActions.NewAction (this);
+	protected CommonActions.OpenAction openAction = new CommonActions.OpenAction (this);	
+	protected CommonActions.ImportAction importAction = new CommonActions.ImportAction (this);	
+	protected CommonActions.SaveAction saveAction = new CommonActions.SaveAction(this);	
+	protected CommonActions.SaveAsAction saveAsAction = new CommonActions.SaveAsAction (this);
+	protected CommonActions.ExportAction exportAction = new CommonActions.ExportAction (this);
+	protected CommonActions.ExitAction exitAction = new CommonActions.ExitAction(this);
+	protected CommonActions.PreferencesAction preferencesAction = new CommonActions.PreferencesAction(this);
+	protected CommonActions.AboutAction aboutAction = new CommonActions.AboutAction(this);
+	protected CommonActions.CopyAction copyAction = new CommonActions.CopyAction(this);
+	protected CommonActions.HelpAction helpAction = new CommonActions.HelpAction(this);	
+	protected CommonActions.PasteAction pasteAction = new CommonActions.PasteAction(this);
+	protected CommonActions.SwitchEditModeAction switchEditModeAction = new CommonActions.SwitchEditModeAction(this);
+	public ShowRightPanelAction showRightPanelAction = new ShowRightPanelAction(this);
+	protected SelectGdbAction selectGdbAction = new SelectGdbAction(this);
+	protected AlignActions.AlignCenterXAction alignCenterXAction = new AlignActions.AlignCenterXAction(this);
+	protected AlignActions.AlignCenterYAction alignCenterYAction = new AlignActions.AlignCenterYAction(this);
+	protected AlignActions.AlignLeftAction alignLeftAction = new AlignActions.AlignLeftAction(this);
+	protected AlignActions.AlignRightAction alignRightAction = new AlignActions.AlignRightAction(this);
+	protected AlignActions.AlignTopAction alignTopAction = new AlignActions.AlignTopAction(this);
+	protected AlignActions.AlignBottomAction alignBottomAction = new AlignActions.AlignBottomAction(this);
+	protected AlignActions.SetCommonWidthAction setCommonWidthAction = new AlignActions.SetCommonWidthAction(this);
+	protected AlignActions.SetCommonHeightAction setCommonHeightAction = new AlignActions.SetCommonHeightAction(this);
+
+	/**
+	 * {@link Action} to select a Gene Database
+	 */
+	private class SelectGdbAction extends Action
+	{
+		MainWindowBase window;
+		public SelectGdbAction(MainWindowBase w)
+		{
+			window = w;
+			setText("Select &Gene Database");
+			setToolTipText("Select Gene Database");
+		}
+		
+		public void run () {			
+			try {
+				DBConnectorSwt dbcon = SwtEngine.getSwtDbConnector(DBConnector.TYPE_GDB);
+				String dbName = dbcon.openChooseDbDialog(getShell());
+				
+				if(dbName == null) return;
+				
+				Gdb.connect(dbName);
+				setStatus("Using Gene Database: '" + SwtPreference.SWT_CURR_GDB + "'");
+				cacheExpressionData();
+			} catch(Exception e) {
+				String msg = "Failed to open Gene Database; " + e.getMessage();
+				MessageDialog.openError (window.getShell(), "Error", 
+						"Error: " + msg + "\n\n" + 
+						"See the error log for details.");
+				Engine.log.error(msg, e);
+			}
+		}
+	}
+
+	/**
+	 * deselect all buttons in the alignActionsCI coolbar
+	 */
+	public void deselectAlignItemActions()
+	{
+		IContributionItem[] items = alignActionsCI.getToolBarManager().getItems();
+		for(int i = 0; i < items.length; i++)
+		{
+			if(items[i] instanceof ActionContributionItem)
+			{
+				((ActionContributionItem)items[i]).getAction().setChecked(false);
+			}
+		}
+		Engine.getActiveVPathway().setNewGraphics(VPathway.NEWNONE);
+	}
+	
+	/**
+	 * {@link Action} to show or hide the right sidepanel
+	 */
+	public class ShowRightPanelAction extends Action
+	{
+		MainWindowBase window;
+		public ShowRightPanelAction (MainWindowBase w)
+		{
+			super("Show &information panel", IAction.AS_CHECK_BOX);
+			window = w;
+			setChecked(true);
+		}
+		
+		public void run() {
+			if(isChecked()) rightPanel.show();
+			else rightPanel.hide();
+		}
+	}
+
+	/**
+	 * Loads expression data for all {@link GeneProduct}s in the loaded pathway
+	 */
+	private void cacheExpressionData()
+	{
+		if(Engine.isDrawingOpen())
+		{
+			VPathway drawing = Engine.getActiveVPathway();
+			//Check for neccesary connections
+			if(Gex.isConnected() && Gdb.isConnected())
+			{
+				ProgressKeeperDialog dialog = new ProgressKeeperDialog(getShell());
+				try {
+					dialog.run(true, true, new GexSwt.CacheProgressKeeper(drawing.getMappIds(), drawing.getSystemCodes()));
+					drawing.redraw();
+				} catch(Exception e) {
+					String msg = "while caching expression data: " + e.getMessage();					
+					MessageDialog.openError (getShell(), "Error", 
+							"Error: " + msg + "\n\n" + 
+							"See the error log for details.");
+					Engine.log.error(msg, e);
+				}
+			}
+		}
+	}
+
+	/**
+	 * Deselects all {@link NewElementAction}s on the toolbar and sets 
+	 * {@link VPathway}.newGraphics to {@link VPathway}.NEWNONE
+	 */
+	public void deselectNewItemActions()
+	{
+		IContributionItem[] items = editActionsCI.getToolBarManager().getItems();
+		for(int i = 0; i < items.length; i++)
+		{
+			if(items[i] instanceof ActionContributionItem)
+			{
+				((ActionContributionItem)items[i]).getAction().setChecked(false);
+			}
+		}
+		Engine.getActiveVPathway().setNewGraphics(VPathway.NEWNONE);
+	}
+
+	// Elements of the coolbar
+	ToolBarContributionItem commonActionsCI;
+	ToolBarContributionItem editActionsCI;
+	ToolBarContributionItem alignActionsCI;
+	ToolBarContributionItem viewActionsCI;
+	
+	/**
+	 * Creates element of the coolbar containing common actions as new, save etc.
+	 */
+	protected void createCommonActionsCI()
+	{
+		ToolBarManager toolBarManager = new ToolBarManager(SWT.FLAT);
+		toolBarManager.add(newAction);
+		toolBarManager.add(openAction);
+		toolBarManager.add(saveAction);
+		commonActionsCI = new ToolBarContributionItem(toolBarManager, "CommonActions");
+	}
+
+	/**
+	 * Creates element of the coolbar only shown in edit mode (new element actions)
+	 */
+	protected void createEditActionsCI()
+	{
+		ToolBarManager toolBarManager = new ToolBarManager(SWT.FLAT);		
+		toolBarManager.add(new NewElementAction(VPathway.NEWGENEPRODUCT));
+		toolBarManager.add(new NewElementAction(VPathway.NEWLABEL));
+		toolBarManager.add(new NewElementAction(VPathway.NEWLINEMENU));
+		toolBarManager.add(new NewElementAction(VPathway.NEWRECTANGLE));
+		toolBarManager.add(new NewElementAction(VPathway.NEWOVAL));
+		toolBarManager.add(new NewElementAction(VPathway.NEWARC));
+		toolBarManager.add(new NewElementAction(VPathway.NEWBRACE));
+		toolBarManager.add(new NewElementAction(VPathway.NEWTBAR));
+		toolBarManager.add(new NewElementAction(VPathway.NEWLINESHAPEMENU));
+
+		editActionsCI = new ToolBarContributionItem(toolBarManager, "EditModeActions");
+	}
+	
+	/**
+	 * Creates element of the coolbar containing controls related to viewing a pathway
+	 */
+	protected void createViewActionsCI()
+	{
+		final MainWindowBase window = this;
+		ToolBarManager toolBarManager = new ToolBarManager(SWT.FLAT);
+		//Add zoomCombo
+		toolBarManager.add(new ControlContribution("ZoomCombo") {
+			protected Control createControl(Composite parent) {
+				final Combo zoomCombo = new Combo(parent, SWT.DROP_DOWN);
+				zoomCombo.setItems(new String[] { "200%", "100%", "75%", "50%", "Zoom to fit" });
+				zoomCombo.setText("100%");
+				zoomCombo.addSelectionListener(new SelectionAdapter() {
+					public void widgetSelected(SelectionEvent e) {
+						int pctZoom = 100;
+						String zoomText = zoomCombo.getText().replace("%", "");
+						try {
+							pctZoom = Integer.parseInt(zoomText);
+						} catch (Exception ex) { 
+							if(zoomText.equals("Zoom to fit"))
+									{ pctZoom = ZOOM_TO_FIT; } else { return; }
+						}
+						new CommonActions.ZoomAction(window, pctZoom).run();
+					}
+					public void widgetDefaultSelected(SelectionEvent e) { widgetSelected(e); }
+				});
+				return zoomCombo;
+			}
+		});
+		//Add swich to editmode
+		toolBarManager.add(switchEditModeAction);
+		
+		viewActionsCI =  new ToolBarContributionItem(toolBarManager, "SwitchActions");
+	}
+		
+	/**
+	 * Shows or hides the editActionsCI
+	 * @param show	true/false for either show or hide
+	 */
+	public void showEditActionsCI(boolean show)
+	{
+		if(show) {
+			getCoolBarManager().insertAfter(viewActionsCI.getId(), editActionsCI);
+		}
+		else {
+			getCoolBarManager().remove(editActionsCI);
+		}
+//		showVisualizationCI(!show); //Visualizations can show up in edit mode...
+		getCoolBarManager().update(true);
+	}
+
+	/**
+	   Shows or hides the alignActionsCI.
+	   @param show	true/false for either show or hide
+	*/
+	public void showAlignActionsCI(boolean show)
+	{
+		if(show) {
+			getCoolBarManager().insertAfter(editActionsCI.getId(), alignActionsCI);
+		}
+		else {
+			getCoolBarManager().remove(alignActionsCI);
+		}
+//		showVisualizationCI(!show); //Visualizations can show up in edit mode...
+		getCoolBarManager().update(true);
+	}
+	
+	//	KH 20070514 begin
+	/**
+	 * set up the alignActions coolbar
+	 */
+	protected void createAlignActionsCI()
+	{
+		ToolBarManager toolBarManager = new ToolBarManager(SWT.FLAT);
+		toolBarManager.add(alignCenterXAction);
+		toolBarManager.add(alignCenterYAction);
+		toolBarManager.add(alignLeftAction);
+		toolBarManager.add(alignRightAction);
+		toolBarManager.add(alignTopAction);
+		toolBarManager.add(alignBottomAction);
+		toolBarManager.add(setCommonWidthAction);
+		toolBarManager.add(setCommonHeightAction);
+	
+		alignActionsCI = new ToolBarContributionItem(toolBarManager, "AlignActions");
+	}
+	
+	protected Control createContents(Composite parent) {
+		Shell shell = parent.getShell();
+		shell.setSize(800, 600);
+		shell.setLocation(100, 100);
+		
+		GuiMain.loadImages(shell.getDisplay());
+		
+		shell.setImage(SwtEngine.getImageRegistry().get("shell.icon"));
+		
+		Composite viewComposite = new Composite(parent, SWT.NULL);
+		viewComposite.setLayout(new FillLayout());
+		
+		sashForm = new SashForm(viewComposite, SWT.HORIZONTAL);
+		
+		swingPathwayComposite = new VPathwaySwingComposite(sashForm, SWT.NONE);
+		
+		rightPanel = new TabbedSidePanel(sashForm, SWT.NULL);
+		
+		//rightPanel controls
+		bpBrowser = new BackpagePanel(rightPanel.getTabFolder(), SWT.NONE);
+		propertyTable = new PropertyPanel(
+				rightPanel.getTabFolder(), SWT.BORDER | SWT.SINGLE | SWT.FULL_SELECTION);
+		pwSearchComposite = new PathwaySearchComposite(rightPanel.getTabFolder(), SWT.NONE, this);
+		legend = new LegendPanel(rightPanel.getTabFolder(), SWT.V_SCROLL | SWT.H_SCROLL);
+		
+		addPanelTabs();
+		
+		int sidePanelSize = GlobalPreference.getValueInt(SwtPreference.SWT_SIDEPANEL_SIZE);
+		sashForm.setWeights(new int[] {100 - sidePanelSize, sidePanelSize});
+		showRightPanelAction.setChecked(sidePanelSize > 0);
+		
+		rightPanel.getTabFolder().setSelection(0); //select backpage browser tab
+		rightPanel.hideTab("Legend"); //hide legend on startup
+		
+		setStatus("Using Gene Database: '" + SwtPreference.SWT_CURR_GDB.getValue() + "'");
+
+		SwtEngine.updateTitle();
+		
+		return parent;
+	}
+	
+	protected abstract void addPanelTabs();
+	
+//	KH end
+	/**
+	   Invoked when user tries to close window.
+	   We'll ask the user if he wants to save the pathway
+	*/
+	protected boolean canHandleShellCloseEvent()
+	{
+		return SwtEngine.canDiscardPathway();
+	}
+	
+	protected MenuManager menuManager = null;
+	/**
+	 * can be accessed by plugins etc. 
+	 * to add menu items and even complete menus.
+	 * 
+	 * (plugin API)
+	 */
+	public MenuManager getMenuManager()
+	{
+		return menuManager;
+	}
+		
+	public boolean close() {
+		Engine.fireApplicationEvent(
+				new ApplicationEvent(this, ApplicationEvent.APPLICATION_CLOSE));
+		return super.close();
+	}
+	
+	VPathwaySwingComposite swingPathwayComposite;
+	public BackpagePanel bpBrowser; //Browser for showing backpage information
+	public PropertyPanel propertyTable;	//Table showing properties of Graphics objects
+	SashForm sashForm; //SashForm containing the drawing area and sidebar
+	TabbedSidePanel rightPanel; //side panel containing backbage browser and property editor
+	PathwaySearchComposite pwSearchComposite; //Composite that handles pathway searches and displays results
+	LegendPanel legend; //Legend to display colorset information
+	
+	public TabbedSidePanel getSidePanel() { return rightPanel; }
+	
+	public LegendPanel getLegend() { return legend; }
+	
+	public void showLegend(boolean show) {	
+		if(show && Gex.isConnected()) {
+			if(rightPanel.isVisible("Legend")) return; //Legend already visible, only refresh
+			rightPanel.unhideTab("Legend", 0);
+			rightPanel.selectTab("Legend");
+		}
+		
+		else rightPanel.hideTab("Legend");
+	}
+					
+	public void applicationEvent(ApplicationEvent e) {
+		switch(e.type) {
+		case ApplicationEvent.PATHWAY_OPENED:
+			if(Gex.isConnected()) cacheExpressionData();
+			break;
+		}
+		switch(e.type) {
+		case ApplicationEvent.VPATHWAY_NEW:
+		case ApplicationEvent.VPATHWAY_OPENED:
+			Engine.getActiveVPathway().addVPathwayListener(this);
+		}
+	}
+
+	public void expressionDataEvent(ExpressionDataEvent e) {
+		switch(e.type) {
+		case ExpressionDataEvent.CONNECTION_CLOSED:
+			getShell().getDisplay().syncExec(new Runnable() {
+				public void run() {
+					showLegend(false);
+				}
+			});
+			break;
+		case ExpressionDataEvent.CONNECTION_OPENED:
+			getShell().getDisplay().syncExec(new Runnable() {
+				public void run() {
+					cacheExpressionData();
+					showLegend(true);
+				}
+			});
+			break;
+		}
+	}
+	
+	public void vPathwayEvent(VPathwayEvent e) {
+		switch(e.getType()) {
+		case VPathwayEvent.EDIT_MODE_OFF:
+			showLegend(true);
+			break;
+		case VPathwayEvent.EDIT_MODE_ON:
+			showLegend(false);
+			break;
+		case VPathwayEvent.NEW_ELEMENT_ADDED:
+			deselectNewItemActions();
+			break;
+		}
+	}
+	
+	public MainWindowBase(Shell shell)
+	{
+		super(shell);
+	}
+
+}
Index: trunk/src/swt/org/pathvisio/gui/swt/CommonActions.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/CommonActions.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/gui/swt/CommonActions.java	(revision 977)
@@ -0,0 +1,625 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.dialogs.MessageDialog;
+import org.eclipse.jface.preference.PreferenceDialog;
+import org.eclipse.jface.preference.PreferenceManager;
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.widgets.FileDialog;
+import org.pathvisio.ApplicationEvent;
+import org.pathvisio.Engine;
+import org.pathvisio.Globals;
+import org.pathvisio.Engine.ApplicationEventListener;
+import org.pathvisio.biopax.gui.BiopaxDialog;
+import org.pathvisio.model.ConverterException;
+import org.pathvisio.model.Pathway;
+import org.pathvisio.model.PathwayExporter;
+import org.pathvisio.preferences.swt.PreferenceDlg;
+import org.pathvisio.preferences.swt.SwtPreferences;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.view.VPathway;
+
+/**
+   This class contains a large number of JFace Actions that are both in V1 and V2.
+*/   
+public class CommonActions
+{
+	static class UndoAction extends Action
+	{
+		MainWindowBase window;
+		public UndoAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Undo@Ctrl+Z");
+			setToolTipText ("Undo last action");
+		}
+		public void run() 
+		{
+			if (Engine.getActivePathway() != null)
+			{
+				Engine.getActivePathway().undo();
+			}
+		}
+	}
+	
+	/**
+	 * {@link Action} to create a new gpml pathway
+	 */
+	static class NewAction extends Action 
+	{
+		MainWindowBase window;
+		public NewAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&New pathway@Ctrl+N");
+			setToolTipText ("Create new pathway");
+			setImageDescriptor(ImageDescriptor.createFromURL(
+					Engine.getResourceURL("icons/new.gif")));
+		}
+		public void run ()
+		{			
+			SwtEngine.newPathway();
+		}	
+	}
+	
+	/**
+	 * {@link Action} to create a new gpml pathway
+	 */
+	static class SvgExportAction extends Action 
+	{
+		MainWindowBase window;
+		public SvgExportAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("Export to SVG");
+			setToolTipText ("Export to Scalable Vector Graphics (SVG) " +
+					"for publication-quality images");
+		}
+		public void run () 
+		{
+			//TODO: move to engine, merge with "save"
+			VPathway drawing = Engine.getActiveVPathway();
+			Pathway gmmlData = Engine.getActivePathway();
+			// Check if a gpml pathway is loaded
+			if (drawing != null)
+			{
+				FileDialog fd = new FileDialog(window.getShell(), SWT.SAVE);
+				fd.setText("Save");
+				fd.setFilterExtensions(new String[] {"*." + Engine.SVG_FILE_EXTENSION, "*.*"});
+				fd.setFilterNames(new String[] {Engine.SVG_FILTER_NAME, "All files (*.*)"});
+				
+				File xmlFile = gmmlData.getSourceFile();
+				if(xmlFile != null) {
+					String name = xmlFile.getName();
+					if (name.endsWith("." + Engine.PATHWAY_FILE_EXTENSION))
+					{
+						name = name.substring(0, name.length() - 
+							Engine.PATHWAY_FILE_EXTENSION.length()) +
+							Engine.SVG_FILE_EXTENSION;
+					}
+					fd.setFileName(name);
+					fd.setFilterPath(xmlFile.getPath());
+				} else {
+					fd.setFileName(SwtPreference.SWT_DIR_PWFILES.getValue());
+				}
+				String fileName = fd.open();
+				// Only proceed if user selected a file
+				
+				if(fileName == null) return;
+				
+				// Append .svg extension if not already present
+				if(!fileName.endsWith("." + Engine.SVG_FILE_EXTENSION)) 
+					fileName += "." + Engine.SVG_FILE_EXTENSION;
+				
+				File checkFile = new File(fileName);
+				boolean confirmed = true;
+				// If file exists, ask overwrite permission
+				if(checkFile.exists())
+				{
+					confirmed = MessageDialog.openQuestion(window.getShell(),"",
+					"File already exists, overwrite?");
+				}
+				if(confirmed)
+				{
+					try
+					{
+						gmmlData.writeToSvg(checkFile);
+					}
+					catch (ConverterException e)
+					{
+						String msg = "While writing svg to " 
+							+ checkFile.getAbsolutePath();					
+						MessageDialog.openError (window.getShell(), "Error", 
+								"Error: " + msg + "\n\n" + 
+								"See the error log for details.");
+						Engine.log.error(msg, e);
+					}
+				}
+			}
+			else
+			{
+				MessageDialog.openError (window.getShell(), "Error", 
+					"No pathway to save! Open or create a new pathway first");
+			}			
+		}
+	}
+
+	/**
+	 * {@link Action} to open an gpml pathway
+	 */
+	static class OpenAction extends Action 
+	{
+		MainWindowBase window;
+		public OpenAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Open pathway@Ctrl+O");
+			setToolTipText ("Open pathway");
+			setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/open.gif")));
+		}
+		public void run () 
+		{
+			FileDialog fd = new FileDialog(window.getShell(), SWT.OPEN);
+			fd.setText("Open");
+			String pwpath = SwtPreference.SWT_DIR_PWFILES.getValue();
+			fd.setFilterPath(pwpath);
+			fd.setFilterExtensions(new String[] {"*." + Engine.PATHWAY_FILE_EXTENSION, "*.*"});
+			fd.setFilterNames(new String[] {Engine.PATHWAY_FILTER_NAME, "All files (*.*)"});
+	        String fnMapp = fd.open();
+	        // Only open pathway if user selected a file
+	        
+	        if(fnMapp != null) { 
+	        	SwtEngine.openPathway(fnMapp); 
+	        }
+		}
+	}
+
+	/**
+	 * {@link Action} to open an gpml pathway
+	 */
+	static class ImportAction extends Action 
+	{
+		MainWindowBase window;
+		public ImportAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Import");
+			setToolTipText ("Import Pathway in GenMAPP format");
+		}
+		public void run () 
+		{
+			if(SwtEngine.canDiscardPathway())
+			{
+				FileDialog fd = new FileDialog(window.getShell(), SWT.OPEN);
+				fd.setText("Open");
+				fd.setFilterPath(SwtPreference.SWT_DIR_PWFILES.getValue());
+				fd.setFilterExtensions(new String[] {"*." + Engine.GENMAPP_FILE_EXTENSION, "*.*"});
+				fd.setFilterNames(new String[] {Engine.GENMAPP_FILTER_NAME, "All files (*.*)"});
+	        	String fnMapp = fd.open();
+	        	// Only open pathway if user selected a file
+	        	
+	        	if(fnMapp != null) { 
+	        		SwtEngine.openPathway(fnMapp); 
+	        	}
+	        }
+		}
+	}
+
+	/**
+	 * {@link Action} to save a gpml pathway to a file specified by the user
+	 */
+	static class SaveAsAction extends Action 
+	{
+		MainWindowBase window;
+		public SaveAsAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("Save pathway &As");
+			setToolTipText ("Save pathway with new file name");
+		}
+		
+		public void run () 
+		{
+			SwtEngine.savePathwayAs();
+		}
+	}
+
+	
+	/**
+	 * {@link Action} to save a gpml pathway to a file specified by the user
+	 */
+	static class ExportAction extends Action 
+	{
+		MainWindowBase window;
+		public ExportAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Export");
+			setToolTipText ("Export Pathway to GenMAPP format");
+		}
+		public void run () {
+			//TODO: move to engine, merge with "save" or "saveAs"
+			VPathway drawing = Engine.getActiveVPathway();
+			Pathway gmmlData = Engine.getActivePathway();
+			// Check if a gpml pathway is loaded
+			if (drawing != null)
+			{
+				FileDialog fd = new FileDialog(window.getShell(), SWT.SAVE);
+				fd.setText("Export");
+				
+				class FileType implements Comparable<FileType> {
+					final String name;
+					final String ext;
+					public FileType(String n, String e) { name = n; ext = e; }
+					public int compareTo(FileType o) {
+						return name.compareTo(o.name);
+					}
+				}
+				
+				ArrayList<FileType> fts = new ArrayList<FileType>();
+				HashMap<String, PathwayExporter> exporters = Engine.getPathwayExporters();
+								
+				for(String ext : exporters.keySet()) {
+					fts.add(new FileType(
+								exporters.get(ext).getName() + " (*." + ext + ")",
+								"*." + ext));
+				}
+				Collections.sort(fts);
+				String[] exts = new String[fts.size()];
+				String[] nms = new String[fts.size()];
+				for(int i = 0; i < fts.size(); i++) {
+					FileType ft = fts.get(i);
+					exts[i] = ft.ext;
+					nms[i] = ft.name;
+				}
+				fd.setFilterExtensions(exts);
+				fd.setFilterNames(nms);
+								
+				File xmlFile = gmmlData.getSourceFile();
+				if(xmlFile != null) {
+					String name = xmlFile.getName();
+					if (name.endsWith("." + Engine.PATHWAY_FILE_EXTENSION))
+					{
+						name = name.substring(0, name.length() - 
+							Engine.PATHWAY_FILE_EXTENSION.length() - 1);
+					}
+					fd.setFileName(name);
+					fd.setFilterPath(xmlFile.getPath());
+				} else {
+					fd.setFileName(SwtPreference.SWT_DIR_PWFILES.getValue());
+				}
+				String fileName = fd.open();
+				// Only proceed if user selected a file
+				if(fileName == null) return;
+				
+				int dot = fileName.lastIndexOf('.');
+				String ext = Engine.GENMAPP_FILE_EXTENSION;
+				if(dot >= 0) {
+					ext = fileName.substring(dot + 1, fileName.length());
+				}
+				PathwayExporter exporter = Engine.getPathwayExporter(ext);
+				
+				if(exporter == null) 
+					MessageDialog.openError (window.getShell(), "Error", 
+					"No exporter for '" + ext +  "' files");
+								
+				File checkFile = new File(fileName);
+				boolean confirmed = true;
+				// If file exists, ask overwrite permission
+				if(checkFile.exists())
+				{
+					confirmed = MessageDialog.openQuestion(window.getShell(),"",
+					"File already exists, overwrite?");
+				}
+				if(confirmed)
+				{
+					try
+					{
+						//gmmlData.writeToMapp(checkFile);
+						exporter.doExport(checkFile, gmmlData);
+					}
+					catch (ConverterException e)
+					{
+						String msg = "While exporting to " 
+							+ checkFile.getAbsolutePath();					
+						MessageDialog.openError (window.getShell(), "Error", 
+								"Error: " + msg + "\n\n" + 
+								"See the error log for details.");
+						Engine.log.error(msg, e);
+					}
+				}
+			}
+			else
+			{
+				MessageDialog.openError (window.getShell(), "Error", 
+					"No pathway to save! Open or create a new pathway first");
+			}			
+		}
+	}
+
+	/**
+	 * {@link Action} to exit the application
+	 */
+	static class ExitAction extends Action 
+	{
+		MainWindowBase window;
+		public ExitAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("E&xit@Ctrl+X");
+			setToolTipText ("Exit Application");
+		}
+		public void run () 
+		{
+			if (SwtEngine.canDiscardPathway())
+			{
+				window.close();
+			}
+		}
+	}
+	
+	static class PreferencesAction extends Action
+	{
+		MainWindowBase window;
+		public PreferencesAction (MainWindowBase w)
+		{
+			window = w;
+			setText("&Preferences");
+			setToolTipText("Edit preferences");
+		}
+		public void run () {
+			PreferenceManager pg = new PreferenceDlg();
+			PreferenceDialog pd = new PreferenceDialog(window.getShell(), pg);
+			pd.setPreferenceStore((SwtPreferences)SwtEngine.getPreferences());
+			pd.open();
+		}
+	}
+
+	/**
+	 * {@link Action} that zooms a mapp to the specified zoomfactor
+	 */
+	static class ZoomAction extends Action 
+	{
+		MainWindowBase window;
+		int pctZoomFactor;
+		
+		/**
+		 * Constructor for this class
+		 * @param w {@link MainWindow} window this action belongs to
+		 * @param newPctZoomFactor the zoom factor as percentage of original
+		 */
+		public ZoomAction (MainWindowBase w, int newPctZoomFactor)
+		{
+			window = w;
+			pctZoomFactor = newPctZoomFactor;
+			if(pctZoomFactor == MainWindowBase.ZOOM_TO_FIT) 
+			{
+				setText ("Zoom to fit");
+				setToolTipText("Zoom mapp to fit window");
+			}
+			else
+			{
+				setText (pctZoomFactor + " %");
+				setToolTipText ("Zoom mapp to " + pctZoomFactor + " %");
+			}
+		}
+		public void run () {
+			VPathway drawing = Engine.getActiveVPathway();
+			if (drawing != null)
+			{
+				drawing.setPctZoom(pctZoomFactor);
+			}
+			else
+			{
+				MessageDialog.openError (window.getShell(), "Error", 
+					"No gpml file loaded! Open or create a new gpml file first");
+			}
+		}
+	}
+
+	/**
+	 * {@link Action} to open a {@link AboutDlg} window
+	 */
+	static class AboutAction extends Action 
+	{
+		MainWindowBase window;
+		public AboutAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&About");
+			setToolTipText ("About " + Globals.APPLICATION_VERSION_NAME);
+		}
+		public void run () {
+			AboutDlg gmmlAboutBox = new AboutDlg(window.getShell(), SWT.NONE);
+			gmmlAboutBox.open();
+		}
+	}
+	
+	/**
+	 * {@link Action} to open a Help window
+	 */
+	static class HelpAction extends Action 
+	{
+		MainWindowBase window;
+		public HelpAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Help@F1");
+			setToolTipText ("Opens " + Globals.APPLICATION_VERSION_NAME + " help in your web browser");
+		}
+		public void run ()
+		{
+			SwtEngine.openWebPage(Globals.HELP_URL, "Opening help page in broswer",
+						"Unable to open web browser" +
+						"\nYou can open the help page manually:\n" +
+						Globals.HELP_URL);
+		}
+	}
+
+	static class CopyAction extends Action
+	{
+		MainWindowBase window;
+		public CopyAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("Copy@Ctrl+C");
+			setToolTipText ("Copy selected objects to clipboard");
+		}
+		public void run()
+		{
+			Engine.getActiveVPathway().copyToClipboard();
+		}
+	}
+
+	static class PasteAction extends Action
+	{
+		MainWindowBase window;
+		public PasteAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("Paste@Ctrl+V");
+			setToolTipText ("Paste contents of clipboard");
+		}
+		public void run()
+		{
+			Engine.getActiveVPathway().pasteFromClipboad();
+		}
+	}
+	
+	/**
+	 * {@link Action} to save a gpml pathway
+	 */
+	static class SaveAction extends Action 
+	{
+		MainWindowBase window;
+		public SaveAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Save pathway@Ctrl+S");
+			setToolTipText ("Save pathway");
+			setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/save.gif")));
+		}
+		
+		public void run ()
+		{
+			SwtEngine.savePathway();
+		}
+	}
+	
+	static class BiopaxAction extends Action 
+	{
+		MainWindowBase window;
+		public BiopaxAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("Edit &BioPAX code");
+			setToolTipText ("Edit BioPAX code");
+		}
+		
+		public void run () {
+			BiopaxDialog d = new BiopaxDialog(window.getShell());
+			d.setPathway(Engine.getActivePathway());
+			d.open();
+		}
+	}
+	
+	/**
+	 * {@link Action} to switch between edit and view mode
+	 */
+	static class SwitchEditModeAction extends Action implements ApplicationEventListener
+	{
+		final String ttChecked = "Exit edit mode";
+		final String ttUnChecked = "Switch to edit mode to edit the pathway content";
+		MainWindowBase window;
+		public SwitchEditModeAction (MainWindowBase w)
+		{
+			super("&Edit mode", IAction.AS_CHECK_BOX);
+			setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/edit.gif")));
+			setToolTipText(ttUnChecked);
+			window = w;
+			
+			Engine.addApplicationEventListener(this);
+		}
+
+		public void run ()
+		{
+			if(Engine.isDrawingOpen())
+			{
+				VPathway drawing = Engine.getActiveVPathway();
+				Pathway pathway = Engine.getActivePathway();
+				if(isChecked())
+				{
+					// give a warning that this can't be edited.
+					if (pathway.getSourceFile() != null && !pathway.getSourceFile().canWrite())
+					{
+						MessageDialog.openWarning(
+								window.getShell(), "Read-only Warning",
+								"You're trying to edit a Read-only file.\n" +
+						"When you want to save your changes, you have to save to a different file.");
+					}
+					//Switch to edit mode: show edit toolbar, show property table in sidebar
+					drawing.setEditMode(true);
+					window.showEditActionsCI(true);
+					window.showAlignActionsCI(true);
+					window.rightPanel.getTabFolder().setSelection(1);
+				}
+				else
+				{
+					//Switch to view mode: hide edit toolbar, show backpage browser in sidebar
+					drawing.setEditMode(false);
+					window.showEditActionsCI(false);
+					window.showAlignActionsCI(false);
+					window.rightPanel.getTabFolder().setSelection(0);
+				}
+			}
+			else //No gpml pathway loaded, deselect action and do nothing
+			{
+				setChecked(false);
+			}
+			window.getCoolBarManager().update(true);
+		}
+		
+		public void setChecked(boolean check) {
+			super.setChecked(check);
+			setToolTipText(check ? ttChecked : ttUnChecked);
+		}
+
+		public void switchEditMode(boolean edit) {
+			setChecked(edit);
+			run();
+
+		}
+
+		public void applicationEvent(ApplicationEvent e) {
+			if(e.type == ApplicationEvent.VPATHWAY_OPENED) {
+				Engine.getActiveVPathway().setEditMode(isChecked());
+			}
+			else if(e.type == ApplicationEvent.VPATHWAY_NEW) {
+				switchEditMode(true);
+			}
+		}
+	}
+}

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/CommonActions.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/GuiMain.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/GuiMain.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/gui/swt/GuiMain.java	(revision 977)
@@ -0,0 +1,205 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.io.File;
+import java.io.PrintStream;
+
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.eclipse.jface.resource.ImageRegistry;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.graphics.ImageData;
+import org.eclipse.swt.widgets.Display;
+import org.pathvisio.Engine;
+import org.pathvisio.data.Gdb;
+import org.pathvisio.data.Gex;
+import org.pathvisio.model.ImageExporter;
+import org.pathvisio.model.MappFormat;
+import org.pathvisio.model.SvgFormat;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.Preference;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.util.swt.SwtUtils;
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.plugins.PluginManager;
+
+/**
+ * This class contains the main method and is responsible for initiating 
+ * the application by setting up the user interface and creating all necessary objects
+ */
+public class GuiMain {
+	
+	/**
+	 * Main method which will be carried out when running the program
+	 */
+	public static void main(String[] args)
+	{
+		boolean debugHandles = false;
+		for(String a : args) {
+			if(		a.equalsIgnoreCase("--MonitorHandles") ||
+					a.equalsIgnoreCase("-mh")) {
+				debugHandles = true;
+			}
+			else if(a.equalsIgnoreCase("--UseR") ||
+					a.equalsIgnoreCase("-ur")) {
+				SwtEngine.USE_R = true;
+			}
+		}
+		
+		//Setup the application window
+		MainWindow window = null;
+		if(debugHandles)	window = SwtEngine.getSleakWindow();
+		else				window = SwtEngine.getWindow();
+		
+		initiate();
+		
+		window.setBlockOnOpen(true);
+		window.open();
+		
+		//Perform exit operations
+		//TODO: implement PropertyChangeListener and fire exit property when closing
+		// make classes themself responsible for closing when exit property is changed
+		Gex.close();
+		Gdb.close();
+		//Close log stream
+		Engine.log.getStream().close();
+		
+		Display.getCurrent().dispose();
+	}
+	
+	/**
+	 * Initiates some objects used by the program
+	 */
+	public static void initiate()
+	{
+		//initiate logger
+		try { 
+			GlobalPreference.FILE_LOG.setDefault(new File(SwtEngine.getApplicationDir(), ".PathVisioLog").toString());
+			Engine.log.setStream(new PrintStream(GlobalPreference.FILE_LOG.getValue())); 
+		} catch(Exception e) {}
+		Engine.log.setLogLevel(true, true, true, true, true, true);//Modify this to adjust log level
+		
+		//load the preferences
+		loadPreferences();
+		
+		//initiate Gene database (to load previously used gdb)
+		Gdb.init();
+		
+		//load visualizations and plugins
+		loadVisualizations();
+		
+		//create data directories if they don't exist yet
+		createDataDirectories();
+		
+		//register listeners for static classes
+		registerListeners();
+				
+		registerExporters();
+		
+		//NOTE: ImageRegistry will be initiated in "createContents" of MainWindow,
+		//since the window has to be opened first (need an active Display)
+	}
+	
+	/**
+	 * Creates data directories stored in preferences (if not exist)
+	 */
+	static void createDataDirectories() {
+		Preference[] dirPrefs = new Preference[] {
+				SwtPreference.SWT_DIR_EXPR,
+				SwtPreference.SWT_DIR_GDB,
+				SwtPreference.SWT_DIR_PWFILES,
+				SwtPreference.SWT_DIR_RDATA,
+		};
+		for(Preference p : dirPrefs) {
+			File dir = new File(p.getValue());
+			if(!dir.exists()) dir.mkdir();
+		}
+	}
+	
+			
+	static void registerListeners() {
+		VisualizationManager vmgr = new VisualizationManager();
+		Gex gex = new Gex();
+		
+		Engine.addApplicationEventListener(vmgr);
+		Engine.addApplicationEventListener(gex);
+	}
+	
+	static void registerExporters() {
+		Engine.addPathwayExporter(new MappFormat());
+		Engine.addPathwayExporter(new SvgFormat());
+		Engine.addPathwayExporter(new ImageExporter(ImageExporter.TYPE_PNG));
+		Engine.addPathwayExporter(new ImageExporter(ImageExporter.TYPE_TIFF));
+		Engine.addPathwayExporter(new ImageExporter(ImageExporter.TYPE_PDF));
+	}
+	
+	static void loadVisualizations() {
+		//load visualization plugins
+		try {
+			PluginManager.loadPlugins();
+		} catch (Throwable e) {
+			Engine.log.error("When loading visualization plugins", e);
+		}
+		
+		VisualizationManager.loadGeneric();
+	}
+	
+	static void loadPreferences() {
+		SwtEngine.getPreferences();
+	}
+	
+	/**
+	 * Loads images used throughout the applications into an {@link ImageRegistry}
+	 */
+	static void loadImages(Display display)
+	{
+		ClassLoader cl = GuiMain.class.getClassLoader();
+	
+		ImageRegistry imageRegistry = new ImageRegistry(display);
+		
+		// Labels for color by expressiondata (mRNA and Protein)
+		ImageData img = new ImageData(cl.getResourceAsStream("images/mRNA.bmp"));
+		img.transparentPixel = img.palette.getPixel(SwtUtils.color2rgb(Engine.TRANSPARENT_COLOR));
+		imageRegistry.put("data.mRNA",
+				new Image(display, img));
+		img = new ImageData(cl.getResourceAsStream("images/protein.bmp"));
+		img.transparentPixel = img.palette.getPixel(SwtUtils.color2rgb(Engine.TRANSPARENT_COLOR));
+		imageRegistry.put("data.protein",
+				new Image(display, img));
+		imageRegistry.put("sidepanel.minimize",
+				ImageDescriptor.createFromURL(cl.getResource("icons/minimize.gif")));
+		imageRegistry.put("sidepanel.hide",
+				ImageDescriptor.createFromURL(cl.getResource("icons/close.gif")));
+		imageRegistry.put("shell.icon", 
+				ImageDescriptor.createFromURL(cl.getResource("images/bigcateye.gif")));
+		imageRegistry.put("about.logo",
+				ImageDescriptor.createFromURL(cl.getResource("images/logo.jpg")));
+						imageRegistry.put("checkbox.unchecked",
+				ImageDescriptor.createFromURL(cl.getResource("icons/unchecked.gif")));
+		imageRegistry.put("checkbox.unavailable",
+				ImageDescriptor.createFromURL(cl.getResource("icons/unchecked_unavailable.gif")));
+		imageRegistry.put("checkbox.checked",
+				ImageDescriptor.createFromURL(cl.getResource("icons/checked.gif")));
+		imageRegistry.put("tree.collapsed",
+				ImageDescriptor.createFromURL(cl.getResource("icons/tree_collapsed.gif")));
+		imageRegistry.put("tree.expanded",
+				ImageDescriptor.createFromURL(cl.getResource("icons/tree_expanded.gif")));
+		SwtEngine.setImageRegistry(imageRegistry);
+	}
+	
+}
+

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/GuiMain.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/AlignActions.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/AlignActions.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/gui/swt/AlignActions.java	(revision 977)
@@ -0,0 +1,177 @@
+//	 PathVisio,
+//	 a tool for data visualization and analysis using Biological Pathways
+//	 Copyright 2006-2007 BiGCaT Bioinformatics
+	//
+//	 Licensed under the Apache License, Version 2.0 (the "License"); 
+//	 you may not use this file except in compliance with the License. 
+//	 You may obtain a copy of the License at 
+//	 
+//	 http://www.apache.org/licenses/LICENSE-2.0 
+//	  
+//	 Unless required by applicable law or agreed to in writing, software 
+//	 distributed under the License is distributed on an "AS IS" BASIS, 
+//	 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+//	 See the License for the specific language governing permissions and 
+//	 limitations under the License.
+	//
+
+package org.pathvisio.gui.swt;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.pathvisio.Engine;
+public class AlignActions {
+
+		
+	public static final char CENTERX = 'x';
+	public static final char CENTERY = 'y';
+	public static final char LEFT = 'l';
+	public static final char RIGHT = 'r';
+	public static final char TOP = 't';
+	public static final char BOTTOM = 'b';
+	public static final char WIDTH = 'w';
+	public static final char HEIGHT = 'h';
+	
+	
+		static class AlignCenterXAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignCenterXAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align horizontal centers");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/aligncenterx.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(CENTERX);
+				
+			}
+		}
+		
+		static class AlignCenterYAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignCenterYAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align vertical centers");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/aligncentery.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(CENTERY);
+				
+			}
+		}
+		static class AlignLeftAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignLeftAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align left edges");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/alignleft.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(LEFT);
+				
+			}
+		}
+		static class AlignRightAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignRightAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align right edges");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/alignright.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(RIGHT);
+				
+			}
+		}
+		static class AlignTopAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignTopAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align top edges");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/aligntop.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(TOP);
+				
+			}
+		}
+		static class AlignBottomAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignBottomAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align bottom edges");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/alignbottom.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(BOTTOM);
+				
+			}
+		}
+		static class SetCommonHeightAction extends Action 
+		{
+			MainWindowBase window;
+			public SetCommonHeightAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Set common height");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/sizeheight.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().scaleSelected(HEIGHT);
+				
+			}
+		}
+		static class SetCommonWidthAction extends Action 
+		{
+			MainWindowBase window;
+			public SetCommonWidthAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Set common width");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/sizewidth.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().scaleSelected(WIDTH);
+				
+			}
+		}
+
+
+	}
+
+
Index: trunk/src/swt/org/pathvisio/gui/swt/BackpagePanel.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/BackpagePanel.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/gui/swt/BackpagePanel.java	(revision 977)
@@ -0,0 +1,296 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.util.List;
+
+import org.eclipse.swt.browser.Browser;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.pathvisio.Engine;
+import org.pathvisio.data.DataSources;
+import org.pathvisio.data.Gdb;
+import org.pathvisio.data.Gex;
+import org.pathvisio.data.Gdb.IdCodePair;
+import org.pathvisio.util.Utils;
+import org.pathvisio.view.GeneProduct;
+import org.pathvisio.view.SelectionBox;
+import org.pathvisio.view.VPathwayElement;
+import org.pathvisio.view.SelectionBox.SelectionEvent;
+import org.pathvisio.view.SelectionBox.SelectionListener;
+
+/**
+ * Backpage browser - side panel that shows the backpage information when a GeneProduct is double-clicked
+ */
+public class BackpagePanel extends Composite implements SelectionListener {
+	/**
+	 * Directory containing HTML files needed to display the backpage information
+	 */
+	final static String BPDIR = "backpage";
+	/**
+	 * Header file, containing style information
+	 */
+	final static String HEADERFILE = "header.html";
+	
+	/**
+	 * Header for the gene information in HTML format
+	 */
+	final static String bpHeader = "<H1>Gene information</H1><P>";
+	/**
+	 * Header for the expression information in HTML format
+	 */
+	final static String gexHeader = "<H1>Expression data</H1><P>";
+	
+	private String bpText;
+	private String gexText;
+	private String header;
+	
+	private Browser bpBrowser;
+	
+	private GeneProduct geneProduct;
+	
+	/**
+	 * Constructor for this class
+	 * @param parent	Parent {@link Composite} for the Browser widget
+	 * @param style		Style for the Browser widget
+	 */
+	public BackpagePanel(Composite parent, int style) {
+		super(parent, style);
+		
+		initializeHeader(); //Load the header including style information
+		setLayout(new FillLayout());
+		bpBrowser = new Browser(this, style); //Set the Browser widget
+		setGeneText(null);
+		setGexText(null);
+		
+		SelectionBox.addListener(this);
+	}
+	
+	public void setGeneProduct(final GeneProduct gp) 
+	{ 
+		if(geneProduct == gp) return;
+		
+		Thread fetchThread = new Thread() {
+			public void run() {
+				geneProduct = gp;
+				if(gp == null) {
+					setGeneText(null);
+					setGexText(null);
+					return;
+				}
+				// Get the backpage text
+				String geneHeader = geneProduct.getGmmlData().getBackpageHead();
+				if (geneHeader == null) geneHeader = "";
+				String geneId = geneProduct.getGmmlData().getGeneID();
+				String systemCode = geneProduct.getGmmlData().getSystemCode();
+				String bpText = geneHeader.equals("") ? geneHeader : "<H2>" + geneHeader + "</H2><P>";
+				String bpInfo = Gdb.getBpInfo(geneId, systemCode);
+				bpText += bpInfo == null ? "<I>No gene information found</I>" : bpInfo;
+				String crossRefText = getCrossRefText(geneId, systemCode);
+				String gexText = Gex.getDataString(new IdCodePair(geneId, systemCode));
+				if (bpText != null) 	setGeneText(bpText);
+				if (gexText != null)	setGexText(gexText + crossRefText);
+				else 					setGexText("<I>No expression data found</I>");
+			}
+		};
+		
+		//Run in seperate thread so that this method can return
+		fetchThread.start();
+	}
+		
+	public String getCrossRefText(String id, String code) {
+		List<IdCodePair> crfs = Gdb.getCrossRefs(id, code);
+		if(crfs.size() == 0) return "";
+		StringBuilder crt = new StringBuilder("<H1>Cross references</H1><P>");
+		for(IdCodePair cr : crfs) {
+			String idtxt = cr.getId();
+			String url = getCrossRefLink(cr);
+			if(url != null) {
+				int os = Utils.getOS();
+				if(os == Utils.OS_WINDOWS) {
+					//In windows: open in new browser window
+					idtxt = "<a href='" + url + "' target='_blank'>" + idtxt + "</a>";
+				} else {
+					//This doesn't work under ubuntu, so no new windoe there
+					idtxt = "<a href='" + url + "'>" + idtxt + "</a>";
+				}
+				
+			}
+			String dbName = DataSources.sysCode2Name.get(cr.getCode());
+			crt.append( idtxt + ", " + (dbName != null ? dbName : cr.getCode()) + "<br>");
+		}
+		return crt.toString();
+	}
+	
+	String getCrossRefLink(IdCodePair idc) {
+		String c = idc.getCode();
+		String id = idc.getId();
+		if(c.equalsIgnoreCase("En"))
+			return "http://www.ensembl.org/Homo_sapiens/searchview?species=all&idx=Gene&q=" + id;
+		if(c.equalsIgnoreCase("P"))
+			return "http://www.expasy.org/uniprot/" + id;
+		if(c.equalsIgnoreCase("Q")) {
+			String pre = "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?";
+			if(id.startsWith("NM")) {
+				return pre + "db=Nucleotide&cmd=Search&term=" + id;
+			} else {
+				return pre + "db=Protein&cmd=search&term=" + id;
+			}
+		}
+		if(c.equalsIgnoreCase("T"))
+			return "http://godatabase.org/cgi-bin/go.cgi?view=details&search_constraint=terms&depth=0&query=" + id;
+		if(c.equalsIgnoreCase("I"))
+			return "http://www.ebi.ac.uk/interpro/IEntry?ac=" + id;
+		if(c.equalsIgnoreCase("Pd"))
+			return "http://bip.weizmann.ac.il/oca-bin/ocashort?id=" + id;
+		if(c.equalsIgnoreCase("X"))
+			return "http://www.ensembl.org/Homo_sapiens/featureview?type=OligoProbe;id=" + id;
+		if(c.equalsIgnoreCase("Em"))
+			return "http://www.ebi.ac.uk/cgi-bin/emblfetch?style=html&id=" + id;
+		if(c.equalsIgnoreCase("L"))
+			return "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=gene&cmd=Retrieve&dopt=full_report&list_uids=" + id;
+		if(c.equalsIgnoreCase("H"))
+			return "http://www.gene.ucl.ac.uk/cgi-bin/nomenclature/get_data.pl?hgnc_id=" + id;
+		if(c.equalsIgnoreCase("I"))
+			return "http://www.ebi.ac.uk/interpro/IEntry?ac=" + id;
+		if(c.equalsIgnoreCase("M"))
+			return "http://www.informatics.jax.org/searches/accession_report.cgi?id=" + id;
+		if(c.equalsIgnoreCase("Om"))
+			return "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=OMIM&cmd=Search&doptcmdl=Detailed&term=?" + id;
+		if(c.equalsIgnoreCase("Pf"))
+			return "http://www.sanger.ac.uk//cgi-bin/Pfam/getacc?" + id;
+		if(c.equalsIgnoreCase("R"))
+			return "http://rgd.mcw.edu/generalSearch/RgdSearch.jsp?quickSearch=1&searchKeyword=" + id;
+		if(c.equalsIgnoreCase("D"))
+			return "http://db.yeastgenome.org/cgi-bin/locus.pl?locus=" + id;
+		if(c.equalsIgnoreCase("S"))
+			return "http://www.expasy.org/uniprot/" + id;
+		if(c.equalsIgnoreCase("U")) {
+			String [] org_nr = id.split("\\.");
+			if(org_nr.length == 2) {
+				return "http://www.ncbi.nlm.nih.gov/UniGene/clust.cgi?ORG=" + 
+				org_nr[0] + "&CID=" + org_nr[1];
+			}
+			else {
+				return null;
+			}
+		}
+		if (c.equalsIgnoreCase("Nw"))
+		{
+			return "http://nugowiki.org/index.php/" + id;
+		}
+		if (c.equalsIgnoreCase("Ca"))
+		{
+			return "http://chem.sis.nlm.nih.gov/chemidplus/direct.jsp?regno=" + id;
+		}
+		if (c.equalsIgnoreCase("Cp"))
+		{
+			return "http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi?cid=" + id;
+		}
+		if (c.equalsIgnoreCase("Ce"))
+		{
+			return "http://www.ebi.ac.uk/chebi/searchId=CHEBI:" + id;
+		}
+		if (c.equalsIgnoreCase("Ch"))
+		{
+			return "http://www.hmdb.ca/scripts/show_card.cgi?METABOCARD=" + id + ".txt";
+		}
+		if (c.equalsIgnoreCase("Ck"))
+		{
+			return "http://www.genome.jp/dbget-bin/www_bget?cpd:" + id;
+		}
+		return null;
+	}
+	
+	/**
+	 * Sets the text for the Gene information part of the browser. Will be prepended by a paragraph
+	 * header as defined in bpHeader
+	 * @param bpText	Text to display in HTML format
+	 */
+	public void setGeneText(String bpText) {
+		if(bpText == null) { //In case no information has to be displayed
+			this.bpText = bpHeader + "<I>No gene selected</I>";
+		} else {
+			this.bpText = bpHeader + bpText;
+		}
+		refresh();
+	}
+	
+	/**
+	 * Sets the text for the expression part of the browser. Will be prepended by a paragraph
+	 * header as defined in gexHeader
+	 * @param gexText	Text to display in HTML format
+	 */
+	public void setGexText(String gexText) {
+		if(gexText != null) { //In case no information has to be displayed
+			this.gexText = gexHeader + gexText;
+		} else {
+			this.gexText = "";
+		}
+		refresh();
+	}
+	
+	/**
+	 * Refreshes the text displayed in the browser
+	 */
+	public void refresh() {
+		getDisplay().asyncExec(new Runnable() {
+			public void run() {
+				bpBrowser.setText(header + bpText + gexText);	
+			}
+		});
+	}
+	
+	/**
+	 * Reads the header of the HTML content displayed in the browser. This header is displayed in the
+	 * file specified in the {@link HEADERFILE} field
+	 */
+	private void initializeHeader() {
+		try {
+			BufferedReader input = new BufferedReader(new InputStreamReader(
+						Engine.getResourceURL(BPDIR + "/" + HEADERFILE).openStream()));
+			String line;
+			header = "";
+			while((line = input.readLine()) != null) {
+				header += line.trim();
+			}
+		} catch (Exception e) {
+			Engine.log.error("Unable to read header file for backpage browser: " + e.getMessage(), e);
+		}
+	}
+
+	public void drawingEvent(SelectionEvent e) {
+		switch(e.type) {
+		case SelectionEvent.OBJECT_ADDED:
+			//Just take the first GeneProduct in the selection
+			for(VPathwayElement o : e.selection) {
+				if(o instanceof GeneProduct) {
+					if(geneProduct != o) setGeneProduct((GeneProduct)o);
+					break; //Selects the first, TODO: use setGmmlDataObjects
+				}
+			}
+			break;
+		case SelectionEvent.OBJECT_REMOVED:
+			if(e.selection.size() != 0) break;
+		case SelectionEvent.SELECTION_CLEARED:
+			setGeneProduct(null);
+			break;
+		}
+	}
+}

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/BackpagePanel.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/search/PathwaySearchComposite.java
===================================================================
--- trunk/src/swt/org/pathvisio/search/PathwaySearchComposite.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/search/PathwaySearchComposite.java	(revision 977)
@@ -0,0 +1,324 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.search;
+
+import java.io.File;
+import java.lang.reflect.InvocationTargetException;
+import java.util.HashMap;
+
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.jface.dialogs.MessageDialog;
+import org.eclipse.jface.dialogs.ProgressMonitorDialog;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.StackLayout;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Combo;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.DirectoryDialog;
+import org.eclipse.swt.widgets.Group;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Text;
+import org.pathvisio.Engine;
+import org.pathvisio.data.DataSources;
+import org.pathvisio.gui.swt.MainWindowBase;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.search.SearchMethods.SearchException;
+import org.pathvisio.util.swt.SwtUtils.SimpleRunnableWithProgress;
+
+public class PathwaySearchComposite extends Composite {
+
+	HashMap<String, SearchOptionComposite> searchControls;
+	
+	MainWindowBase window;
+	
+	public PathwaySearchComposite(Composite parent, int style, MainWindowBase window) {
+		super(parent, style);
+		this.window = window;
+				
+		setLayout(new GridLayout());
+		initSearchComposite();
+		initSearchResultTable();
+		
+	}
+	
+	StackLayout pathwaySearchStack;
+	SearchResultTable searchResultTable;
+	
+	private void initSearchComposite() {
+		searchControls = new HashMap<String, SearchOptionComposite>();
+
+		String[] soLabels = new String[] { "gene id", "gene symbol" };
+		final HashMap<String, String> labelMappings = new HashMap<String, String>();
+		labelMappings.put(soLabels[0], "pathwaysContainingGene");
+		labelMappings.put(soLabels[1], "pathwaysContainingGeneSymbol");
+		
+		final Group group = new Group(this, SWT.SHADOW_ETCHED_IN);
+		group.setText("Search");
+		group.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+		
+		group.setLayout(new GridLayout(2, false));
+		Label label = new Label(group, SWT.CENTER);
+		label.setText("Search by:");
+		final Combo combo = new Combo(group, SWT.READ_ONLY);
+		combo.setItems(soLabels);
+		combo.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+		GridData span2cols = new GridData(GridData.FILL_HORIZONTAL);
+		span2cols.horizontalSpan = 2;
+		
+		final Group sGroup = new Group(group, SWT.NULL);
+		pathwaySearchStack = new StackLayout();
+		sGroup.setLayout(pathwaySearchStack);
+		sGroup.setLayoutData(span2cols);
+				
+		//Add search options composites to stacklayout
+		final Composite[] searchOptionControls = new Composite[2];
+		searchOptionControls[0] = pathwaysContainingGene(sGroup);
+		searchOptionControls[1] = pathwaysContainingGeneSymbol(sGroup);
+		
+		combo.addSelectionListener(new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				int selection = combo.getSelectionIndex();
+				if(selection > -1)
+					searchControls.get(labelMappings.get(combo.getText())).select();
+				sGroup.layout();
+			}
+		});
+		
+		//Set initial selection
+		//set symbol search as default
+		pathwaySearchStack.topControl = searchOptionControls[1];
+		combo.select(1);
+	}
+	
+	private void initSearchResultTable() {
+		Group group = new Group(this, SWT.SHADOW_ETCHED_IN);
+		group.setText("Results");
+		group.setLayoutData(new GridData(GridData.FILL_BOTH));
+		group.setLayout(new FillLayout());
+		searchResultTable = new SearchResultTable(group, SWT.NULL);
+		
+	}
+	
+	public Composite pathwaysContainingGeneSymbol(Composite parent) {
+		SearchOptionComposite comp = new SearchOptionComposite(parent, SWT.NULL)
+		{
+			void select() {
+				pathwaySearchStack.topControl = this;
+				pack();
+			}
+			
+			public Composite createContents(Composite parent) {
+				setLayout(new GridLayout(3, false));
+				
+				GridData span2cols = new GridData(GridData.FILL_HORIZONTAL);
+				span2cols.horizontalSpan = 2;
+				
+				Label symLabel = new Label(parent, SWT.CENTER);
+				symLabel.setText("Gene symbol:");
+				final Text symText = new Text(parent, SWT.SINGLE | SWT.BORDER);
+				symText.setLayoutData(span2cols);
+								
+				Label dirLabel = new Label(parent, SWT.CENTER);
+				dirLabel.setText("Directory to search:");
+				
+				final Text dirText = createDirText(parent);
+				createDirButton(parent, dirText);
+				
+				Button searchButton = new Button(parent, SWT.PUSH);
+				searchButton.setText("Search");
+				GridData span3cols = new GridData(GridData.HORIZONTAL_ALIGN_END);
+				span3cols.horizontalSpan = 3;
+				searchButton.setLayoutData(span3cols);
+				searchButton.addSelectionListener(new SelectionAdapter() {
+					public void widgetSelected(SelectionEvent e) {
+						String id = symText.getText();
+						String folder = dirText.getText();
+						if(id.equals("") || folder.equals("")) {
+							MessageDialog.openError(getShell(), "error", "please specify id and pathway folder"); 
+							return;
+						}
+						
+						SearchRunnableWithProgress srwp = new SearchRunnableWithProgress(
+								"pathwaysContainingGeneSymbol", 
+								new Class[] { String.class, File.class, 
+										SearchResultTable.class, SearchRunnableWithProgress.class });
+						srwp.setArgs(new Object[] {id, new File(folder), searchResultTable, srwp });
+						ProgressMonitorDialog dialog = new ProgressMonitorDialog(getShell());
+						try { dialog.run(true, true, srwp); } catch(Exception ex) 
+						{ 
+							MessageDialog.openError(getShell(), "Error", "Unable to perform search: " + ex.getMessage());
+							return;
+						}
+					}
+				});
+				
+				//Add controls to hash to enable preset values
+				name2Control.put("idText", symText);
+				name2Control.put("dirText", dirText);
+				return parent;
+			}
+		};
+		searchControls.put("pathwaysContainingGeneSymbol", comp); //Add to available search options
+		return comp;
+	}
+	
+	public Composite pathwaysContainingGene(Composite parent) {
+		SearchOptionComposite comp = new SearchOptionComposite(parent, SWT.NULL)
+		{
+			void select() {
+				pathwaySearchStack.topControl = this;
+			}
+			
+			public Composite createContents(Composite parent) {
+				setLayout(new GridLayout(3, false));
+				
+				GridData span2cols = new GridData(GridData.FILL_HORIZONTAL);
+				span2cols.horizontalSpan = 2;
+				
+				Label idLabel = new Label(parent, SWT.CENTER);
+				idLabel.setText("Gene id:");
+				final Text idText = new Text(parent, SWT.SINGLE | SWT.BORDER);
+				idText.setLayoutData(span2cols);
+				
+				Label systemLabel = new Label(parent, SWT.CENTER);
+				systemLabel.setText("Id system:");
+				final Combo systemCombo = new Combo(parent, SWT.SINGLE | SWT.READ_ONLY);
+				systemCombo.setItems(DataSources.dataSources);
+				systemCombo.setLayoutData(span2cols);
+				
+				Label dirLabel = new Label(parent, SWT.CENTER);
+				dirLabel.setText("Directory to search:");
+				
+				final Text dirText = createDirText(parent);
+				createDirButton(parent, dirText);
+				
+				Button searchButton = new Button(parent, SWT.PUSH);
+				searchButton.setText("Search");
+				GridData span3cols = new GridData(GridData.HORIZONTAL_ALIGN_END);
+				span3cols.horizontalSpan = 3;
+				searchButton.setLayoutData(span3cols);
+				searchButton.addSelectionListener(new SelectionAdapter() {
+					public void widgetSelected(SelectionEvent e) {
+						String id = idText.getText();
+						int codeIndex = systemCombo.getSelectionIndex();
+						String code =  codeIndex == -1 ? "" : DataSources.systemCodes[codeIndex];
+						String folder = dirText.getText();
+						if(id.equals("") || code.equals("") || folder.equals("")) {
+							MessageDialog.openError(getShell(), "error", "please specify id, code and pathway folder"); 
+							return;
+						}
+						
+						SearchRunnableWithProgress srwp = new SearchRunnableWithProgress(
+								"pathwaysContainingGeneID", 
+								new Class[] { String.class, String.class, File.class, 
+										SearchResultTable.class, SearchRunnableWithProgress.class });
+						SearchRunnableWithProgress.setMonitorInfo("Searching", (int)SearchMethods.TOTAL_WORK);
+						srwp.setArgs(new Object[] {id, code, new File(folder), searchResultTable, srwp });
+						ProgressMonitorDialog dialog = new ProgressMonitorDialog(getShell());
+						try { dialog.run(true, true, srwp); } catch(Exception ex) 
+						{ 
+							MessageDialog.openError(getShell(), "Error", "Unable to perform search: " + ex.getMessage());
+							return;
+						}
+					}
+				});
+				
+				//Add controls to hash to enable preset values
+				name2Control.put("idText", idText);
+				name2Control.put("systemCombo", systemCombo);
+				name2Control.put("dirText", dirText);
+				return parent;
+			}
+		};
+		searchControls.put("pathwaysContainingGene", comp); //Add to available search options
+		return comp;
+	}
+	
+	private Text createDirText(Composite parent) {
+		Text t = new Text(parent, SWT.SINGLE | SWT.BORDER);
+		t.setText(SwtPreference.SWT_DIR_PWFILES.getValue());
+		t.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+		return t;
+	}
+	
+	private Button createDirButton(Composite parent, final Text dirText) {
+		Button b = new Button(parent, SWT.PUSH);
+		b.setText("Browse");
+		b.addSelectionListener(new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				DirectoryDialog dd = new DirectoryDialog(getShell());
+				dd.setFilterPath(dirText.getText());
+				String dirName = dd.open();
+				if(dirName != null) dirText.setText(dirName);
+			}
+		});
+		return b;
+	}
+	
+	public class SearchRunnableWithProgress extends SimpleRunnableWithProgress {
+
+		public SearchRunnableWithProgress(String method, Class[] parameters) {
+			super(SearchMethods.class, method, parameters);
+		}
+		
+		public void run(IProgressMonitor monitor) {
+			try {
+				super.run(monitor);
+			} catch (InterruptedException e) {
+				openMessageDialog("error", e.getMessage());
+				Engine.log.error("Unable to start search", e);
+			} catch (InvocationTargetException e) {
+				if(e.getCause() instanceof SearchException)
+					openMessageDialog("", e.getCause().getMessage());
+				else {
+					openMessageDialog("error", "Cause: " + e.getCause().getMessage());
+					Engine.log.error("while searching", e);
+				}
+			}
+		}
+		
+	}
+	
+	public abstract class SearchOptionComposite extends Composite {
+		HashMap<String, Control> name2Control;
+		
+		public SearchOptionComposite(Composite parent, int style) {
+			super(parent, style);
+			name2Control = new HashMap<String,Control>();
+			createContents(this);
+		}
+		
+		public void setContents(HashMap<String, String> name2Value) {
+			for(String key : name2Control.keySet()) {
+				if(name2Value.containsKey(key)) {
+					Control c = name2Control.get(key);
+					if(c instanceof Text) 		((Text)c).setText(name2Value.get(key));
+					else if(c instanceof Combo) ((Combo)c).setText(name2Value.get(key));
+				}
+			}
+		}
+		
+		abstract void select();
+		public abstract Composite createContents(Composite parent);
+	}
+}

Property changes on: trunk/src/swt/org/pathvisio/search/PathwaySearchComposite.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/search/SearchMethods.java
===================================================================
--- trunk/src/swt/org/pathvisio/search/SearchMethods.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/search/SearchMethods.java	(revision 977)
@@ -0,0 +1,189 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.search;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import org.pathvisio.Engine;
+import org.pathvisio.data.Gdb;
+import org.pathvisio.data.Gdb.IdCodePair;
+import org.pathvisio.search.PathwaySearchComposite.SearchRunnableWithProgress;
+import org.pathvisio.util.FileUtils;
+import org.pathvisio.util.PathwayParser;
+import org.pathvisio.util.tableviewer.PathwayTable;
+import org.pathvisio.util.tableviewer.TableData;
+import org.pathvisio.util.tableviewer.TableData.Row;
+import org.xml.sax.SAXException;
+import org.xml.sax.XMLReader;
+import org.xml.sax.helpers.XMLReaderFactory;
+
+public abstract class SearchMethods {	
+	public static final String MSG_NOT_IN_GDB = "Gene not found in selected gene database";
+	public static final String MSG_NOTHING_FOUND = "Nothing found";
+	public static final String MSG_CANCELLED = "cancelled";
+	
+	public static final double TOTAL_WORK = 1000.0;
+		
+	/**
+	 * Search for pathways containing the given gene and display result in given result table
+	 * @param id	Gene identifier to search for
+	 * @param code	System code of the gene identifier
+	 * @param folder	Directory to search (includes sub-directories)
+	 * @param srt	{@link SearchResultTable} to display the results in
+	 * @return string with message to display. if null, no message is displayed
+	 */
+	public static String pathwaysContainingGene(String id, String code, File folder, 
+			SearchResultTable srt) throws SearchException {
+		return pathwaysContainingGene(id, code, folder, srt);
+	}
+	
+	/**
+	 * Search for pathways containing the given gene and display result in given result table
+	 * @param id	Gene identifier to search for
+	 * @param code	System code of the gene identifier
+	 * @param folder	Directory to search (includes sub-directories)
+	 * @param srt	{@link SearchResultTable} to display the results in
+	 * @param runnable	{@link SearchRunnableWithProgress} containing the monitor responsible for
+	 * displaying the progress
+	 */
+	public static void pathwaysContainingGeneID(String id, String code, File folder, 
+			SearchResultTable srt, SearchRunnableWithProgress runnable) 
+			throws SearchException, SAXException {
+		
+		TableData srs = new TableData();
+		srs.addColumn("pathway");
+		srs.addColumn("directory");
+		srs.addColumn(PathwayTable.COLNAME_FILE, false);
+		srs.addColumn(SearchResultTable.COLUMN_FOUND_IDS, false);
+
+		srt.setTableData(srs);
+		//Get all cross references
+		List<IdCodePair> refs = Gdb.getCrossRefs(id, code);
+		if(refs.size() == 0) throw new NoGdbException();
+		
+		SearchRunnableWithProgress.monitorWorked((int)(TOTAL_WORK * 0.2));
+		
+		//get all pathway files in the folder and subfolders
+		ArrayList<File> pathways = FileUtils.getFiles(folder, Engine.PATHWAY_FILE_EXTENSION, true);
+
+		XMLReader xmlReader = XMLReaderFactory.createXMLReader();
+		for(File f : pathways) {
+			if(SearchRunnableWithProgress.getMonitor().isCanceled()) return;
+			//Get all genes in the pathway
+			PathwayParser parser = new PathwayParser(xmlReader);
+			try { xmlReader.parse(f.getAbsolutePath()); } catch(Exception e) { }
+			ArrayList<PathwayParser.Gene> genes = parser.getGenes();
+			//Check if one of the given ids is in the pathway
+			for(PathwayParser.Gene gene : genes) {
+				if(refs.contains(new IdCodePair(gene.getId(), gene.getCode()))) {//Gene found, add pathway to search result and break
+					Row sr = srs.new Row();
+					sr.setCell("pathway", f.getName());
+					sr.setCell("directory", f.getParentFile().getName());
+					sr.setCell(PathwayTable.COLNAME_FILE, f.getAbsolutePath());
+					ArrayList<String> idsFound = new ArrayList<String>();
+					idsFound.add(gene.getId());
+					sr.setCell(SearchResultTable.COLUMN_FOUND_IDS, idsFound);
+					srt.refreshTableViewer(true);
+					break;
+				}
+			}
+			SearchRunnableWithProgress.monitorWorked((int)Math.ceil(TOTAL_WORK / pathways.size()));
+		}
+		if(srs.getResults().size() == 0) throw new NothingFoundException();
+	}
+
+	public static void pathwaysContainingGeneSymbol(String regex, File folder, 
+			SearchResultTable srt, SearchRunnableWithProgress runnable) 
+			throws SearchException, SAXException {
+
+		//Create regex
+		Pattern pattern = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);
+		
+		TableData srs = new TableData();
+		srs.addColumn("pathway");
+		srs.addColumn("directory");
+		srs.addColumn(PathwayTable.COLNAME_FILE, false);
+		srs.addColumn("namesFound");
+		srs.addColumn(SearchResultTable.COLUMN_FOUND_IDS, false);
+
+		srt.setTableData(srs);
+		
+		//get all pathway files in the folder and subfolders
+		ArrayList<File> pathways = FileUtils.getFiles(folder, Engine.PATHWAY_FILE_EXTENSION, true);
+
+		XMLReader xmlReader = XMLReaderFactory.createXMLReader();
+		for(File f : pathways) {
+			if(SearchRunnableWithProgress.getMonitor().isCanceled()) return;
+			//Get all genes in the pathway
+			PathwayParser parser = new PathwayParser(xmlReader);
+			try { xmlReader.parse(f.getAbsolutePath()); } catch(Exception e) { }
+			ArrayList<PathwayParser.Gene> genes = parser.getGenes();
+			//Find what symbols match
+			ArrayList<PathwayParser.Gene> matched = new ArrayList<PathwayParser.Gene>();
+			ArrayList<String> idsFound = new ArrayList<String>();
+			ArrayList<String> namesFound = new ArrayList<String>();
+			for(PathwayParser.Gene gene : genes) {
+				Matcher m = pattern.matcher(gene.getSymbol());
+				if(m.find()) {
+					matched.add(gene);
+					idsFound.add(gene.getId());
+					namesFound.add(gene.getSymbol());
+				}
+			}
+			if(matched.size() > 0) {
+				Row sr = srs.new Row();
+				sr.setCell("pathway", f.getName());
+				sr.setCell("directory", f.getParentFile().getName());
+				sr.setCell(PathwayTable.COLNAME_FILE, f.getAbsolutePath());
+				sr.setCell(SearchResultTable.COLUMN_FOUND_IDS, idsFound);
+				sr.setCell("namesFound", namesFound);
+
+				srt.refreshTableViewer(true);
+			}
+			SearchRunnableWithProgress.monitorWorked((int)Math.ceil(TOTAL_WORK / pathways.size()));
+		}
+		if(srs.getResults().size() == 0) throw new NothingFoundException();
+	}
+	
+	static class SearchException extends Exception {
+		private static final long serialVersionUID = 1L;
+
+		SearchException(String msg) {
+			super(msg);
+		}
+	}
+	
+	static class NothingFoundException extends SearchException {
+		private static final long serialVersionUID = 1L;
+
+		NothingFoundException() {
+			super(MSG_NOTHING_FOUND);
+		}
+	}
+	
+	static class NoGdbException extends SearchException {
+		private static final long serialVersionUID = 1L;
+
+		NoGdbException() {
+			super(MSG_NOT_IN_GDB);
+		}
+	}
+}

Property changes on: trunk/src/swt/org/pathvisio/search/SearchMethods.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/search/SearchResultTable.java
===================================================================
--- trunk/src/swt/org/pathvisio/search/SearchResultTable.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/search/SearchResultTable.java	(revision 977)
@@ -0,0 +1,108 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.search;
+
+import java.util.ArrayList;
+
+import org.eclipse.jface.viewers.IStructuredSelection;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Label;
+import org.pathvisio.ApplicationEvent;
+import org.pathvisio.Engine;
+import org.pathvisio.Engine.ApplicationEventListener;
+import org.pathvisio.util.tableviewer.PathwayTable;
+import org.pathvisio.util.tableviewer.TableData.Row;
+import org.pathvisio.view.GeneProduct;
+import org.pathvisio.view.VPathway;
+import org.pathvisio.view.VPathwayElement;
+
+
+/**
+ * This composite displays a table on which SearchResults can be
+ * displayed
+ */
+public class SearchResultTable extends PathwayTable implements ApplicationEventListener {
+	public static String COLUMN_FOUND_IDS = "idsFound";
+	
+	public SearchResultTable(Composite parent, int style) {
+		super(parent, SWT.NULL);
+		Engine.addApplicationEventListener(this);
+	}
+		
+	public int getNrResults() { return getNrRows(); }
+		
+	public void highlightResults(boolean highlight) {
+		VPathway drawing = Engine.getActiveVPathway();
+		if(drawing == null) return; //No drawing open
+		
+		if(highlight) { 
+			Row sr = (Row) //Get selected searchresult
+			((IStructuredSelection)tableViewer.getSelection()).getFirstElement();
+			if(sr == null) return; //Nothing selected
+			
+			try {
+				ArrayList idsFound = sr.getCell(COLUMN_FOUND_IDS).getArray();
+				GeneProduct gp = null;
+				for(VPathwayElement o : drawing.getDrawingObjects()) {
+					if(o instanceof GeneProduct) {
+						gp = (GeneProduct)o;
+						if(idsFound.contains(gp.getID())) gp.highlight();
+					}
+				}
+				drawing.redraw();
+			} catch(Exception ex) { 
+				Engine.log.error("when highlighting genes from search result table", ex);
+			}
+		}
+		else drawing.resetHighlight();
+	}
+	
+	Button highlightButton;
+	protected void createContents() {
+		setLayout(new GridLayout(1, false));
+		
+		Composite optionsComposite = new Composite(this, SWT.NULL);
+		optionsComposite.setLayout(new GridLayout(2, false));
+		highlightButton = new Button(optionsComposite, SWT.CHECK);
+		highlightButton.setSelection(true);
+		highlightButton.addSelectionListener(new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				highlightResults(highlightButton.getSelection());
+			}
+		});
+		
+		Label highlightLabel = new Label(optionsComposite, SWT.CENTER);
+		highlightLabel.setText("Highlight found genes");
+		
+		Composite tableComposite = new Composite(this, SWT.NULL);
+		tableComposite.setLayout(new FillLayout());
+		tableComposite.setLayoutData(new GridData(GridData.FILL_BOTH));
+		initTable(tableComposite);
+	}
+
+	public void applicationEvent(ApplicationEvent e) {
+		if(e.type == ApplicationEvent.PATHWAY_OPENED)
+				highlightResults(highlightButton.getSelection());
+	}
+}	

Property changes on: trunk/src/swt/org/pathvisio/search/SearchResultTable.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/debug/Sleak.java
===================================================================
--- trunk/src/swt/org/pathvisio/debug/Sleak.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/debug/Sleak.java	(revision 977)
@@ -0,0 +1,310 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+/*
+ * Copyright (c) 2000, 2002 IBM Corp.  All rights reserved.
+ * This file is made available under the terms of the Common Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/cpl-v10.html
+ */
+package org.pathvisio.debug;
+
+import java.io.ByteArrayOutputStream;
+import java.io.PrintStream;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.Cursor;
+import org.eclipse.swt.graphics.DeviceData;
+import org.eclipse.swt.graphics.Font;
+import org.eclipse.swt.graphics.FontData;
+import org.eclipse.swt.graphics.GC;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.graphics.Region;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Canvas;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.List;
+import org.eclipse.swt.widgets.Listener;
+import org.eclipse.swt.widgets.MessageBox;
+import org.eclipse.swt.widgets.Shell;
+import org.eclipse.swt.widgets.Text;
+
+/**
+   Debugging helper. Sleak can check if all SWT resources are properly disposed, to help
+   avoid resource leaks.
+*/
+public class Sleak
+{
+	Display display;
+	Shell shell;
+	List list;
+	Canvas canvas;
+	Button start, stop, check;
+	Text text;
+	Label label;
+	
+	Object [] oldObjects = new Object [0];
+	Error [] oldErrors = new Error [0];
+	Object [] objects = new Object [0];
+	Error [] errors = new Error [0];
+	
+public void open () {
+	display = Display.getCurrent ();
+	shell = new Shell (display);
+	shell.setText ("S-Leak");
+	list = new List (shell, SWT.BORDER | SWT.V_SCROLL);
+	list.addListener (SWT.Selection, new Listener () {
+		public void handleEvent (Event event) {
+			refreshObject ();
+		}
+	});
+	text = new Text (shell, SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
+	canvas = new Canvas (shell, SWT.BORDER);
+	canvas.addListener (SWT.Paint, new Listener () {
+		public void handleEvent (Event event) {
+			paintCanvas (event);
+		}
+	});
+	check = new Button (shell, SWT.CHECK);
+	check.setText ("Stack");
+	check.addListener (SWT.Selection, new Listener () {
+		public void handleEvent (Event e) {
+			toggleStackTrace ();
+		}
+	});
+	start = new Button (shell, SWT.PUSH);
+	start.setText ("Snap");
+	start.addListener (SWT.Selection, new Listener () {
+		public void handleEvent (Event event) {
+			refreshAll ();
+		}
+	});
+	stop = new Button (shell, SWT.PUSH);
+	stop.setText ("Diff");
+	stop.addListener (SWT.Selection, new Listener () {
+		public void handleEvent (Event event) {
+			refreshDifference ();
+		}
+	});
+	label = new Label (shell, SWT.BORDER);
+	label.setText ("0 object(s)");
+	shell.addListener (SWT.Resize, new Listener () {
+		public void handleEvent (Event e) {
+			layout ();
+		}
+	});
+	check.setSelection (false);
+	text.setVisible (false);
+	Point size = shell.getSize ();
+	shell.setSize (size.x / 2, size.y / 2);
+	shell.open ();
+}
+
+void refreshLabel () {
+	int colors = 0, cursors = 0, fonts = 0, gcs = 0, images = 0, regions = 0;
+	for (int i=0; i<objects.length; i++) {
+		Object object = objects [i];
+		if (object instanceof Color) colors++;
+		if (object instanceof Cursor) cursors++;
+		if (object instanceof Font) fonts++;
+		if (object instanceof GC) gcs++;
+		if (object instanceof Image) images++;
+		if (object instanceof Region) regions++;
+	}
+	String string = "";
+	if (colors != 0) string += colors + " Color(s)\n";
+	if (cursors != 0) string += cursors + " Cursor(s)\n";
+	if (fonts != 0) string += fonts + " Font(s)\n";
+	if (gcs != 0) string += gcs + " GC(s)\n";
+	if (images != 0) string += images + " Image(s)\n";
+	/* Currently regions are not counted. */
+//	if (regions != 0) string += regions + " Region(s)\n";
+	if (string.length () != 0) {
+		string = string.substring (0, string.length () - 1);
+	}
+	label.setText (string);
+}
+
+void refreshDifference () {
+	DeviceData info = display.getDeviceData ();
+	if (!info.tracking) {
+		MessageBox dialog = new MessageBox (shell, SWT.ICON_WARNING | SWT.OK);
+		dialog.setText (shell.getText ());
+		dialog.setMessage ("Warning: Device is not tracking resource allocation");
+		dialog.open ();
+	}
+	Object [] newObjects = info.objects;
+	Error [] newErrors = info.errors;
+	Object [] diffObjects = new Object [newObjects.length];
+	Error [] diffErrors = new Error [newErrors.length];
+	int count = 0;
+	for (int i=0; i<newObjects.length; i++) {
+		int index = 0;
+		while (index < oldObjects.length) {
+			if (newObjects [i] == oldObjects [index]) break;
+			index++;
+		}
+		if (index == oldObjects.length) {
+			diffObjects [count] = newObjects [i];
+			diffErrors [count] = newErrors [i];
+			count++;
+		}
+	}
+	objects = new Object [count];
+	errors = new Error [count];
+	System.arraycopy (diffObjects, 0, objects, 0, count);
+	System.arraycopy (diffErrors, 0, errors, 0, count);
+	list.removeAll ();
+	text.setText ("");
+	canvas.redraw ();
+	for (int i=0; i<objects.length; i++) {
+		list.add (objectName (objects [i]));
+	}
+	refreshLabel ();
+	layout ();
+}
+
+String objectName (Object object) {
+	String string = object.toString ();
+	int index = string.lastIndexOf ('.');
+	if (index == -1) return string;
+	return string.substring (index + 1, string.length ());
+}
+
+void toggleStackTrace () {
+	refreshObject ();
+	layout ();
+}
+
+void paintCanvas (Event event) {
+	canvas.setCursor (null);
+	int index = list.getSelectionIndex ();
+	if (index == -1) return;
+	GC gc = event.gc;
+	Object object = objects [index];
+	if (object instanceof Color) {
+		if (((Color)object).isDisposed ()) return;
+		gc.setBackground ((Color) object);
+		gc.fillRectangle (canvas.getClientArea());
+		return;
+	}
+	if (object instanceof Cursor) {
+		if (((Cursor)object).isDisposed ()) return;
+		canvas.setCursor ((Cursor) object);
+		return;
+	}
+	if (object instanceof Font) {
+		if (((Font)object).isDisposed ()) return;
+		gc.setFont ((Font) object);
+		FontData [] array = gc.getFont ().getFontData ();
+		String string = "";
+		String lf = text.getLineDelimiter ();
+		for (int i=0; i<array.length; i++) {
+			FontData data = array [i];
+			String style = "NORMAL";
+			int bits = data.getStyle ();
+			if (bits != 0) {
+				if ((bits & SWT.BOLD) != 0) style = "BOLD ";
+				if ((bits & SWT.ITALIC) != 0) style += "ITALIC";
+			}
+			string += data.getName () + " " + data.getHeight () + " " + style + lf;
+		}
+		gc.drawString (string, 0, 0);
+		return;
+	}
+	//NOTHING TO DRAW FOR GC
+//	if (object instanceof GC) {
+//		return;
+//	}
+	if (object instanceof Image) {
+		if (((Image)object).isDisposed ()) return;
+		gc.drawImage ((Image) object, 0, 0);
+		return;
+	}
+	if (object instanceof Region) {
+		if (((Region)object).isDisposed ()) return;
+		String string = ((Region)object).getBounds().toString();
+		gc.drawString (string, 0, 0);
+		return;
+	}
+}
+
+void refreshObject () {
+	int index = list.getSelectionIndex ();
+	if (index == -1) return;
+	if (check.getSelection ()) {
+		ByteArrayOutputStream stream = new ByteArrayOutputStream ();
+		PrintStream s = new PrintStream (stream);
+		errors [index].printStackTrace (s);
+		text.setText (stream.toString ());
+		text.setVisible (true);
+		canvas.setVisible (false);
+	} else {
+		canvas.setVisible (true);
+		text.setVisible (false);
+		canvas.redraw ();
+	}
+}
+
+void refreshAll () {
+	oldObjects = new Object [0];
+	oldErrors = new Error [0];
+	refreshDifference ();
+	oldObjects = objects;
+	oldErrors = errors;
+}
+
+void layout () {
+	Rectangle rect = shell.getClientArea ();
+	int width = 0;
+	String [] items = list.getItems ();
+	GC gc = new GC (list);
+	for (int i=0; i<objects.length; i++) {
+		width = Math.max (width, gc.stringExtent (items [i]).x);
+	}
+	gc.dispose ();
+	Point size1 = start.computeSize (SWT.DEFAULT, SWT.DEFAULT);
+	Point size2 = stop.computeSize (SWT.DEFAULT, SWT.DEFAULT);
+	Point size3 = check.computeSize (SWT.DEFAULT, SWT.DEFAULT);
+	Point size4 = label.computeSize (SWT.DEFAULT, SWT.DEFAULT);
+	width = Math.max (size1.x, Math.max (size2.x, Math.max (size3.x, width)));
+	width = Math.max (64, Math.max (size4.x, list.computeSize (width, SWT.DEFAULT).x));
+	start.setBounds (0, 0, width, size1.y);
+	stop.setBounds (0, size1.y, width, size2.y);
+	check.setBounds (0, size1.y + size2.y, width, size3.y);
+	label.setBounds (0, rect.height - size4.y, width, size4.y);
+	int height = size1.y + size2.y + size3.y;
+	list.setBounds (0, height, width, rect.height - height - size4.y);
+	text.setBounds (width, 0, rect.width - width, rect.height);
+	canvas.setBounds (width, 0, rect.width - width, rect.height);
+}
+
+public static void main (String [] args) {
+	Display display = new Display ();
+	Sleak sleak = new Sleak ();
+	sleak.open ();
+	while (!sleak.shell.isDisposed ()) {
+		if (!display.readAndDispatch ()) display.sleep ();
+	}
+	display.dispose ();
+}
+		
+}

Property changes on: trunk/src/swt/org/pathvisio/debug/Sleak.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/data/GpmlTransfer.java
===================================================================
--- trunk/src/swt/org/pathvisio/data/GpmlTransfer.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/data/GpmlTransfer.java	(revision 977)
@@ -0,0 +1,118 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.data;
+
+import java.util.List;
+
+import org.eclipse.swt.dnd.ByteArrayTransfer;
+import org.eclipse.swt.dnd.TransferData;
+import org.jdom.Document;
+import org.jdom.Element;
+import org.jdom.Namespace;
+import org.jdom.output.Format;
+import org.jdom.output.XMLOutputter;
+import org.pathvisio.Engine;
+import org.pathvisio.model.GpmlFormat;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.GpmlFormat;
+import org.pathvisio.gui.swt.SwtEngine;
+
+/**
+   Clipboard Transfer Object, for transferring Gpml fragments
+   between applications
+   TODO: unfinished
+ */
+public class GpmlTransfer extends ByteArrayTransfer 
+{
+	private static final String TYPENAME = "gpml";
+	private static final int TYPEID = registerType(TYPENAME);
+	private static GpmlTransfer _instance = new GpmlTransfer();
+	
+	private GpmlTransfer() {} // prevent instantiation because it is private
+	
+	public static GpmlTransfer getInstance()
+	{
+		return _instance;
+	}
+	
+	public void javaToNative (Object data, TransferData transferData)
+	{
+		
+		if (!(data instanceof List)) { return; } // wrong type of data
+		
+		byte[] result = null;
+		List<PathwayElement> clipboard = (List<PathwayElement>)(data);
+		Document doc = new Document();
+		Namespace ns = Namespace.getNamespace("http://www.w3.org/2000/svg");
+
+		for (PathwayElement o : clipboard)
+		{
+			try
+			{
+				Element e = GpmlFormat.createJdomElement(o, ns);
+				doc.addContent(e);
+			}
+			catch (Exception e)
+			{
+				Engine.log.error ("Converter exception", e);
+			}
+
+			XMLOutputter xmlcode = new XMLOutputter(Format.getPrettyFormat());
+			Format f = xmlcode.getFormat();
+			f.setEncoding("ISO-8859-1");
+			f.setTextMode(Format.TextMode.PRESERVE);
+			xmlcode.setFormat(f);
+			
+			//Open a filewriter
+			try
+			{
+				result = xmlcode.outputString(doc).getBytes();				
+			}
+			catch (Exception e)
+			{
+				Engine.log.error ("Error?!?!", e);
+			}
+		}
+		super.javaToNative(result, transferData);
+	}
+	
+	public Object nativeToJava (TransferData transferData)
+	{
+		 if (isSupportedType(transferData)) 
+		 {
+			 byte[] buffer = (byte[]) super.nativeToJava(transferData);
+			 if (buffer == null)
+				 return null;
+
+			 //TODO
+			 String x = "" + buffer;
+			 Object result = null;
+			 return result;
+		}
+		 
+		return null;
+	}
+	
+	protected int[] getTypeIds() {
+		return new int[]{TYPEID};
+	}
+
+	protected String[] getTypeNames() {
+		return new String[]{TYPENAME};
+	}
+
+}

Property changes on: trunk/src/swt/org/pathvisio/data/GpmlTransfer.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/util/tableviewer/TableData.java
===================================================================
--- trunk/src/swt/org/pathvisio/util/tableviewer/TableData.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/util/tableviewer/TableData.java	(revision 977)
@@ -0,0 +1,195 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.util.tableviewer;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+
+/**
+ * This class holds a collection of {@link Row}s sharing the same {@link Cell}s
+ */
+public class TableData {
+	private HashMap<String, Column> colHash;
+	private ArrayList<Column> cols;
+	private ArrayList<Row> rows;
+	
+	public TableData() {
+		colHash = new HashMap<String, Column>();
+		cols = new ArrayList<Column>();
+		rows = new ArrayList<Row>();
+	}
+		
+	public ArrayList<Row> getResults() { return rows; }
+	public ArrayList<String> getColNames() { 
+		return getColNames(false); 
+	}
+	
+	public ArrayList<String> getColNames(boolean showHidden) {
+		ArrayList<String> attrNames = new ArrayList<String>();
+		for(Column c : cols) {
+			if(!showHidden) { if(c.isVisible()) attrNames.add(c.getName()); }
+			else attrNames.add(c.getName());
+		}
+		return attrNames;
+	}
+	
+	public void addColumn(String name) {
+		addColumn(name, true);
+	}
+	public void addColumn(String name, boolean visible) {
+		Column c = new Column(name, visible);
+		cols.add(c);
+		colHash.put(name, c);	
+	}
+	
+	public Column colByName(String colName) {
+		return colHash.get(colName);
+	}
+	
+	private void addResult(Row rs) { rows.add(rs); }
+	
+	/**
+	 * This class contains a single result from a search
+	 */
+	public class Row {
+		private HashMap<Column, Cell> cells;
+		
+		public Row() { 
+			cells = new HashMap<Column, Cell>();
+			for(Column c : cols) {
+				cells.put(c,
+						new Cell(c, Cell.TYPE_TEXT));
+			}
+			addResult(this);
+		}
+		
+		public void setCell(String name, String value) {
+			Cell c = cells.get(colByName(name));
+			if(c != null) c.setText(value);
+		}
+		
+		public void setCell(String name, double value) {
+			Cell c = cells.get(colByName(name));
+			if(c != null) c.setNumeric(value);
+		}
+		
+		public void setCell(String name, ArrayList value) {
+			Cell c = cells.get(colByName(name));
+			if(c != null) c.setArray(value);
+		}
+				
+		public Cell getCell(String name) throws IllegalArgumentException {
+			Cell c = cells.get(colByName(name));
+			if(c != null) return c;
+			else 
+				throw new IllegalArgumentException("Attribute " + name + " does not exist");
+		}
+	}
+	
+	/**
+	 * This class represents a column
+	 */
+	public class Column {
+		String name;
+		boolean visible;
+		
+		public Column(String name, boolean visible) {
+			this.name = name;
+			this.visible = visible;
+		}
+		
+		public Column(String name) {
+			this(name, true);
+		}
+		
+		boolean isVisible() { return visible; }
+		String getName() { return name; }
+	}
+	
+	/**
+	 * This class represents a cell, which can either
+	 * have a numeric or text value
+	 */
+	public class Cell implements Comparable {
+		Column col;
+		
+		public static final int TYPE_TEXT = 0;
+		public static final int TYPE_ARRAYLIST = 1;
+		public static final int TYPE_NUM  = 2;
+				
+		private String textValue;
+		private double numValue;
+		private ArrayList arrayValue;
+		
+		private int type;
+		
+		public Cell(Column c, int t) {
+			col = c;
+			type = t; 
+			textValue = ""; 
+		}
+		
+		public Column getColumn() { return col; }
+		
+		public void setType(int type) { 
+			this.type = type;
+		}
+		
+		public String getText() { 
+			String text = "";
+			switch(type) {
+			case TYPE_TEXT: text = textValue; break;
+			case TYPE_NUM: text = Double.toString(numValue); break;
+			case TYPE_ARRAYLIST: text = arrayValue.toString();
+			}
+			return text;
+		}
+		
+		public double getNumeric() { return numValue; }
+		public ArrayList getArray() { return arrayValue; }
+		
+		public void setText(String value) {
+			setType(TYPE_TEXT);
+			textValue = value; 
+		}
+		public void setNumeric(double value) {
+			setType(TYPE_NUM);
+			numValue = value; 
+		}
+		public void setArray(ArrayList value) { 
+			setType(TYPE_ARRAYLIST);
+			arrayValue = value; 
+		}
+				
+		public int compareTo(Object o) {
+			Cell c = (Cell)o;
+						
+			if(type == c.type) {
+				switch(type) {
+				case TYPE_TEXT: return textValue.compareTo(c.textValue);
+				case TYPE_NUM:
+					//Make sure NaNs are lowest
+					if(Double.isNaN(numValue)) return -1;
+					if(Double.isNaN(c.numValue)) return 1;
+					return Double.compare(numValue, c.numValue);
+				case TYPE_ARRAYLIST: return arrayValue.size() - c.arrayValue.size();
+				default: return -1;
+				}
+			} else return type - c.type;
+		}
+	}
+}

Property changes on: trunk/src/swt/org/pathvisio/util/tableviewer/TableData.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/util/tableviewer/PathwayTable.java
===================================================================
--- trunk/src/swt/org/pathvisio/util/tableviewer/PathwayTable.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/util/tableviewer/PathwayTable.java	(revision 977)
@@ -0,0 +1,215 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.util.tableviewer;
+
+import java.io.File;
+import java.util.ArrayList;
+
+import org.eclipse.jface.viewers.ILabelProviderListener;
+import org.eclipse.jface.viewers.IStructuredContentProvider;
+import org.eclipse.jface.viewers.IStructuredSelection;
+import org.eclipse.jface.viewers.ITableLabelProvider;
+import org.eclipse.jface.viewers.TableViewer;
+import org.eclipse.jface.viewers.Viewer;
+import org.eclipse.jface.viewers.ViewerSorter;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.MouseAdapter;
+import org.eclipse.swt.events.MouseEvent;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.FileDialog;
+import org.eclipse.swt.widgets.Table;
+import org.eclipse.swt.widgets.TableColumn;
+import org.pathvisio.Engine;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.util.swt.TableColumnResizer;
+import org.pathvisio.util.swt.SwtUtils.FileInputDialog;
+import org.pathvisio.util.tableviewer.TableData.Row;
+
+
+/**
+ * This composite displays a table on which {@link TableData} can be
+ * displayed and opened
+ */
+public class PathwayTable extends Composite {
+	public static final String COLNAME_FILE = "fileName";
+	
+	protected TableViewer tableViewer;
+	private TableColumnResizer columnResizer;
+	private Display display;
+	
+	public PathwayTable(Composite parent, int style) {
+		super(parent, SWT.NULL);
+		display = getShell().getDisplay();
+
+		createContents();
+	}
+	
+	public void setTableData(final TableData srs) {
+		display.asyncExec(new Runnable() { 
+			//asyncExec, because can be accessed from seperate thread
+			public void run() {
+				//Recreate the table's columns to display the TableData columns
+				Table t = tableViewer.getTable();
+				for(TableColumn tc : t.getColumns()) tc.dispose();
+				
+				ArrayList<String> attrNames = srs.getColNames();
+				String[] colProps = new String[attrNames.size()];
+				for(int i = 0; i < attrNames.size(); i++) {
+					final TableColumn tc = new TableColumn(t, SWT.NULL);
+					tc.setText(attrNames.get(i));
+					tc.setWidth(20);
+					colProps[i] = attrNames.get(i);
+					tc.addSelectionListener(new SelectionAdapter() {
+						public void widgetSelected(SelectionEvent e) {
+							Table t = tableViewer.getTable();
+							if(tableViewer.getTable().getSortColumn() == tc)
+								t.setSortDirection(t.getSortDirection() == SWT.DOWN ? SWT.UP : SWT.DOWN);
+							else {
+								tableViewer.getTable().setSortColumn(tc);
+								if(t.getSortDirection() == SWT.NONE) t.setSortDirection(SWT.DOWN);
+							}
+							tableViewer.setSorter(new PathwaySorter(tc.getText()));
+						}
+					});
+				}
+				tableViewer.setColumnProperties(colProps);
+				tableViewer.setInput(srs);
+				columnResizer.doResize();
+			}
+		});
+
+	}
+	
+	public void refreshTableViewer(final boolean updateLabels) {
+		display.asyncExec(new Runnable() { 
+			//asyncExec, because can be accessed from seperate thread
+			public void run() {
+				tableViewer.refresh(updateLabels);
+			}
+		});
+	}
+	
+	public int getNrRows() { return tableViewer.getTable().getItemCount(); }
+	
+	public TableViewer getTableViewer() { return tableViewer; }
+		
+	protected void createContents() {
+		setLayout(new FillLayout());
+		initTable(this);
+	}
+	
+	protected void initTable(Composite parent) {
+		Table t = new Table(parent, SWT.SINGLE | SWT.FULL_SELECTION);
+		columnResizer = new TableColumnResizer(t, parent);
+		t.addControlListener(columnResizer);
+		t.addMouseListener(tableMouseListener);
+		t.setHeaderVisible(true);
+		tableViewer = new TableViewer(t); 
+		tableViewer.setContentProvider(tableContentProvider);
+		tableViewer.setLabelProvider(tableLabelProvider);
+	}
+	
+	private MouseAdapter tableMouseListener = new MouseAdapter() {
+		public void mouseDoubleClick(MouseEvent e) {
+			Row sr = (Row)
+			((IStructuredSelection)tableViewer.getSelection()).getFirstElement();
+			if(sr == null) return;
+			try {
+				String pw = sr.getCell(COLNAME_FILE).getText();
+				File pwFile = new File(pw);
+				if(!pwFile.canRead()) {
+					FileDialog fd = new FileDialog(getShell(), SWT.OPEN);
+					fd.setFilterPath(SwtPreference.SWT_DIR_PWFILES.getValue());
+					FileInputDialog fid = new FileInputDialog(getShell(), "Specify pathway file", 
+							"Couldn't find pathway file, please specify which pathway to open",
+							pwFile.getAbsolutePath(), null, fd);
+					if(fid.open() == FileInputDialog.OK) {
+						pw = fid.getValue();
+					}
+				}
+				SwtEngine.openPathway(pw);
+			} catch(Exception ex) { 
+				Engine.log.error("when trying to open pathway from pathway table", ex);
+			}
+		}
+	};
+	
+	private IStructuredContentProvider tableContentProvider = new IStructuredContentProvider() {
+
+		public Object[] getElements(Object inputElement) {			
+			if(inputElement instanceof TableData) {
+				TableData srs = (TableData)inputElement;
+				return srs.getResults().toArray();
+			}
+			return new Object[] {};
+		}
+
+		public void dispose() {	}
+		public void inputChanged(Viewer viewer, Object oldInput, Object newInput) { }
+		
+	};
+	
+	private ITableLabelProvider tableLabelProvider = new ITableLabelProvider() {
+
+		public Image getColumnImage(Object element, int columnIndex) { return null;	}
+
+		public String getColumnText(Object element, int columnIndex) {
+			TableData.Row sr = (TableData.Row)element;
+			String name = (String)tableViewer.getColumnProperties()[columnIndex];
+			
+			try { return sr.getCell(name).getText(); } catch (Exception e) { return "error"; }
+		}
+
+		public void addListener(ILabelProviderListener listener) {	}
+		public void dispose() {	}
+		public boolean isLabelProperty(Object arg0, String arg1) { return false; }
+		public void removeListener(ILabelProviderListener arg0) { }
+		
+	};
+	
+	private class PathwaySorter extends ViewerSorter {
+		String property;
+		int propertyIndex;
+		
+		public PathwaySorter(String sortByProperty) {
+			property = sortByProperty;
+		}
+		
+		public int compare(Viewer viewer, Object e1, Object e2) {
+			int sortDirection = SWT.DOWN;
+			if(viewer instanceof TableViewer)
+				sortDirection = ((TableViewer)viewer).getTable().getSortDirection();
+			
+			Row r1, r2;
+			if(sortDirection == SWT.UP) {
+				r1 = (Row)e1;
+				r2 = (Row)e2;
+			} else {
+				r1 = (Row)e2;
+				r2 = (Row)e1;
+			}
+
+			return r1.getCell(property).compareTo(r2.getCell(property));
+		}
+	}
+}	

Property changes on: trunk/src/swt/org/pathvisio/util/tableviewer/PathwayTable.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/util/swt/SuggestCombo.java
===================================================================
--- trunk/src/swt/org/pathvisio/util/swt/SuggestCombo.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/util/swt/SuggestCombo.java	(revision 977)
@@ -0,0 +1,357 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.util.swt;
+
+import java.util.ArrayList;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.DisposeEvent;
+import org.eclipse.swt.events.DisposeListener;
+import org.eclipse.swt.events.ShellAdapter;
+import org.eclipse.swt.events.ShellEvent;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.List;
+import org.eclipse.swt.widgets.Listener;
+import org.eclipse.swt.widgets.Shell;
+import org.eclipse.swt.widgets.Text;
+import org.pathvisio.util.swt.SuggestCombo.SuggestionProvider.SuggestThread;
+
+public class SuggestCombo extends Composite {
+	protected boolean ignoreModify;
+	protected boolean ignoreFocusOut;
+
+	private SuggestThread currThread;
+	
+	private java.util.List<SuggestionListener> listeners;
+	private SuggestionProvider suggestionProvider;
+	
+	private int maxHeight = 100;
+	
+	private Text text;
+	private Shell suggestShell;
+	private List suggestList;
+	
+	public SuggestCombo(Composite parent, SuggestionProvider s) {
+		super(parent, SWT.NONE);
+		listeners = new ArrayList<SuggestionListener>();
+		suggestionProvider = s;
+		init(parent);
+	}
+	
+	public Control getControl() { 
+		return text;
+	}
+	
+	public SuggestionProvider getSuggestionProvider() { 
+		return suggestionProvider; 
+	}
+	
+	public boolean isFocusControl() {		
+		return 	text.isVisible() && text.isFocusControl() ||
+				isSuggestFocus();
+	}
+	
+	public boolean isSuggestFocus() {
+		return 	suggestShell.isVisible() && suggestShell.isFocusControl() ||
+				suggestList.isVisible() && suggestList.isFocusControl();
+	}
+	
+	public String getText() {
+		return text.getText();
+	}
+	
+	public void setText(String s) {
+		text.setText(s);
+	}
+	
+	public void setMaxHeight(int height) {
+		maxHeight = height;
+	}
+	
+	public int getMaxHeight() { return maxHeight; }
+	
+	void init(Composite parent) {
+		setLayout(new FillLayout());
+		
+		text = new Text(this, SWT.NONE);
+		Listener textListener = new Listener() {
+			public void handleEvent(Event e) {
+				switch(e.type) {
+				case SWT.Modify:
+					if(!ignoreModify) {
+						startSuggesting();
+						currThread.setText(text.getText());
+					} else {
+//						hideSuggestions();
+						ignoreModify = false;
+					}
+					break;
+				case SWT.KeyDown:
+					if(e.keyCode == SWT.ARROW_DOWN) {
+						if(suggestShell.isVisible()) {
+							suggestList.select(0);
+							suggestList.setFocus();
+						}
+					}
+					break;
+				case SWT.FocusOut:
+					if(!ignoreFocusOut) {
+						//Check if focus is on suggestShell/suggestList
+						if(!isSuggestFocus()) stopSuggesting();
+					}
+					break;
+				}
+			}
+		};
+		
+		text.addListener(SWT.Modify, textListener);
+		text.addListener(SWT.KeyDown, textListener);
+		text.addListener(SWT.FocusOut, textListener);
+
+		suggestShell = new Shell(getShell(), SWT.TOOL | SWT.ON_TOP);
+		suggestShell.setLayout(new FillLayout());
+		suggestList = new List(suggestShell, SWT.SINGLE | SWT.V_SCROLL | SWT.H_SCROLL);
+		
+		Listener listListener = new Listener() {
+			public void handleEvent(Event e) {
+				switch(e.type) {
+				case SWT.KeyDown:
+					if(e.keyCode != 13) break; //TODO:find proper SWT constant for return key
+				case SWT.DefaultSelection:
+				case SWT.MouseDown:
+					String[] selection = suggestList.getSelection();
+					if(selection.length > 0) 
+						suggestionSelected(suggestList.getSelection()[0]);
+					break;
+				case SWT.FocusOut:
+					if(!ignoreFocusOut) {
+						stopSuggesting();
+					}
+				}
+			}
+		};
+		suggestList.addListener(SWT.KeyDown, listListener);
+		suggestList.addListener(SWT.DefaultSelection, listListener);
+		suggestList.addListener(SWT.MouseDown, listListener);
+		suggestList.addListener(SWT.FocusOut, listListener);
+		
+		getShell().addShellListener(new ShellAdapter() {
+			public void shellDeactivated(ShellEvent e) {
+				stopSuggesting();
+			}
+		});
+		suggestShell.addShellListener(new ShellAdapter() {
+			public void shellActivated(ShellEvent arg0) {
+				showSuggestions();
+			}
+		});
+		// DisposeListener, in case user closes PathVisio while suggestShell is still active
+		suggestShell.addDisposeListener(new DisposeListener() {
+			public void widgetDisposed(DisposeEvent e) {
+				stopSuggesting();
+			}
+		});
+	}
+	
+	public void setVisible(boolean visible) {
+		stopSuggesting();
+		super.setVisible(visible);
+	}
+	
+	public void dispose() {
+		super.dispose();
+		suggestShell.dispose();
+	}
+	
+	void startSuggesting() {		
+		if(!suggestShell.isVisible()) {
+			initSuggestShell();
+		}
+		if(!isSuggesting()) {
+			currThread = new SuggestThread(text.getText(), this);
+			currThread.start();
+		}
+	}
+	
+	void stopSuggesting() {
+		doHideSuggestions();
+		if(currThread != null) {
+			currThread.interrupt();
+		}
+		currThread = null;
+	}
+	
+	boolean isSuggesting() {
+		return currThread != null && currThread.getState() != Thread.State.TERMINATED;
+	}
+	
+	public void addSuggestion(final String suggestion) {
+		getDisplay().asyncExec(new Runnable() {
+			public void run() {
+				doAddSuggestion(suggestion);
+			}
+		});
+}
+	
+	void doAddSuggestion(String suggestion) {
+			suggestList.add(suggestion);
+			showSuggestions();
+			resizeSuggestShell();
+	}
+	
+
+	
+	void initSuggestShell() {
+		Point location = text.getLocation();
+		location.y += text.getSize().y;
+		suggestShell.setLocation(text.toDisplay(location));
+		resizeSuggestShell();
+	}
+	
+	void resizeSuggestShell() {
+		Point listSize = suggestList.computeSize(SWT.DEFAULT, SWT.DEFAULT);
+		suggestShell.setSize(listSize.x, listSize.y < maxHeight ? listSize.y : maxHeight);
+	}
+	
+	public void setSuggestions(final String[] suggestions) {
+		getDisplay().asyncExec(new Runnable() {
+			public void run() {
+				doSetSuggestions(suggestions);
+			}
+		});
+	}
+	
+	void doSetSuggestions(String[] suggestions) {
+		suggestList.setItems(suggestions);
+		resizeSuggestShell();
+		showSuggestions();
+	}
+	
+	public void hideSuggestions() {
+		getDisplay().asyncExec(new Runnable() {
+			public void run() {
+				doHideSuggestions();
+			}
+		});
+	}
+	
+	void doHideSuggestions() {
+		if(!suggestShell.isDisposed()) 
+			suggestShell.setVisible(false);
+	}
+	
+	void showSuggestions() {
+		boolean restoreFocus = text.isFocusControl();
+		if(isFocusControl() && suggestList.getItemCount() > 0) {
+			suggestShell.setVisible(true);
+			
+			if(restoreFocus) {
+				ignoreFocusOut = true;
+				text.setFocus();
+				ignoreFocusOut = false;
+			}
+			
+		} else {
+			doHideSuggestions();
+		}
+	}
+	
+	void suggestionSelected(String suggestion) {
+		ignoreModify = true;
+		text.setText(suggestion);
+		doHideSuggestions();
+		for(SuggestionListener l : listeners) {
+			ignoreModify = true;
+			l.suggestionSelected(suggestion);
+		}
+	}
+	
+	public void addSuggetsionListener(SuggestionListener l) {
+		listeners.add(l);
+	}
+	
+	public interface SuggestionProvider {		
+		public String[] getSuggestions(String text, SuggestCombo suggestCombo);
+		
+		public class SuggestThread extends Thread {
+			protected SuggestCombo suggestCombo;
+			volatile protected String text;
+			volatile protected boolean textChange;
+			
+			private Thread doSuggestThread;
+			
+			public SuggestCombo getSuggestCombo() { return suggestCombo; }
+			public String getText() { return text; }
+			
+			public void setText(String newText) { 
+				text = newText;
+				textChange = true;
+			}
+			
+			public SuggestThread(String _text, SuggestCombo _suggestCombo) {
+				text = _text;
+				suggestCombo = _suggestCombo;
+			}
+			
+			public void start() {
+				if(suggestCombo == null || suggestCombo.isDisposed()) return;
+				super.start();
+			}
+
+			void setSuggestions(String[] suggestions) {
+				if(Thread.currentThread() == doSuggestThread) {
+					suggestCombo.setSuggestions(suggestions);
+				}
+			}
+			
+			public void run() {
+				while(!isInterrupted()) {
+					if(textChange) {
+						if(doSuggestThread != null) doSuggestThread.interrupt();
+						suggestCombo.hideSuggestions();
+						if(!text.equals("")) {
+							doSuggestThread = new Thread() {
+								public void run() {
+									SuggestionProvider sp = suggestCombo.getSuggestionProvider();
+									setSuggestions(sp.getSuggestions(text, suggestCombo));
+								}
+							};
+							doSuggestThread.start();
+						} else {
+							suggestCombo.hideSuggestions();
+						}
+						textChange = false;
+					} else {						
+						try {
+							Thread.sleep(300); //Wait for a while, in case user continues typing
+						} catch (InterruptedException e) {
+							return;
+						}
+					}
+				}
+			}
+		}
+	}
+		
+	public interface SuggestionListener {
+		public void suggestionSelected(String suggestion);
+	}
+}
Index: trunk/src/swt/org/pathvisio/util/swt/SuggestCellEditor.java
===================================================================
--- trunk/src/swt/org/pathvisio/util/swt/SuggestCellEditor.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/util/swt/SuggestCellEditor.java	(revision 977)
@@ -0,0 +1,78 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.util.swt;
+
+import org.eclipse.jface.viewers.CellEditor;
+import org.eclipse.swt.events.FocusAdapter;
+import org.eclipse.swt.events.FocusEvent;
+import org.eclipse.swt.events.KeyAdapter;
+import org.eclipse.swt.events.KeyEvent;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.pathvisio.util.swt.SuggestCombo.SuggestionProvider;
+
+public abstract class SuggestCellEditor extends CellEditor {
+	protected SuggestCombo suggestCombo;
+	
+	public SuggestCellEditor() {
+		super();
+	}
+	
+	public SuggestCellEditor(Composite parent) {
+		super(parent);
+	}
+		
+	protected Control createControl(Composite parent) {
+		suggestCombo = new SuggestCombo(parent, getSuggestionProvider());
+
+		setKeyListeners();
+		setFocusListeners();
+
+		return suggestCombo;
+	}
+
+	protected void setKeyListeners() {
+		suggestCombo.getControl().addKeyListener(new KeyAdapter() {
+            public void keyPressed(KeyEvent e) {
+                keyReleaseOccured(e);
+            }
+		});
+	}
+	
+	protected void setFocusListeners() {
+        suggestCombo.getControl().addFocusListener(new FocusAdapter() {
+            public void focusLost(FocusEvent e) {
+            	if(!suggestCombo.isSuggestFocus()) {
+            		SuggestCellEditor.this.focusLost();
+            	}
+            }
+        });
+	}
+	public abstract SuggestionProvider getSuggestionProvider();
+		
+	protected Object doGetValue() {
+		return suggestCombo.getText();
+	}
+	
+	protected void doSetValue(Object value) {
+		suggestCombo.setText(value == null ? "" : value.toString());
+	}
+
+	protected void doSetFocus() {}
+
+
+}
Index: trunk/src/swt/org/pathvisio/util/swt/TableColumnResizer.java
===================================================================
--- trunk/src/swt/org/pathvisio/util/swt/TableColumnResizer.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/util/swt/TableColumnResizer.java	(revision 977)
@@ -0,0 +1,129 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.util.swt;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.ControlAdapter;
+import org.eclipse.swt.events.ControlEvent;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Table;
+import org.eclipse.swt.widgets.TableColumn;
+
+/**
+ * This class is responsible for resizing a table's column width to fit its parents width
+ * Columns that are unresizable ({@link TableColumn#getResizable()} = false) are skipped
+ * NOTE: Be sure the table's parent {@link Composite} contains only the table (no
+ * other controls) and uses {@link FillLayout}.
+ */
+public class TableColumnResizer extends ControlAdapter {
+	Table table;
+	Composite parent;
+	TableColumn[] cols;
+	double[] weights;
+	int[] widths;
+	
+	/**
+	 * Constructor for this class
+	 * @param table		The tables of which the columns have to be resized
+	 * @param parent	The parent composite to fill the column width
+	 * @param weights	The relative size of each column (when a column is unresizable, set this to 0)
+	 */
+	public TableColumnResizer(Table table, Composite parent, int[] weights) {
+		this.table = table;
+		this.parent = parent == null ? table.getParent() : parent;
+		cols = table.getColumns();
+		setWeights(weights);
+		initWidths();
+	}
+	
+	void initWidths() {
+		widths = new int[cols.length];
+		for(int i = 0; i < cols.length; i++)
+			widths[i] = cols[i].getWidth();
+	}
+	
+	public void setWeights(int[] intWeights) {
+		if(intWeights == null) {
+			weights = new double[cols.length];
+			int resizable = 0;
+			for(TableColumn c : cols) resizable += c.getResizable() ? 1 : 0;
+			for(int i = 0; i < weights.length; i++) weights[i] = 1.0 / resizable;
+		} else {
+			int sum = 0;
+			for(int i : intWeights) sum += i;
+			weights = new double[intWeights.length];
+			for(int i = 0; i < intWeights.length; i++) weights[i] = (double)intWeights[i] / sum;
+		}
+	}
+	public TableColumnResizer(Table table, Composite parent) {
+		this(table, parent, null);
+	}
+	
+	public void controlResized(ControlEvent e) {
+		doResize();
+	}
+	
+	public void doResize() {
+		//Check if number of columns is the same
+		if(table.getColumns().length != cols.length) {
+			cols = table.getColumns();
+			setWeights(null);
+		}
+		cols = table.getColumns();
+		
+		Rectangle area = parent.getClientArea();
+		Point preferredSize = table.computeSize(SWT.DEFAULT, SWT.DEFAULT);
+		int width = area.width - 2 * table.getBorderWidth();
+		if (preferredSize.y > area.height + table.getHeaderHeight()) {
+			// Subtract the scrollbar width from the total column width
+			// if a vertical scrollbar will be required
+			Point vBarSize = table.getVerticalBar().getSize();
+			width -= vBarSize.x * 2;
+		}
+		
+		//Subtract width of columns with fixed size from available width
+		for(int i = 0; i < cols.length; i++) width -= cols[i].getResizable() ? 0 : widths[i];
+		
+		Point oldSize = table.getSize();
+		if (oldSize.x > area.width) {
+			// table is getting smaller so make the columns
+			// smaller first and then resize the table to
+			// match the client area width
+			for (int i = 0; i < cols.length; i++) {
+				if(cols[i].getResizable()) {
+					cols[i].setWidth((int)(width * weights[i]));
+				}
+			}
+			
+			table.setSize(area.width, area.height);
+		} else {
+			// table is getting bigger so make the table
+			// bigger first and then make the columns wider
+			// to match the client area width
+			table.setSize(area.width, area.height);
+			
+			for (int i = 0; i < cols.length; i++) {
+				if(cols[i].getResizable())	{
+					cols[i].setWidth((int)(width * weights[i]));
+				}
+			}
+		}
+	}
+}
Index: trunk/src/swt/org/pathvisio/util/swt/SwtUtils.java
===================================================================
--- trunk/src/swt/org/pathvisio/util/swt/SwtUtils.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/util/swt/SwtUtils.java	(revision 977)
@@ -0,0 +1,537 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.util.swt;
+
+import java.awt.image.BufferedImage;
+import java.awt.image.DirectColorModel;
+import java.awt.image.IndexColorModel;
+import java.awt.image.WritableRaster;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.jface.dialogs.IInputValidator;
+import org.eclipse.jface.dialogs.InputDialog;
+import org.eclipse.jface.dialogs.MessageDialog;
+import org.eclipse.jface.operation.IRunnableWithProgress;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.Font;
+import org.eclipse.swt.graphics.FontData;
+import org.eclipse.swt.graphics.GC;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.graphics.ImageData;
+import org.eclipse.swt.graphics.PaletteData;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.RGB;
+import org.eclipse.swt.graphics.Transform;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.FileDialog;
+import org.eclipse.swt.widgets.Shell;
+import org.pathvisio.Engine;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.model.Pathway;
+import org.pathvisio.view.VPathway;
+
+public class SwtUtils {
+
+	public static GridData getColorLabelGrid() {
+		GridData colorLabelGrid = new GridData(GridData.HORIZONTAL_ALIGN_BEGINNING);
+		colorLabelGrid.widthHint = colorLabelGrid.heightHint = 15;
+		return colorLabelGrid;
+	}
+	
+	/**
+	 * Change the given {@link Color}; this method disposes the old color for you
+	 * @param cOld	the old {@link Color}
+	 * @param rgbNew	the {@link RGB} to construct the new color
+	 * @param display	the display to assign the color to
+	 * @return	a brand new {@link Color}
+	 */
+	public static Color changeColor(Color cOld, RGB rgbNew, Display display)
+	{
+		if(cOld != null && !cOld.isDisposed())
+		{
+			cOld.dispose();
+			cOld = null;
+		}
+		if(rgbNew == null) rgbNew = new RGB(0,0,0);
+		return new Color(display, rgbNew);
+	}
+	
+	public static RGB color2rgb(java.awt.Color c) {
+		return new RGB(c.getRed(), c.getGreen(), c.getBlue());
+	}
+	
+	public static java.awt.Color rgb2color(RGB rgb) {
+		return new java.awt.Color(rgb.red, rgb.green, rgb.blue);
+	}
+	
+	/**
+	 * Change the given {@link Color}; this method disposes the old color for you
+	 * @param cOld	the old {@link Color}
+	 * @param rgbNew	the {@link Pathway.Color} to construct the new color
+	 * @param display	the display to assign the color to
+	 * @return	a brand new {@link Color}
+	 */
+	public static Color changeColor(Color cOld, java.awt.Color rgbNew, Display display)
+	{
+		if(cOld != null && !cOld.isDisposed())
+		{
+			cOld.dispose();
+			cOld = null;
+		}
+		if(rgbNew == null) rgbNew = new java.awt.Color(0,0,0);
+		return new Color(display, color2rgb(rgbNew));
+	}
+	
+	/**
+	 * Change the given {@link Font}; this method disposes the old font for you
+	 * @param fOld	the old {@link Font}
+	 * @param fd	the {@link FontData} to construct the font with
+	 * @param display	the display to assign the font to
+	 * @return	a brand new {@link Font}
+	 */
+	public static Font changeFont(Font fOld, FontData fd, Display display)
+	{
+		if(fOld != null && !fOld.isDisposed())
+		{
+			fOld.dispose();
+		}
+		return fd != null ? new Font(display, fd) : null;
+	}
+	
+	public static Image changeImage(Image iOld, ImageData iNew, Display display)
+	{
+		if(iOld != null && !iOld.isDisposed())
+		{
+			iOld.dispose();
+		}
+		return iNew != null ? new Image(display, iNew) : null;
+	}
+	
+	  public static ImageData convertImageToSWT(BufferedImage bufferedImage) {
+		    if (bufferedImage.getColorModel() instanceof DirectColorModel) {
+		      DirectColorModel colorModel = (DirectColorModel) bufferedImage
+		          .getColorModel();
+		      PaletteData palette = new PaletteData(colorModel.getRedMask(),
+		          colorModel.getGreenMask(), colorModel.getBlueMask());
+		      ImageData data = new ImageData(bufferedImage.getWidth(),
+		          bufferedImage.getHeight(), colorModel.getPixelSize(),
+		          palette);
+		      WritableRaster raster = bufferedImage.getRaster();
+		      int[] pixelArray = new int[4];
+		      for (int y = 0; y < data.height; y++) {
+		        for (int x = 0; x < data.width; x++) {
+		          raster.getPixel(x, y, pixelArray);
+		          int pixel = palette.getPixel(new RGB(pixelArray[0],
+		              pixelArray[1], pixelArray[2]));
+		          data.setPixel(x, y, pixel);
+		        }
+		      }
+		      return data;
+		    } else if (bufferedImage.getColorModel() instanceof IndexColorModel) {
+		      IndexColorModel colorModel = (IndexColorModel) bufferedImage
+		          .getColorModel();
+		      int size = colorModel.getMapSize();
+		      byte[] reds = new byte[size];
+		      byte[] greens = new byte[size];
+		      byte[] blues = new byte[size];
+		      colorModel.getReds(reds);
+		      colorModel.getGreens(greens);
+		      colorModel.getBlues(blues);
+		      RGB[] rgbs = new RGB[size];
+		      for (int i = 0; i < rgbs.length; i++) {
+		        rgbs[i] = new RGB(reds[i] & 0xFF, greens[i] & 0xFF,
+		            blues[i] & 0xFF);
+		      }
+		      PaletteData palette = new PaletteData(rgbs);
+		      ImageData data = new ImageData(bufferedImage.getWidth(),
+		          bufferedImage.getHeight(), colorModel.getPixelSize(),
+		          palette);
+		      data.transparentPixel = colorModel.getTransparentPixel();
+		      WritableRaster raster = bufferedImage.getRaster();
+		      int[] pixelArray = new int[1];
+		      for (int y = 0; y < data.height; y++) {
+		        for (int x = 0; x < data.width; x++) {
+		          raster.getPixel(x, y, pixelArray);
+		          data.setPixel(x, y, pixelArray[0]);
+		        }
+		      }
+		      return data;
+		    }
+		    return null;
+		  }
+	  
+	public static void setCompositeAndChildrenEnabled(Composite comp, boolean enable) {
+		comp.setEnabled(enable);
+		for(Control c : comp.getChildren()) {
+			c.setEnabled(enable);
+			if(c instanceof Composite)
+				setCompositeAndChildrenEnabled((Composite) c, enable);
+		}
+	}
+	
+	public static void setCompositeAndChildrenBackground(Composite comp, Color color) {
+		comp.setBackground(color);
+		for(Control c : comp.getChildren()) {
+			c.setBackground(color);
+			if(c instanceof Composite)
+				setCompositeAndChildrenBackground((Composite) c, color);
+		}
+	}
+	
+	static int[] incrs;
+	static int ii;
+	static int pixratio;
+	public static Font adjustFontSize(Font f, Point toFit, String text, GC gc, Display display) {
+		VPathway d = Engine.getActiveVPathway();
+		pixratio = (int)Math.ceil(3 * (d == null ? 1 : d.getZoomFactor()));
+		ii = 3;
+		incrs = new int[3];
+//		System.err.println(">>>>>>>>>>>> Starting adjust <<<<<<<<<<<<,");
+//		System.err.println("INITIAL: "+ f.getFontData()[0].getHeight());
+		f = setFontSize(f.getFontData()[0].getHeight(), f, gc, display);
+		return findFontSize(f, toFit, text, gc, display);		
+	}
+	
+	static int getIncrement(Point toFit, String text, GC gc) {	
+		int borderX = 3;
+		int borderY = 0;
+		
+		Point size = gc.textExtent(text);
+		
+		int dx = size.x - toFit.x + borderX;
+		int dy = size.y - toFit.y + borderY;
+		if(dx == 0 && dy == 0) return 0; //rare case
+		return add(pix2point(-Math.max(dx, dy)));
+	}
+	
+	static Font findFontSize(Font f, Point toFit, String text, GC gc, Display display) {
+		int incr = getIncrement(toFit, text, gc);
+//		System.err.println("incr: " + incr);
+		if(incr != 0 && checkIncrs()) {
+			int size = f.getFontData()[0].getHeight() + incr;
+//			System.err.println("Size: " + size);
+			if(size < 0) {
+				pixratio++;
+//				System.err.println("Increasing pixratio: " + pixratio);
+			} else {
+				f = setFontSize(size, f, gc,display);
+			}
+			f = findFontSize(f, toFit, text, gc, display);
+		}
+		return f;
+	}
+	
+	static boolean checkIncrs() {
+		//System.err.println(incrs[0] + " : " + incrs[1] + " : " + incrs[2]);
+		return !(incrs[0] == incrs[2]);
+	}
+	
+	static int add(int incr) {
+		incrs[0] = incrs[1];
+		incrs[1] = incrs[2];
+		incrs[2] = incr;
+		return incr;
+	}
+	
+	static int pix2point(int pix) { 
+		//System.err.println("pix: " + pix);
+		//System.err.println("point: " + (double)pix/pixratio);
+		return pix / pixratio; 
+	}
+	
+	public static FontData awtFont2FontData(java.awt.Font f) {
+		int style = SWT.NORMAL;
+		if(f.isBold()) style |= SWT.BOLD;
+		if(f.isItalic()) style |= SWT.ITALIC;
+		return new FontData(f.getName(), f.getSize(), style);
+	}
+	
+	public static java.awt.Font fontData2awtFont(FontData fd) {
+		int style = java.awt.Font.PLAIN;
+		if((fd.style & SWT.BOLD) != 0) style |= java.awt.Font.BOLD;
+		if((fd.style & SWT.ITALIC) != 0) style |= java.awt.Font.ITALIC;
+		return new java.awt.Font(fd.getName(), fd.getHeight(), style);		
+	}
+	
+	static Font setFontSize(int size, Font f, GC gc, Display display) {
+		FontData fd = f.getFontData()[0];
+		fd.setHeight(size);
+		f = changeFont(f, fd, display);
+		gc.setFont(f);
+		return f;
+	}
+	
+	public static int getAverageCharWidth(Display d) {
+		GC gc = new GC(d);
+		int w = gc.getFontMetrics().getAverageCharWidth();
+		gc.dispose();
+		return w;
+	}
+	
+	/**
+	 * Rotates the {@link GC} around the objects center
+	 * @param gc	the {@link GC} to rotate
+	 * @param tr	a {@link Transform} that can be used for rotation
+	 * @param rotation The rotation in degrees
+	 * @param x The x-coordinate of the rotation center
+	 * @param y The y-coordinate of the rotation center
+	 */
+	public static void rotateGC(GC gc, Transform tr, float rotation, int x, int y) {
+		tr.translate(x, y);
+		tr.rotate(rotation);	
+		tr.translate(-x, -y);
+		gc.setTransform(tr);
+	}
+	
+	public static class FileInputDialog extends InputDialog {
+		FileDialog fd;
+		public FileInputDialog(Shell parentShell, String dialogTitle, 
+				String dialogMessage, String initialValue, 
+				IInputValidator validator, FileDialog fileDialog) {
+			super(parentShell, dialogTitle, dialogMessage, initialValue, validator); 
+			fd = fileDialog;
+		}
+
+		protected Control createDialogArea(Composite parent) {
+			Composite composite = (Composite) super.createDialogArea(parent);
+			Button browse = new Button(parent, SWT.PUSH);
+			browse.setText("Browse");
+			browse.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					String fn = fd.open();
+					if(fn != null) getText().setText(fn);
+				}
+			});
+			return composite;
+		}
+	}
+	
+	/**
+	 * This class is a re-usable implementation of {@link IRunnableWithProgress} and can invoke
+	 * any given {@link Method} that needs to be runned in a seperate thread using a progress monitor
+	 * @author thomas
+	 *
+	 */
+	public static class SimpleRunnableWithProgress implements IRunnableWithProgress {
+		Method doMethod; 					//The method to perform
+		private Object[] args;				//The arguments to pass to the method
+		Object instance;					//The instance of the class that contains the method to be run
+		boolean runAsSyncExec;
+		
+		volatile static IProgressMonitor monitor;	//The progress monitor
+		
+		static final String INIT_TASKNAME = "";
+		static final int INIT_TOTALWORK = 1000;
+		static String taskName = INIT_TASKNAME;		//Taskname to display in the progress monitor
+		static int totalWork = INIT_TOTALWORK;		//Total work to be performed
+				
+		/**
+		 * Constructor for this class<BR>
+		 * Sets the signature of the method to be called and its argument values
+		 * @param fromClass the Class to which the method belongs that
+		 * has to be called. you can get this with instance.getClass()
+		 * or StaticClass.class
+		 * @param method	the method to be called
+		 * @param parameters	the classes of the method's arguments
+		 * @param args	the argument values to pass to the method
+		 * @param instance	an instance of the class to which the method belongs (null for static methods)
+		 */
+		public SimpleRunnableWithProgress(Class fromClass, String method, 
+				Class[] parameters,	Object[] args, Object instance) {
+			super();
+			this.args = args;
+			this.instance = instance;
+			try {
+				doMethod = fromClass.getMethod(method, parameters);
+			} catch(NoSuchMethodException e) {
+				openMessageDialog("Error: method not found", e.getMessage());
+			}
+		}
+		
+		/**
+		 * Constructor for this class<BR>
+		 * Sets the signature of the method to be called
+		 * @param fromClass	the Class to which the method belongs that has to be called
+		 * @param method	the method to be called
+		 * @param parameters	the classes of the method's arguments
+		 */
+		public SimpleRunnableWithProgress(Class fromClass, String method, Class[] parameters) {
+			this(fromClass, method, parameters, null, null);
+		}
+		
+		/**
+		 * Set the values of the to be called method's arguments
+		 * @param args
+		 */
+		public void setArgs(Object[] args) { this.args = args; }
+		
+		/**
+		 * Set an instance of the to be called method's class
+		 * @param obj
+		 */
+		public void setInstance(Object obj) { instance = obj; } 
+		
+		/**
+		 * Get the progress monitor currently used
+		 * @return the currently used progress monitor, or null if none is used
+		 */
+		public static IProgressMonitor getMonitor() { return monitor; }
+		
+		/**
+		 * Get the total work to be performed
+		 */
+		public static int getTotalWork() { return totalWork; }
+		
+		/**
+		 * Returns whether cancelation of current operation has been requested
+		 * @return true if the monitor is cancelled, false if running or null
+		 */
+		public static boolean isCancelled() {
+			if(monitor != null) return monitor.isCanceled();
+			else return false; //Not canceled if no monitor
+		}
+		
+		/**
+		 * Set the monitor information (before starting the process)
+		 * @param tn	the taskname to be displayed (may be changed while running)
+		 * @param tw	the total work to be performed
+		 */
+		public static void setMonitorInfo(String tn, int tw) {
+			taskName = tn;
+			totalWork = tw;
+		}
+		
+		/**
+		 * Set the total work to be performed
+		 */
+		public static void setTotalWork(int tw) {
+			totalWork = tw;
+		}
+		
+		/**
+		 * Set the task name that is displayed on the progress monitor
+		 */
+		public static void setTaskName(String tn) {
+			taskName = tn;
+		}
+		
+		public void setRunAsSyncExec(boolean useSyncExec) {
+			runAsSyncExec = useSyncExec;
+		}
+		
+		Throwable runException;
+		public void run(IProgressMonitor monitor) throws InterruptedException,
+			InvocationTargetException {
+			
+			SimpleRunnableWithProgress.monitor = monitor;
+			
+			if(args == null || doMethod == null) {
+				InterruptedException ex = new InterruptedException("missing method or arguments, see error log for details");
+				Engine.log.error("unable to invoke " + doMethod, ex);
+				throw ex;
+			}
+					
+			monitor.beginTask(taskName, totalWork);
+
+			runException = null;
+			if(runAsSyncExec) {//Invoke in syncExec, method may access widgets from this thread
+				SwtEngine.getWindow().getShell().getDisplay().syncExec(new Runnable() {
+					public void run() {
+						runException = doInvoke();
+					}
+				});
+			} else {
+				runException = doInvoke();
+			}
+			
+			monitor.done();
+			resetMonitor();
+			
+			if(runException != null) {
+				if		(runException instanceof IllegalAccessException)
+					throw new InvocationTargetException(runException, "Unable to invoke method " + doMethod);
+				else if	(runException instanceof IllegalArgumentException)
+					throw new InvocationTargetException(runException, "Unable to invoke method " + doMethod);
+				else if (runException instanceof InvocationTargetException)
+					throw (InvocationTargetException)runException;
+				else
+					throw new InvocationTargetException(runException);
+			}
+		}
+		
+		void resetMonitor() {
+			monitor = null;
+			totalWork = INIT_TOTALWORK;
+			taskName = INIT_TASKNAME;
+		}
+		
+		private Throwable doInvoke() {
+			try { doMethod.invoke(instance, args); } catch(Throwable t) { return t; }
+			return null;
+		}
+
+		/**
+		 * Notify the {@link IProgressMonitor} that given number of work has been performed<BR>
+		 * Equivalent to calling {@link IProgressMonitor#worked(int)} from an {@link Display#asyncExec(Runnable)}
+		 * @see IProgressMonitor#worked(int)
+		 * @param w
+		 */
+		public static void monitorWorked(final int w) {
+			SwtEngine.getWindow().getShell().getDisplay().asyncExec(new Runnable() {
+				public void run() {
+					if(monitor != null) monitor.worked(w);
+				}
+			});
+		}
+		
+		/**
+		 * Sets the task name of the progress monitor to the given value
+		 * * Equivalent to calling {@link IProgressMonitor#setTaskName(String)} from an {@link Display#asyncExec(Runnable)}
+		 * @see IProgressMonitor#setTaskName(String)
+		 */
+		public static void monitorSetTaskName(final String taskName) {
+			SwtEngine.getWindow().getShell().getDisplay().asyncExec(new Runnable() {
+				public void run() {
+					if(monitor != null) monitor.setTaskName(taskName);
+				}
+			});
+		}
+		
+		/**
+		 * Opens a message dialog from withing a {@link Display#asyncExec(Runnable)}
+		 * @param title	the title of the dialog
+		 * @param msg	the message to be displayed on the dialog
+		 * @see MessageDialog#openInformation(org.eclipse.swt.widgets.Shell, String, String)
+		 */
+		public void openMessageDialog(final String title, final String msg) {
+			SwtEngine.getWindow().getShell().getDisplay().asyncExec(new Runnable() {
+				public void run() {
+					MessageDialog.openInformation(SwtEngine.getWindow().getShell(), title, msg);
+				}
+			});
+		}
+	}
+}
