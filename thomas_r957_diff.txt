Index: trunk/src/plugins/org/pathvisio/visualization/plugins/ExpressionImagePlugin.java
===================================================================
--- trunk/src/plugins/org/pathvisio/visualization/plugins/ExpressionImagePlugin.java	(revision 956)
+++ trunk/src/plugins/org/pathvisio/visualization/plugins/ExpressionImagePlugin.java	(revision 957)
@@ -16,9 +16,6 @@
 //
 package org.pathvisio.visualization.plugins;
 
-import org.pathvisio.gui.swt.Engine;
-import org.pathvisio.view.Graphics;
-
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
@@ -64,15 +61,16 @@
 import org.eclipse.swt.widgets.Label;
 import org.eclipse.swt.widgets.Spinner;
 import org.jdom.Element;
-
-import org.pathvisio.util.ColorConverter;
-import org.pathvisio.util.SwtUtils;
-import org.pathvisio.visualization.Visualization;
-import org.pathvisio.visualization.colorset.ColorSet;
+import org.pathvisio.Engine;
 import org.pathvisio.data.CachedData;
 import org.pathvisio.data.Gex;
 import org.pathvisio.data.Gdb.IdCodePair;
 import org.pathvisio.data.Gex.Sample;
+import org.pathvisio.util.ColorConverter;
+import org.pathvisio.util.SwtUtils;
+import org.pathvisio.view.Graphics;
+import org.pathvisio.visualization.Visualization;
+import org.pathvisio.visualization.colorset.ColorSet;
 
 public class ExpressionImagePlugin extends PluginWithColoredSamples {
 	static final String NAME = "Colored image";
@@ -80,7 +78,7 @@
 		"This plugin displays one or more images on Gene Product objects and \n" +
 		"colors the image(s) accoring to the expression value for the Gene Product.";
 		
-	static final RGB DEFAULT_TRANSPARENT = Engine.TRANSPARENT_COLOR;
+	static final RGB DEFAULT_TRANSPARENT = SwtUtils.color2rgb(Engine.TRANSPARENT_COLOR);
 		
 	List<URL> imageURLs;
 	
@@ -568,14 +566,14 @@
 			xml.setAttribute(XML_ATTR_ASPECT, Boolean.toString(getMaintainAspect()));
 			xml.setAttribute(XML_ATTR_TOLERANCE, Integer.toString(getTolerance()));
 			xml.setAttribute(XML_ATTR_IMAGE, getURL().toString());
-			xml.addContent(ColorConverter.createColorElement(XML_ATTR_REPLACE, getReplaceColor()));
+			xml.addContent(ColorConverter.createColorElement(XML_ATTR_REPLACE, SwtUtils.rgb2color(getReplaceColor())));
 		}
 		protected void loadAttributes(Element xml) {
 			try {
 				setMaintainAspect(Boolean.parseBoolean(xml.getAttributeValue(XML_ATTR_ASPECT)));
 				setTolerance(Integer.parseInt(xml.getAttributeValue(XML_ATTR_TOLERANCE)));
 				setURL(new URL(xml.getAttributeValue(XML_ATTR_IMAGE)));
-				setReplaceColor(ColorConverter.parseColorElement(xml.getChild(XML_ATTR_REPLACE)));
+				setReplaceColor(SwtUtils.color2rgb(ColorConverter.parseColorElement(xml.getChild(XML_ATTR_REPLACE))));
 			} catch(Exception e) {
 				Engine.log.error("Unable to load plugin", e);
 			}
Index: trunk/src/plugins/org/pathvisio/visualization/plugins/ExpressionAsTextPlugin.java
===================================================================
--- trunk/src/plugins/org/pathvisio/visualization/plugins/ExpressionAsTextPlugin.java	(revision 956)
+++ trunk/src/plugins/org/pathvisio/visualization/plugins/ExpressionAsTextPlugin.java	(revision 957)
@@ -16,10 +16,6 @@
 //
 package org.pathvisio.visualization.plugins;
 
-import org.pathvisio.gui.swt.Engine;
-import org.pathvisio.view.GeneProduct;
-import org.pathvisio.view.Graphics;
-
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
@@ -53,15 +49,17 @@
 import org.eclipse.swt.widgets.Label;
 import org.eclipse.swt.widgets.Spinner;
 import org.jdom.Element;
-
-import org.pathvisio.util.SwtUtils;
-import org.pathvisio.visualization.Visualization;
+import org.pathvisio.Engine;
 import org.pathvisio.data.CachedData;
 import org.pathvisio.data.Gex;
 import org.pathvisio.data.CachedData.Data;
 import org.pathvisio.data.Gdb.IdCodePair;
 import org.pathvisio.data.Gex.Sample;
-import org.pathvisio.model.PathwayElement;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.util.SwtUtils;
+import org.pathvisio.view.GeneProduct;
+import org.pathvisio.view.Graphics;
+import org.pathvisio.visualization.Visualization;
 
 /**
  * Provides label for Gene Product
@@ -232,7 +230,7 @@
 		FontData fd = fontData == null ? DEFAULT_FONTDATA : fontData;
 		if(adjustZoom) {
 			fd = new FontData(fd.getName(), fd.getHeight(), fd.getStyle());
-			fd.setHeight((int)Math.ceil(Engine.getVPathway().vFromM(fd.getHeight()) * 15));//TODO: get rid of 15
+			fd.setHeight((int)Math.ceil(Engine.getActiveVPathway().vFromM(fd.getHeight()) * 15));//TODO: get rid of 15
 		}
 		return fd;
 	}
Index: trunk/src/plugins/org/pathvisio/visualization/plugins/PluginWithColoredSamples.java
===================================================================
--- trunk/src/plugins/org/pathvisio/visualization/plugins/PluginWithColoredSamples.java	(revision 956)
+++ trunk/src/plugins/org/pathvisio/visualization/plugins/PluginWithColoredSamples.java	(revision 957)
@@ -62,20 +62,19 @@
 import org.eclipse.swt.widgets.TableColumn;
 import org.eclipse.swt.widgets.TableItem;
 import org.jdom.Element;
-
-import org.pathvisio.gui.swt.Engine;
-import org.pathvisio.view.GeneProduct;
-import org.pathvisio.view.Graphics;
+import org.pathvisio.Engine;
+import org.pathvisio.data.CachedData;
+import org.pathvisio.data.Gex;
+import org.pathvisio.data.Gdb.IdCodePair;
+import org.pathvisio.data.Gex.Sample;
 import org.pathvisio.util.ColorConverter;
 import org.pathvisio.util.SwtUtils;
 import org.pathvisio.util.TableColumnResizer;
+import org.pathvisio.view.GeneProduct;
+import org.pathvisio.view.Graphics;
 import org.pathvisio.visualization.Visualization;
 import org.pathvisio.visualization.colorset.ColorSet;
 import org.pathvisio.visualization.colorset.ColorSetManager;
-import org.pathvisio.data.CachedData;
-import org.pathvisio.data.Gex;
-import org.pathvisio.data.Gdb.IdCodePair;
-import org.pathvisio.data.Gex.Sample;
 
 /**
  * Extend this class if you want to create a visualization plug-in where the user
Index: trunk/src/plugins/org/pathvisio/visualization/plugins/ExpressionColorPlugin.java
===================================================================
--- trunk/src/plugins/org/pathvisio/visualization/plugins/ExpressionColorPlugin.java	(revision 956)
+++ trunk/src/plugins/org/pathvisio/visualization/plugins/ExpressionColorPlugin.java	(revision 957)
@@ -43,18 +43,17 @@
 import org.eclipse.swt.widgets.Label;
 import org.eclipse.swt.widgets.Listener;
 import org.jdom.Element;
-
-import org.pathvisio.gui.swt.Engine;
-import org.pathvisio.view.Graphics;
-import org.pathvisio.util.ColorConverter;
-import org.pathvisio.util.SwtUtils;
-import org.pathvisio.visualization.Visualization;
-import org.pathvisio.visualization.colorset.ColorSet;
+import org.pathvisio.Engine;
 import org.pathvisio.data.CachedData;
 import org.pathvisio.data.Gex;
 import org.pathvisio.data.CachedData.Data;
 import org.pathvisio.data.Gdb.IdCodePair;
 import org.pathvisio.data.Gex.Sample;
+import org.pathvisio.util.ColorConverter;
+import org.pathvisio.util.SwtUtils;
+import org.pathvisio.view.Graphics;
+import org.pathvisio.visualization.Visualization;
+import org.pathvisio.visualization.colorset.ColorSet;
 
 public class ExpressionColorPlugin extends PluginWithColoredSamples {
 	final String NAME = "Color by expression";
@@ -157,12 +156,12 @@
 	
 	protected void saveAttributes(Element xml) {
 		xml.setAttribute(XML_ATTR_DRAWLINE, Boolean.toString(drawLine));
-		xml.addContent(ColorConverter.createColorElement(XML_ELM_LINECOLOR, getLineColor()));
+		xml.addContent(ColorConverter.createColorElement(XML_ELM_LINECOLOR, SwtUtils.rgb2color(getLineColor())));
 	}
 		
 	protected void loadAttributes(Element xml) {
 		try {
-			lineColor = ColorConverter.parseColorElement(xml.getChild(XML_ELM_LINECOLOR));
+			lineColor = SwtUtils.color2rgb(ColorConverter.parseColorElement(xml.getChild(XML_ELM_LINECOLOR)));
 			drawLine = Boolean.parseBoolean(xml.getAttributeValue(XML_ATTR_DRAWLINE));
 		} catch(Exception e) {
 			Engine.log.error("Unable to parse settings for plugin " + NAME, e);
Index: trunk/src/plugins/org/pathvisio/visualization/plugins/LabelPlugin.java
===================================================================
--- trunk/src/plugins/org/pathvisio/visualization/plugins/LabelPlugin.java	(revision 956)
+++ trunk/src/plugins/org/pathvisio/visualization/plugins/LabelPlugin.java	(revision 957)
@@ -16,10 +16,6 @@
 //
 package org.pathvisio.visualization.plugins;
 
-import org.pathvisio.gui.swt.Engine;
-import org.pathvisio.view.GeneProduct;
-import org.pathvisio.view.Graphics;
-
 import java.util.Collection;
 
 import org.eclipse.swt.SWT;
@@ -45,10 +41,12 @@
 import org.eclipse.swt.widgets.Group;
 import org.eclipse.swt.widgets.Label;
 import org.jdom.Element;
-
+import org.pathvisio.Engine;
 import org.pathvisio.util.ColorConverter;
 import org.pathvisio.util.SwtUtils;
 import org.pathvisio.util.Utils;
+import org.pathvisio.view.GeneProduct;
+import org.pathvisio.view.Graphics;
 import org.pathvisio.visualization.Visualization;
 import org.pathvisio.visualization.Visualization.PluginSet;
 
@@ -213,7 +211,7 @@
 		FontData fd = fontData == null ? DEFAULT_FONTDATA : fontData;
 		if(adjustZoom) {
 			fd = new FontData(fd.getName(), fd.getHeight(), fd.getStyle());
-			fd.setHeight((int)Math.ceil(Engine.getVPathway().vFromM(fd.getHeight()) * 15)); //TODO: get rid of 15
+			fd.setHeight((int)Math.ceil(Engine.getActiveVPathway().vFromM(fd.getHeight()) * 15)); //TODO: get rid of 15
 		}
 		return fd;
 	}
@@ -340,7 +338,7 @@
 		elm.setAttribute(XML_ATTR_STYLE, Integer.toString(style));
 		elm.setAttribute(XML_ATTR_ADAPT_FONT, Boolean.toString(adaptFontSize));
 		elm.setAttribute(XML_ATTR_FONTDATA, getFontData().toString());
-		elm.addContent(ColorConverter.createColorElement(XML_ELM_FONTCOLOR, getFontColor()));
+		elm.addContent(ColorConverter.createColorElement(XML_ELM_FONTCOLOR, SwtUtils.rgb2color(getFontColor())));
 		elm.setAttribute(XML_ATTR_OVERLAY, Boolean.toString(getOverlay()));
 		elm.setAttribute(XML_ATTR_ALIGN, Integer.toString(getAlignment()));
 		return elm;
@@ -360,7 +358,7 @@
 			if(adaptStr != null) adaptFontSize = Boolean.parseBoolean(adaptStr);
 			if(fontStr != null) fontData = new FontData(fontStr);
 			if(ovrStr != null) setOverlay(Boolean.parseBoolean(ovrStr));
-			if(fcElm != null) fontColor = ColorConverter.parseColorElement(fcElm);
+			if(fcElm != null) fontColor = SwtUtils.color2rgb(ColorConverter.parseColorElement(fcElm));
 			if(alnStr != null) align = Integer.parseInt(alnStr);
 		} catch(NumberFormatException e) {
 			Engine.log.error("Unable to load configuration for " + NAME, e);
Index: trunk/src/v1/org/pathvisio/gui/swt/MainWindow.java
===================================================================
--- trunk/src/v1/org/pathvisio/gui/swt/MainWindow.java	(revision 956)
+++ trunk/src/v1/org/pathvisio/gui/swt/MainWindow.java	(revision 957)
@@ -16,6 +16,8 @@
 //
 package org.pathvisio.gui.swt;
 
+import java.util.prefs.Preferences;
+
 import org.eclipse.jface.action.CoolBarManager;
 import org.eclipse.jface.action.MenuManager;
 import org.eclipse.jface.action.Separator;
@@ -26,15 +28,10 @@
 import org.eclipse.swt.widgets.Composite;
 import org.eclipse.swt.widgets.Control;
 import org.eclipse.swt.widgets.Shell;
+import org.pathvisio.Engine;
 import org.pathvisio.data.Gex;
-import org.pathvisio.gui.swt.BackpagePanel;
-import org.pathvisio.gui.swt.CommonActions;
-import org.pathvisio.gui.swt.Engine;
-import org.pathvisio.gui.swt.GuiMain;
-import org.pathvisio.gui.swt.MainWindowBase;
-import org.pathvisio.gui.swt.PropertyPanel;
-import org.pathvisio.gui.swt.TabbedSidePanel;
-import org.pathvisio.preferences.swt.Preferences;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
 import org.pathvisio.search.PathwaySearchComposite;
 import org.pathvisio.visualization.LegendPanel;
 
@@ -139,7 +136,7 @@
 		
 		GuiMain.loadImages(shell.getDisplay());
 		
-		shell.setImage(Engine.getImageRegistry().get("shell.icon"));
+		shell.setImage(SwtEngine.getImageRegistry().get("shell.icon"));
 		
 		Composite viewComposite = new Composite(parent, SWT.NULL);
 		viewComposite.setLayout(new FillLayout());
@@ -163,16 +160,16 @@
 		rightPanel.addTab(pwSearchComposite, "Pathway Search");
 		rightPanel.addTab(legend, "Legend");
 		
-		int sidePanelSize = Engine.getPreferences().getInt(Preferences.PREF_SIDEPANEL_SIZE);
+		int sidePanelSize = GlobalPreference.getValueInt(SwtPreference.SWT_SIDEPANEL_SIZE);
 		sashForm.setWeights(new int[] {100 - sidePanelSize, sidePanelSize});
 		showRightPanelAction.setChecked(sidePanelSize > 0);
 		
 		rightPanel.getTabFolder().setSelection(0); //select backpage browser tab
 		rightPanel.hideTab("Legend"); //hide legend on startup
 		
-		setStatus("Using Gene Database: '" + Engine.getPreferences().getString(Preferences.PREF_CURR_GDB) + "'");
+		setStatus("Using Gene Database: '" + SwtPreference.SWT_CURR_GDB.getValue() + "'");
 
-		Engine.updateTitle();
+		SwtEngine.updateTitle();
 		
 		return parent;		
 	};
Index: trunk/src/swing/org/pathvisio/preferences/swing/SwingPreferences.java
===================================================================
--- trunk/src/swing/org/pathvisio/preferences/swing/SwingPreferences.java	(revision 0)
+++ trunk/src/swing/org/pathvisio/preferences/swing/SwingPreferences.java	(revision 957)
@@ -0,0 +1,50 @@
+package org.pathvisio.preferences.swing;
+
+import java.io.IOException;
+
+import org.pathvisio.preferences.Preference;
+import org.pathvisio.preferences.PreferenceCollection;
+
+public class SwingPreferences implements PreferenceCollection {
+	public Preference byName(String name) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public void save() throws IOException {
+		// TODO Auto-generated method stub
+		
+	}
+	
+	public enum SwingPreference implements Preference {
+		;
+			String value;
+			String defaultValue;
+			
+			
+			SwingPreference(String defaultValue) {
+				this.defaultValue = defaultValue;
+			}
+			
+			public String getDefault() {
+				return defaultValue;
+			}
+
+			public String getValue() {
+				if(value == null) {
+					return defaultValue;
+				} else {
+					return value;
+				}
+			}
+
+			public void setDefault(String defValue) {
+				defaultValue = defValue;
+			}
+
+			public void setValue(String newValue) {
+				value = newValue;
+			}
+		}
+}
+
Index: trunk/src/swing/org/pathvisio/gui/swing/MainPanel.java
===================================================================
--- trunk/src/swing/org/pathvisio/gui/swing/MainPanel.java	(revision 0)
+++ trunk/src/swing/org/pathvisio/gui/swing/MainPanel.java	(revision 957)
@@ -0,0 +1,184 @@
+package org.pathvisio.gui.swing;
+
+import java.awt.BorderLayout;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+
+import javax.swing.ImageIcon;
+import javax.swing.JComboBox;
+import javax.swing.JLabel;
+import javax.swing.JMenu;
+import javax.swing.JMenuBar;
+import javax.swing.JMenuItem;
+import javax.swing.JPanel;
+import javax.swing.JScrollPane;
+import javax.swing.JSplitPane;
+import javax.swing.JTable;
+import javax.swing.JToolBar;
+import javax.swing.table.TableCellEditor;
+import javax.swing.table.TableCellRenderer;
+
+import org.pathvisio.Engine;
+import org.pathvisio.gui.swing.CommonActions.CopyAction;
+import org.pathvisio.gui.swing.CommonActions.ExportAction;
+import org.pathvisio.gui.swing.CommonActions.ImportAction;
+import org.pathvisio.gui.swing.CommonActions.NewElementAction;
+import org.pathvisio.gui.swing.CommonActions.PasteAction;
+import org.pathvisio.gui.swing.CommonActions.SaveAction;
+import org.pathvisio.gui.swing.CommonActions.ZoomAction;
+import org.pathvisio.gui.swing.propertypanel.PathwayTableModel;
+import org.pathvisio.view.VPathway;
+import org.pathvisio.view.swing.VPathwaySwing;
+
+import com.mammothsoftware.frwk.ddb.DropDownButton;
+
+public class MainPanel extends JPanel {
+	private JSplitPane splitPane;
+	private JMenuBar menuBar;
+	private JToolBar toolBar;
+	private JScrollPane pathwayScrollPane;
+	private JScrollPane sidebarScrollPane;
+	private JTable propertyTable;
+	
+	public MainPanel() {
+		setLayout(new BorderLayout());
+		
+		menuBar = new JMenuBar();
+		addMenuActions(menuBar);
+		toolBar = new JToolBar();
+		addToolBarActions(toolBar);
+		
+		add(toolBar, BorderLayout.NORTH);
+		//menuBar will be added by container (JFrame or JApplet)
+		
+		pathwayScrollPane = new JScrollPane();
+		
+		final PathwayTableModel model = new PathwayTableModel();
+		propertyTable = new JTable(model) {
+			public TableCellRenderer getCellRenderer(int row, int column) {
+				TableCellRenderer r = model.getCellRenderer(row, column);
+				return r == null ? super.getCellRenderer(row, column) : r;
+			}
+			public TableCellEditor getCellEditor(int row, int column) {
+				TableCellEditor e = model.getCellEditor(row, column);
+				return e == null ? super.getCellEditor(row, column) : e;
+			}
+		};
+		
+		sidebarScrollPane = new JScrollPane(propertyTable);
+		
+		splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, pathwayScrollPane, sidebarScrollPane);
+		splitPane.setResizeWeight(1);
+		splitPane.setOneTouchExpandable(true);
+		add(splitPane, BorderLayout.CENTER);
+	}
+	
+	protected void addMenuActions(JMenuBar mb) {
+		JMenu pathwayMenu = new JMenu("Pathway");
+		pathwayMenu.add(new SaveAction());
+		pathwayMenu.add(new ImportAction(this));
+		pathwayMenu.add(new ExportAction());
+		
+		JMenu editMenu = new JMenu("Edit");
+		editMenu.add(new CopyAction());
+		editMenu.add(new PasteAction());
+		
+		JMenu viewMenu = new JMenu("View");
+		JMenu zoomMenu = new JMenu("Zoom");
+		viewMenu.add(zoomMenu);
+		zoomMenu.add(new ZoomAction(VPathway.ZOOM_TO_FIT));
+		zoomMenu.add(new ZoomAction(10));
+		zoomMenu.add(new ZoomAction(25));
+		zoomMenu.add(new ZoomAction(50));
+		zoomMenu.add(new ZoomAction(75));
+		zoomMenu.add(new ZoomAction(100));
+		zoomMenu.add(new ZoomAction(150));
+		zoomMenu.add(new ZoomAction(200));
+		
+		mb.add(pathwayMenu);
+		mb.add(editMenu);
+		mb.add(viewMenu);
+	}
+	
+	protected void addToolBarActions(JToolBar tb) {
+		tb.add(new SaveAction());
+		tb.add(new ImportAction(this));
+		tb.add(new ExportAction());
+		tb.addSeparator();
+		tb.add(new CopyAction());
+		tb.add(new PasteAction());
+		tb.addSeparator();
+		
+		tb.addSeparator();
+		tb.add(new JLabel("Zoom:", JLabel.LEFT));
+		JComboBox combo = new JComboBox(new Object[] { 
+				new ZoomAction(VPathway.ZOOM_TO_FIT),
+				new ZoomAction(10),
+				new ZoomAction(25),
+				new ZoomAction(50),
+				new ZoomAction(75),
+				new ZoomAction(100),
+				new ZoomAction(150),
+				new ZoomAction(200)
+		} );
+		combo.setEditable(true);
+		combo.addActionListener(new ActionListener() {
+			public void actionPerformed(ActionEvent e) {
+				JComboBox combo = (JComboBox)e.getSource();
+				Object s = combo.getSelectedItem();
+				if(s instanceof ZoomAction) {
+					((ZoomAction)s).actionPerformed(e);
+				} else if(s instanceof String) {
+					String zs = (String)s;
+					try {
+						double zf = Double.parseDouble(zs);
+						new ZoomAction(zf).actionPerformed(e);
+					} catch(Exception ex) {
+						//Ignore bad input
+					}
+				}
+			}
+		});
+		tb.add(combo);
+		tb.addSeparator();
+		
+		tb.add(new NewElementAction(VPathway.NEWGENEPRODUCT));
+		tb.add(new NewElementAction(VPathway.NEWLABEL));
+		//New line menu
+		DropDownButton lineButton = new DropDownButton(new ImageIcon(Engine.getResourceURL("icons/newlinemenu.gif")));
+		lineButton.addComponent(new JMenuItem(new NewElementAction(VPathway.NEWLINE)));
+		lineButton.addComponent(new JMenuItem(new NewElementAction(VPathway.NEWLINEARROW)));
+		lineButton.addComponent(new JMenuItem(new NewElementAction(VPathway.NEWLINEDASHED)));
+		lineButton.addComponent(new JMenuItem(new NewElementAction(VPathway.NEWLINEDASHEDARROW)));
+		lineButton.setRunFirstItem(true);
+		tb.add(lineButton);
+		
+		tb.add(new NewElementAction(VPathway.NEWRECTANGLE));
+		tb.add(new NewElementAction(VPathway.NEWOVAL));
+		tb.add(new NewElementAction(VPathway.NEWARC));
+		tb.add(new NewElementAction(VPathway.NEWBRACE));
+		tb.add(new NewElementAction(VPathway.NEWTBAR));
+		
+		//New lineshape menu
+		DropDownButton lineShapeButton = new DropDownButton(new ImageIcon(Engine.getResourceURL("icons/newlineshapemenu.gif")));
+		lineShapeButton.addComponent(new JMenuItem(new NewElementAction(VPathway.NEWLIGANDROUND)));
+		lineShapeButton.addComponent(new JMenuItem(new NewElementAction(VPathway.NEWRECEPTORROUND)));
+		lineShapeButton.addComponent(new JMenuItem(new NewElementAction(VPathway.NEWLIGANDSQUARE)));
+		lineShapeButton.addComponent(new JMenuItem(new NewElementAction(VPathway.NEWRECEPTORSQUARE)));
+		lineShapeButton.setRunFirstItem(true);
+		tb.add(lineShapeButton);
+	}
+	
+	public JMenuBar getMenuBar() {
+		return menuBar;
+	}
+	
+	public JToolBar getToolBar() {
+		return toolBar;
+	}
+
+	public JScrollPane getScrollPane() {
+		return pathwayScrollPane;
+	}
+}
+
Index: trunk/src/swing/org/pathvisio/gui/swing/propertypanel/SidebarManager.java
===================================================================
--- trunk/src/swing/org/pathvisio/gui/swing/propertypanel/SidebarManager.java	(revision 0)
+++ trunk/src/swing/org/pathvisio/gui/swing/propertypanel/SidebarManager.java	(revision 957)
@@ -0,0 +1,10 @@
+package org.pathvisio.gui.swing.propertypanel;
+
+import java.util.Collection;
+import java.util.List;
+
+import org.pathvisio.model.PathwayElement;
+
+public class SidebarManager {
+
+}
Index: trunk/src/swing/org/pathvisio/gui/swing/propertypanel/PathwayTableModel.java
===================================================================
--- trunk/src/swing/org/pathvisio/gui/swing/propertypanel/PathwayTableModel.java	(revision 0)
+++ trunk/src/swing/org/pathvisio/gui/swing/propertypanel/PathwayTableModel.java	(revision 957)
@@ -0,0 +1,177 @@
+package org.pathvisio.gui.swing.propertypanel;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.List;
+
+import javax.swing.DefaultCellEditor;
+import javax.swing.JTextField;
+import javax.swing.table.AbstractTableModel;
+import javax.swing.table.TableCellEditor;
+import javax.swing.table.TableCellRenderer;
+
+import org.pathvisio.Engine;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.PathwayEvent;
+import org.pathvisio.model.PathwayListener;
+import org.pathvisio.model.PropertyType;
+import org.pathvisio.view.Graphics;
+import org.pathvisio.view.SelectionBox;
+import org.pathvisio.view.SelectionBox.SelectionEvent;
+import org.pathvisio.view.SelectionBox.SelectionListener;
+
+public class PathwayTableModel extends AbstractTableModel implements SelectionListener, PathwayListener {
+	TableCellEditor defaultEditor = new DefaultCellEditor(new JTextField());
+	
+	Collection<PathwayElement> input;
+	List<TypedProperty> properties;
+	
+	public PathwayTableModel() {
+		input = new HashSet<PathwayElement>();
+		properties = new ArrayList<TypedProperty>();
+		SelectionBox.addListener(this);
+	}
+	
+	private void clearInput() {
+		for(PathwayElement e : input) {
+			e.removeListener(this);
+		}
+		input.clear();
+		refresh();
+	}
+	
+	private void removeInput(PathwayElement pwElm) {
+		input.remove(pwElm);
+		pwElm.removeListener(this);
+		refresh();
+	}
+	
+	private void addInput(PathwayElement pwElm) {
+		input.add(pwElm);
+		pwElm.addListener(this);
+		refresh();
+	}
+	
+	protected void refresh() {
+		properties = generateProperties(input);
+		fireTableDataChanged();
+	}
+	
+	protected List<TypedProperty> generateProperties(Collection<PathwayElement> elements) {
+		List<TypedProperty> properties = new ArrayList<TypedProperty>();
+		List<PropertyType> propTypes = getProperties(elements);
+		for(PropertyType pt : propTypes) {
+			TypedProperty value = getAggregateProperty(pt, elements);
+			properties.add(value);
+		}
+		return properties;
+	}
+	
+	protected List<PropertyType> getProperties(Collection<PathwayElement> elements) {
+		ArrayList<PropertyType> properties = null;
+		ArrayList<PropertyType> remove = new ArrayList<PropertyType>();
+		for(PathwayElement e : elements) {
+			if(properties == null) {
+				properties = new ArrayList<PropertyType>();
+				properties.addAll(e.getAttributes());
+				continue;
+			}
+			remove.clear();
+			List<PropertyType> attributes = e.getAttributes();
+			for(PropertyType p : properties) {
+				if(!attributes.contains(p)) {
+					remove.add(p);
+				}
+			}
+			properties.removeAll(remove);
+		}
+		return properties == null ? new ArrayList<PropertyType>() : properties;
+	}
+	
+	TypedProperty getAggregateProperty(PropertyType key, Collection<PathwayElement> elements) {
+		Object value = null;
+		boolean first = true;
+		for(PathwayElement e : elements) {
+			Object o = e.getProperty(key);
+			if(!first && (o == null || !o.equals(value))) {
+				return new TypedProperty(elements, key);
+			}
+			value = o;
+			first = false;
+		}
+		return new TypedProperty(elements, value, key);
+	}
+		
+	public int getColumnCount() {
+		return 2;
+	}
+
+	public int getRowCount() {
+		return properties.size();
+	}
+
+	public TypedProperty getPropertyAt(int row) {
+		return properties.get(row);
+	}
+	
+	public Object getValueAt(int rowIndex, int columnIndex) {
+		TypedProperty p = getPropertyAt(rowIndex);
+		if(columnIndex == 0) return p.getType().desc();
+		else return p.getValue();
+	}
+
+	public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
+		if(columnIndex != 0) {
+			TypedProperty p = getPropertyAt(rowIndex);
+			p.setValue(aValue);
+		}
+		Engine.getActiveVPathway().redrawDirtyRect();
+	}
+	
+	public String getColumnName(int column) {
+		if(column == 0) return "Property";
+		return "Value";
+	}
+	
+	public boolean isCellEditable(int rowIndex, int columnIndex) {
+		return columnIndex == 1;
+	}
+		
+	public void drawingEvent(SelectionEvent e) {
+		switch(e.type) {
+		case SelectionEvent.OBJECT_ADDED:
+			if(e.affectedObject instanceof Graphics)
+				addInput(((Graphics)e.affectedObject).getGmmlData());
+			break;
+		case SelectionEvent.OBJECT_REMOVED:
+			if(e.affectedObject instanceof Graphics)
+				removeInput(((Graphics)e.affectedObject).getGmmlData());
+			break;
+		case SelectionEvent.SELECTION_CLEARED:
+			 clearInput();
+			break;
+		}		
+	}
+
+	public TableCellRenderer getCellRenderer(int row, int column) {
+		if(column != 0) {
+			TypedProperty tp = getPropertyAt(row);
+			System.out.println("Getting cell renderer" + tp);
+			if(tp != null) return tp.getCellRenderer();
+		}
+		return null;
+	}
+
+	public TableCellEditor getCellEditor(int row, int column) {
+		if(column != 0) {
+			TypedProperty tp = getPropertyAt(row);
+			if(tp != null) return tp.getCellEditor();
+		}
+		return null;
+	}
+	
+	public void gmmlObjectModified(PathwayEvent e) {
+		refresh();
+	}
+}
Index: trunk/src/swing/org/pathvisio/gui/swing/propertypanel/TypedProperty.java
===================================================================
--- trunk/src/swing/org/pathvisio/gui/swing/propertypanel/TypedProperty.java	(revision 0)
+++ trunk/src/swing/org/pathvisio/gui/swing/propertypanel/TypedProperty.java	(revision 957)
@@ -0,0 +1,353 @@
+package org.pathvisio.gui.swing.propertypanel;
+
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.text.NumberFormat;
+import java.util.Collection;
+import java.util.HashMap;
+
+import javax.swing.AbstractCellEditor;
+import javax.swing.BorderFactory;
+import javax.swing.DefaultCellEditor;
+import javax.swing.JButton;
+import javax.swing.JCheckBox;
+import javax.swing.JColorChooser;
+import javax.swing.JComboBox;
+import javax.swing.JDialog;
+import javax.swing.JLabel;
+import javax.swing.JTable;
+import javax.swing.JTextField;
+import javax.swing.border.Border;
+import javax.swing.table.DefaultTableCellRenderer;
+import javax.swing.table.TableCellEditor;
+import javax.swing.table.TableCellRenderer;
+
+import org.pathvisio.data.DataSources;
+import org.pathvisio.model.LineStyle;
+import org.pathvisio.model.LineType;
+import org.pathvisio.model.MappFormat;
+import org.pathvisio.model.OrientationType;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.PropertyType;
+
+public class TypedProperty {	
+	Collection<PathwayElement> elements;
+	Object value;
+	PropertyType type;
+	boolean different;
+
+	public TypedProperty(Collection<PathwayElement> elements, PropertyType type) {
+		this(elements, null, type, true);
+	}
+	
+	public TypedProperty(Collection<PathwayElement> elements, Object value, PropertyType type) {
+		this(elements, value, type, false);
+	}
+	
+	private TypedProperty(Collection<PathwayElement> elements, Object value, PropertyType type, boolean different) {
+		this.elements = elements;
+		this.value = value;
+		this.type = type;
+		this.different = different;
+	}
+
+	public void setValue(Object value) {
+		this.value = value;
+		if(value != null) {
+			for(PathwayElement e : elements) {
+				e.setProperty(type, value);
+			}
+		}
+	}
+
+	public Object getValue() {
+		return value;
+	}
+	
+	public PropertyType getType() {
+		return type;
+	}
+
+	public boolean hasDifferentValues() { return different; }
+	public void setHasDifferentValues(boolean diff) { different = diff; }
+
+	public TableCellRenderer getCellRenderer() {
+		if(hasDifferentValues()) return differentRenderer;
+		switch(type.type()) {
+		case COLOR:
+			return colorRenderer;
+		case LINETYPE:
+			return lineTypeRenderer;
+		case LINESTYLE:
+			return lineStyleRenderer;
+		case DATASOURCE:
+			return datasourceRenderer;
+		case BOOLEAN:
+			return checkboxRenderer;
+		case ORIENTATION:
+			return orientationRenderer;
+		case ORGANISM:
+			return organismRenderer;
+		case ANGLE:
+			return angleRenderer;
+		case DOUBLE:
+			return doubleRenderer;
+		case FONT:
+		case GENETYPE: //TODO
+		}
+		return null;
+	}
+
+	public TableCellEditor getCellEditor() {
+		switch(type.type()) {
+		case BOOLEAN:
+			return checkboxEditor;
+		case DATASOURCE:
+			return datasourceEditor;
+		case COLOR:
+			return colorEditor;
+		case LINETYPE:
+			return lineTypeEditor;
+		case LINESTYLE:
+			return lineStyleEditor;
+		case ORIENTATION:
+			return orientationEditor;
+		case ORGANISM:
+			return organismEditor;
+		case ANGLE:
+			return angleEditor;
+		case DOUBLE:
+			return doubleEditor;
+		default:
+			return null;
+		}
+	}
+	
+	private static class DoubleEditor extends DefaultCellEditor {
+		public DoubleEditor() {
+			super(new JTextField());
+		}
+		public Object getCellEditorValue() {
+			String value = ((JTextField)getComponent()).getText();
+			Double d = new Double(0);
+			try {
+				d = Double.parseDouble(value);
+			} catch(Exception e) {
+				//ignore
+			}
+			return d;
+		}
+	}
+	
+	private static class AngleEditor extends DefaultCellEditor {
+		public AngleEditor() {
+			super(new JTextField());
+		}
+		public Object getCellEditorValue() {
+			String value = ((JTextField)getComponent()).getText();
+			Double d = new Double(0);
+			try {
+				d = Double.parseDouble(value) * Math.PI / 180;
+			} catch(Exception e) {
+				//ignore
+			}
+			return d;
+		}
+		
+		public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
+			value =  (Double)(value) * 180.0 / Math.PI;
+			return super.getTableCellEditorComponent(table, value, isSelected, row, column);
+		}
+	}
+	
+	private static class ComboEditor extends DefaultCellEditor {
+		HashMap label2value;
+		boolean useIndex;
+		
+		public ComboEditor(Object[] labels, boolean useIndex) {
+			super(new JComboBox(labels));
+			this.useIndex = useIndex;
+		}
+
+		public ComboEditor(Object[] labels, Object[] values) {
+			this(labels, false);
+			if(values != null) {
+				if(labels.length != values.length) {
+					throw new IllegalArgumentException("Number of labels doesn't equal number of values");
+				}
+				label2value = new HashMap();
+				for(int i = 0; i < labels.length; i++) {
+					label2value.put(labels[i], values[i]);
+				}
+			}
+		}
+		
+		public Object getCellEditorValue() {
+			if(label2value == null) { //Use index
+				JComboBox cb = (JComboBox)getComponent();
+				return useIndex ? cb.getSelectedIndex() : cb.getSelectedItem();
+			} else {
+				Object label = super.getCellEditorValue();
+				return label2value.get(label);
+			}
+		}
+	}
+	
+	private static class ColorEditor extends AbstractCellEditor implements TableCellEditor, ActionListener {
+		Color currentColor;
+		JButton button;
+		JColorChooser colorChooser;
+		JDialog dialog;
+		protected static final String EDIT = "edit";
+
+		public ColorEditor() {
+			button = new JButton();
+			button.setActionCommand("edit");
+			button.addActionListener(this);
+			button.setBorderPainted(false);
+
+			colorChooser = new JColorChooser();
+			dialog = JColorChooser.createDialog(button,
+					"Pick a Color",
+					true,  //modal
+					colorChooser,
+					this,  //OK button handler
+					null); //no CANCEL button handler
+		}
+
+		public void actionPerformed(ActionEvent e) {
+			if (EDIT.equals(e.getActionCommand())) {
+				button.setBackground(currentColor);
+				colorChooser.setColor(currentColor);
+				dialog.setVisible(true);
+
+				fireEditingStopped(); //Make the renderer reappear.
+
+			} else {
+				currentColor = colorChooser.getColor();
+			}
+		}
+
+		public Object getCellEditorValue() {
+			return currentColor;
+		}
+
+		public Component getTableCellEditorComponent(JTable table,
+				Object value,
+				boolean isSelected,
+				int row,
+				int column) {
+			currentColor = (Color)value;
+			return button;
+		}
+	}
+
+	private static ColorRenderer colorRenderer = new ColorRenderer();
+	private static ComboRenderer lineTypeRenderer = new ComboRenderer(LineType.getNames(), LineType.values());
+	private static ComboRenderer lineStyleRenderer = new ComboRenderer(LineStyle.getNames());
+	private static ComboRenderer datasourceRenderer = new ComboRenderer(DataSources.dataSources);
+	private static CheckBoxRenderer checkboxRenderer = new CheckBoxRenderer();
+	private static ComboRenderer orientationRenderer = new ComboRenderer(OrientationType.getNames());
+	private static ComboRenderer organismRenderer = new ComboRenderer(MappFormat.organism_latin_name);
+	
+	private static ColorEditor colorEditor = new ColorEditor();
+	private static ComboEditor lineTypeEditor = new ComboEditor(LineType.getNames(), true);
+	private static ComboEditor lineStyleEditor = new ComboEditor(LineStyle.getNames(), true);
+	private static ComboEditor datasourceEditor = new ComboEditor(DataSources.dataSources, false);
+	private static DefaultCellEditor checkboxEditor = new DefaultCellEditor(new JCheckBox());
+	private static ComboEditor orientationEditor = new ComboEditor(OrientationType.getNames(), true);
+	private static ComboEditor organismEditor = new ComboEditor(MappFormat.organism_latin_name, false);
+	private static AngleEditor angleEditor = new AngleEditor();
+	private static DoubleEditor doubleEditor = new DoubleEditor();
+	
+	private static DefaultTableCellRenderer angleRenderer = new DefaultTableCellRenderer() {
+		protected void setValue(Object value) {
+			super.setValue( (Double)(value) * 180.0 / Math.PI );
+		}
+	};
+	
+	private static DefaultTableCellRenderer doubleRenderer = new DefaultTableCellRenderer() {
+		protected void setValue(Object value) {
+			double d = (Double)value;
+			super.setValue(d);
+		}
+	};
+	
+	private static DefaultTableCellRenderer differentRenderer = new DefaultTableCellRenderer() {
+		protected void setValue(Object value) {
+			value = "Different values";
+			super.setValue(value);
+		}
+	};
+
+	private static class CheckBoxRenderer extends JCheckBox implements TableCellRenderer {
+		public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
+			setSelected((Boolean)value);
+			return this;
+		}
+	}
+	
+	private static class ComboRenderer extends JComboBox implements TableCellRenderer {
+		HashMap value2label;
+		public ComboRenderer(Object[] values) {
+			super(values);
+		}
+		
+		public ComboRenderer(Object[] labels, Object[] values) {
+			this(labels);
+			if(labels.length != values.length) {
+				throw new IllegalArgumentException("Number of labels doesn't equal number of values");
+			}
+			value2label = new HashMap();
+			for(int i = 0; i < labels.length; i++) {
+				value2label.put(values[i], labels[i]);
+			}
+		}
+
+		public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
+			if(value2label != null) {
+				value = value2label.get(value);
+			}
+			setSelectedItem(value);
+			return this;
+		}
+	}
+	
+	private static class ColorRenderer extends JLabel implements TableCellRenderer {
+		Border unselectedBorder = null;
+		Border selectedBorder = null;
+		boolean isBordered = true;
+
+		public ColorRenderer() {
+			setOpaque(true);
+		}
+
+		public Component getTableCellRendererComponent(
+				JTable table, Object color, boolean isSelected, boolean hasFocus, int row, int column) {
+			Color newColor = (Color)color;
+			setBackground(newColor);
+			if (isBordered) {
+				if (isSelected) {
+					if (selectedBorder == null) {
+						selectedBorder = BorderFactory.createMatteBorder(2,5,2,5,
+								table.getSelectionBackground());
+					}
+					setBorder(selectedBorder);
+				} else {
+					if (unselectedBorder == null) {
+						unselectedBorder = BorderFactory.createMatteBorder(2,5,2,5,
+								table.getBackground());
+					}
+					setBorder(unselectedBorder);
+				}
+			}
+
+			setToolTipText("RGB value: " + newColor.getRed() + ", "
+					+ newColor.getGreen() + ", "
+					+ newColor.getBlue());
+			return this;
+		}
+	}
+}
Index: trunk/src/swing/org/pathvisio/gui/swing/GuiInit.java
===================================================================
--- trunk/src/swing/org/pathvisio/gui/swing/GuiInit.java	(revision 0)
+++ trunk/src/swing/org/pathvisio/gui/swing/GuiInit.java	(revision 957)
@@ -0,0 +1,19 @@
+package org.pathvisio.gui.swing;
+
+import org.pathvisio.Engine;
+import org.pathvisio.model.GpmlFormat;
+
+public class GuiInit {
+	public static void init() {
+		initImporters();
+		initExporters();
+	}
+	
+	private static void initImporters() {
+		Engine.addPathwayImporter(new GpmlFormat());
+	}
+	
+	private static void initExporters() {
+		Engine.addPathwayExporter(new GpmlFormat());
+	}
+}
Index: trunk/src/swing/org/pathvisio/gui/swing/CommonActions.java
===================================================================
--- trunk/src/swing/org/pathvisio/gui/swing/CommonActions.java	(revision 0)
+++ trunk/src/swing/org/pathvisio/gui/swing/CommonActions.java	(revision 957)
@@ -0,0 +1,284 @@
+package org.pathvisio.gui.swing;
+
+import java.awt.Component;
+import java.awt.Dimension;
+import java.awt.event.ActionEvent;
+import java.awt.event.KeyEvent;
+import java.io.File;
+import java.net.URL;
+
+import javax.swing.AbstractAction;
+import javax.swing.Action;
+import javax.swing.ImageIcon;
+import javax.swing.JFileChooser;
+import javax.swing.KeyStroke;
+import javax.swing.ProgressMonitor;
+import javax.swing.filechooser.FileFilter;
+
+import org.pathvisio.Engine;
+import org.pathvisio.gui.swt.MainWindow;
+import org.pathvisio.model.ConverterException;
+import org.pathvisio.model.PathwayImporter;
+import org.pathvisio.view.VPathway;
+import org.pathvisio.view.VPathwayEvent;
+import org.pathvisio.view.VPathwayListener;
+import org.pathvisio.view.swing.VPathwaySwing;
+
+public abstract class CommonActions {
+	private static URL IMG_SAVE = Engine.getResourceURL("icons/save.gif");
+	private static URL IMG_IMPORT = Engine.getResourceURL("icons/import.gif");
+	private static URL IMG_EXPORT = Engine.getResourceURL("icons/export.gif");
+	private static URL IMG_COPY= Engine.getResourceURL("icons/copy.gif");
+	private static URL IMG_PASTE = Engine.getResourceURL("icons/paste.gif");
+	
+	static class ZoomAction extends AbstractAction {
+		Component parent;
+		double zoomFactor;
+		
+		public ZoomAction(double zf) {
+			zoomFactor = zf;
+			String descr = "Set zoom to " + (int)zf + "%";
+			putValue(Action.NAME, toString());
+			putValue(Action.SHORT_DESCRIPTION, descr);
+			putValue(Action.LONG_DESCRIPTION, descr);
+		}
+		
+		public void actionPerformed(ActionEvent e) {
+			VPathway vPathway = Engine.getActiveVPathway();
+			if(vPathway != null) {
+				vPathway.setPctZoom(zoomFactor);
+			}
+		}
+		
+		public String toString() {
+			if(zoomFactor == VPathway.ZOOM_TO_FIT) {
+				return "Fit to window";
+			}
+			return (int)zoomFactor + "%";
+		}
+	}
+	
+	static class SaveAction extends AbstractAction {
+		public SaveAction() {
+			super("Save", new ImageIcon(IMG_SAVE));
+			putValue(Action.SHORT_DESCRIPTION, "Save the pathway");
+			putValue(Action.LONG_DESCRIPTION, "Save the pathway");
+			putValue(Action.ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_S, ActionEvent.CTRL_MASK));
+		}
+
+		public void actionPerformed(ActionEvent e) {
+			// TODO Auto-generated method stub
+			
+		}
+	}
+	
+	static class ImportAction extends AbstractAction {
+		MainPanel mainPanel;
+		
+		public ImportAction(MainPanel parent) {
+			super("Import", new ImageIcon(IMG_IMPORT));
+			mainPanel = parent;
+			putValue(Action.SHORT_DESCRIPTION, "Import pathway");
+			putValue(Action.LONG_DESCRIPTION, "Import a pathway from various file formats");
+			putValue(Action.ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_M, ActionEvent.CTRL_MASK));
+		}
+		
+		public void actionPerformed(ActionEvent e) {
+				final Component component = (Component)e.getSource();
+				//Open file dialog
+				JFileChooser jfc = new JFileChooser();
+				jfc.setAcceptAllFileFilterUsed(false);
+				jfc.setDialogTitle("Import pathway");
+				jfc.setDialogType(JFileChooser.OPEN_DIALOG);
+				
+				for(final PathwayImporter imp : Engine.getPathwayImporters().values()) {
+					FileFilter ff = new FileFilter() {
+						public boolean accept(File f) {
+							if(f.isDirectory()) return true;
+							
+							String fn = f.toString();
+							int i = fn.lastIndexOf('.');
+							if(i > 0) {
+								String ext = fn.substring(i + 1);
+								for(String impExt : imp.getExtensions()) {
+									if(impExt.equalsIgnoreCase(ext)) {
+										return true;
+									}
+								}
+							}
+							return false;
+						}
+
+						public String getDescription() {
+							StringBuilder exts = new StringBuilder();
+							for(String e : imp.getExtensions()) {
+								exts.append(".");
+								exts.append(e);
+								exts.append(", ");
+							}
+							String str = exts.substring(0, exts.length() - 2);
+							return imp.getName() + " (" + str + ")";
+						}
+					};
+					jfc.addChoosableFileFilter(ff);
+				}
+				
+				int status = jfc.showDialog(component, "Import");
+				if(status == JFileChooser.APPROVE_OPTION) {
+					try {
+						int totalWork = 1000;
+						ProgressMonitor m = new ProgressMonitor(component, "Loading pathway", "Please wait while the pathway is being loaded", 0, 1000);
+						m.setProgress(10);
+						Engine.importPathway(jfc.getSelectedFile(), new VPathwaySwing(mainPanel.getScrollPane()));
+						m.setProgress((int)(totalWork*2/3));
+						Engine.getActiveVPathway().setEditMode(true);
+						m.setProgress(totalWork);
+					} catch(ConverterException ex) {
+						SwingEngine.handleConverterException(SwingEngine.MSG_UNABLE_IMPORT, component, ex);
+					}
+				}
+		}
+	}
+	
+	static class ExportAction extends AbstractAction {
+		public ExportAction() {
+			super("Export", new ImageIcon(IMG_EXPORT));
+			putValue(Action.SHORT_DESCRIPTION, "Export pathway");
+			putValue(Action.LONG_DESCRIPTION, "Export the pathway to various file formats");
+			putValue(Action.ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_E, ActionEvent.CTRL_MASK));
+		}
+		
+		public void actionPerformed(ActionEvent e) {
+			//TODO
+		}
+	}
+	
+	static class CopyAction extends AbstractAction {
+		public CopyAction() {
+			super("Copy", new ImageIcon(IMG_COPY));
+			String descr = "Copy selected pathway objects to clipboard";
+			putValue(Action.SHORT_DESCRIPTION, descr);
+			putValue(Action.LONG_DESCRIPTION, descr);
+			putValue(Action.ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_C, ActionEvent.CTRL_MASK));
+		}
+
+		public void actionPerformed(ActionEvent e) {
+			Engine.getActiveVPathway().copyToClipboard();
+		}		
+	}
+	
+	static class PasteAction extends AbstractAction {
+		public PasteAction() {
+			super("Paste", new ImageIcon(IMG_PASTE));
+			String descr = "Paste pathway elements from clipboard";
+			putValue(Action.SHORT_DESCRIPTION, descr);
+			putValue(Action.LONG_DESCRIPTION, descr);
+			putValue(Action.ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_V, ActionEvent.CTRL_MASK));
+		}
+
+		public void actionPerformed(ActionEvent e) {
+			Engine.getActiveVPathway().pasteFromClipboad();
+		}
+	}
+	
+	static class NewElementAction extends AbstractAction implements VPathwayListener {
+		int element;
+		public NewElementAction(int type) {
+			super();
+			element = type;
+			
+			String descr = "";
+			URL imageURL = null;
+			switch(element) {
+			case VPathway.NEWLINE: 
+				descr = "Draw new line";
+				imageURL = Engine.getResourceURL("icons/newline.gif");
+				break;
+			case VPathway.NEWLINEARROW:
+				descr = "Draw new arrow";
+				imageURL = Engine.getResourceURL("icons/newarrow.gif");
+				break;
+			case VPathway.NEWLINEDASHED:
+				descr = "Draw new dashed line";
+				imageURL = Engine.getResourceURL("icons/newdashedline.gif");
+				break;
+			case VPathway.NEWLINEDASHEDARROW:
+				descr = "Draw new dashed arrow";
+				imageURL = Engine.getResourceURL("icons/newdashedarrow.gif");
+				break;
+			case VPathway.NEWLABEL:
+				descr = "Draw new label";
+				imageURL = Engine.getResourceURL("icons/newlabel.gif");
+				break;
+			case VPathway.NEWARC:
+				descr = "Draw new arc";
+				imageURL = Engine.getResourceURL("icons/newarc.gif");
+				break;
+			case VPathway.NEWBRACE:
+				descr = "Draw new brace";
+				imageURL = Engine.getResourceURL("icons/newbrace.gif");
+				break;
+			case VPathway.NEWGENEPRODUCT:
+				descr = "Draw new data node";
+				imageURL = Engine.getResourceURL("icons/newgeneproduct.gif");
+				break;
+			case VPathway.NEWRECTANGLE:
+				descr = "Draw new rectangle";
+				imageURL = Engine.getResourceURL("icons/newrectangle.gif");
+				break;
+			case VPathway.NEWOVAL:
+				descr = "Draw new oval";
+				imageURL = Engine.getResourceURL("icons/newoval.gif");
+				break;
+			case VPathway.NEWTBAR:
+				descr = "Draw new TBar";
+				imageURL = Engine.getResourceURL("icons/newtbar.gif");
+				break;
+			case VPathway.NEWRECEPTORROUND:
+				descr = "Draw new round receptor";
+				imageURL = Engine.getResourceURL("icons/newreceptorround.gif");
+				break;
+			case VPathway.NEWRECEPTORSQUARE:
+				descr = "Draw new square receptor";
+				imageURL = Engine.getResourceURL("icons/newreceptorsquare.gif");
+				break;
+			case VPathway.NEWLIGANDROUND:
+				descr = "Draw new round ligand";
+				imageURL = Engine.getResourceURL("icons/newligandround.gif");
+				break;
+			case VPathway.NEWLIGANDSQUARE:
+				descr = "Draw new square ligand";
+				imageURL = Engine.getResourceURL("icons/newligandsquare.gif");
+				break;
+			case VPathway.NEWLINEMENU:
+				imageURL = Engine.getResourceURL("icons/newlinemenu.gif");
+				descr = "Draw new line or arrow";
+				break;
+			case VPathway.NEWLINESHAPEMENU:
+				imageURL = Engine.getResourceURL("icons/newlineshapemenu.gif");
+				descr = "Draw new ligand or receptor";
+				break;
+			}
+			putValue(Action.SHORT_DESCRIPTION, descr);
+			putValue(Action.LONG_DESCRIPTION, descr);
+			if(imageURL != null) {
+				putValue(Action.SMALL_ICON, new ImageIcon(imageURL));
+			}
+		}
+		
+		public void actionPerformed(ActionEvent e) {
+			VPathway vp = Engine.getActiveVPathway();
+			vp.addVPathwayListener(this);
+			if(vp != null) {
+				vp.setNewGraphics(element);
+			}
+		}
+
+		public void vPathwayEvent(VPathwayEvent e) {
+			if(e.getType() == VPathwayEvent.NEW_ELEMENT_ADDED) {
+				e.getVPathway().setNewGraphics(VPathway.NEWNONE);
+				e.getVPathway().removeVPathwayListener(this);	
+			}
+		}
+	}
+}
Index: trunk/src/swing/org/pathvisio/gui/swing/GuiMain.java
===================================================================
--- trunk/src/swing/org/pathvisio/gui/swing/GuiMain.java	(revision 0)
+++ trunk/src/swing/org/pathvisio/gui/swing/GuiMain.java	(revision 957)
@@ -0,0 +1,42 @@
+package org.pathvisio.gui.swing;
+
+import javax.swing.JFrame;
+
+import org.pathvisio.Engine;
+import org.pathvisio.view.swing.VPathwaySwing;
+
+public class GuiMain {
+
+	private static void createAndShowGUI() {
+		GuiInit.init();
+		
+		//Create and set up the window.
+		JFrame frame = new JFrame("PathVisio...swing it baby!");
+		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+		
+		MainPanel mainPanel = SwingEngine.getApplicationPanel();
+		frame.add(mainPanel);
+		frame.setJMenuBar(mainPanel.getMenuBar());
+		frame.setSize(800, 600);
+		
+//		try {
+//		    UIManager.setLookAndFeel(
+//		        UIManager.getSystemLookAndFeelClassName());
+//		} catch (Exception ex) {
+//			Engine.log.error("Unable to load native look and feel", ex);
+//		}
+		
+		//Display the window.
+		frame.setVisible(true);
+		Engine.newPathway(new VPathwaySwing(mainPanel.getScrollPane()));
+		Engine.getActiveVPathway().setEditMode(true);
+	}
+
+	public static void main(String[] args) {
+		javax.swing.SwingUtilities.invokeLater(new Runnable() {
+			public void run() {
+				createAndShowGUI();
+			}
+		});
+	}
+}
Index: trunk/src/swing/org/pathvisio/gui/swing/AppletMain.java
===================================================================
--- trunk/src/swing/org/pathvisio/gui/swing/AppletMain.java	(revision 0)
+++ trunk/src/swing/org/pathvisio/gui/swing/AppletMain.java	(revision 957)
@@ -0,0 +1,22 @@
+package org.pathvisio.gui.swing;
+
+import javax.swing.JApplet;
+
+public class AppletMain extends JApplet {
+	public void init() {
+		super.init();
+		GuiInit.init();
+		MainPanel mainPanel = SwingEngine.getApplicationPanel();
+		add(mainPanel);
+	}
+	
+	public void start() {
+		// TODO Auto-generated method stub
+		super.start();
+	}
+	
+	public void stop() {
+		// TODO Auto-generated method stub
+		super.stop();
+	}
+}
Index: trunk/src/swing/org/pathvisio/gui/swing/SwingEngine.java
===================================================================
--- trunk/src/swing/org/pathvisio/gui/swing/SwingEngine.java	(revision 0)
+++ trunk/src/swing/org/pathvisio/gui/swing/SwingEngine.java	(revision 957)
@@ -0,0 +1,43 @@
+package org.pathvisio.gui.swing;
+
+import java.awt.Component;
+
+import javax.swing.JOptionPane;
+
+import org.pathvisio.Engine;
+import org.pathvisio.model.ConverterException;
+
+public class SwingEngine {
+	private static MainPanel mainPanel;
+	
+	public static MainPanel getApplicationPanel() {
+		if(mainPanel == null) mainPanel = new MainPanel();
+		return mainPanel;
+	}
+	
+	public static String MSG_UNABLE_IMPORT = "Unable to import GPML file.";
+	public static String MSG_UNABLE_EXPORT = "Unable to export GPML file.";
+	public static String MSG_UNABLE_SAVE = "Unable to save GPML file.";
+	public static String MSG_UNABLE_OPEN = "Unable to open GPML file.";
+	
+	public static void handleConverterException(String message, Component c, ConverterException e) {
+		if (e.getMessage().contains("Cannot find the declaration of element 'Pathway'"))
+		{
+			JOptionPane.showMessageDialog(c,
+					message + "\n\n" +
+					"The most likely cause for this error is that you are trying to open an old Gpml file. " +
+					"Please note that the Gpml format has changed as of March 2007. " +
+					"The standard pathway set can be re-downloaded from http://pathvisio.org " +
+					"Non-standard pathways need to be recreated or upgraded. " +
+					"Please contact the authors at martijn.vaniersel@bigcat.unimaas.nl if you need help with this.\n" +
+					"\nSee error log for details");
+			Engine.log.error("Unable to open Gpml file", e);
+		}
+		else
+		{
+			JOptionPane.showMessageDialog(c,
+					message + "\n" + e.getClass() + e.getMessage());
+			Engine.log.error("Unable to open Gpml file", e);
+		}
+	}
+}
Index: trunk/src/swing/org/pathvisio/view/swing/SwingKeyEvent.java
===================================================================
--- trunk/src/swing/org/pathvisio/view/swing/SwingKeyEvent.java	(revision 0)
+++ trunk/src/swing/org/pathvisio/view/swing/SwingKeyEvent.java	(revision 957)
@@ -0,0 +1,45 @@
+package org.pathvisio.view.swing;
+
+import java.awt.event.KeyEvent;
+
+public class SwingKeyEvent extends org.pathvisio.view.KeyEvent {
+	KeyEvent awtEvent;
+	
+	public SwingKeyEvent(KeyEvent e) {
+		super(e.getSource(), convertKeyCode(e), convertType(e), e.getModifiers());
+		awtEvent = e;
+		System.out.println(getKeyCode());
+	}
+	
+	protected static int convertKeyCode(KeyEvent e) {
+		if(e.getID() == KeyEvent.KEY_TYPED) {
+			return e.getKeyChar();
+		} else {
+			switch(e.getKeyCode()) {
+				case KeyEvent.VK_CONTROL:
+					return org.pathvisio.view.KeyEvent.CTRL;
+				case KeyEvent.VK_ALT:
+					return org.pathvisio.view.KeyEvent.ALT;
+				case KeyEvent.VK_DELETE:
+					return org.pathvisio.view.KeyEvent.DEL;
+				case KeyEvent.VK_SHIFT:
+					return org.pathvisio.view.KeyEvent.SHIFT;
+				case KeyEvent.VK_INSERT:
+					return org.pathvisio.view.KeyEvent.INSERT;
+				default:
+					return e.getKeyCode();
+			}
+		}
+	}
+	
+	protected static int convertType(KeyEvent e) {
+		switch(e.getID()) {
+		case KeyEvent.KEY_PRESSED:
+			return org.pathvisio.view.KeyEvent.KEY_PRESSED;
+		case KeyEvent.KEY_RELEASED:
+			return org.pathvisio.view.KeyEvent.KEY_RELEASED;
+		default:
+			throw new IllegalArgumentException("KeyEvent type not supported");
+		}
+	}
+}
Index: trunk/src/swing/org/pathvisio/view/swing/SwingMouseEvent.java
===================================================================
--- trunk/src/swing/org/pathvisio/view/swing/SwingMouseEvent.java	(revision 0)
+++ trunk/src/swing/org/pathvisio/view/swing/SwingMouseEvent.java	(revision 957)
@@ -0,0 +1,36 @@
+package org.pathvisio.view.swing;
+
+import java.awt.Point;
+import java.awt.event.MouseEvent;
+
+public class SwingMouseEvent extends org.pathvisio.view.MouseEvent {
+	MouseEvent awtEvent;
+	
+	public SwingMouseEvent(MouseEvent e) {
+		super(e.getSource(), convertType(e), e.getButton(), 
+				e.getX(), e.getY(), e.getClickCount(), e.getModifiers());
+		awtEvent = e;
+	}
+
+	protected static int convertType(MouseEvent e) {
+		if(e.isPopupTrigger()) return MOUSE_HOVER;
+
+		switch(e.getID()) {
+		case MouseEvent.MOUSE_ENTERED:
+			return org.pathvisio.view.MouseEvent.MOUSE_ENTER;
+		case MouseEvent.MOUSE_EXITED:
+			return org.pathvisio.view.MouseEvent.MOUSE_EXIT;
+		case MouseEvent.MOUSE_MOVED:
+		case MouseEvent.MOUSE_DRAGGED:
+			return org.pathvisio.view.MouseEvent.MOUSE_MOVE;
+		case MouseEvent.MOUSE_PRESSED:
+			return org.pathvisio.view.MouseEvent.MOUSE_DOWN;
+		case MouseEvent.MOUSE_RELEASED:
+			return org.pathvisio.view.MouseEvent.MOUSE_UP;
+		case MouseEvent.MOUSE_CLICKED:
+			return org.pathvisio.view.MouseEvent.MOUSE_CLICK;
+		default:
+			throw new IllegalArgumentException("Mouse event type not supported");
+		}
+	}
+}
Index: trunk/src/swing/org/pathvisio/view/swing/VPathwaySwing.java
===================================================================
--- trunk/src/swing/org/pathvisio/view/swing/VPathwaySwing.java	(revision 0)
+++ trunk/src/swing/org/pathvisio/view/swing/VPathwaySwing.java	(revision 957)
@@ -0,0 +1,126 @@
+package org.pathvisio.view.swing;
+
+import java.awt.Component;
+import java.awt.Dimension;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.Rectangle;
+import java.awt.event.KeyEvent;
+import java.awt.event.KeyListener;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseListener;
+import java.awt.event.MouseMotionListener;
+
+import javax.swing.JComponent;
+import javax.swing.JScrollPane;
+
+import org.pathvisio.gui.swing.SwingEngine;
+import org.pathvisio.view.VPathway;
+import org.pathvisio.view.VPathwayWrapper;
+
+public class VPathwaySwing extends JComponent implements VPathwayWrapper, MouseMotionListener, MouseListener, KeyListener {
+	VPathway child;
+	JScrollPane container;
+	
+	public VPathwaySwing(JScrollPane parent) {
+		super();
+		if(parent == null) throw new IllegalArgumentException("parent is null");
+		this.container = parent;
+		addMouseListener(this);
+		addMouseMotionListener(this);
+		addKeyListener(this);
+	}
+	
+	public void setChild(VPathway c) {
+		child = c;
+	}
+	
+	public Rectangle getVBounds() {
+		return getBounds();
+	}
+
+	public Dimension getVSize() {
+		System.out.println(getPreferredSize());
+		return getPreferredSize();
+	}
+
+	public Dimension getViewportSize() {
+		if(container instanceof JScrollPane) {
+			return ((JScrollPane)container).getViewport().getExtentSize();
+		}
+		return getSize();
+	}
+	
+	public void redraw() {
+		repaint();
+	}
+
+	protected void paintComponent(Graphics g) {
+		child.draw((Graphics2D)g);
+	}
+	
+	public void redraw(Rectangle r) {
+		repaint(r);
+	}
+
+	public void setVSize(Dimension size) {
+		setSize(size);
+		setMaximumSize(size);
+		setMinimumSize(size);
+		setPreferredSize(size);
+	}
+
+	public void setVSize(int w, int h) {
+		setVSize(new Dimension(w, h));
+	}
+
+	public void mouseClicked(MouseEvent arg0) {
+		//TODO: find out how to handle this one
+	}
+
+	public void mouseEntered(MouseEvent e) {
+		child.mouseEnter(new SwingMouseEvent(e));		
+	}
+
+	public void mouseExited(MouseEvent e) {
+		child.mouseExit(new SwingMouseEvent(e));
+		
+	}
+
+	public void mousePressed(MouseEvent e) {
+		child.mouseDown(new SwingMouseEvent(e));
+	}
+
+	public void mouseReleased(MouseEvent e) {
+		child.mouseUp(new SwingMouseEvent(e));
+	}
+
+	public void keyPressed(KeyEvent e) {
+		child.keyPressed(new SwingKeyEvent(e));
+		System.out.println("Key pressed........!");
+	}
+
+	public void keyReleased(KeyEvent e) {
+		child.keyReleased(new SwingKeyEvent(e));
+		System.out.println("Key released......!");
+	}
+
+	public void keyTyped(KeyEvent e) {
+		// TODO: find out how to handle this one
+		System.out.println("Key types.....!");
+	}
+
+	public void mouseDragged(MouseEvent e) {
+		child.mouseMove(new SwingMouseEvent(e));
+	}
+
+	public void mouseMoved(MouseEvent e) {
+		child.mouseMove(new SwingMouseEvent(e));
+	}
+
+	public VPathway createVPathway() {
+		setChild(new VPathway(this));
+		container.setViewportView(this);
+		return child;
+	}
+}
Index: trunk/src/swing/com/mammothsoftware/frwk/ddb/RolloverButton.java
===================================================================
--- trunk/src/swing/com/mammothsoftware/frwk/ddb/RolloverButton.java	(revision 0)
+++ trunk/src/swing/com/mammothsoftware/frwk/ddb/RolloverButton.java	(revision 957)
@@ -0,0 +1,113 @@
+// Copyright (C) 2005 Mammoth Software LLC
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+//
+// Contact the author at: info@mammothsoftware.com
+package com.mammothsoftware.frwk.ddb;
+
+import java.awt.Dimension;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseListener;
+
+import javax.swing.Action;
+import javax.swing.BorderFactory;
+import javax.swing.Icon;
+import javax.swing.JButton;
+import javax.swing.border.Border;
+import javax.swing.border.CompoundBorder;
+
+/**
+ * A button that uses a mouse listener to indicate rollover.
+ * 
+ * @author m. bangham
+ * Copyright 2005 Mammoth Software LLC
+ */
+public class RolloverButton extends JButton {
+	
+	public RolloverButton() {
+		init();
+		initRolloverListener();
+	}
+	
+	public RolloverButton(Icon icon, int size) {
+		super(icon);
+		init();
+		initRolloverListener();
+
+		setFixedSize(size);
+	}
+	
+	public RolloverButton(Icon icon, int size, boolean isRollover) {
+		super(icon);
+		init();
+		if (isRollover) initRolloverListener();
+		
+		setFixedSize(size);
+	}
+	
+	public RolloverButton(int size, boolean isRollover) {
+		super();
+		init();
+		if (isRollover) initRolloverListener();
+		
+		setFixedSize(size);
+	}
+	
+	public RolloverButton(Action action, int size) {
+		// Note: using setAction(action) causes both icon and text
+		// to be displayed on toolbar.
+		super((Icon)action.getValue(Action.SMALL_ICON));
+		init();
+		initRolloverListener();
+		addActionListener(action);
+		setFixedSize(size);
+	}
+
+	private void init() {
+		setRequestFocusEnabled(false);
+		setRolloverEnabled(true);
+	}
+	
+	protected void setFixedSize(int size) {
+		setPreferredSize(new Dimension(size, size));
+		setMaximumSize(new Dimension(size, size));
+		setMinimumSize(new Dimension(size, size));
+	}
+	
+	protected void initRolloverListener() {
+		MouseListener l = new MouseAdapter(){
+			Border curBorder = null;
+			public void mouseEntered(MouseEvent e) {
+				curBorder = getBorder();
+				/* Borders can have different insets - get the size and force it
+				 * so the new rollover border doesn't change the button size. */
+				setBorder(new CompoundBorder(getRolloverBorder(), curBorder));
+				getModel().setRollover(true);
+			}
+			public void mouseExited(MouseEvent e) {
+				setBorder(curBorder);
+				getModel().setRollover(false);
+			}
+		};
+		addMouseListener(l);
+	}
+	
+	protected Border getRolloverBorder() {
+		Border border = BorderFactory.createRaisedBevelBorder();
+		
+		return border;
+	}
+}
Index: trunk/src/swing/com/mammothsoftware/frwk/ddb/DropDownButton.java
===================================================================
--- trunk/src/swing/com/mammothsoftware/frwk/ddb/DropDownButton.java	(revision 0)
+++ trunk/src/swing/com/mammothsoftware/frwk/ddb/DropDownButton.java	(revision 957)
@@ -0,0 +1,241 @@
+// Copyright (C) 2005 Mammoth Software LLC
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+//
+// Contact the author at: info@mammothsoftware.com
+package com.mammothsoftware.frwk.ddb;
+
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.Dimension;
+import java.awt.Graphics;
+import java.awt.Insets;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseListener;
+
+import javax.swing.BorderFactory;
+import javax.swing.Icon;
+import javax.swing.JButton;
+import javax.swing.JMenuItem;
+import javax.swing.JPopupMenu;
+import javax.swing.JToolBar;
+import javax.swing.border.Border;
+import javax.swing.border.CompoundBorder;
+
+/**
+ * A Drop Down Button.
+ * 
+ * @author m. bangham
+ * Copyright 2005 Mammoth Software LLC
+ */
+public class DropDownButton extends JButton implements ActionListener {
+	private JPopupMenu popup = new JPopupMenu();
+	private JToolBar tb = new ToolBar();
+	private JButton mainButton;
+	private JButton arrowButton;
+	private ActionListener mainButtonListener = new ActionListener() {
+		public void actionPerformed(ActionEvent e) {
+			Component component = popup.getComponent(0);
+			if (component instanceof JMenuItem) {
+				JMenuItem item = (JMenuItem)component;
+				item.doClick(0);
+			}
+		}
+	};
+	
+	public DropDownButton(Icon icon) {
+		this();
+		mainButton = new RolloverButton(icon, 25, false);
+		arrowButton = new RolloverButton(new DownArrow(), 11, false);
+		init();
+	}
+	
+	public DropDownButton(Icon icon, int size) {
+		this();
+		mainButton = new RolloverButton(icon, size, false);
+		arrowButton = new RolloverButton(new DownArrow(), 11, false);
+		init();
+	}
+	
+	public DropDownButton(RolloverButton mainButton, RolloverButton arrowButton) {
+		this();
+		this.mainButton = mainButton;
+		this.arrowButton = arrowButton;
+		init();
+	}
+	
+	private DropDownButton() {
+		super();
+		setBorder(null);
+	}
+	
+	public void updateUI() {
+		super.updateUI();
+		setBorder(null);
+	}
+	
+	protected Border getRolloverBorder() {
+		return BorderFactory.createRaisedBevelBorder();
+	}
+	
+	private void initRolloverListener() {
+		MouseListener l = new MouseAdapter(){
+			Border mainBorder = null;
+			Border arrowBorder = null;
+			public void mouseEntered(MouseEvent e) {
+				mainBorder = mainButton.getBorder();
+				arrowBorder = mainButton.getBorder();
+				mainButton.setBorder(new CompoundBorder(getRolloverBorder(), mainBorder));
+				arrowButton.setBorder(new CompoundBorder(getRolloverBorder(), arrowBorder));
+				mainButton.getModel().setRollover(true);
+				arrowButton.getModel().setRollover(true);
+			}
+			public void mouseExited(MouseEvent e) {
+				mainButton.setBorder(mainBorder);
+				arrowButton.setBorder(arrowBorder);
+				mainButton.getModel().setRollover(false);
+				arrowButton.getModel().setRollover(false);
+			}
+		};
+		mainButton.addMouseListener(l);
+		arrowButton.addMouseListener(l);
+	}
+	
+	private void init() {
+		initRolloverListener();
+		
+      Icon disDownArrow = new DisabledDownArrow();
+      arrowButton.setDisabledIcon(disDownArrow);
+      arrowButton.setMaximumSize(new Dimension(11,100));
+      mainButton.addActionListener(this); 
+      arrowButton.addActionListener(this);
+      
+      setMargin(new Insets(0, 0, 0, 0));
+      
+      
+      // Windows draws border around buttons, but not toolbar buttons
+      // Using a toolbar keeps the look consistent.
+      tb.setBorder(null);
+      tb.setMargin(new Insets(0, 0, 0, 0));
+      tb.setFloatable(false);
+      tb.add(mainButton);
+      tb.add(arrowButton);
+      add(tb);
+      
+      setFixedSize(mainButton, arrowButton);
+  
+	}
+	/*
+	 * Forces the width of this button to be the sum of the widths of the main
+	 * button and the arrow button. The height is the max of the main button or
+	 * the arrow button.
+	 */
+	private void setFixedSize(JButton mainButton, JButton arrowButton) {
+      int width = (int)(mainButton.getPreferredSize().getWidth() +
+      					arrowButton.getPreferredSize().getWidth());
+      int height = (int)Math.max(mainButton.getPreferredSize().getHeight(),
+      					arrowButton.getPreferredSize().getHeight());
+
+      setMaximumSize(new Dimension(width, height));
+      setMinimumSize(new Dimension(width, height));
+      setPreferredSize(new Dimension(width, height));
+	}
+   
+	/**
+	 * Removes a component from the popup
+	 * @param component
+	 */
+	public void removeComponent(Component component) {
+		popup.remove(component);
+	}
+
+	/**
+	 * Adds a component to the popup
+	 * @param component
+	 * @return
+	 */
+	public Component addComponent(Component component) {
+		return popup.add(component);
+	}
+	
+	/**
+	 * Indicates that the first item in the menu should be executed
+	 * when the main button is clicked
+	 * @param isRunFirstItem True for on, false for off
+	 */
+	public void setRunFirstItem(boolean isRunFirstItem) {
+		mainButton.removeActionListener(this);
+		if (!isRunFirstItem) {
+			mainButton.addActionListener(this);
+		}
+		else
+			mainButton.addActionListener(mainButtonListener);
+	}
+	
+   /*------------------------------[ ActionListener ]---------------------------------------------------*/ 
+	 
+   public void actionPerformed(ActionEvent ae){ 
+        JPopupMenu popup = getPopupMenu(); 
+        popup.show(this, 0, this.getHeight()); 
+    } 
+   
+   protected JPopupMenu getPopupMenu() { return popup; }
+	
+   private static class DownArrow implements Icon {
+   	 
+      Color arrowColor = Color.black;
+
+      public void paintIcon(Component c, Graphics g, int x, int y) {
+          g.setColor(arrowColor);
+          g.drawLine(x, y, x+4, y);
+          g.drawLine(x+1, y+1, x+3, y+1);
+          g.drawLine(x+2, y+2, x+2, y+2);
+      }
+
+      public int getIconWidth() {
+          return 6;
+      }
+
+      public int getIconHeight() {
+          return 4;
+      }
+
+  }
+   
+   private static class DisabledDownArrow extends DownArrow {
+   	 
+      public DisabledDownArrow() {
+          arrowColor = new Color(140, 140, 140);
+      }
+
+      public void paintIcon(Component c, Graphics g, int x, int y) {
+          super.paintIcon(c, g, x, y);
+          g.setColor(Color.white);
+          g.drawLine(x+3, y+2, x+4, y+1);
+          g.drawLine(x+3, y+3, x+5, y+1);
+      }
+  }
+   
+   private static class ToolBar extends JToolBar {
+   	public void updateUI() {
+   		super.updateUI();
+   		setBorder(null);
+   	}
+   }
+
+}
Index: trunk/src/v2/org/pathvisio/R/wizard/RWizard.java
===================================================================
--- trunk/src/v2/org/pathvisio/R/wizard/RWizard.java	(revision 956)
+++ trunk/src/v2/org/pathvisio/R/wizard/RWizard.java	(revision 957)
@@ -25,12 +25,11 @@
 import org.eclipse.jface.wizard.Wizard;
 import org.eclipse.jface.wizard.WizardDialog;
 import org.eclipse.swt.widgets.Shell;
-
-import org.pathvisio.gui.swt.Engine;
-import org.pathvisio.util.SwtUtils.SimpleRunnableWithProgress;
+import org.pathvisio.Engine;
 import org.pathvisio.R.RDataIn;
 import org.pathvisio.R.RCommands.RException;
 import org.pathvisio.R.RCommands.RObjectContainer;
+import org.pathvisio.util.SwtUtils.SimpleRunnableWithProgress;
 
 
 public class RWizard extends Wizard {
Index: trunk/src/v2/org/pathvisio/R/wizard/PageData.java
===================================================================
--- trunk/src/v2/org/pathvisio/R/wizard/PageData.java	(revision 956)
+++ trunk/src/v2/org/pathvisio/R/wizard/PageData.java	(revision 957)
@@ -16,8 +16,6 @@
 //
 package org.pathvisio.R.wizard;
 
-import org.pathvisio.gui.swt.Engine;
-
 import java.io.File;
 import java.lang.reflect.InvocationTargetException;
 
@@ -39,13 +37,13 @@
 import org.eclipse.swt.widgets.Group;
 import org.eclipse.swt.widgets.Label;
 import org.eclipse.swt.widgets.Text;
-
-import org.pathvisio.preferences.Preferences;
+import org.pathvisio.Engine;
 import org.pathvisio.R.RCommands;
 import org.pathvisio.R.RDataIn;
 import org.pathvisio.R.RDataOut;
 import org.pathvisio.R.RCommands.RInterruptedException;
 import org.pathvisio.data.Gex;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
 
 public class PageData extends WizardPage {
 	RDataOut rDataOut;
@@ -186,7 +184,7 @@
 				DirectoryDialog fd = new DirectoryDialog(getShell());
 				String pwTxt = pwDir.getText();
 				fd.setFilterPath(pwTxt.equals("") ? 
-						Engine.getPreferences().getString(Preferences.PREF_DIR_PWFILES) : pwTxt);
+						SwtPreference.SWT_DIR_PWFILES.getValue() : pwTxt);
 				String dir = fd.open();
 				if(dir != null) pwDir.setText(dir);
 				checkPageComplete();
@@ -204,7 +202,7 @@
 			FileDialog fd = new FileDialog(getShell(), 
 					e.widget == exportBrowse ? SWT.SAVE : SWT.OPEN);
 			String expTxt = exportFile.getText();
-			fd.setFilterPath(expTxt.equals("") ? Engine.getPreferences().getString(Preferences.PREF_DIR_RDATA) : expTxt);
+			fd.setFilterPath(expTxt.equals("") ? SwtPreference.SWT_DIR_RDATA.getValue() : expTxt);
 			String file = fd.open();
 			if(file != null) {
 				if		(e.widget == exportBrowse) 	exportFile.setText(file);
Index: trunk/src/v2/org/pathvisio/R/wizard/PageStats.java
===================================================================
--- trunk/src/v2/org/pathvisio/R/wizard/PageStats.java	(revision 956)
+++ trunk/src/v2/org/pathvisio/R/wizard/PageStats.java	(revision 957)
@@ -17,8 +17,6 @@
 
 package org.pathvisio.R.wizard;
 
-import org.pathvisio.gui.swt.Engine;
-
 import java.text.SimpleDateFormat;
 import java.util.Calendar;
 import java.util.TimeZone;
@@ -36,12 +34,13 @@
 import org.eclipse.swt.widgets.Control;
 import org.eclipse.swt.widgets.Label;
 import org.eclipse.swt.widgets.Text;
-
-import org.pathvisio.util.SwtUtils.SimpleRunnableWithProgress;
+import org.pathvisio.Engine;
 import org.pathvisio.R.RController;
 import org.pathvisio.R.RFunctionLoader;
 import org.pathvisio.R.RCommands.RException;
 import org.pathvisio.R.RFunctionLoader.RFunction;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.util.SwtUtils.SimpleRunnableWithProgress;
 
 public class PageStats extends WizardPage {
 	String resultVar;
@@ -140,7 +139,7 @@
 	}
 	
 	protected void doSetTopToParent(final Control top) {
-		Engine.getWindow().getShell().getDisplay().asyncExec(new Runnable() {
+		SwtEngine.getWindow().getShell().getDisplay().asyncExec(new Runnable() {
 			public void run() {
 				((StackLayout)((Composite)getControl()).getLayout()).topControl = top.getParent();
 				((Composite)getControl()).layout();
Index: trunk/src/v2/org/pathvisio/R/RDataIn.java
===================================================================
--- trunk/src/v2/org/pathvisio/R/RDataIn.java	(revision 956)
+++ trunk/src/v2/org/pathvisio/R/RDataIn.java	(revision 957)
@@ -16,9 +16,6 @@
 //
 package org.pathvisio.R;
 
-import org.pathvisio.gui.swt.Engine;
-import org.pathvisio.gui.swt.TabbedSidePanel;
-
 import java.io.File;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -28,11 +25,12 @@
 
 import org.eclipse.swt.SWT;
 import org.eclipse.swt.custom.CTabItem;
-
-import org.pathvisio.util.tableviewer.PathwayTable;
-import org.pathvisio.util.tableviewer.TableData;
 import org.pathvisio.R.RCommands.RException;
 import org.pathvisio.R.RCommands.RObjectContainer;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.gui.swt.TabbedSidePanel;
+import org.pathvisio.util.tableviewer.PathwayTable;
+import org.pathvisio.util.tableviewer.TableData;
 
 public class RDataIn {
 	RObjectContainer inFileObjects;
@@ -99,7 +97,7 @@
 	}
 	
 	public static void displayResults(List<ResultSet> results, String tabName) {		
-		TabbedSidePanel sp = Engine.getWindow().getSidePanel();
+		TabbedSidePanel sp = SwtEngine.getWindow().getSidePanel();
 		
 		StatsResultTable srt = new StatsResultTable(sp.getTabFolder(), SWT.NULL);
 		srt.setResults(results);
Index: trunk/src/v2/org/pathvisio/R/RDataOut.java
===================================================================
--- trunk/src/v2/org/pathvisio/R/RDataOut.java	(revision 956)
+++ trunk/src/v2/org/pathvisio/R/RDataOut.java	(revision 957)
@@ -16,8 +16,6 @@
 //
 package org.pathvisio.R;
 
-import org.pathvisio.gui.swt.Engine;
-
 import java.io.File;
 import java.lang.reflect.InvocationTargetException;
 import java.sql.PreparedStatement;
@@ -29,17 +27,7 @@
 import java.util.List;
 
 import org.eclipse.jface.dialogs.ProgressMonitorDialog;
-import org.rosuda.JRI.REXP;
-import org.rosuda.JRI.RVector;
-import org.rosuda.JRI.Rengine;
-import org.xml.sax.XMLReader;
-import org.xml.sax.helpers.XMLReaderFactory;
-
-import org.pathvisio.util.FileUtils;
-import org.pathvisio.util.SwtUtils.SimpleRunnableWithProgress;
-import org.pathvisio.util.PathwayParser;
-import org.pathvisio.util.PathwayParser.Gene;
-import org.pathvisio.visualization.colorset.Criterion;
+import org.pathvisio.Engine;
 import org.pathvisio.R.RCommands.RException;
 import org.pathvisio.R.RCommands.RObjectContainer;
 import org.pathvisio.R.RCommands.RTemp;
@@ -48,6 +36,17 @@
 import org.pathvisio.data.Gex;
 import org.pathvisio.data.Gdb.IdCodePair;
 import org.pathvisio.data.Gex.Sample;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.util.FileUtils;
+import org.pathvisio.util.PathwayParser;
+import org.pathvisio.util.PathwayParser.Gene;
+import org.pathvisio.util.SwtUtils.SimpleRunnableWithProgress;
+import org.pathvisio.visualization.colorset.Criterion;
+import org.rosuda.JRI.REXP;
+import org.rosuda.JRI.RVector;
+import org.rosuda.JRI.Rengine;
+import org.xml.sax.XMLReader;
+import org.xml.sax.helpers.XMLReaderFactory;
 
 public class RDataOut {
 	List<File> pwFiles;
@@ -113,7 +112,7 @@
 	public void doExport() throws RException, InvocationTargetException, InterruptedException {
 		Rengine re = RController.getR();
 		
-		ProgressMonitorDialog dialog = new ProgressMonitorDialog(Engine.getWindow().getShell());
+		ProgressMonitorDialog dialog = new ProgressMonitorDialog(SwtEngine.getWindow().getShell());
 		SimpleRunnableWithProgress rwp = null;
 		try {
 			if(exportData) {
Index: trunk/src/v2/org/pathvisio/R/RController.java
===================================================================
--- trunk/src/v2/org/pathvisio/R/RController.java	(revision 956)
+++ trunk/src/v2/org/pathvisio/R/RController.java	(revision 957)
@@ -16,10 +16,6 @@
 //
 package org.pathvisio.R;
 
-import org.pathvisio.gui.swt.Engine;
-import org.pathvisio.gui.swt.Engine.ApplicationEvent;
-import org.pathvisio.gui.swt.Engine.ApplicationEventListener;
-
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -37,13 +33,16 @@
 import org.eclipse.jface.dialogs.MessageDialog;
 import org.eclipse.jface.dialogs.ProgressMonitorDialog;
 import org.eclipse.jface.operation.IRunnableWithProgress;
+import org.pathvisio.Engine;
+import org.pathvisio.Engine.ApplicationEvent;
+import org.pathvisio.Engine.ApplicationEventListener;
+import org.pathvisio.R.RCommands.RException;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.util.JarUtils;
+import org.pathvisio.util.Utils;
 import org.rosuda.JRI.REXP;
 import org.rosuda.JRI.Rengine;
 
-import org.pathvisio.util.JarUtils;
-import org.pathvisio.util.Utils;
-import org.pathvisio.R.RCommands.RException;
-
 public class RController implements ApplicationEventListener{	
 	private static Rengine re;
 	private static BufferedReader rOut;
@@ -65,7 +64,7 @@
 	public static boolean startR() {
 		//Start R-engine (with progress monitor)
 		try {
-			new ProgressMonitorDialog(Engine.getWindow().getShell()).run(true, true,
+			new ProgressMonitorDialog(SwtEngine.getWindow().getShell()).run(true, true,
 					new IRunnableWithProgress() {
 				public void run(IProgressMonitor m) throws 	InvocationTargetException, 
 				InterruptedException 
@@ -206,10 +205,10 @@
 	
 	private static String locateRExec() {
 		final StringBuilder cmd = new StringBuilder();
-		Engine.getWindow().getShell().getDisplay().syncExec(new Runnable() {
+		SwtEngine.getWindow().getShell().getDisplay().syncExec(new Runnable() {
 			public void run() {
 				String exec = Utils.getOS() == Utils.OS_WINDOWS ? "R.exe" : "R";
-				InputDialog libDialog = new InputDialog(Engine.getWindow().getShell(),
+				InputDialog libDialog = new InputDialog(SwtEngine.getWindow().getShell(),
 						"Unable to find R executable",
 						"Unable to locate " + exec + "\nPlease install R (" + WWW_R + ") " +
 						" or specify location:", "", null);
@@ -395,9 +394,9 @@
 	}
 		
 	public static void openError(final String msg, final Throwable e) {
-		Engine.getWindow().getShell().getDisplay().asyncExec(new Runnable() {
+		SwtEngine.getWindow().getShell().getDisplay().asyncExec(new Runnable() {
 			public void run() {
-				MessageDialog.openError(Engine.getWindow().getShell(), 
+				MessageDialog.openError(SwtEngine.getWindow().getShell(), 
 						ERR_MSG_PRE, (msg == null ? "" : msg + "\n \n Details:\n") + e.getMessage() + 
 						" (" + e.getClass().getName() + ")");
 			}
@@ -405,7 +404,7 @@
 	}
 		
 	public void applicationEvent(ApplicationEvent e) {
-		if(e.type == ApplicationEvent.CLOSE_APPLICATION) {
+		if(e.type == ApplicationEvent.APPLICATION_CLOSE) {
 			endR(); //End the R process
 			if(rOut != null) { //Close the R output file
 				try { 
Index: trunk/src/v2/org/pathvisio/R/StatsResultTable.java
===================================================================
--- trunk/src/v2/org/pathvisio/R/StatsResultTable.java	(revision 956)
+++ trunk/src/v2/org/pathvisio/R/StatsResultTable.java	(revision 957)
@@ -16,8 +16,6 @@
 //
 package org.pathvisio.R;
 
-import org.pathvisio.gui.swt.Engine;
-
 import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
@@ -36,12 +34,11 @@
 import org.eclipse.swt.widgets.FileDialog;
 import org.eclipse.swt.widgets.Group;
 import org.eclipse.swt.widgets.Label;
-
-import org.pathvisio.preferences.Preferences;
-import org.pathvisio.util.Utils;
-import org.pathvisio.util.tableviewer.PathwayTable;
 import org.pathvisio.R.RCommands.RException;
 import org.pathvisio.R.RDataIn.ResultSet;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.util.Utils;
+import org.pathvisio.util.tableviewer.PathwayTable;
 
 public class StatsResultTable extends PathwayTable {
 	List<ResultSet> results;
@@ -127,7 +124,7 @@
 		saveAsR.addSelectionListener(new SelectionAdapter() {
 			public void widgetSelected(SelectionEvent e) {
 				FileDialog fd = new FileDialog(getShell(), SWT.SAVE);
-				fd.setFilterPath(Engine.getPreferences().getString(Preferences.PREF_DIR_RDATA));
+				fd.setFilterPath(SwtPreference.SWT_DIR_RDATA.getValue());
 				String fn = fd.open();
 				if(fn == null) return;
 				try {
Index: trunk/src/v2/org/pathvisio/R/RFunctionLoader.java
===================================================================
--- trunk/src/v2/org/pathvisio/R/RFunctionLoader.java	(revision 956)
+++ trunk/src/v2/org/pathvisio/R/RFunctionLoader.java	(revision 957)
@@ -51,9 +51,9 @@
 import org.eclipse.swt.widgets.Label;
 import org.eclipse.swt.widgets.Shell;
 import org.eclipse.swt.widgets.Text;
+import org.pathvisio.Engine;
 import org.pathvisio.R.RCommands.RException;
 import org.pathvisio.R.wizard.RWizard;
-import org.pathvisio.gui.swt.Engine;
 import org.pathvisio.util.JarUtils;
 import org.pathvisio.util.Utils;
 import org.pathvisio.util.SwtUtils.SimpleRunnableWithProgress;
Index: trunk/src/v2/org/pathvisio/gui/swt/MainWindow.java
===================================================================
--- trunk/src/v2/org/pathvisio/gui/swt/MainWindow.java	(revision 956)
+++ trunk/src/v2/org/pathvisio/gui/swt/MainWindow.java	(revision 957)
@@ -37,6 +37,7 @@
 import org.eclipse.swt.widgets.Control;
 import org.eclipse.swt.widgets.FileDialog;
 import org.eclipse.swt.widgets.Shell;
+import org.pathvisio.Engine;
 import org.pathvisio.R.RController;
 import org.pathvisio.R.RDataIn;
 import org.pathvisio.R.RCommands.RException;
@@ -47,12 +48,8 @@
 import org.pathvisio.data.GexImportWizard;
 import org.pathvisio.data.Gex.ExpressionDataEvent;
 import org.pathvisio.data.Gex.ExpressionDataListener;
-import org.pathvisio.gui.swt.BackpagePanel;
-import org.pathvisio.gui.swt.Engine;
-import org.pathvisio.gui.swt.GuiMain;
-import org.pathvisio.gui.swt.PropertyPanel;
-import org.pathvisio.gui.swt.TabbedSidePanel;
-import org.pathvisio.preferences.Preferences;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
 import org.pathvisio.search.PathwaySearchComposite;
 import org.pathvisio.visualization.LegendPanel;
 import org.pathvisio.visualization.VisualizationDialog;
@@ -331,7 +328,7 @@
 		
 		public void run() {
 			FileDialog fd = new FileDialog(getShell(), SWT.OPEN);
-			fd.setFilterPath(Engine.getPreferences().getString(Preferences.PREF_DIR_RDATA));
+			fd.setFilterPath(SwtPreference.SWT_DIR_RDATA.getValue());
 			fd.setFilterNames(new String[] {"R data file"});
 			fd.setFilterExtensions(new String[] {"*.*"});
 			File file = new File(fd.open());
@@ -416,7 +413,7 @@
 		dataMenu.add(createGexAction);
 		dataMenu.add(colorSetManagerAction);
 		dataMenu.add(visualizationDialogAction);
-		if(Engine.USE_R) {
+		if(SwtEngine.USE_R) {
 			MenuManager statsMenu = new MenuManager("&Pathway statistics");
 			dataMenu.add(statsMenu);
 			statsMenu.add(rStatsAction);
@@ -475,7 +472,7 @@
 		
 		GuiMain.loadImages(shell.getDisplay());
 		
-		shell.setImage(Engine.getImageRegistry().get("shell.icon"));
+		shell.setImage(SwtEngine.getImageRegistry().get("shell.icon"));
 		
 		Composite viewComposite = new Composite(parent, SWT.NULL);
 		viewComposite.setLayout(new FillLayout());
@@ -501,16 +498,16 @@
 		rightPanel.addTab(legend, "Legend");
 		rightPanel.addTab(visPanel, "Visualization");
 		
-		int sidePanelSize = Engine.getPreferences().getInt(Preferences.PREF_SIDEPANEL_SIZE);
+		int sidePanelSize = GlobalPreference.getValueInt(SwtPreference.SWT_SIDEPANEL_SIZE);
 		sashForm.setWeights(new int[] {100 - sidePanelSize, sidePanelSize});
 		showRightPanelAction.setChecked(sidePanelSize > 0);
 		
 		rightPanel.getTabFolder().setSelection(0); //select backpage browser tab
 		rightPanel.hideTab("Legend"); //hide legend on startup
 		
-		setStatus("Using Gene Database: '" + Engine.getPreferences().getString(Preferences.PREF_CURR_GDB) + "'");
+		setStatus("Using Gene Database: '" + SwtPreference.SWT_CURR_GDB.getValue() + "'");
 
-		Engine.updateTitle();
+		SwtEngine.updateTitle();
 		
 		return parent;		
 	};
Index: trunk/src/core/org/pathvisio/model/Color.java
===================================================================
--- trunk/src/core/org/pathvisio/model/Color.java	(revision 956)
+++ trunk/src/core/org/pathvisio/model/Color.java	(revision 957)
@@ -1,28 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.model;
-
-public class Color 
-{
-	public int red, green, blue;
-	public Color(int r, int g, int b) 
-	{
-		red = r;
-		green = g;
-		blue = b;
-	}
-}
Index: trunk/src/core/org/pathvisio/model/PathwayImporter.java
===================================================================
--- trunk/src/core/org/pathvisio/model/PathwayImporter.java	(revision 956)
+++ trunk/src/core/org/pathvisio/model/PathwayImporter.java	(revision 957)
@@ -16,7 +16,7 @@
 //
 package org.pathvisio.model;
 
-import java.io.File;
+import java.io.File;
 
 public interface PathwayImporter {
 	public String getName();
Index: trunk/src/core/org/pathvisio/model/PathwayExporter.java
===================================================================
--- trunk/src/core/org/pathvisio/model/PathwayExporter.java	(revision 956)
+++ trunk/src/core/org/pathvisio/model/PathwayExporter.java	(revision 957)
@@ -16,7 +16,7 @@
 //
 package org.pathvisio.model;
 
-import java.io.File;
+import java.io.File;
 
 public interface PathwayExporter {
 	public String getName();
Index: trunk/src/core/org/pathvisio/model/MappFormat.java
===================================================================
--- trunk/src/core/org/pathvisio/model/MappFormat.java	(revision 956)
+++ trunk/src/core/org/pathvisio/model/MappFormat.java	(revision 957)
@@ -33,8 +33,8 @@
 import java.util.List;
 import java.util.Map;
 
+import org.pathvisio.Engine;
 import org.pathvisio.data.DataSources;
-import org.pathvisio.gui.swt.Engine;
 
 /**
  * The class MappFormat is responsible for all interaction with 
Index: trunk/src/core/org/pathvisio/model/LineStyle.java
===================================================================
--- trunk/src/core/org/pathvisio/model/LineStyle.java	(revision 956)
+++ trunk/src/core/org/pathvisio/model/LineStyle.java	(revision 957)
@@ -16,7 +16,14 @@
 //
 package org.pathvisio.model;
 
+import java.util.ArrayList;
+import java.util.List;
+
 public class LineStyle {
 	public static final int SOLID = 0;
 	public static final int DASHED = 1;
+	
+	public static String[] getNames() {
+		return new String[] {"Solid", "Dashed"};
+	}
 }
Index: trunk/src/core/org/pathvisio/model/GpmlFormat.java
===================================================================
--- trunk/src/core/org/pathvisio/model/GpmlFormat.java	(revision 956)
+++ trunk/src/core/org/pathvisio/model/GpmlFormat.java	(revision 957)
@@ -16,6 +16,8 @@
 //
 package org.pathvisio.model;
 
+import java.awt.Color;
+import java.io.File;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -29,8 +31,7 @@
 import org.jdom.Document;
 import org.jdom.Element;
 import org.jdom.Namespace;
-import org.jdom.filter.Filter;
-import org.pathvisio.gui.swt.Engine;
+import org.pathvisio.Engine;
 
 /**
  * class responsible for interaction with Gpml format.
@@ -41,7 +42,7 @@
  * @author Martijn
  *
  */
-public class GpmlFormat 
+public class GpmlFormat implements PathwayImporter, PathwayExporter
 {
 	public static final Namespace GPML = Namespace.getNamespace("http://genmapp.org/GPML/2007");
 	public static final Namespace RDF = Namespace.getNamespace("rdf", "http://www.w3.org/1999/02/22-rdf-syntax-ns#");
@@ -972,9 +973,9 @@
 	 */
 	public static String color2HexBin(Color color)
 	{
-		String red = padding(Integer.toBinaryString(color.red), 8, '0');
-		String green = padding(Integer.toBinaryString(color.green), 8, '0');
-		String blue = padding(Integer.toBinaryString(color.blue), 8, '0');
+		String red = padding(Integer.toBinaryString(color.getRed()), 8, '0');
+		String green = padding(Integer.toBinaryString(color.getGreen()), 8, '0');
+		String blue = padding(Integer.toBinaryString(color.getBlue()), 8, '0');
 		String hexBinary = Integer.toHexString(Integer.valueOf(red + green + blue, 2));
 		return padding(hexBinary, 6, '0');
 	}
@@ -1020,4 +1021,20 @@
 			"Maroon", "Navy", "Olive", "Purple", "Red", "Silver", "Teal",
 			"White", "Yellow", "Transparent"
 		});
+
+	public void doImport(File file, Pathway pathway) throws ConverterException {
+		pathway.readFromXml(file, true);
 }
+	public void doExport(File file, Pathway pathway) throws ConverterException {
+		pathway.writeToXml(file, true);
+	}
+	
+	public String[] getExtensions() {
+		return new String[] { "gpml", "xml" };
+	}
+
+	public String getName() {
+		return "GPML file";
+	}
+
+}
\ No newline at end of file
Index: trunk/src/core/org/pathvisio/model/SvgFormat.java
===================================================================
--- trunk/src/core/org/pathvisio/model/SvgFormat.java	(revision 956)
+++ trunk/src/core/org/pathvisio/model/SvgFormat.java	(revision 957)
@@ -16,6 +16,7 @@
 //
 package org.pathvisio.model;
 
+import java.awt.Color;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
@@ -256,7 +257,7 @@
 	}
 	
 	static String rgb2String(Color rgb) {
-		return "rgb(" + rgb.red + "," + rgb.green + "," + rgb.blue + ")";
+		return "rgb(" + rgb.getRed() + "," + rgb.getGreen() + "," + rgb.getBlue() + ")";
 	}
 	
 	static int toPixel(double coordinate) {
Index: trunk/src/core/org/pathvisio/model/ImageExporter.java
===================================================================
--- trunk/src/core/org/pathvisio/model/ImageExporter.java	(revision 956)
+++ trunk/src/core/org/pathvisio/model/ImageExporter.java	(revision 957)
@@ -16,20 +16,20 @@
 //
 package org.pathvisio.model;
 
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.OutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.OutputStream;
+
+import org.apache.batik.transcoder.Transcoder;
+import org.apache.batik.transcoder.TranscoderInput;
+import org.apache.batik.transcoder.TranscoderOutput;
+import org.apache.batik.transcoder.image.ImageTranscoder;
+import org.apache.batik.transcoder.image.PNGTranscoder;
+import org.apache.batik.transcoder.image.TIFFTranscoder;
+import org.jdom.Document;
+import org.jdom.JDOMException;
+import org.jdom.output.DOMOutputter;
 
-import org.apache.batik.transcoder.Transcoder;
-import org.apache.batik.transcoder.TranscoderInput;
-import org.apache.batik.transcoder.TranscoderOutput;
-import org.apache.batik.transcoder.image.ImageTranscoder;
-import org.apache.batik.transcoder.image.PNGTranscoder;
-import org.apache.batik.transcoder.image.TIFFTranscoder;
-import org.jdom.Document;
-import org.jdom.JDOMException;
-import org.jdom.output.DOMOutputter;
-
 public class ImageExporter implements PathwayExporter {
 	public static final int TYPE_PNG = 0;
 	public static final int TYPE_TIFF = 1;
Index: trunk/src/core/org/pathvisio/model/ConvertType.java
===================================================================
--- trunk/src/core/org/pathvisio/model/ConvertType.java	(revision 956)
+++ trunk/src/core/org/pathvisio/model/ConvertType.java	(revision 957)
@@ -16,6 +16,7 @@
 //
 package org.pathvisio.model;
 
+import java.awt.Color;
 import java.math.BigDecimal;
 
 public class ConvertType
@@ -102,7 +103,7 @@
     		return "-1";
     	else
     	{
-	    	int c = ((int)rgb.red) + ((int)rgb.green << 8) + ((int)rgb.blue << 16);
+	    	int c = (rgb.getRed()) + (rgb.getGreen() << 8) + (rgb.getBlue() << 16);
 	    	return "" + c;
     	}
     }
Index: trunk/src/core/org/pathvisio/model/PathwayElement.java
===================================================================
--- trunk/src/core/org/pathvisio/model/PathwayElement.java	(revision 956)
+++ trunk/src/core/org/pathvisio/model/PathwayElement.java	(revision 957)
@@ -16,6 +16,7 @@
 //
 package org.pathvisio.model;
 
+import java.awt.Color;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashSet;
Index: trunk/src/core/org/pathvisio/model/LineType.java
===================================================================
--- trunk/src/core/org/pathvisio/model/LineType.java	(revision 956)
+++ trunk/src/core/org/pathvisio/model/LineType.java	(revision 957)
@@ -16,7 +16,9 @@
 //
 package org.pathvisio.model;
 
+import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 
 public enum LineType 
@@ -58,4 +60,15 @@
 	{
 		return gpmlMapping.get (value);
 	}
+	
+	static public String[] getNames()
+	{
+		List<String> result = new ArrayList<String>();		
+		for (LineType l : LineType.values())
+		{
+			result.add("" + l.gpmlName);
+		}
+		String [] resultArray = new String [result.size()];
+		return result.toArray(resultArray);
+	}
 }
Index: trunk/src/core/org/pathvisio/model/OrientationType.java
===================================================================
--- trunk/src/core/org/pathvisio/model/OrientationType.java	(revision 956)
+++ trunk/src/core/org/pathvisio/model/OrientationType.java	(revision 957)
@@ -46,4 +46,7 @@
 		return (String)orientationMappings.get(value);
 	}
 
+	public static String[] getNames() {
+		return new String[] {"Top", "Right", "Bottom", "Left"};
+	}
 }
Index: trunk/src/core/org/pathvisio/visualization/Visualization.java
===================================================================
--- trunk/src/core/org/pathvisio/visualization/Visualization.java	(revision 956)
+++ trunk/src/core/org/pathvisio/visualization/Visualization.java	(revision 957)
@@ -38,17 +38,16 @@
 import org.eclipse.swt.widgets.Listener;
 import org.eclipse.swt.widgets.Shell;
 import org.jdom.Element;
-
+import org.pathvisio.Engine;
+import org.pathvisio.data.Gex;
+import org.pathvisio.data.Gex.ExpressionDataEvent;
+import org.pathvisio.data.Gex.ExpressionDataListener;
 import org.pathvisio.util.Utils;
+import org.pathvisio.view.Graphics;
 import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
 import org.pathvisio.visualization.VisualizationManager.VisualizationListener;
 import org.pathvisio.visualization.plugins.PluginManager;
 import org.pathvisio.visualization.plugins.VisualizationPlugin;
-import org.pathvisio.data.Gex;
-import org.pathvisio.data.Gex.ExpressionDataEvent;
-import org.pathvisio.data.Gex.ExpressionDataListener;
-import org.pathvisio.gui.swt.Engine;
-import org.pathvisio.view.Graphics;
 
 /**
  * Represents a set of configured visualization plugins
Index: trunk/src/core/org/pathvisio/visualization/VisualizationDialog.java
===================================================================
--- trunk/src/core/org/pathvisio/visualization/VisualizationDialog.java	(revision 956)
+++ trunk/src/core/org/pathvisio/visualization/VisualizationDialog.java	(revision 957)
@@ -63,14 +63,14 @@
 import org.eclipse.swt.widgets.TableColumn;
 import org.eclipse.swt.widgets.TableItem;
 import org.eclipse.swt.widgets.Text;
-
-import org.pathvisio.gui.swt.Engine;
+import org.pathvisio.Engine;
+import org.pathvisio.data.Gex;
+import org.pathvisio.gui.swt.SwtEngine;
 import org.pathvisio.util.TableColumnResizer;
 import org.pathvisio.util.Utils;
 import org.pathvisio.visualization.Visualization.PluginSet;
 import org.pathvisio.visualization.colorset.ColorSetComposite;
 import org.pathvisio.visualization.plugins.PluginManager;
-import org.pathvisio.data.Gex;
 
 /**
  * Dialog to configure visualizations
@@ -577,9 +577,9 @@
 	}
 	
 	class PluginTableLabelProvider implements ITableLabelProvider {
-		final Image checkTrue = Engine.getImageRegistry().get("checkbox.checked");
-		final Image checkFalse = Engine.getImageRegistry().get("checkbox.unchecked");
-		final Image checkUnavailable = Engine.getImageRegistry().get("checkbox.unavailable");
+		final Image checkTrue = SwtEngine.getImageRegistry().get("checkbox.checked");
+		final Image checkFalse = SwtEngine.getImageRegistry().get("checkbox.unchecked");
+		final Image checkUnavailable = SwtEngine.getImageRegistry().get("checkbox.unavailable");
 		
 		public String getColumnText(Object element, int columnIndex) {
 			PluginSet ps = (PluginSet)element;
Index: trunk/src/core/org/pathvisio/visualization/plugins/PluginManager.java
===================================================================
--- trunk/src/core/org/pathvisio/visualization/plugins/PluginManager.java	(revision 956)
+++ trunk/src/core/org/pathvisio/visualization/plugins/PluginManager.java	(revision 957)
@@ -36,13 +36,13 @@
 import org.jdom.input.SAXBuilder;
 import org.jdom.output.Format;
 import org.jdom.output.XMLOutputter;
-
-import org.pathvisio.gui.swt.Engine;
+import org.pathvisio.Engine;
+import org.pathvisio.data.Gex;
+import org.pathvisio.gui.swt.SwtEngine;
 import org.pathvisio.util.Utils;
 import org.pathvisio.visualization.Visualization;
 import org.pathvisio.visualization.VisualizationManager;
 import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
-import org.pathvisio.data.Gex;
 
 public abstract class PluginManager {
 	static final String PLUGIN_PKG = "org.pathvisio.visualization.plugins";
@@ -156,7 +156,7 @@
 	
 	static Document getAdditionalXML() {
 		if(addDoc == null) {
-			File f = new File(Engine.getApplicationDir(), FILE_ADD_PLUGINS);
+			File f = new File(SwtEngine.getApplicationDir(), FILE_ADD_PLUGINS);
 			if(!f.exists()) {
 				return createXML();
 			} else {
@@ -226,7 +226,7 @@
 	static void saveXML(Document doc) {
 		XMLOutputter out = new XMLOutputter(Format.getPrettyFormat());
 		try {
-			FileWriter fw = new FileWriter(new File(Engine.getApplicationDir(), FILE_ADD_PLUGINS));
+			FileWriter fw = new FileWriter(new File(SwtEngine.getApplicationDir(), FILE_ADD_PLUGINS));
 			out.output(doc, fw);
 			fw.close();
 		} catch(IOException e) {
Index: trunk/src/core/org/pathvisio/visualization/colorset/ColorSet.java
===================================================================
--- trunk/src/core/org/pathvisio/visualization/colorset/ColorSet.java	(revision 956)
+++ trunk/src/core/org/pathvisio/visualization/colorset/ColorSet.java	(revision 957)
@@ -24,10 +24,11 @@
 import org.eclipse.jface.dialogs.MessageDialog;
 import org.eclipse.swt.graphics.RGB;
 import org.jdom.Element;
-
-import org.pathvisio.gui.swt.Engine;
-import org.pathvisio.preferences.swt.Preferences;
+import org.pathvisio.Engine;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.preferences.GlobalPreference;
 import org.pathvisio.util.ColorConverter;
+import org.pathvisio.util.SwtUtils;
 import org.pathvisio.visualization.VisualizationManager;
 import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
 
@@ -40,9 +41,9 @@
 	public static final int ID_COLOR_NO_GENE_FOUND = 2;
 	public static final int ID_COLOR_NO_DATA_FOUND = 3;
 	
-	RGB color_no_criteria_met = Preferences.getColorProperty(Preferences.PREF_COL_NO_CRIT_MET);
-	RGB color_no_gene_found = Preferences.getColorProperty(Preferences.PREF_COL_NO_GENE_FOUND);
-	RGB color_no_data_found = Preferences.getColorProperty(Preferences.PREF_COL_NO_DATA_FOUND);
+	RGB color_no_criteria_met = SwtUtils.color2rgb(GlobalPreference.getValueColor(GlobalPreference.COLOR_NO_CRIT_MET));
+	RGB color_no_gene_found = SwtUtils.color2rgb(GlobalPreference.getValueColor(GlobalPreference.COLOR_NO_GENE_FOUND));
+	RGB color_no_data_found = SwtUtils.color2rgb(GlobalPreference.getValueColor(GlobalPreference.COLOR_NO_DATA_FOUND));
 		
 	String name;
 	
@@ -177,9 +178,9 @@
 		Element elm = new Element(XML_ELEMENT);
 		elm.setAttribute(XML_ATTR_NAME, name);
 		
-		elm.addContent(ColorConverter.createColorElement(XML_ELM_COLOR_NCM, color_no_criteria_met));
-		elm.addContent(ColorConverter.createColorElement(XML_ELM_COLOR_NGF, color_no_gene_found));
-		elm.addContent(ColorConverter.createColorElement(XML_ELM_COLOR_NDF, color_no_data_found));
+		elm.addContent(ColorConverter.createColorElement(XML_ELM_COLOR_NCM, SwtUtils.rgb2color(color_no_criteria_met)));
+		elm.addContent(ColorConverter.createColorElement(XML_ELM_COLOR_NGF, SwtUtils.rgb2color(color_no_gene_found)));
+		elm.addContent(ColorConverter.createColorElement(XML_ELM_COLOR_NDF, SwtUtils.rgb2color(color_no_data_found)));
 		
 		for(ColorSetObject cso : colorSetObjects)
 			elm.addContent(cso.toXML());
@@ -197,11 +198,11 @@
 				else if(name.equals(ColorCriterion.XML_ELEMENT_NAME))
 					cs.addObject(new ColorCriterion(cs, elm));
 				else if(name.equals(XML_ELM_COLOR_NCM))
-					cs.setColor(ID_COLOR_NO_CRITERIA_MET, ColorConverter.parseColorElement(elm));
+					cs.setColor(ID_COLOR_NO_CRITERIA_MET, SwtUtils.color2rgb(ColorConverter.parseColorElement(elm)));
 				else if(name.equals(XML_ELM_COLOR_NGF))
-					cs.setColor(ID_COLOR_NO_GENE_FOUND, ColorConverter.parseColorElement(elm));
+					cs.setColor(ID_COLOR_NO_GENE_FOUND, SwtUtils.color2rgb(ColorConverter.parseColorElement(elm)));
 				else if(name.equals(XML_ELM_COLOR_NDF))
-					cs.setColor(ID_COLOR_NO_DATA_FOUND, ColorConverter.parseColorElement(elm));
+					cs.setColor(ID_COLOR_NO_DATA_FOUND, SwtUtils.color2rgb(ColorConverter.parseColorElement(elm)));
 			} catch(Exception ex) {
 				Engine.log.error("Unable to parse colorset xml", ex);
 			}
@@ -212,7 +213,7 @@
 	static void printParseError(String criterion, Exception e) {
 		Engine.log.error("Unable to parse colorset data stored in " +
 				"expression database: " + criterion, e);
-		MessageDialog.openWarning(Engine.getWindow().getShell(), 
+		MessageDialog.openWarning(SwtEngine.getWindow().getShell(), 
 					"Warning", "Unable to parse the colorset data in this expression dataset");
 	}
 	
Index: trunk/src/core/org/pathvisio/visualization/colorset/ColorGradient.java
===================================================================
--- trunk/src/core/org/pathvisio/visualization/colorset/ColorGradient.java	(revision 956)
+++ trunk/src/core/org/pathvisio/visualization/colorset/ColorGradient.java	(revision 957)
@@ -45,9 +45,9 @@
 import org.eclipse.swt.widgets.TableColumn;
 import org.eclipse.swt.widgets.TableItem;
 import org.jdom.Element;
-
-import org.pathvisio.gui.swt.Engine;
+import org.pathvisio.Engine;
 import org.pathvisio.util.ColorConverter;
+import org.pathvisio.util.SwtUtils;
 import org.pathvisio.util.TableColumnResizer;
 
 /**
@@ -215,7 +215,7 @@
 		
 		public ColorValuePair(Element xml) {
 			Object o = xml.getChildren(XML_ELM_COLOR).get(0);
-			color = ColorConverter.parseColorElement((Element)o);
+			color = SwtUtils.color2rgb(ColorConverter.parseColorElement((Element)o));
 			value = Double.parseDouble(xml.getAttributeValue(XML_ATTR_VALUE));
 		}
 		
@@ -239,7 +239,7 @@
 		public Element toXML() {
 			Element elm = new Element(XML_ELEMENT);
 			elm.setAttribute(XML_ATTR_VALUE, Double.toString(value));
-			elm.addContent(ColorConverter.createColorElement(XML_ELM_COLOR, color));
+			elm.addContent(ColorConverter.createColorElement(XML_ELM_COLOR, SwtUtils.rgb2color(color)));
 			return elm;
 		}
 	}
Index: trunk/src/core/org/pathvisio/visualization/colorset/ColorCriterion.java
===================================================================
--- trunk/src/core/org/pathvisio/visualization/colorset/ColorCriterion.java	(revision 956)
+++ trunk/src/core/org/pathvisio/visualization/colorset/ColorCriterion.java	(revision 957)
@@ -32,8 +32,7 @@
 import org.eclipse.swt.widgets.Listener;
 import org.eclipse.swt.widgets.Text;
 import org.jdom.Element;
-
-import org.pathvisio.gui.swt.Engine;
+import org.pathvisio.Engine;
 import org.pathvisio.util.ColorConverter;
 import org.pathvisio.util.SwtUtils;
 
@@ -78,7 +77,7 @@
 			criterion = new Criterion();
 			criterion.setExpression(expression);
 			Element ce = xml.getChild(XML_ELM_COLOR);
-			if(ce != null) color = ColorConverter.parseColorElement(ce);
+			if(ce != null) color = SwtUtils.color2rgb(ColorConverter.parseColorElement(ce));
 		} catch(Exception e) {
 			Engine.log.error("Unable to load ColorCriterion", e);
 		}
@@ -88,7 +87,7 @@
 	static final String XML_ATTR_EXPRESSION = "expression";
 	public Element toXML() {
 		Element elm = super.toXML();
-		Element ce = ColorConverter.createColorElement(XML_ELM_COLOR, getColor());
+		Element ce = ColorConverter.createColorElement(XML_ELM_COLOR, SwtUtils.rgb2color(getColor()));
 		elm.addContent(ce);
 		elm.setAttribute(XML_ATTR_EXPRESSION, criterion.getExpression());
 		
Index: trunk/src/core/org/pathvisio/visualization/colorset/Criterion.java
===================================================================
--- trunk/src/core/org/pathvisio/visualization/colorset/Criterion.java	(revision 956)
+++ trunk/src/core/org/pathvisio/visualization/colorset/Criterion.java	(revision 957)
@@ -19,12 +19,11 @@
 import java.util.HashMap;
 
 import org.eclipse.swt.widgets.Composite;
-
-import org.pathvisio.gui.swt.Engine;
-import org.pathvisio.visualization.VisualizationManager;
-import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+import org.pathvisio.Engine;
 import org.pathvisio.data.Gex;
 import org.pathvisio.data.Gex.Sample;
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
 
 public class Criterion {
 	static final String displaySample = "|Displayed sample|";
Index: trunk/src/core/org/pathvisio/visualization/VisualizationManager.java
===================================================================
--- trunk/src/core/org/pathvisio/visualization/VisualizationManager.java	(revision 956)
+++ trunk/src/core/org/pathvisio/visualization/VisualizationManager.java	(revision 957)
@@ -43,16 +43,16 @@
 import org.jdom.input.SAXBuilder;
 import org.jdom.output.Format;
 import org.jdom.output.XMLOutputter;
-
-import org.pathvisio.gui.swt.Engine;
-import org.pathvisio.gui.swt.Engine.ApplicationEvent;
-import org.pathvisio.gui.swt.Engine.ApplicationEventListener;
+import org.pathvisio.Engine;
+import org.pathvisio.Engine.ApplicationEvent;
+import org.pathvisio.Engine.ApplicationEventListener;
+import org.pathvisio.data.Gex;
+import org.pathvisio.data.Gex.ExpressionDataEvent;
+import org.pathvisio.data.Gex.ExpressionDataListener;
+import org.pathvisio.gui.swt.SwtEngine;
 import org.pathvisio.view.Graphics;
 import org.pathvisio.view.SelectionBox;
 import org.pathvisio.view.SelectionBox.SelectionListener;
-import org.pathvisio.data.Gex;
-import org.pathvisio.data.Gex.ExpressionDataEvent;
-import org.pathvisio.data.Gex.ExpressionDataListener;
 
 /**
  * Manages visualizations
@@ -204,7 +204,7 @@
 	}
 	
 	static File getGenericFile() {
-		return new File(Engine.getApplicationDir(), FILENAME_GENERIC);
+		return new File(SwtEngine.getApplicationDir(), FILENAME_GENERIC);
 	}
 	
 	static VisComboItem visComboItem = new VisComboItem("VisualizationCombo");
@@ -365,7 +365,7 @@
 	}
 	
 	public void applicationEvent(ApplicationEvent e) {
-		if(e.type == ApplicationEvent.CLOSE_APPLICATION) {
+		if(e.type == ApplicationEvent.APPLICATION_CLOSE) {
 			saveGeneric();
 		}		
 	}
Index: trunk/src/core/org/pathvisio/visualization/LegendPanel.java
===================================================================
--- trunk/src/core/org/pathvisio/visualization/LegendPanel.java	(revision 956)
+++ trunk/src/core/org/pathvisio/visualization/LegendPanel.java	(revision 957)
@@ -45,7 +45,7 @@
 import org.eclipse.swt.widgets.Control;
 import org.eclipse.swt.widgets.Group;
 import org.eclipse.swt.widgets.Label;
-import org.pathvisio.gui.swt.Engine;
+import org.pathvisio.gui.swt.SwtEngine;
 import org.pathvisio.util.SwtUtils;
 import org.pathvisio.visualization.LegendPanel.CollapseGroup.CollapseListener;
 import org.pathvisio.visualization.Visualization.PluginSet;
@@ -726,7 +726,7 @@
 				gd.heightHint = computeSize(SWT.DEFAULT, SWT.DEFAULT).y;
 			}
 			layout();
-			switchLabel.setImage(Engine.getImageRegistry().get(
+			switchLabel.setImage(SwtEngine.getImageRegistry().get(
 					expanded ? "tree.expanded" : "tree.collapsed"));
 		}
 		
Index: trunk/src/core/org/pathvisio/biopax/gui/BiopaxDialog.java
===================================================================
--- trunk/src/core/org/pathvisio/biopax/gui/BiopaxDialog.java	(revision 956)
+++ trunk/src/core/org/pathvisio/biopax/gui/BiopaxDialog.java	(revision 957)
@@ -26,7 +26,7 @@
 import org.eclipse.swt.widgets.Shell;
 import org.eclipse.swt.widgets.Text;
 import org.pathvisio.biopax.BiopaxManager;
-import org.pathvisio.gui.swt.Engine;
+import org.pathvisio.Engine;
 import org.pathvisio.model.ConverterException;
 import org.pathvisio.model.Pathway;
 
Index: trunk/src/core/org/pathvisio/biopax/gui/BiopaxCellEditor.java
===================================================================
--- trunk/src/core/org/pathvisio/biopax/gui/BiopaxCellEditor.java	(revision 956)
+++ trunk/src/core/org/pathvisio/biopax/gui/BiopaxCellEditor.java	(revision 957)
@@ -20,8 +20,8 @@
 import org.eclipse.swt.widgets.Button;
 import org.eclipse.swt.widgets.Composite;
 import org.eclipse.swt.widgets.Control;
+import org.pathvisio.Engine;
 import org.pathvisio.biopax.BiopaxManager;
-import org.pathvisio.gui.swt.Engine;
 
 public class BiopaxCellEditor extends DialogCellEditor {	
 	public BiopaxCellEditor(Composite parent, String label) {
@@ -35,7 +35,7 @@
 	}
 
 	protected Object openDialogBox(Control cellEditorWindow) {
-		BiopaxManager bpm = new BiopaxManager(Engine.getPathway().getBiopax().getBiopax());
+		BiopaxManager bpm = new BiopaxManager(Engine.getActivePathway().getBiopax().getBiopax());
 		BiopaxRefDialog d = new BiopaxRefDialog(cellEditorWindow.getShell(), bpm, (String)getValue());
 		d.open();
 		return d.getRef();
Index: trunk/src/core/org/pathvisio/biopax/BiopaxManager.java
===================================================================
--- trunk/src/core/org/pathvisio/biopax/BiopaxManager.java	(revision 956)
+++ trunk/src/core/org/pathvisio/biopax/BiopaxManager.java	(revision 957)
@@ -29,7 +29,7 @@
 import org.jdom.input.SAXBuilder;
 import org.jdom.output.Format;
 import org.jdom.output.XMLOutputter;
-import org.pathvisio.gui.swt.Engine;
+import org.pathvisio.Engine;
 import org.pathvisio.model.ConverterException;
 import org.pathvisio.util.Utils;
 
Index: trunk/src/core/org/pathvisio/Engine.java
===================================================================
--- trunk/src/core/org/pathvisio/Engine.java	(revision 0)
+++ trunk/src/core/org/pathvisio/Engine.java	(revision 957)
@@ -0,0 +1,264 @@
+package org.pathvisio;
+
+import java.awt.Color;
+import java.io.File;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.EventObject;
+import java.util.HashMap;
+import java.util.List;
+
+import org.pathvisio.data.DBConnector;
+import org.pathvisio.debug.Logger;
+import org.pathvisio.model.ConverterException;
+import org.pathvisio.model.Pathway;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.PathwayExporter;
+import org.pathvisio.model.PathwayImporter;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.util.Utils;
+import org.pathvisio.view.VPathway;
+
+public class Engine {
+	private static Pathway pathway;
+	private static VPathway vPathway;
+		
+	public static final String SVG_FILE_EXTENSION = "svg";
+	public static final String SVG_FILTER_NAME = "Scalable Vector Graphics (*." + SVG_FILE_EXTENSION + ")";
+	public static final String PATHWAY_FILE_EXTENSION = "gpml";
+	public static final String PATHWAY_FILTER_NAME = "PathVisio Pathway (*." + PATHWAY_FILE_EXTENSION + ")";
+	public static final String GENMAPP_FILE_EXTENSION = "mapp";
+	public static final String GENMAPP_FILTER_NAME = "GenMAPP Pathway (*." + GENMAPP_FILE_EXTENSION + ")";
+	
+	/**
+	 * the transparent color used in the icons for visualization of protein/mrna data
+	 */
+	public static final Color TRANSPARENT_COLOR = new Color(255, 0, 255);
+	
+	public final static Logger log = new Logger();
+			
+	/**
+	 * Get the {@link URL} for the resource stored in a jar file in the classpath
+	 * @param name	the filename of the resource
+	 * @return the URL pointing to the resource
+	 */
+	public static URL getResourceURL(String name) {
+		URL url = Engine.class.getClassLoader().getResource(name);
+		if(url == null) log.error("Couldn't load resource '" + name + "'");
+		return url;
+	}
+	
+	/**
+	 * Gets the currently open drawing
+	 */
+	public static VPathway getActiveVPathway() {
+		return vPathway;
+	}
+
+	/**
+	 * Sets the currently active Pathway and its VPathway 
+	 * (Used by SwtEngine, will be removed after finishing Graphics2D transision)
+	 * @param vpw
+	 */
+	@Deprecated
+	public static void setActiveVPathway(Pathway pw, VPathway vpw) {
+		pathway = pw;
+		vPathway = vpw;
+	}
+	
+	/**
+	 * Returns the currently open Pathway
+	 */
+	public static Pathway getActivePathway() {
+		return pathway;
+	}
+	
+	/**
+	 * application global clipboard.
+	 */
+	public static List<PathwayElement> clipboard = null;
+	
+	public static void importPathway(File file) throws ConverterException {
+		String fileName = file.toString();
+		
+		int dot = fileName.lastIndexOf('.');
+		String ext = Engine.PATHWAY_FILE_EXTENSION; //
+		if(dot >= 0) {
+			ext = fileName.substring(dot + 1, fileName.length());
+		}
+		PathwayImporter importer = getPathwayImporter(ext);
+		
+		if(importer == null) throw new ConverterException( "No importer for '" + ext +  "' files" );
+		
+		Pathway _pathway = new Pathway();
+		importer.doImport(file, _pathway);
+		pathway = _pathway;
+		fireApplicationEvent(new ApplicationEvent(pathway, ApplicationEvent.PATHWAY_OPENED));
+	}
+	
+	public static void openPathway(String fileName) throws ConverterException {
+		openPathway(new File(fileName));
+	}
+	
+	/**
+	 * Open a pathway from a gpml file
+	 */
+	public static void openPathway(File pathwayFile) throws ConverterException
+	{
+		Pathway _pathway = null;		
+		String pwf = pathwayFile.toString();
+		
+		// initialize new JDOM gpml representation and read the file
+		_pathway = new Pathway();
+		if (pwf.endsWith(".mapp"))
+		{
+			_pathway.readFromMapp(new File(pwf));
+		}
+		else
+		{
+			_pathway.readFromXml(new File(pwf), true);
+		}
+		if(_pathway != null) //Only continue if the data is correctly loaded
+		{
+			pathway = _pathway;
+			fireApplicationEvent(new ApplicationEvent(pathway, ApplicationEvent.PATHWAY_OPENED));
+		}
+		
+	}
+	
+	public static void savePathway() throws ConverterException {
+		savePathway(pathway.getSourceFile());
+	}
+	
+	public static void savePathway(File toFile) throws ConverterException {
+		pathway.writeToXml(toFile, true);
+	}
+	
+	private static void createVPathway(Pathway p) {
+		vPathway.fromGmmlData(pathway);
+		fireApplicationEvent(new ApplicationEvent(vPathway, ApplicationEvent.VPATHWAY_CREATED));
+	}
+		
+	/**
+	 * Create a new pathway and view (Pathay and VPathway)
+	 */
+	public static void newPathway() {
+		pathway = new Pathway();
+		pathway.initMappInfo();
+		
+		fireApplicationEvent(new ApplicationEvent(vPathway, ApplicationEvent.PATHWAY_NEW));
+	}
+	
+	public static void newVPathway(Pathway pathway) {
+		vPathway.fromGmmlData(pathway);
+	}
+	
+	/**
+	 * Find out whether a drawing is currently open or not
+	 * @return true if a drawing is open, false if not
+	 */
+	public static boolean isDrawingOpen() { return vPathway != null; }
+
+
+	private static HashMap<String, PathwayExporter> exporters = new HashMap<String, PathwayExporter>();
+	private static HashMap<String, PathwayImporter> importers = new HashMap<String, PathwayImporter>();
+	/**
+	 * Add a {@link PathwayExporter} that handles export of GPML to another file format
+	 * @param export
+	 */
+	public static void addPathwayExporter(PathwayExporter export) {
+		for(String ext : export.getExtensions()) {
+			exporters.put(ext, export);
+		}
+	}
+
+	/**
+	 * Add a {@link PathwayImporter} that handles imoprt of GPML to another file format
+	 * @param export
+	 */
+	public static void addPathwayImporter(PathwayImporter importer) {
+		for(String ext : importer.getExtensions()) {
+			importers.put(ext, importer);
+		}
+	}
+	
+	public static PathwayExporter getPathwayExporter(String ext) {
+		return exporters.get(ext);
+	}
+
+	public static PathwayImporter getPathwayImporter(String ext) {
+		return importers.get(ext);
+	}
+	
+	public static HashMap<String, PathwayExporter> getPathwayExporters() {
+		return exporters;
+	}
+		
+	public static HashMap<String, PathwayImporter> getPathwayImporters() {
+		return importers;
+	}
+	
+	public static DBConnector getDbConnector(int type) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
+		DBConnector connector = null;
+		String className = null;
+		switch(type) {
+		case DBConnector.TYPE_GDB:
+			className = SwtPreference.SWT_DB_ENGINE_GDB.getValue();
+			break;
+		case DBConnector.TYPE_GEX:
+			className = SwtPreference.SWT_DB_ENGINE_GDB.getValue();
+			break;
+		}
+		if(className == null) return null;
+		
+		Class dbc = Class.forName(className);
+		
+		if(Utils.isSubClass(dbc, DBConnector.class)) {
+			connector = (DBConnector)dbc.newInstance();
+			connector.setDbType(type);
+		}
+	
+		return connector;
+	}
+		
+	private static List<ApplicationEventListener> applicationEventListeners  = new ArrayList<ApplicationEventListener>();
+	
+	/**
+	 * Add an {@link ApplicationEventListener}, that will be notified if a
+	 * property changes that has an effect throughout the program (e.g. opening a pathway)
+	 * @param l The {@link ApplicationEventListener} to add
+	 */
+	public static void addApplicationEventListener(ApplicationEventListener l) {
+		applicationEventListeners.add(l);
+	}
+	
+	/**
+	 * Fire a {@link ApplicationEvent} to notify all {@link ApplicationEventListener}s registered
+	 * to this class
+	 * @param e
+	 */
+	public static void fireApplicationEvent(ApplicationEvent e) {
+		for(ApplicationEventListener l : applicationEventListeners) l.applicationEvent(e);
+	}
+	
+	public interface ApplicationEventListener {
+		public void applicationEvent(ApplicationEvent e);
+	}
+	
+	public static class ApplicationEvent extends EventObject {
+		private static final long serialVersionUID = 1L;
+		public static final int PATHWAY_OPENED = 1;
+		public static final int PATHWAY_NEW = 2;
+		public static final int APPLICATION_CLOSE = 3;
+		public static final int VPATHWAY_CREATED = 4;
+
+		public Object source;
+		public int type;
+		
+		public ApplicationEvent(Object source, int type) {
+			super(source);
+			this.source = source;
+			this.type = type;
+		}
+	}
+}
\ No newline at end of file
Index: trunk/src/core/org/pathvisio/search/PathwaySearchComposite.java
===================================================================
--- trunk/src/core/org/pathvisio/search/PathwaySearchComposite.java	(revision 956)
+++ trunk/src/core/org/pathvisio/search/PathwaySearchComposite.java	(revision 957)
@@ -38,13 +38,13 @@
 import org.eclipse.swt.widgets.Group;
 import org.eclipse.swt.widgets.Label;
 import org.eclipse.swt.widgets.Text;
-
-import org.pathvisio.gui.swt.Engine;
+import org.pathvisio.Engine;
+import org.pathvisio.data.DataSources;
 import org.pathvisio.gui.swt.MainWindowBase;
-import org.pathvisio.preferences.swt.Preferences;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
 import org.pathvisio.search.SearchMethods.SearchException;
 import org.pathvisio.util.SwtUtils.SimpleRunnableWithProgress;
-import org.pathvisio.data.DataSources;
 
 public class PathwaySearchComposite extends Composite {
 
@@ -257,7 +257,7 @@
 	
 	private Text createDirText(Composite parent) {
 		Text t = new Text(parent, SWT.SINGLE | SWT.BORDER);
-		t.setText(Engine.getPreferences().getString(Preferences.PREF_DIR_PWFILES));
+		t.setText(SwtPreference.SWT_DIR_PWFILES.getValue());
 		t.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
 		return t;
 	}
Index: trunk/src/core/org/pathvisio/search/SearchMethods.java
===================================================================
--- trunk/src/core/org/pathvisio/search/SearchMethods.java	(revision 956)
+++ trunk/src/core/org/pathvisio/search/SearchMethods.java	(revision 957)
@@ -16,7 +16,7 @@
 //
 package org.pathvisio.search;
 
-import org.pathvisio.gui.swt.Engine;
+import org.pathvisio.gui.swt.SwtEngine;
 
 import java.io.File;
 import java.util.ArrayList;
@@ -24,18 +24,18 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import org.xml.sax.SAXException;
-import org.xml.sax.XMLReader;
-import org.xml.sax.helpers.XMLReaderFactory;
-
+import org.pathvisio.Engine;
+import org.pathvisio.data.Gdb;
+import org.pathvisio.data.Gdb.IdCodePair;
 import org.pathvisio.search.PathwaySearchComposite.SearchRunnableWithProgress;
 import org.pathvisio.util.FileUtils;
 import org.pathvisio.util.PathwayParser;
 import org.pathvisio.util.tableviewer.PathwayTable;
 import org.pathvisio.util.tableviewer.TableData;
 import org.pathvisio.util.tableviewer.TableData.Row;
-import org.pathvisio.data.Gdb;
-import org.pathvisio.data.Gdb.IdCodePair;
+import org.xml.sax.SAXException;
+import org.xml.sax.XMLReader;
+import org.xml.sax.helpers.XMLReaderFactory;
 
 public abstract class SearchMethods {	
 	public static final String MSG_NOT_IN_GDB = "Gene not found in selected gene database";
Index: trunk/src/core/org/pathvisio/search/SearchResultTable.java
===================================================================
--- trunk/src/core/org/pathvisio/search/SearchResultTable.java	(revision 956)
+++ trunk/src/core/org/pathvisio/search/SearchResultTable.java	(revision 957)
@@ -28,9 +28,9 @@
 import org.eclipse.swt.widgets.Button;
 import org.eclipse.swt.widgets.Composite;
 import org.eclipse.swt.widgets.Label;
-import org.pathvisio.gui.swt.Engine;
-import org.pathvisio.gui.swt.Engine.ApplicationEvent;
-import org.pathvisio.gui.swt.Engine.ApplicationEventListener;
+import org.pathvisio.Engine;
+import org.pathvisio.Engine.ApplicationEvent;
+import org.pathvisio.Engine.ApplicationEventListener;
 import org.pathvisio.util.tableviewer.PathwayTable;
 import org.pathvisio.util.tableviewer.TableData.Row;
 import org.pathvisio.view.GeneProduct;
@@ -53,7 +53,7 @@
 	public int getNrResults() { return getNrRows(); }
 		
 	public void highlightResults(boolean highlight) {
-		VPathway drawing = Engine.getVPathway();
+		VPathway drawing = Engine.getActiveVPathway();
 		if(drawing == null) return; //No drawing open
 		
 		if(highlight) { 
@@ -102,7 +102,7 @@
 	}
 
 	public void applicationEvent(ApplicationEvent e) {
-		if(e.type == ApplicationEvent.OPEN_PATHWAY)
+		if(e.type == ApplicationEvent.PATHWAY_OPENED)
 				highlightResults(highlightButton.getSelection());
 	}
 }	
Index: trunk/src/core/org/pathvisio/debug/StopWatch.java
===================================================================
--- trunk/src/core/org/pathvisio/debug/StopWatch.java	(revision 956)
+++ trunk/src/core/org/pathvisio/debug/StopWatch.java	(revision 957)
@@ -16,7 +16,7 @@
 //
 package org.pathvisio.debug;
 
-import org.pathvisio.gui.swt.Engine;
+import org.pathvisio.Engine;
 
 /**
    A simple helper class for speed optimizations
Index: trunk/src/core/org/pathvisio/data/GexImportWizard.java
===================================================================
--- trunk/src/core/org/pathvisio/data/GexImportWizard.java	(revision 956)
+++ trunk/src/core/org/pathvisio/data/GexImportWizard.java	(revision 957)
@@ -48,9 +48,9 @@
 import org.eclipse.swt.widgets.TableColumn;
 import org.eclipse.swt.widgets.TableItem;
 import org.eclipse.swt.widgets.Text;
+import org.pathvisio.Engine;
 import org.pathvisio.Globals;
-import org.pathvisio.gui.swt.Engine;
-import org.pathvisio.preferences.swt.Preferences;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
 import org.pathvisio.util.TableColumnResizer;
 
 /**
@@ -160,7 +160,7 @@
 							"*.*" });
 					fileDialog.setFilterNames(new String[] { "Text file",
 							"All files" });
-					fileDialog.setFilterPath(Engine.getPreferences().getString(Preferences.PREF_DIR_EXPR));
+					fileDialog.setFilterPath(SwtPreference.SWT_DIR_EXPR.getValue());
 					String file = fileDialog.open();
 					if (file != null) {
 						txtText.setText(file);
Index: trunk/src/core/org/pathvisio/data/DBConnector.java
===================================================================
--- trunk/src/core/org/pathvisio/data/DBConnector.java	(revision 956)
+++ trunk/src/core/org/pathvisio/data/DBConnector.java	(revision 957)
@@ -24,10 +24,9 @@
 import org.eclipse.swt.widgets.DirectoryDialog;
 import org.eclipse.swt.widgets.FileDialog;
 import org.eclipse.swt.widgets.Shell;
+import org.pathvisio.Engine;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
 
-import org.pathvisio.gui.swt.Engine;
-import org.pathvisio.preferences.swt.Preferences;
-
 /**
  * This class provides the connection for the databases (annotation and expression database) used
  * in PathVisio. Implement the abstract methods when you want to add support for a new database engine.
@@ -221,10 +220,10 @@
 		String filterPath = null;
 		switch(getDbType()) {
 		case TYPE_GDB: 
-			filterPath = Engine.getPreferences().getString(Preferences.PREF_DIR_GDB);
+			filterPath = SwtPreference.SWT_DIR_GDB.getValue();
 			break;
 		case TYPE_GEX:
-			filterPath = Engine.getPreferences().getString(Preferences.PREF_DIR_EXPR);
+			filterPath = SwtPreference.SWT_DIR_EXPR.getValue();
 			break;
 		}
 		if(filterPath != null) fileDialog.setFilterPath(filterPath);
@@ -247,10 +246,10 @@
 		String filterPath = null;
 		switch(getDbType()) {
 		case TYPE_GDB: 
-			filterPath = Engine.getPreferences().getString(Preferences.PREF_DIR_GDB);
+			filterPath = SwtPreference.SWT_DIR_GDB.getValue();
 			break;
 		case TYPE_GEX:
-			filterPath = Engine.getPreferences().getString(Preferences.PREF_DIR_EXPR);
+			filterPath = SwtPreference.SWT_DIR_EXPR.getValue();
 			break;
 		}
 		if(filterPath != null) dirDialog.setFilterPath(filterPath);
Index: trunk/src/core/org/pathvisio/data/ImportInformation.java
===================================================================
--- trunk/src/core/org/pathvisio/data/ImportInformation.java	(revision 956)
+++ trunk/src/core/org/pathvisio/data/ImportInformation.java	(revision 957)
@@ -21,7 +21,8 @@
 import java.io.FileReader;
 import java.io.IOException;
 
-import org.pathvisio.gui.swt.Engine;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.Engine;
 
 /**
  * This class contains the information needed to start importing a delimited
Index: trunk/src/core/org/pathvisio/data/CachedData.java
===================================================================
--- trunk/src/core/org/pathvisio/data/CachedData.java	(revision 956)
+++ trunk/src/core/org/pathvisio/data/CachedData.java	(revision 957)
@@ -16,14 +16,14 @@
 //
 package org.pathvisio.data;
 
-import java.sql.Types;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
+import java.sql.Types;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+import org.pathvisio.data.Gdb.IdCodePair;
+import org.pathvisio.data.Gex.Sample;
 
-import org.pathvisio.data.Gdb.IdCodePair;
-import org.pathvisio.data.Gex.Sample;
-
 /**
  * This class represents cached expression data for a pathway.
  * The caching of expression data will occur when a pathway is opened and an expression dataset is loaded.
Index: trunk/src/core/org/pathvisio/data/DBConnHsqldb.java
===================================================================
--- trunk/src/core/org/pathvisio/data/DBConnHsqldb.java	(revision 956)
+++ trunk/src/core/org/pathvisio/data/DBConnHsqldb.java	(revision 957)
@@ -28,9 +28,8 @@
 import org.eclipse.swt.SWT;
 import org.eclipse.swt.widgets.FileDialog;
 import org.eclipse.swt.widgets.Shell;
-
+import org.pathvisio.Engine;
 import org.pathvisio.debug.StopWatch;
-import org.pathvisio.gui.swt.Engine;
 
 /**
    DBConnector implementation using the hsqldb driver
Index: trunk/src/core/org/pathvisio/data/Gex.java
===================================================================
--- trunk/src/core/org/pathvisio/data/Gex.java	(revision 956)
+++ trunk/src/core/org/pathvisio/data/Gex.java	(revision 957)
@@ -48,13 +48,13 @@
 import org.jdom.input.SAXBuilder;
 import org.jdom.output.Format;
 import org.jdom.output.XMLOutputter;
+import org.pathvisio.Engine;
+import org.pathvisio.Engine.ApplicationEvent;
+import org.pathvisio.Engine.ApplicationEventListener;
 import org.pathvisio.data.CachedData.Data;
 import org.pathvisio.data.Gdb.IdCodePair;
 import org.pathvisio.data.GexImportWizard.ImportPage;
 import org.pathvisio.debug.StopWatch;
-import org.pathvisio.gui.swt.Engine;
-import org.pathvisio.gui.swt.Engine.ApplicationEvent;
-import org.pathvisio.gui.swt.Engine.ApplicationEventListener;
 import org.pathvisio.util.FileUtils;
 import org.pathvisio.visualization.VisualizationManager;
 import org.pathvisio.visualization.colorset.ColorSetManager;
@@ -980,7 +980,7 @@
 	
 	public void applicationEvent(ApplicationEvent e) {
 		switch(e.type) {
-		case ApplicationEvent.CLOSE_APPLICATION:
+		case ApplicationEvent.APPLICATION_CLOSE:
 			if(isConnected()) close();
 		}
 	}
Index: trunk/src/core/org/pathvisio/data/GpmlTransfer.java
===================================================================
--- trunk/src/core/org/pathvisio/data/GpmlTransfer.java	(revision 956)
+++ trunk/src/core/org/pathvisio/data/GpmlTransfer.java	(revision 957)
@@ -25,10 +25,11 @@
 import org.jdom.Namespace;
 import org.jdom.output.Format;
 import org.jdom.output.XMLOutputter;
-
+import org.pathvisio.Engine;
+import org.pathvisio.model.GpmlFormat;
 import org.pathvisio.model.PathwayElement;
 import org.pathvisio.model.GpmlFormat;
-import org.pathvisio.gui.swt.Engine;
+import org.pathvisio.gui.swt.SwtEngine;
 
 /**
    Clipboard Transfer Object, for transferring Gpml fragments
Index: trunk/src/core/org/pathvisio/data/DBConnDerby.java
===================================================================
--- trunk/src/core/org/pathvisio/data/DBConnDerby.java	(revision 956)
+++ trunk/src/core/org/pathvisio/data/DBConnDerby.java	(revision 957)
@@ -16,8 +16,6 @@
 //
 package org.pathvisio.data;
 
-import org.pathvisio.gui.swt.Engine;
-
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
@@ -35,9 +33,9 @@
 import org.eclipse.swt.SWT;
 import org.eclipse.swt.widgets.FileDialog;
 import org.eclipse.swt.widgets.Shell;
-
-import org.pathvisio.util.FileUtils;
+import org.pathvisio.Engine;
 import org.pathvisio.debug.StopWatch;
+import org.pathvisio.util.FileUtils;
 
 /**
    DBConnector implementation using the Derby driver, with the database in a
Index: trunk/src/core/org/pathvisio/data/Gdb.java
===================================================================
--- trunk/src/core/org/pathvisio/data/Gdb.java	(revision 956)
+++ trunk/src/core/org/pathvisio/data/Gdb.java	(revision 957)
@@ -34,9 +34,11 @@
 
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.jface.operation.IRunnableWithProgress;
+import org.pathvisio.Engine;
 import org.pathvisio.debug.StopWatch;
-import org.pathvisio.gui.swt.Engine;
-import org.pathvisio.preferences.swt.Preferences;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
 
 /**
  * This class handles everything related to the Gene Database. It contains the database connection,
@@ -74,14 +76,14 @@
 	 */
 	public static void init()
 	{
-		String currGdb = Engine.getPreferences().getString(Preferences.PREF_CURR_GDB);
-		if(!currGdb.equals("") && !Engine.getPreferences().isDefault(Preferences.PREF_CURR_GDB))
+		String currGdb = SwtPreference.SWT_CURR_GDB.getValue();
+		if(!currGdb.equals("") && !GlobalPreference.isDefault(SwtPreference.SWT_CURR_GDB))
 		{
 			dbName = currGdb;
 			try {
 				connect(null);
 			} catch(Exception e) {
-				setCurrentGdb(Engine.getPreferences().getDefaultString(Preferences.PREF_CURR_GDB));
+				setCurrentGdb(SwtPreference.SWT_CURR_GDB.getDefault());
 			}
 		}
 	}
@@ -91,9 +93,9 @@
 	 * @param dbNm	The name of the gene database
 	 */
 	public static void setCurrentGdb(String dbNm) {
-		dbName = dbNm;
-		Engine.getPreferences().setValue(Preferences.PREF_CURR_GDB, dbNm);
-		try { Engine.getPreferences().save(); } 
+		dbName = dbNm; 
+		SwtPreference.SWT_CURR_GDB.setValue(dbNm);
+		try { SwtEngine.getPreferences().save(); } 
 		catch(Exception e) { Engine.log.error("Unable to save preferences", e); } 
 	}
 	
Index: trunk/src/core/org/pathvisio/data/DBConnDerbyDirectory.java
===================================================================
--- trunk/src/core/org/pathvisio/data/DBConnDerbyDirectory.java	(revision 956)
+++ trunk/src/core/org/pathvisio/data/DBConnDerbyDirectory.java	(revision 957)
@@ -16,12 +16,11 @@
 //
 package org.pathvisio.data;
 
-import org.pathvisio.gui.swt.Engine;
-
 import java.sql.DriverManager;
+
 import org.eclipse.swt.widgets.DirectoryDialog;
 import org.eclipse.swt.widgets.Shell;
-
+import org.pathvisio.Engine;
 import org.pathvisio.util.FileUtils;
 
 /**
Index: trunk/src/core/org/pathvisio/view/GeneProduct.java
===================================================================
--- trunk/src/core/org/pathvisio/view/GeneProduct.java	(revision 956)
+++ trunk/src/core/org/pathvisio/view/GeneProduct.java	(revision 957)
@@ -1,204 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.view;
-
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.events.PaintEvent;
-import org.eclipse.swt.graphics.Color;
-import org.eclipse.swt.graphics.Font;
-import org.eclipse.swt.graphics.FontData;
-import org.eclipse.swt.graphics.GC;
-import org.eclipse.swt.graphics.Point;
-import org.eclipse.swt.graphics.RGB;
-import org.eclipse.swt.graphics.Rectangle;
-import org.eclipse.swt.graphics.Region;
-
-import org.pathvisio.util.SwtUtils;
-import org.pathvisio.data.DataSources;
-import org.pathvisio.model.PathwayElement;
-
-/**
- * This class implements a geneproduct and 
- * provides methods to resize and draw it.
- */
-public class GeneProduct extends GraphicsShape
-{
-	private static final long serialVersionUID = 1L;
-	public static final RGB INITIAL_FILL_COLOR = new RGB(255, 255, 255);
-	
-	// note: not the same as color!
-	RGB fillColor = INITIAL_FILL_COLOR;
-		
-	public GeneProduct (VPathway canvas, PathwayElement o) {
-		super(canvas, o);		
-		setHandleLocation();
-	}
-		
-	public int getDrawingOrder() {
-		return VPathway.DRAW_ORDER_GENEPRODUCT;
-	}
-	
-	/**
-	 * @deprecated get this info from PathwayElement directly
-	 */
-	public String getID() 
-	{
-		//Looks like the wrong way around, but in gpml the ID is attribute 'Name'
-		//NOTE: maybe change this in gpml?
-		return gdata.getGeneID();
-	}
-		
-	/**
-	 * Looks up the systemcode for this gene in Pathway.sysName2Code
-	 * @return	The system code or an empty string if the system is not found
-	 * 
-	 * @deprecated use PathwayElement.getSystemCode()
-	 */
-	public String getSystemCode()
-	{
-		String systemCode = "";
-		if(DataSources.sysName2Code.containsKey(gdata.getDataSource())) 
-			systemCode = DataSources.sysName2Code.get(gdata.getDataSource());
-		return systemCode;
-	}
-	
-//	private Text t;
-//	public void createTextControl()
-//	{		
-//		Color background = canvas.getShell().getDisplay()
-//		.getSystemColor(SWT.COLOR_INFO_BACKGROUND);
-//		
-//		Composite textComposite = new Composite(canvas, SWT.NONE);
-//		textComposite.setLayout(new GridLayout());
-//		textComposite.setLocation(getCenterX(), getCenterY() - 10);
-//		textComposite.setBackground(background);
-//		
-//		Label label = new Label(textComposite, SWT.CENTER);
-//		label.setText("Specify gene name:");
-//		label.setBackground(background);
-//		t = new Text(textComposite, SWT.SINGLE | SWT.BORDER);
-//				
-//		t.addSelectionListener(new SelectionAdapter() {
-//			public void widgetDefaultSelected(SelectionEvent e) {
-//				disposeTextControl();
-//			}
-//		});
-//				
-//		t.setFocus();
-//		
-//		Button b = new Button(textComposite, SWT.PUSH);
-//		b.setText("OK");
-//		b.addSelectionListener(new SelectionAdapter() {
-//			public void widgetSelected(SelectionEvent e) {
-//				disposeTextControl();
-//			}
-//		});
-//		
-//		textComposite.pack();
-//	}
-	
-//	protected void disposeTextControl()
-//	{	
-//		markDirty();
-//		gdata.setGeneID (t.getText());
-//		markDirty();
-//		//TODO: implement listener. 
-//		//canvas.updatePropertyTable(this);
-//		Composite c = t.getParent();
-//		c.setVisible(false);
-//		c.dispose();
-//		
-//		canvas.redrawDirtyRect();
-//	}
-			
-	/**
-	 * Calculate the font size adjusted to the canvas zoom factor.
-	 */
-	private int getVFontSize()
-	{
-		return (int)(vFromM (gdata.getMFontSize()));
-	}
-
-	public void draw(PaintEvent e, GC buffer)
-	{
-		Color c = null;
-		Color b = SwtUtils.changeColor(c, new RGB(255, 255, 255), e.display);
-		Font f = null;
-		
-		if(isSelected())
-		{
-			c = SwtUtils.changeColor(c, selectColor, e.display);
-		}
-		else 
-		{
-			c = SwtUtils.changeColor(c, gdata.getColor(), e.display);
-		}
-		
-		buffer.setForeground(c);
-		buffer.setBackground(b);
-		buffer.setLineStyle (SWT.LINE_SOLID);
-		buffer.setLineWidth (1);		
-		
-		Rectangle area = new Rectangle(
-				getVLeft(), getVTop(), getVWidth(), getVHeight());
-		
-		buffer.fillRectangle (area); // white background
-		buffer.drawRectangle (area);
-		
-		buffer.setClipping ( area.x - 1, area.y - 1, area.width + 1, area.height + 1);
-		
-		f = SwtUtils.changeFont(f, new FontData(gdata.getFontName(), getVFontSize(), SWT.NONE), e.display);
-		buffer.setFont(f);
-		
-		String label = gdata.getTextLabel();
-		Point textSize = buffer.textExtent (label);
-		buffer.drawString (label, 
-				area.x + (int)(area.width / 2) - (int)(textSize.x / 2),
-				area.y + (int)(area.height / 2) - (int)(textSize.y / 2), true);
-				
-				
-		Region r = null;
-		buffer.setClipping(r);
-		
-		c.dispose();
-		b.dispose();
-		f.dispose();
-	}
-	
-	protected void draw(PaintEvent e)
-	{
-		draw(e, e.gc);
-	}
-	
-	public void drawHighlight(PaintEvent e, GC buffer)
-	{
-		if(isHighlighted())
-		{
-			Color c = null;
-			c = SwtUtils.changeColor(c, highlightColor, e.display);
-			buffer.setForeground(c);
-			buffer.setLineWidth(2);
-			buffer.drawRectangle (
-					getVLeft() - 1,
-					getVTop() - 1,
-					getVWidth() + 3,
-					getVHeight() + 3
-				);
-			if(c != null) c.dispose();
-		}
-	}
-}
Index: trunk/src/core/org/pathvisio/view/Label.java
===================================================================
--- trunk/src/core/org/pathvisio/view/Label.java	(revision 956)
+++ trunk/src/core/org/pathvisio/view/Label.java	(revision 957)
@@ -1,258 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.view;
-
-import java.awt.Polygon;
-import java.awt.Rectangle;
-import java.awt.Shape;
-import java.awt.geom.Rectangle2D;
-
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.events.PaintEvent;
-import org.eclipse.swt.events.SelectionAdapter;
-import org.eclipse.swt.events.SelectionEvent;
-import org.eclipse.swt.graphics.Color;
-import org.eclipse.swt.graphics.Font;
-import org.eclipse.swt.graphics.GC;
-import org.eclipse.swt.graphics.Point;
-import org.eclipse.swt.graphics.RGB;
-import org.eclipse.swt.layout.GridData;
-import org.eclipse.swt.layout.GridLayout;
-import org.eclipse.swt.widgets.Button;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Text;
-
-import org.pathvisio.preferences.swt.Preferences;
-import org.pathvisio.util.SwtUtils;
-import org.pathvisio.model.PathwayElement;
-import org.pathvisio.model.PathwayEvent;
-
-public class Label extends GraphicsShape
-{
-	private static final long serialVersionUID = 1L;
-	
-	public static final int M_INITIAL_FONTSIZE = 10 * 15;
-	public static final int M_INITIAL_WIDTH = 80 * 15;
-	public static final int M_INITIAL_HEIGHT = 20 * 15;
-		
-	double getFontSize()
-	{
-		return gdata.getMFontSize() * canvas.getZoomFactor();
-	}
-	
-	void setFontSize(double v)
-	{
-		gdata.setMFontSize(v / canvas.getZoomFactor());
-	}
-				
-	/**
-	 * Constructor for this class
-	 * @param canvas - the VPathway this label will be part of
-	 */
-	public Label(VPathway canvas, PathwayElement o)
-	{
-		super(canvas, o);
-		setHandleLocation();
-	}
-	
-	public int getDrawingOrder() {
-		return VPathway.DRAW_ORDER_LABEL;
-	}
-	
-	public String getLabelText() {
-		return gdata.getTextLabel();
-	}
-	
-	String prevText = "";
-	public void adjustWidthToText() {
-		if(gdata.getTextLabel().equals(prevText)) return;
-		
-		prevText = getLabelText();
-		
-		Point mts = mComputeTextSize();
-		
-		//Keep center location
-		double mWidth = mts.x;
-		double mHeight = mts.y;
-		
-		listen = false; //Disable listener
-		gdata.setMLeft(gdata.getMLeft() - (mWidth - gdata.getMWidth())/2);
-		gdata.setMTop(gdata.getMTop() - (mHeight - gdata.getMHeight())/2);
-		gdata.setMWidth(mWidth);
-		gdata.setMHeight(mHeight);
-		listen = true; //Enable listener
-		
-		setHandleLocation();
-	}
-	
-	private Text t;
-	public void createTextControl()
-	{
-		Color background = canvas.getShell().getDisplay()
-		.getSystemColor(SWT.COLOR_INFO_BACKGROUND);
-		
-		Composite textComposite = new Composite(canvas, SWT.NONE);
-		textComposite.setLayout(new GridLayout());
-		textComposite.setLocation(getVCenterX(), getVCenterY() - 10);
-		textComposite.setBackground(background);
-		
-		org.eclipse.swt.widgets.Label label = new org.eclipse.swt.widgets.Label(textComposite, SWT.CENTER);
-		label.setText("Specify label:");
-		label.setBackground(background);
-		t = new Text(textComposite, SWT.SINGLE | SWT.BORDER);
-		t.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
-		t.addSelectionListener(new SelectionAdapter() {
-			public void widgetDefaultSelected(SelectionEvent e) {
-				disposeTextControl();
-			}
-		});
-				
-		t.setFocus();
-		
-		Button b = new Button(textComposite, SWT.PUSH);
-		b.setText("OK");
-		b.addSelectionListener(new SelectionAdapter() {
-			public void widgetSelected(SelectionEvent e) {
-				disposeTextControl();
-			}
-		});
-		
-		textComposite.pack();
-	}
-	
-	Point mComputeTextSize() {
-		GC gc = new GC(canvas.getDisplay());
-		Font f = new Font(canvas.getDisplay(), 
-				gdata.getFontName(), 
-				(int)gdata.getMFontSize(), getFontStyle());
-		gc.setFont (f);
-		Point ts = gc.textExtent(gdata.getTextLabel());
-		f.dispose();
-		gc.dispose();
-		
-		return ts;
-	}
-	
-	protected void disposeTextControl()
-	{
-		gdata.setTextLabel(t.getText());
-		Composite c = t.getParent();
-		c.setVisible(false);
-		c.dispose();
-	}
-		
-	double getVFontSize()
-	{
-		return vFromM(gdata.getMFontSize());
-	}
-
-	private int getFontStyle() {
-		int style = SWT.NONE;
-		
-		if (gdata.isBold())
-		{
-			style |= SWT.BOLD;
-		}
-		
-		if (gdata.isItalic())
-		{
-			style |= SWT.ITALIC;
-		}
-		return style;
-	}
-	
-	public void draw(PaintEvent e, GC buffer)
-	{
-		int style = getFontStyle();
-		
-		Font f = new Font(e.display, gdata.getFontName(), (int)getVFontSize(), style);
-		
-		buffer.setFont (f);
-		
-		Point textSize = buffer.textExtent (gdata.getTextLabel());
-		
-		Color c = null;
-		if (isSelected())
-		{
-			c = SwtUtils.changeColor(c, selectColor, e.display);
-		}
-		else if (isHighlighted())
-		{
-			RGB rgb = Preferences.getColorProperty(Preferences.PREF_COL_HIGHLIGHTED);
-			c = SwtUtils.changeColor(c, rgb, e.display);
-		}
-		else 
-		{
-			c = SwtUtils.changeColor(c, gdata.getColor(), e.display);
-		}
-		buffer.setForeground (c);
-		
-		buffer.drawString (gdata.getTextLabel(), 
-			(int) getVCenterX() - (textSize.x / 2) , 
-			(int) getVCenterY() - (textSize.y / 2), true);
-		
-		f.dispose();
-		c.dispose();
-		
-	}
-	
-	protected void draw(PaintEvent e)
-	{
-		draw(e, e.gc);
-	}	
-	
-	public void gmmlObjectModified(PathwayEvent e) {
-		if(listen) {
-			super.gmmlObjectModified(e);
-			adjustWidthToText();
-		}
-	}
-	
-	/**
-	 * Outline of a label is determined by
-	 * - position of the handles
-	 * - size of the text
-	 * Because the text can sometimes be larger than the handles
-	 */
-	protected Shape getVOutline()
-	{
-		int[] vx = new int[4];
-		int[] vy = new int[4];
-		
-		int[] p = getVHandleLocation(handleNE).asIntArray();
-		vx[0] = p[0]; vy[0] = p[1];
-		p = getVHandleLocation(handleSE).asIntArray();
-		vx[1] = p[0]; vy[1] = p[1];
-		p = getVHandleLocation(handleSW).asIntArray();
-		vx[2] = p[0]; vy[2] = p[1];
-		p = getVHandleLocation(handleNW).asIntArray();
-		vx[3] = p[0]; vy[3] = p[1];
-		
-		Polygon pol = new Polygon(vx, vy, 4);		
-		Rectangle bounds = pol.getBounds();
-		
-		Point mq = mComputeTextSize();
-		double vqx = vFromM(mq.x);
-		double vqy = vFromM(mq.y);
-		
-		LinAlg.Point c = getVCenter();
-		bounds.add(new Rectangle2D.Double(c.x - vqx / 2, c.y - vqy / 2, vqx, vqy)); 
-		
-		return bounds;
-	}
-	
-}
Index: trunk/src/core/org/pathvisio/view/Graphics.java
===================================================================
--- trunk/src/core/org/pathvisio/view/Graphics.java	(revision 956)
+++ trunk/src/core/org/pathvisio/view/Graphics.java	(revision 957)
@@ -1,131 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.view;
-
-import org.eclipse.swt.graphics.RGB;
-import org.eclipse.swt.graphics.Region;
-
-import org.pathvisio.preferences.swt.Preferences;
-import org.pathvisio.model.Pathway;
-import org.pathvisio.model.PathwayElement;
-import org.pathvisio.model.PathwayEvent;
-import org.pathvisio.model.PathwayListener;
-
-
-/**
- * This class is a parent class for all graphics
- * that can be added to a VPathway.
- */
-public abstract class Graphics extends VPathwayElement implements PathwayListener
-{
-	public static RGB selectColor = Preferences.getColorProperty(Preferences.PREF_COL_SELECTED);
-	public static RGB highlightColor = Preferences.getColorProperty(Preferences.PREF_COL_HIGHLIGHTED);
-	
-	protected PathwayElement gdata = null;
-	
-	public Graphics(VPathway canvas, PathwayElement o) {
-		super(canvas);
-		o.addListener(this);
-		gdata = o;
-	}
-	
-	public void select()
-	{
-		super.select();
-		for (Handle h : getHandles())
-		{
-			h.show();
-		}
-	}
-	
-	public void deselect()
-	{
-		super.deselect();
-		for (Handle h : getHandles())
-		{
-			h.hide();
-		}
-	}
-	
-	public PathwayElement getGmmlData() {
-		return gdata;
-	}
-	
-//	public List getAttributes() { return gdata.getAttributes() ;}
-	boolean listen = true;
-	public void gmmlObjectModified(PathwayEvent e) {	
-		if(listen) markDirty(); // mark everything dirty
-	}
-	
-	public Region createVisualizationRegion() {
-		Region region = new Region();
-		java.awt.Rectangle r = getVBounds();
-		region.add(r.x, r.y, r.width, r.height);
-		return region;
-	}
-	
-	
-	/**
-	 * Get the x-coordinate of the center point of this object
-	 * adjusted to the current zoom factor
-
-	 * @return the center x-coordinate as integer
-	 */
-	public int getVCenterX() { return (int)(vFromM(gdata.getMCenterX())); }
-	
-	/**
-	 * Get the y-coordinate of the center point of this object
-	 * adjusted to the current zoom factor
-	 * 
-	 * @return the center y-coordinate as integer
-	 */
-	public int getVCenterY() { return (int)(vFromM(gdata.getMCenterY())); }
-
-	public int getVLeft() { return (int)(vFromM(gdata.getMLeft())); }
-	public int getVWidth() { return (int)(vFromM(gdata.getMWidth()));  }
-	public int getVTop() { return (int)(vFromM(gdata.getMTop())); }
-	public int getVHeight() { return (int)(vFromM(gdata.getMHeight())); }
-	
-	/**
-	 * Get the x-coordinate of the center point of this object
-	 * adjusted to the current zoom factor
-
-	 * @return the center x-coordinate as double
-	 */
-	public double getVCenterXDouble() { return vFromM(gdata.getMCenterX()); }
-	
-	/**
-	 * Get the y-coordinate of the center point of this object
-	 * adjusted to the current zoom factor
-	 * 
-	 * @return the center y-coordinate as double
-	 */
-	public double getVCenterYDouble() { return vFromM(gdata.getMCenterY()); }
-
-	public double getVLeftDouble() { return vFromM(gdata.getMLeft()); }
-	public double getVWidthDouble() { return vFromM(gdata.getMWidth());  }
-	public double getVTopDouble() { return vFromM(gdata.getMTop()); }
-	public double getVHeightDouble() { return vFromM(gdata.getMHeight()); }
-	
-	protected void destroy() {
-		super.destroy();
-		gdata.removeListener(canvas);
-		Pathway parent = gdata.getParent();
-		if(parent != null) parent.remove(gdata);
-	}
-	
-}
\ No newline at end of file
Index: trunk/src/core/org/pathvisio/view/Shape.java
===================================================================
--- trunk/src/core/org/pathvisio/view/Shape.java	(revision 956)
+++ trunk/src/core/org/pathvisio/view/Shape.java	(revision 957)
@@ -1,147 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.view;
-
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.events.PaintEvent;
-import org.eclipse.swt.graphics.Color;
-import org.eclipse.swt.graphics.GC;
-import org.eclipse.swt.graphics.RGB;
-import org.eclipse.swt.graphics.Transform;
-import org.pathvisio.model.PathwayElement;
-import org.pathvisio.preferences.swt.Preferences;
-import org.pathvisio.util.SwtUtils;
-
-/**
- * This class represents a GMMLShape, which can be a 
- * rectangle or ellips, depending of its type.
- */
-public class Shape extends GraphicsShape
-{
-	private static final long serialVersionUID = 1L;
-			
-	/**
-	 * Constructor for this class
-	 * @param canvas - the VPathway this Shape will be part of
-	 */
-	public Shape(VPathway canvas, PathwayElement o)
-	{
-		super(canvas, o);
-		setHandleLocation();
-	}
-		
-	public int getDrawingOrder() {
-		switch(gdata.getShapeType()) {
-		case BRACE:
-			return VPathway.DRAW_ORDER_BRACE;
-		default:
-			return VPathway.DRAW_ORDER_SHAPE;
-		}
-	}
-	
-	public void draw(PaintEvent e, GC buffer)
-	{	
-		Color c = null;
-		Color b = null;
-		if (isSelected())
-		{
-			c = SwtUtils.changeColor(c, selectColor, e.display);
-		}
-		else if (isHighlighted())
-		{
-			RGB rgb = Preferences.getColorProperty(Preferences.PREF_COL_HIGHLIGHTED);
-			c = SwtUtils.changeColor(c, rgb, e.display);
-		}
-		else 
-		{
-			c = SwtUtils.changeColor(c, gdata.getColor(), e.display);
-		}
-		buffer.setForeground (c);
-		buffer.setLineStyle (SWT.LINE_SOLID);
-		b = SwtUtils.changeColor(c, gdata.getFillColor(), e.display);
-		buffer.setBackground (b);
-		
-		Transform tr = new Transform(e.display);
-		rotateGC(buffer, tr);
-		
-		int vStartX = getVLeft();
-		int vStartY = getVTop();
-		int vWidth = getVWidth();
-		int vHeight = getVHeight();
-		
-		switch (gdata.getShapeType())
-		{
-			case RECTANGLE: 
-				buffer.setLineWidth (1);
-				if (!gdata.isTransparent())
-					buffer.fillRectangle (
-						vStartX,	vStartY,	vWidth, vHeight);
-				buffer.drawRectangle (
-					vStartX,	vStartY,	vWidth, vHeight);				
-				break;
-			case OVAL:				
-				buffer.setLineWidth (1);
-				if (!gdata.isTransparent())
-					buffer.fillOval (
-						vStartX, vStartY,	vWidth, vHeight);
-				buffer.drawOval (
-					vStartX, vStartY,	vWidth, vHeight);
-				break;
-			case ARC:
-				buffer.setLineWidth (1);
-				/**
-				 * Arcs are different from Oval and Rect, in that
-				 * they are not filled in GenMAPP, and that the
-				 * color column is used for the line color.
-				 * Likewise, we don't fill them in PathVisio.
-				 */
-//				if (!gdata.isTransparent())
-//					buffer.fillArc(
-//							startX, startY,	width, height, 0, 180);					
-				buffer.drawArc(
-						vStartX, vStartY,	vWidth, vHeight, 0, -180);
-				break;
-			case BRACE:
-				buffer.setLineWidth (2);
-								
-				int cx = getVCenterX();
-				int cy = getVCenterY();
-				int w = getVWidth();
-				int d = getVHeight();
-				
-				buffer.drawLine (cx + d/2, cy, cx + w/2 - d/2, cy); //line on the right
-				buffer.drawLine (cx - d/2, cy, cx - w/2 + d/2, cy); //line on the left
-				buffer.drawArc (cx - w/2, cy, d, d, -180, -90); //arc on the left
-				buffer.drawArc (cx - d, cy - d,	d, d, -90, 90); //left arc in the middle
-				buffer.drawArc (cx, cy - d, d, d, -90, -90); //right arc in the middle
-				buffer.drawArc (cx + w/2 - d, cy, d, d, 0, 90); //arc on the right
-				break;
-		}
-
-		buffer.setTransform(null);
-		
-		c.dispose();
-		b.dispose();
-		tr.dispose();
-	}
-	
-	protected void draw(PaintEvent e)
-	{
-		draw(e, e.gc);
-	}
-	
-}
\ No newline at end of file
Index: trunk/src/core/org/pathvisio/view/GraphicsShape.java
===================================================================
--- trunk/src/core/org/pathvisio/view/GraphicsShape.java	(revision 956)
+++ trunk/src/core/org/pathvisio/view/GraphicsShape.java	(revision 957)
@@ -1,486 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.view;
-
-import java.awt.Polygon;
-import java.awt.Shape;
-import java.awt.geom.Rectangle2D;
-import java.util.HashSet;
-import java.util.Set;
-
-import org.eclipse.swt.graphics.GC;
-import org.eclipse.swt.graphics.Transform;
-
-import org.pathvisio.util.SwtUtils;
-import org.pathvisio.view.LinAlg.Point;
-import org.pathvisio.model.PathwayElement;
-import org.pathvisio.model.PathwayEvent;
-import org.pathvisio.model.PathwayElement.MPoint;
-import org.pathvisio.model.GraphLink.GraphRefContainer;
-
-/**
- * This is an {@link Graphics} class representing shapelike forms,
- * and provides implementation for containing 8 handles placed in a 
- * (rotated) rectangle around the shape and a rotation handle
- */
-public abstract class GraphicsShape extends Graphics {
-
-	private static final double M_ROTATION_HANDLE_POSITION = 20.0 * 15;
-
-	//Side handles
-	Handle handleN;
-	Handle handleE;
-	Handle handleS;
-	Handle handleW;
-	//Corner handles
-	Handle handleNE;
-	Handle handleSE;
-	Handle handleSW;
-	Handle handleNW;
-	//Rotation handle
-	Handle handleR;
-		
-	final Handle[][] handleMatrix; //Used to get opposite handles
-	
-	public GraphicsShape(VPathway canvas, PathwayElement o) {
-		super(canvas, o);
-		
-		handleN	= new Handle(Handle.DIRECTION_Y, this, canvas);
-		handleE	= new Handle(Handle.DIRECTION_X, this, canvas);
-		handleS	= new Handle(Handle.DIRECTION_Y, this, canvas);
-		handleW	= new Handle(Handle.DIRECTION_X, this, canvas);
-				
-		handleNE = new Handle(Handle.DIRECTION_FREE, this, canvas);
-		handleSE = new Handle(Handle.DIRECTION_FREE, this, canvas);
-		handleSW = new Handle(Handle.DIRECTION_FREE, this, canvas);
-		handleNW = new Handle(Handle.DIRECTION_FREE, this, canvas);
-		
-		handleR = new Handle(Handle.DIRECTION_ROT, this, canvas);
-		
-		handleMatrix = new Handle[][] {
-				{ handleNW, 	handleNE },
-				{ handleSW, 	handleSE }};
-	}
-	
-	
-	/**
-	 * Adjust model to changes in the shape, 
-	 * and at the same time calculates the new position 
-	 * in gpml coordinates (so without zoom factor)
-	 */
-	private void setVShape(double vleft, double vtop, double vwidth, double vheight) 
-	{
-//		gdata.dontFireEvents(3);
-		gdata.setMWidth(mFromV(vwidth));
-		gdata.setMHeight(mFromV(vheight));
-		gdata.setMLeft(mFromV(vleft));
-		gdata.setMTop(mFromV(vtop));
-	}
-	
-	protected void vMoveBy(double vdx, double vdy)
-	{
-		gdata.setMLeft(gdata.getMLeft()  + mFromV(vdx));
-		gdata.setMTop(gdata.getMTop() + mFromV(vdy));
-		//Move graphRefs
-		//GraphLink.moveRefsBy(gdata, mFromV(vdx), mFromV(vdy));
-		Set<VPoint> toMove = new HashSet<VPoint>();
-		for(GraphRefContainer ref : gdata.getReferences()) {
-			if(ref instanceof MPoint) {
-				toMove.add(canvas.getPoint((MPoint)ref));
-			}
-		}
-		for(VPoint p : toMove) p.vMoveBy(vdx, vdy);
-	}
-
-	public void setVScaleRectangle(Rectangle2D.Double r) {
-		setVShape(r.x, r.y, r.width, r.height);
-	}
-	
-	protected Rectangle2D.Double getVScaleRectangle() {
-		return new Rectangle2D.Double(getVLeftDouble(), getVTopDouble(), getVWidthDouble(), getVHeightDouble());
-	}
-	
-	public Handle[] getHandles()
-	{
-		if( this instanceof SelectionBox) {
-			// Only corner handles
-			return new Handle[] {
-					handleNE, handleSE,
-					handleSW, handleNW
-			};
-		}
-		if(	this instanceof GeneProduct || 
-			this instanceof Label) {
-			// No rotation handle for these objects
-			return new Handle[] {
-					handleN, handleNE, handleE, handleSE,
-					handleS, handleSW, handleW,	handleNW,
-			};
-		}
-		return new Handle[] {
-				handleN, handleNE, handleE, handleSE,
-				handleS, handleSW, handleW,	handleNW,
-				handleR
-		};
-	}
-	
-	/**
-	 * Translate the given point to internal coordinate system
-	 * (origin in center and axis direction rotated with this objects rotation
-	 * @param MPoint p
-	 */
-	private Point mToInternal(Point p) {
-		Point pt = mRelativeToCenter(p);
-		Point pr = LinAlg.rotate(pt, gdata.getRotation());
-		return pr;
-	}
-
-	/**
-	 * Translate the given point to external coordinate system (of the
-	 * drawing canvas)
-	 * @param MPoint p
-	 */
-	private Point mToExternal(Point p) {
-		Point pr = LinAlg.rotate(p, -gdata.getRotation());
-		Point pt = mRelativeToCanvas(pr);
-		return pt;
-	}
-
-	/**
-	 * Translate the given coordinates to external coordinate system (of the
-	 * drawing canvas)
-	 * @param x
-	 * @param y
-	 */
-	private Point mToExternal(double x, double y) {
-		return mToExternal(new Point(x, y));
-	}
-
-	/**
-	 * Get the coordinates of the given point relative
-	 * to this object's center
-	 * @param p
-	 */
-	private Point mRelativeToCenter(Point p) {
-		return p.subtract(getMCenter());
-	}
-
-	/**
-	 * Get the coordinates of the given point relative
-	 * to the canvas' origin
-	 * @param p
-	 */
-	private Point vRelativeToCanvas(Point p) {
-		return p.add(getVCenter());
-	}
-
-	private Point mRelativeToCanvas(Point p) {
-		return p.add(getMCenter());
-	}
-
-	/**
-	 * Get the center point of this object
-	 */
-	public Point getVCenter() {
-		return new Point(getVCenterX(), getVCenterY());
-	}
-
-	/**
-	 * Get the center point of this object
-	 */
-	public Point getMCenter() {
-		return new Point(gdata.getMCenterX(), gdata.getMCenterY());
-	}
-
-	/**
-	 * Set the center point of this object
-	 * @param cn
-	 */
-	public void setMCenter(Point mcn) {
-//		gdata.dontFireEvents(1);
-		gdata.setMCenterX(mcn.x);
-		gdata.setMCenterY(mcn.y);
-	}
-
-	public void setVCenter(Point vcn) {
-//		gdata.dontFireEvents(1);
-		gdata.setMCenterX(mFromV(vcn.x));
-		gdata.setMCenterY(mFromV(vcn.y));
-	}
-
-	/**
-	 * Calculate a new center point given the new width and height, in a
-	 * way that the center moves over the rotated axis of this object
-	 * @param mWidthNew
-	 * @param mHeightNew
-	 */
-	public Point mCalcNewCenter(double mWidthNew, double mHeightNew) {
-		Point mcn = new Point((mWidthNew - gdata.getMWidth())/2, (mHeightNew - gdata.getMHeight())/2);
-		Point mcr = LinAlg.rotate(mcn, -gdata.getRotation());
-		return mRelativeToCanvas(mcr);
-	}
-
-	public Point vCalcNewCenter(double vWidthNew, double vHeightNew) {
-		Point vcn = new Point((vWidthNew - getVWidth())/2, (vHeightNew - getVHeight())/2);
-		Point vcr = LinAlg.rotate(vcn, -gdata.getRotation());
-		return vRelativeToCanvas(vcr);
-	}
-
-	/**
-	 * Set the rotation of this object
-	 * @param angle angle of rotation in radians
-	 */
-	public void setRotation(double angle) {
-		if(angle < 0) gdata.setRotation(angle + Math.PI*2);
-		else if(angle > Math.PI*2) gdata.setRotation (angle - Math.PI*2);
-		else gdata.setRotation(angle);
-	}
-	
-	/**
-	 * Rotates the {@link GC} around the objects center
-	 * @param gc	the {@link GC} to rotate
-	 * @param tr	a {@link Transform} that can be used for rotation
-	 */
-	protected void rotateGC(GC gc, Transform tr) {		
-		SwtUtils.rotateGC(gc, tr, (float)Math.toDegrees(gdata.getRotation()), 
-				getVCenterX(), getVCenterY());
-	}
-	
-	public void adjustToHandle(Handle h) {
-		//Rotation
-		if 	(h == handleR) {
-			Point def = mRelativeToCenter(getMHandleLocation(h));
-			Point cur = mRelativeToCenter(new Point(h.mCenterx, h.mCentery));
-			
-			setRotation(gdata.getRotation() + LinAlg.angle(def, cur));
-			
-			return;
-		}
-					
-		// Transformation
-		Point mih = mToInternal(new Point(h.mCenterx, h.mCentery));
-		
-		double mdx = 0;
-		double mdy = 0;
-		double mdw = 0;
-		double mdh = 0;
-			
-		if	(h == handleN || h == handleNE || h == handleNW) {
-			mdy = -(mih.y + gdata.getMHeight()/2);
-			mdh = -mdy;
-		}
-		if	(h == handleS || h == handleSE || h == handleSW ) {
-			mdy = mih.y - gdata.getMHeight()/2;
-			mdh = mdy;
-		}
-		if	(h == handleE || h == handleNE || h == handleSE) {
-			mdx = mih.x - gdata.getMWidth()/2;
-			mdw = mdx;
-		}
-		if	(h == handleW || h == handleNW || h== handleSW) {
-			mdx = -(mih.x + gdata.getMWidth()/2);
-			mdw = -mdx;
-		};
-		
-		Point mnc = mCalcNewCenter(gdata.getMWidth() + mdw, gdata.getMHeight() + mdh);
-//		gdata.dontFireEvents(1);
-		gdata.setMHeight(gdata.getMHeight() + mdy);
-		gdata.setMWidth(gdata.getMWidth() + mdx);
-		setMCenter(mnc);		
-	
-		//In case object had zero width, switch handles
-		if(gdata.getMWidth() < 0) {
-			negativeWidth(h);
-		}
-		if(gdata.getMHeight() < 0) {
-			negativeHeight(h);
-		}
-	}
-	
-	/**
-	 * This method implements actions performed when the width of
-	 * the object becomes negative after adjusting to a handle
-	 * @param h	The handle this object adjusted to
-	 */
-	public void negativeWidth(Handle h) {
-		if(h.getDirection() == Handle.DIRECTION_FREE)  {
-			h = getOppositeHandle(h, Handle.DIRECTION_X);
-		} else {
-			h = getOppositeHandle(h, Handle.DIRECTION_XY);
-		}
-		double mw = -gdata.getMWidth();
-		double msx = gdata.getMLeft() - mw;
-//		gdata.dontFireEvents(1);
-		gdata.setMWidth (mw);
-		gdata.setMLeft(msx);
-		canvas.setPressedObject(h);
-	}
-	
-	/**
-	 * This method implements actions performed when the height of
-	 * the object becomes negative after adjusting to a handle
-	 * @param h	The handle this object adjusted to
-	 */
-	public void negativeHeight(Handle h) {
-		if(h.getDirection() == Handle.DIRECTION_FREE)  {
-			h = getOppositeHandle(h, Handle.DIRECTION_Y);
-		} else {
-			h = getOppositeHandle(h, Handle.DIRECTION_XY);
-		}
-		double ht = -gdata.getMHeight();
-		double sy = gdata.getMTop() - ht;
-//		gdata.dontFireEvents(1);
-		gdata.setMHeight(ht);
-		gdata.setMTop(sy);
-		canvas.setPressedObject(h);
-	}
-	
-	/**
-	 * Sets the handles at the correct location;
-	 * @param ignore the position of this handle will not be adjusted
-	 */
-	private void setHandleLocation(Handle ignore)
-	{
-		Point p;
-		p = getMHandleLocation(handleN);
-		if(ignore != handleN) handleN.setMLocation(p.x, p.y);
-		p = getMHandleLocation(handleE);
-		if(ignore != handleE) handleE.setMLocation(p.x, p.y);
-		p = getMHandleLocation(handleS);
-		if(ignore != handleS) handleS.setMLocation(p.x, p.y);
-		p = getMHandleLocation(handleW);
-		if(ignore != handleW) handleW.setMLocation(p.x, p.y);
-		
-		p = getMHandleLocation(handleNE);
-		if(ignore != handleNE) handleNE.setMLocation(p.x, p.y);
-		p = getMHandleLocation(handleSE);
-		if(ignore != handleSE) handleSE.setMLocation(p.x, p.y);
-		p = getMHandleLocation(handleSW);
-		if(ignore != handleSW) handleSW.setMLocation(p.x, p.y);
-		p = getMHandleLocation(handleNW);
-		if(ignore != handleNW) handleNW.setMLocation(p.x, p.y);
-
-		p = getMHandleLocation(handleR);
-		if(ignore != handleR) handleR.setMLocation(p.x, p.y);
-		
-		for(Handle h : getHandles()) h.rotation = gdata.getRotation();
-	}
-	
-	/**
-	 * Sets the handles at the correct location
-	 */
-	public void setHandleLocation()
-	{
-		setHandleLocation(null);
-	}
-	
-	/**
-	 * Get the default location of the given handle 
-	 * (in coordinates relative to the canvas)
-	 * @param h
-	 */
-	protected Point getVHandleLocation(Handle h) 
-	{
-		Point mp = getMHandleLocation (h);
-		if (mp != null)			
-			return new Point (vFromM(mp.x), vFromM(mp.y));
-		else return null;
-	}
-
-	protected Point getMHandleLocation(Handle h) {
-		if(h == handleN) return mToExternal(0, -gdata.getMHeight()/2);
-		if(h == handleE) return mToExternal(gdata.getMWidth()/2, 0);
-		if(h == handleS) return mToExternal(0,  gdata.getMHeight()/2);
-		if(h == handleW) return mToExternal(-gdata.getMWidth()/2, 0);
-		
-		if(h == handleNE) return mToExternal(gdata.getMWidth()/2, -gdata.getMHeight()/2);
-		if(h == handleSE) return mToExternal(gdata.getMWidth()/2, gdata.getMHeight()/2);
-		if(h == handleSW) return mToExternal(-gdata.getMWidth()/2, gdata.getMHeight()/2);
-		if(h == handleNW) return mToExternal(-gdata.getMWidth()/2, -gdata.getMHeight()/2);
-
-		if(h == handleR) return mToExternal(gdata.getMWidth()/2 + M_ROTATION_HANDLE_POSITION, 0);
-		return null;
-	}
-	
-	/**
-	 * Gets the handle opposite to the given handle.
-	 * For directions N, E, S and W this is always their complement,
-	 * for directions NE, NW, SE, SW, you can constraint the direction, e.g.:
-	 * if direction is X, the opposite of NE will be NW instead of SW
-	 * @param h	The handle to find the opposite for
-	 * @param direction	Constraints on the direction, one of {@link Handle}#DIRECTION_*.
-	 * Will be ignored for N, E, S and W handles
-	 * @return	The opposite handle
-	 */
-	Handle getOppositeHandle(Handle h, int direction) {
-		//Ignore direction for N, E, S and W
-		if(h == handleN) return handleS;
-		if(h == handleE) return handleW;
-		if(h == handleS) return handleN;
-		if(h == handleW) return handleE;
-				
-		int[] pos = handleFromMatrix(h);
-		switch(direction) {
-		case Handle.DIRECTION_XY:
-		case Handle.DIRECTION_MINXY:
-		case Handle.DIRECTION_FREE:
-			return handleMatrix[ Math.abs(pos[0] - 1)][ Math.abs(pos[1] - 1)];
-		case Handle.DIRECTION_Y:
-			return handleMatrix[ Math.abs(pos[0] - 1)][pos[1]];
-		case Handle.DIRECTION_X:
-			return handleMatrix[ pos[0]][ Math.abs(pos[1] - 1)];
-		default:
-			return null;
-		}
-	}
-	
-	int[] handleFromMatrix(Handle h) {
-		for(int x = 0; x < 2; x++) {
-			for(int y = 0; y < 2; y++) {
-				if(handleMatrix[x][y] == h) return new int[] {x,y};
-			}
-		}
-		return null;
-	}
-	
-	/**
-	 * Creates a shape of the outline of this object
-	 */
-	protected Shape getVOutline()
-	{
-		int[] x = new int[4];
-		int[] y = new int[4];
-		
-		int[] p = getVHandleLocation(handleNE).asIntArray();
-		x[0] = p[0]; y[0] = p[1];
-		p = getVHandleLocation(handleSE).asIntArray();
-		x[1] = p[0]; y[1] = p[1];
-		p = getVHandleLocation(handleSW).asIntArray();
-		x[2] = p[0]; y[2] = p[1];
-		p = getVHandleLocation(handleNW).asIntArray();
-		x[3] = p[0]; y[3] = p[1];
-		
-		Polygon pol = new Polygon(x, y, 4);
-		return pol;
-	}
-			
-	public void gmmlObjectModified(PathwayEvent e) {		
-		markDirty(); // mark everything dirty
-		setHandleLocation();
-	}
-	
-}
Index: trunk/src/core/org/pathvisio/view/VPathway.java
===================================================================
--- trunk/src/core/org/pathvisio/view/VPathway.java	(revision 956)
+++ trunk/src/core/org/pathvisio/view/VPathway.java	(revision 957)
@@ -1,1434 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.view;
-
-
-import java.awt.Rectangle;
-import java.awt.geom.Point2D;
-import java.awt.geom.Rectangle2D;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.events.KeyEvent;
-import org.eclipse.swt.events.KeyListener;
-import org.eclipse.swt.events.MouseEvent;
-import org.eclipse.swt.events.MouseListener;
-import org.eclipse.swt.events.MouseMoveListener;
-import org.eclipse.swt.events.MouseTrackListener;
-import org.eclipse.swt.events.PaintEvent;
-import org.eclipse.swt.events.PaintListener;
-import org.eclipse.swt.graphics.GC;
-import org.eclipse.swt.graphics.Image;
-import org.eclipse.swt.graphics.Point;
-import org.eclipse.swt.widgets.Canvas;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Shell;
-
-import org.pathvisio.visualization.Visualization;
-import org.pathvisio.visualization.VisualizationManager;
-import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
-import org.pathvisio.visualization.VisualizationManager.VisualizationListener;
-import org.pathvisio.model.*;
-import org.pathvisio.model.PathwayElement.MPoint;
-import org.pathvisio.gui.swt.*;
-
-/**
- * This class implements and handles a drawing.
- * Graphics objects are stored in the drawing and can be 
- * visualized. The class also provides methods for mouse  and key
- * event handling.
- */
-public class VPathway extends Canvas implements MouseListener, MouseMoveListener, 
-PaintListener, MouseTrackListener, KeyListener, PathwayListener, VisualizationListener
-{	
-	private static final long serialVersionUID = 1L;
-	static final double M_PASTE_OFFSET = 10 * 15;
-	
-	/**
-	 * All objects that are visible on this mapp, including the handles
-	 * but excluding the legend, mappInfo and selectionBox objects
-	 */
-	private ArrayList<VPathwayElement> drawingObjects;
-	public ArrayList<VPathwayElement> getDrawingObjects() { return drawingObjects; }
-	
-	/**
-	 * The {@link VPathwayElement} that is pressed last mouseDown event}
-	 */
-	VPathwayElement pressedObject	= null;	
-	
-	/**
-	 * The {@link Graphics} that is directly selected since last mouseDown event
-	 */
-	public Graphics selectedGraphics = null;
-	
-	/**
-	 * {@link InfoBox} object that contains information about this pathway,
-	 * currently only used for information in {@link gmmlVision.PropertyPanel}
-	 * (TODO: has to be implemented to behave the same as any Graphics object
-	 * when displayed on the drawing)
-	 */
-	InfoBox infoBox;
-	private Pathway data;
-	public Pathway getGmmlData()
-	{
-		return data;
-	}
-	
-	SelectionBox s; 
-		
-	private boolean editMode;
-	/**
-	 * Checks if this drawing is in edit mode
-	 * @return false if in edit mode, true if not
-	 */
-	public boolean isEditMode() { return editMode; }
-	
-	/**
-	 * Map the contents of a single data object to this VPathway
-	 */	
-	private Graphics fromGmmlDataObject (PathwayElement o)
-	{
-		Graphics result = null;
-		switch (o.getObjectType())
-		{
-			case ObjectType.DATANODE: result = new GeneProduct(this, o); break;
-			case ObjectType.SHAPE: result = new Shape(this, o); break;
-			case ObjectType.LINE: result = new Line(this, o); break;
-			case ObjectType.MAPPINFO: 
-				InfoBox mi = new InfoBox(this, o);
-				addObject(mi); 
-				setMappInfo(mi);
-				result = mi; 
-				break;				
-			case ObjectType.LABEL: result = new Label(this, o); break;					
-			case ObjectType.GROUP: result = new Group(this, o); break;					
-		}
-		return result;
-	}
-	
-	/**
-	 * Maps the contents of a pathway to this VPathway
-	 */	
-	public void fromGmmlData(Pathway _data)
-	{		
-		data = _data;
-			
-		for (PathwayElement o : data.getDataObjects())
-		{
-			fromGmmlDataObject (o);
-		}
-		int width = (int)vFromM(infoBox.getGmmlData().getMBoardWidth());
-		int height = (int)vFromM(infoBox.getGmmlData().getMBoardHeight());
-		setSize(width, height); 
-		data.fireObjectModifiedEvent(new PathwayEvent(null, PathwayEvent.MODIFIED_GENERAL));
-		data.addListener(this);
-	}
-
-	private int newGraphics = NEWNONE;
-	/**
-	 * Method to set the new graphics type that has to be added next time the user clicks on the
-	 * drawing. 
-	 * @param type One of the NEWXX fields of this class, where XX stands for the type of graphics to draw
-	 */
-	public void setNewGraphics(int type) { newGraphics = type; }
-	
-	private Rectangle dirtyRect = null;
-	/**
-	 * Adds object boundaries to the 'dirty rectangle', which marks the area that needs to be redrawn
-	 */
-	public void addDirtyRect(Rectangle r)
-	{
-		if(r == null) { //In case r is null, add whole drawing
-			org.eclipse.swt.graphics.Rectangle b = getBounds();
-			r = new Rectangle(b.x, b.y, b.width, b.height);
-		}
-		if(dirtyRect == null)
-			dirtyRect = r;
-		else
-			dirtyRect.add(r);	
-	}
-	
-	/**
-	 * Redraw parts marked dirty
-	 * reset dirty rect afterwards
-	 */
-	public void redrawDirtyRect()
-	{
-		if (dirtyRect != null)
-			redraw (dirtyRect.x, dirtyRect.y, dirtyRect.width + 1, dirtyRect.height + 1, false);
-		dirtyRect = null;
-	}
-	
-	/**
-	 *Constructor for this class
-	 */	
-	public VPathway(Composite parent, int style)
-	{
-		super (parent, style);
-		
-		drawingObjects	= new ArrayList<VPathwayElement>();
-		
-		s = new SelectionBox(this);
-		
-		addMouseListener(this);
-		addMouseMoveListener(this);
-		addPaintListener (this);
-		addMouseTrackListener(this);
-		addKeyListener(this);
-		VisualizationManager.addListener(this);
-	}
-		
-	/**
-	 * Sets the MappInfo containing information on the pathway
-	 * @param mappInfo
-	 */
-	public void setMappInfo(InfoBox mappInfo)
-	{
-		this.infoBox = mappInfo;
-		infoBox.getGmmlData().addListener(this);
-	}
-
-	/**
-	 * Gets the MappInfo containing information on the pathway
-	 */
-	public InfoBox getMappInfo() { return infoBox; }
-		
-	/**
-	 * Adds an element to the drawing
-	 * @param o the element to add
-	 */
-	public void addObject(VPathwayElement o)
-	{
-		if(!drawingObjects.contains(o)) { //Don't add duplicates!
-			drawingObjects.add(o);
-		}
-		
-	}
-
-	HashMap<MPoint, VPoint> pointsMtoV = new HashMap<MPoint, VPoint>();
-	protected VPoint getPoint(MPoint mPoint) {
-		VPoint p = pointsMtoV.get(mPoint);
-		if(p == null) {
-			p = newPoint(mPoint);
-		}
-		return p;
-	}
-	
-	
-	private VPoint newPoint(MPoint mPoint) {
-		VPoint p = null;
-		for(MPoint ep : mPoint.getEqualPoints()) {
-			p = pointsMtoV.get(ep);
-			if(p != null) {
-				p.addMPoint(mPoint);
-				pointsMtoV.put(mPoint, p);
-				break;
-			}
-		}
-		if(p == null) p = new VPoint(this);
-		p.addMPoint(mPoint);
-		pointsMtoV.put(mPoint, p);
-		return p;
-	}
-	
-	/**
-	 * Get the gene identifiers of all genes in this pathway
-	 * @return	List containing an identifier for every gene on the mapp
-	 * @deprecated get this info from Pathway directly
-	 */
-	public ArrayList<String> getMappIds()
-	{
-		ArrayList<String> mappIds = new ArrayList<String>();
-		for(VPathwayElement o : drawingObjects)
-		{
-			if(o instanceof GeneProduct)
-			{
-				mappIds.add(((GeneProduct)o).getID());
-			}
-		}
-		return mappIds;
-	}
-	
-	/**
-	 * Get the systemcodes of all genes in this pathway
-	 * @return	List containing a systemcode for every gene on the mapp
-	 * 
-	 * @deprecated get this info from Pathway directly
-	 */
-	public ArrayList<String> getSystemCodes()
-	{
-		ArrayList<String> systemCodes = new ArrayList<String>();
-		for(VPathwayElement o : drawingObjects)
-		{
-			if(o instanceof GeneProduct)
-			{
-				systemCodes.add(((GeneProduct)o).getSystemCode());
-			}
-		}
-		return systemCodes;
-	}
-	
-	/**
-	 * Set this drawing to editmode
-	 * @param editMode	true if editmode has to be enabled, false if disabled (view mode)
-	 */
-	public void setEditMode(boolean editMode)
-	{
-		this.editMode = editMode;
-		if(!editMode)
-		{
-			clearSelection();
-		}
-		Engine.getWindow().showLegend(!editMode);	
-		redraw();
-	}
-	
-	private double zoomFactor = 1.0/15.0;
-	/**
-	 * Get the current zoomfactor used. 
-	 * 1/15 means 100%, 15 gpml unit = 1 pixel
-	 * 2/15 means 200%, 7.5 gpml unit = 1 pixel
-	 * 
-	 * The 15/1 ratio is there because of 
-	 * the Visual Basic legacy of GenMAPP
-	 * 
-	 * To distinguish between model coordinates and view coordinates,
-	 * we prefix all coordinates with either v or m (or V or M). For example:
-	 * 
-	 * mTop = gdata.getMTop();
-	 * vTop = GeneProduct.getVTop();
-	 * 
-	 * Calculations done on M's and V's should always match.
-	 * The only way to convert is to use the functions
-	 * mFromV and vFromM.
-	 * 
-	 * Correct: mRight = mLeft + mWidth;
-	 * Wrong: mLeft += vDx; 
-	 * Fixed: mLeft += mFromV(vDx);
-	 * 
-	 * @return	the current zoomfactor
-	 */
-	public double getZoomFactor() { return zoomFactor; }
-
-	/**
-	 * same as getZoomFactor, but in %
-	 * @return
-	 */
-	public double getPctZoom() { return zoomFactor * 100 * 15.0; }
-
-	/**
-	 * Sets the drawings zoom in percent
-	 * @param pctZoomFactor zoomfactor in percent
-	 */
-	public void setPctZoom(double pctZoomFactor)
-	{
-		zoomFactor = pctZoomFactor / 100.0 / 15.0;
-		int width = (int)vFromM(infoBox.getGmmlData().getMBoardWidth());
-		int height = (int)vFromM(infoBox.getGmmlData().getMBoardHeight());
-		setSize(width, height); 				
-		redraw();
-	}
-
-	public void setPressedObject(VPathwayElement o) {
-		pressedObject = o;
-	}
-	
-	int vPreviousX;
-	int vPreviousY;
-	boolean isDragging;
-	/**
-	 * handles mouse movement
-	 */
-	public void mouseMove(MouseEvent ve)
-	{
-		boolean altPressed = (ve.stateMask & SWT.ALT) != 0;
-		// If draggin, drag the pressed object
-		if (pressedObject != null && isDragging)
-		{
-			double vdx = ve.x - vPreviousX;
-			double vdy = ve.y - vPreviousY;
-			pressedObject.vMoveBy(vdx, vdy);
-				
-			vPreviousX = ve.x;
-			vPreviousY = ve.y;
-			
-			if (pressedObject instanceof Handle && altPressed && newGraphics == NEWNONE &&
-					((Handle)pressedObject).parent instanceof VPoint)
-			{
-				resetHighlight();
-				Point2D p2d = new Point2D.Double(ve.x, ve.y);
-				List<VPathwayElement> objects = getObjectsAt (p2d);
-				Collections.sort(objects);
-				Handle g = (Handle)pressedObject;
-				VPoint p = (VPoint)g.parent;
-				VPathwayElement x = null;
-				for (VPathwayElement o : objects)
-				{
-					if (o instanceof VPoint && o != p) {
-						x = o;
-						p.link((VPoint)o);
-						break;
-					} else if(o instanceof Graphics && !(o instanceof Line)) {
-						x = o;
-						p.link((Graphics)o);
-						break;
-					} 
-				}
-				if(x != null) x.highlight();
-			}
-			redrawDirtyRect();
-		}
-	}
-	
-	public void selectObject(VPathwayElement o) {
-		clearSelection();
-		lastAdded.select();
-		s.addToSelection(lastAdded);
-	}
-	
-	/**
-	 * Handles mouse Pressed input
-	 */
-	public void mouseDown(MouseEvent e)
-	{		
-		setFocus();
-		if (editMode)
-		{
-			if (newGraphics != NEWNONE)
-			{
-				newObject(new Point(e.x, e.y));
-				Engine.getWindow().deselectNewItemActions();
-			}
-			else
-			{
-				editObject(new Point(e.x, e.y), e);
-			}
-		}
-		else
-		{
-			mouseDownViewMode(e);
-		}
-
-	}
-		
-	/**
-	 * Handles mouse Released input
-	 */
-	public void mouseUp(MouseEvent e)
-	{
-		if(isDragging)
-		{
-			resetHighlight();
-			if(s.isSelecting()) { //If we were selecting, stop it
-				s.stopSelecting();
-			}
-			// check if we placed a new object by clicking or dragging
-			// if it was a click, give object the initial size.
-			else if (newObject != null && 
-					Math.abs(newObjectDragStart.x - e.x) <= MIN_DRAG_LENGTH &&
-					Math.abs(newObjectDragStart.y - e.y) <= MIN_DRAG_LENGTH)
-			{
-				newObject.setInitialSize();
-			}
-			newObject = null;
-			redrawDirtyRect();
-		}
-		isDragging = false;
-	}
-	
-	/**
-	 * Handles mouse entered input
-	 */
-	public void mouseDoubleClick(MouseEvent e) {	}
-
-	/**
-	 * Paints all components in the drawing.
-	 * This method is called automatically in the 
-	 * painting process
-	 */
-	public void paintControl (PaintEvent e)
-	{		
-		Image image = (Image)getData("double-buffer-image");
-		// create an image for double-buffering, if it doesn't exist 
-		// or the component has been resized
-		if(image == null
-				|| image.getBounds().width != getSize().x
-				|| image.getBounds().height != getSize().y)
-		{
-			Engine.log.trace("Creating image of size " + getSize().x + ", " + getSize().y);
-			image = new Image(getDisplay(), getSize().x, getSize().y);
-			setData("double-buffer-image", image);
-		}
-
-		GC buffer = new GC(image);
-		buffer.setBackground(e.display.getSystemColor(SWT.COLOR_WHITE));
-		buffer.fillRectangle(e.x, e.y, e.width, e.height);
-		
-		buffer.setAntialias(SWT.ON);
-		
-		Rectangle2D.Double r = new Rectangle.Double(e.x, e.y, e.width, e.height);
-		    	
-		Collections.sort(drawingObjects);
-		
-		Visualization v = VisualizationManager.getCurrent();
-		for(VPathwayElement o : drawingObjects)
-		{
-			if(o.vIntersects(r))
-			{
-				if(checkDrawAllowed(o)) {
-					o.draw (e, buffer);
-				}
-				
-				if(v != null && o instanceof Graphics) {
-						try {
-							v.visualizeDrawing((Graphics) o, e, buffer);
-						} catch(Exception ex) {
-							Engine.log.error(
-									"Unable to apply visualization " + v + " on " + o, ex);
-							ex.printStackTrace();
-						}
-				}
-				if(o instanceof GeneProduct) ((GeneProduct)o).drawHighlight(e, buffer);
-			}
-		}
-		
-		e.gc.drawImage(image, 0, 0);
-		buffer.dispose();
-	}
-
-	boolean checkDrawAllowed(VPathwayElement o) {
-		if(isEditMode()) return true;
-		else return !(	o instanceof Handle ||
-						(o == s && !isDragging)
-					);
-	}
-
-	/**
-	 * deselect all elements on the drawing
-	 */
-	private void clearSelection()
-	{
-		for(VPathwayElement o : drawingObjects) o.deselect(); //Deselect all objects
-		s.reset();
-	}
-
-	/**
-	 * Handles event when on mouseDown in case the drawing is in view mode
-	 * (does nothing yet)
-	 * @param e	the mouse event to handle
-	 */
-	private void mouseDownViewMode(MouseEvent e) 
-	{
-		Point2D p2d = new Point2D.Double(e.x, e.y);
-
-		pressedObject = getObjectAt(p2d);
-		
-		if (pressedObject != null)
-			doClickSelect(p2d, e);
-		else
-			startSelecting(p2d);
-	}
-	
-	/**
-	 * Initializes selection, resetting the selectionbox
-	 * and then setting it to the position specified
-	 * @param vp - the point to start with the selection
-	 */
-	private void startSelecting(Point2D vp)
-	{
-		vPreviousX = (int)vp.getX();
-		vPreviousY = (int)vp.getY();
-		isDragging = true;
-		
-		clearSelection();
-		s.reset(vp.getX(), vp.getY());
-		s.startSelecting();
-		pressedObject = s.getCornerHandle();
-	}
-		
-	/**
-	 * Resets highlighting, unhighlights all GmmlDrawingObjects
-	 */
-	public void resetHighlight() 
-	{
-		for(VPathwayElement o : drawingObjects) o.unhighlight();
-		redraw();
-	}
-	
-	/**
-	 * Called by MouseDown, when we're in editting mode and we're not adding new objects
-	 * prepares for dragging the object
-	 */
-	private void editObject(Point p, MouseEvent e)
-	{
-		Point2D p2d = new Point2D.Double(p.x, p.y);
-		
-		pressedObject = getObjectAt(p2d);
-		
-		// if we clicked on an object
-		if (pressedObject != null)
-		{
-			// if our object is an handle, select also it's parent.
-			if(pressedObject instanceof Handle)
-			{
-				((Handle)pressedObject).parent.select();
-			} else {
-				doClickSelect(p2d, e);
-			}
-			
-			// start dragging
-			vPreviousX = p.x;
-			vPreviousY = p.y;
-			
-			isDragging = true;		
-		}
-		else
-		{
-			// start dragging selectionbox	
-			startSelecting(p2d);
-		}		
-	}
-
-	/**
-	 * Find the object at a particular location on the drawing
-	 * 
-	 * if you want to get more than one @see #getObjectsAt(Point2D)
-	 */
-	VPathwayElement getObjectAt(Point2D p2d) {
-		Collections.sort(drawingObjects);
-		VPathwayElement probj = null;
-		for (VPathwayElement o : drawingObjects)
-		{
-			if (o.vContains(p2d))
-			{
-				// select this object, unless it is an invisible gmmlHandle
-				if (o instanceof Handle && !((Handle)o).isVisible()) 
-					;
-				else 
-					probj = o;
-			}
-		}
-		return probj;
-	}
-	
-	/**
-	 * Find all objects at a particular location on the drawing
-	 * 
-	 * if you only need the top object, @see #getObjectAt(Point2D)
-	 */
-	List<VPathwayElement> getObjectsAt(Point2D p2d) 
-	{
-		List<VPathwayElement> result = new ArrayList<VPathwayElement>();
-		for (VPathwayElement o : drawingObjects)
-		{
-			if (o.vContains(p2d))
-			{
-				// select this object, unless it is an invisible gmmlHandle
-				if (o instanceof Handle && !((Handle)o).isVisible()) 
-					;
-				else 
-					result.add(o);
-			}
-		}
-		return result;
-	}
-	
-	void doClickSelect(Point2D p2d, MouseEvent e) {
-		//Ctrl pressed, add/remove from selection
-		boolean ctrlPressed =  (e.stateMask & SWT.CTRL) != 0;
-		if(ctrlPressed) 
-		{
-			if(pressedObject instanceof SelectionBox) {
-				//Object inside selectionbox clicked, pass to selectionbox
-				s.objectClicked(p2d);
-			}
-			else if(pressedObject.isSelected()) { //Already in selection: remove
-				s.removeFromSelection(pressedObject);
-			} else {
-				s.addToSelection(pressedObject); //Not in selection: add
-			}
-			pressedObject = null; //Disable dragging
-		} 
-		else //Ctrl not pressed
-		{
-			//If pressedobject is not selectionbox:
-			//Clear current selection and select pressed object
-			if(!(pressedObject instanceof SelectionBox))
-			{
-				clearSelection();
-				s.addToSelection(pressedObject);
-			} else { //Check if clicked object inside selectionbox
-				if(s.getChild(p2d) == null) clearSelection();
-			}
-		}
-		redrawDirtyRect();
-	}
-	
-	public static final int NEWNONE = -1;
-	public static final int NEWLINE = 0;
-	public static final int NEWLABEL = 1;
-	public static final int NEWARC = 2;
-	public static final int NEWBRACE = 3;
-	public static final int NEWGENEPRODUCT = 4;
-	public static final int NEWLINEDASHED = 5;
-	public static final int NEWLINEARROW = 6;
-	public static final int NEWLINEDASHEDARROW = 7;
-	public static final int NEWRECTANGLE = 8;
-	public static final int NEWOVAL = 9;
-	public static final int NEWTBAR = 10;
-	public static final int NEWRECEPTORROUND = 11;
-	public static final int NEWLIGANDROUND = 12;
-	public static final int NEWRECEPTORSQUARE = 13;
-	public static final int NEWLIGANDSQUARE = 14;
-	public static final int NEWLINEMENU = 15;
-	public static final int NEWLINESHAPEMENU = 16;
-	public static final Color stdRGB = new Color(0, 0, 0);
-
-	/**
-	 * pathvisio distinguishes between placing objects with a click
-	 * or with a drag. If you don't move the cursor in between the mousedown
-	 * and mouseup event, the object is placed with a default initial size.
-	 * 
-	 * newObjectDragStart is used to determine the mousemovement during the click.
-	 */
-	private Point newObjectDragStart;
-	
-	/** newly placed object, is set to null again when mouse button is released */
-	private PathwayElement newObject = null;
-	/** minimum drag length for it to be considered a drag and not a click */
-	private static final int MIN_DRAG_LENGTH = 3;
-
-	/**
-	 * Add a new object to the drawing
-	 * {@see VPathway#setNewGraphics(int)}
-	 * @param p	The point where the user clicked on the drawing to add a new graphics
-	 */
-	private void newObject(Point ve)
-	{
-		newObjectDragStart = ve;
-		int mx = (int)mFromV((double)ve.x);
-		int my = (int)mFromV((double)ve.y); 
-		
-		PathwayElement gdata = null;
-		Handle h = null;
-		lastAdded = null; // reset lastAdded class member
-		switch(newGraphics) {
-		case NEWNONE:
-			return;
-		case NEWLINE:
-			gdata = new PathwayElement(ObjectType.LINE);
-			gdata.setMStartX(mx);
-			gdata.setMStartY(my);
-			gdata.setMEndX(mx);
-			gdata.setMEndY(my);	
-			gdata.setColor (stdRGB);
-			gdata.setLineStyle (LineStyle.SOLID);
-			gdata.setLineType (LineType.LINE);
-			data.add (gdata); // will cause lastAdded to be set
-			h = ((Line)lastAdded).getEnd().getHandle();
-			isDragging = true;
-			break;
-		case NEWLINEARROW:
-			gdata = new PathwayElement(ObjectType.LINE);
-			gdata.setMStartX(mx);
-			gdata.setMStartY(my);
-			gdata.setMEndX(mx);
-			gdata.setMEndY(my);	
-			gdata.setColor (stdRGB);
-			gdata.setLineStyle (LineStyle.SOLID);
-			gdata.setLineType (LineType.ARROW);
-			data.add (gdata); // will cause lastAdded to be set
-			h = ((Line)lastAdded).getEnd().getHandle();
-			isDragging = true;
-			break;
-		case NEWLINEDASHED:
-			gdata = new PathwayElement(ObjectType.LINE);
-			gdata.setMStartX(mx);
-			gdata.setMStartY(my);
-			gdata.setMEndX(mx);
-			gdata.setMEndY(my);	
-			gdata.setColor (stdRGB);
-			gdata.setLineStyle (LineStyle.DASHED);
-			gdata.setLineType (LineType.LINE);
-			data.add (gdata); // will cause lastAdded to be set
-			h = ((Line)lastAdded).getEnd().getHandle();
-			isDragging = true;
-			break;
-		case NEWLINEDASHEDARROW:
-			gdata = new PathwayElement(ObjectType.LINE);
-			gdata.setMStartX(mx);
-			gdata.setMStartY(my);
-			gdata.setMEndX(mx);
-			gdata.setMEndY(my);	
-			gdata.setColor (stdRGB);
-			gdata.setLineStyle (LineStyle.DASHED);
-			gdata.setLineType (LineType.ARROW);
-			data.add (gdata); // will cause lastAdded to be set
-			h = ((Line)lastAdded).getEnd().getHandle();
-			isDragging = true;
-			break;
-		case NEWLABEL:
-			gdata = new PathwayElement(ObjectType.LABEL);
-			gdata.setMCenterX(mx);
-			gdata.setMCenterY(my);
-			gdata.setMWidth(Label.M_INITIAL_WIDTH);
-			gdata.setMHeight(Label.M_INITIAL_HEIGHT);
-			gdata.setMFontSize (Label.M_INITIAL_FONTSIZE);
-			gdata.setGraphId(data.getUniqueId());
-			data.add (gdata); // will cause lastAdded to be set
-			((Label)lastAdded).createTextControl();
-			h = null;
-			break;
-		case NEWARC:
-			gdata = new PathwayElement(ObjectType.SHAPE);
-			gdata.setShapeType(ShapeType.ARC);
-			gdata.setMCenterX (mx);
-			gdata.setMCenterY (my);
-			gdata.setMWidth(1);
-			gdata.setMHeight(1);
-			gdata.setColor(stdRGB);
-			gdata.setRotation (0);
-			data.add (gdata); // will cause lastAdded to be set
-			h = ((Shape)lastAdded).handleSE;
-			isDragging = true;
-			break;
-		case NEWBRACE:
-			gdata = new PathwayElement(ObjectType.SHAPE);
-			gdata.setShapeType(ShapeType.BRACE);
-			gdata.setMCenterX (mx);
-			gdata.setMCenterY (my);
-			gdata.setMWidth(1);
-			gdata.setMHeight(1);
-			gdata.setOrientation(OrientationType.RIGHT);
-			gdata.setColor(stdRGB);
-			data.add (gdata); // will cause lastAdded to be set
-			h = ((Shape)lastAdded).handleSE;
-			isDragging = true;
-			break;
-		case NEWGENEPRODUCT:
-			gdata = new PathwayElement(ObjectType.DATANODE);
-			gdata.setMCenterX(mx);
-			gdata.setMCenterY(my);
-			gdata.setMWidth(1);
-			gdata.setMHeight(1);
-			gdata.setTextLabel("Gene");
-			gdata.setXref("");
-			gdata.setColor(stdRGB);
-			gdata.setGraphId(data.getUniqueId());
-			data.add (gdata); // will cause lastAdded to be set
-			h = ((GeneProduct)lastAdded).handleSE;
-			isDragging = true;
-			break;
-		case NEWRECTANGLE:
-			gdata = new PathwayElement(ObjectType.SHAPE);
-			gdata.setShapeType(ShapeType.RECTANGLE);
-			gdata.setMCenterX (mx);
-			gdata.setMCenterY (my);
-			gdata.setMWidth(1);
-			gdata.setMHeight(1);
-			gdata.setColor(stdRGB);
-			gdata.setRotation (0);
-			gdata.setGraphId(data.getUniqueId());
-			data.add (gdata); // will cause lastAdded to be set
-			h = ((Shape)lastAdded).handleSE;
-			isDragging = true;
-			break;
-		case NEWOVAL:
-			gdata = new PathwayElement(ObjectType.SHAPE);
-			gdata.setShapeType(ShapeType.OVAL);
-			gdata.setMCenterX (mx);
-			gdata.setMCenterY (my);
-			gdata.setMWidth(1);
-			gdata.setMHeight(1);
-			gdata.setColor(stdRGB);
-			gdata.setRotation (0);
-			gdata.setGraphId(data.getUniqueId());
-			data.add (gdata); // will cause lastAdded to be set
-			h = ((Shape)lastAdded).handleSE;
-			isDragging = true;
-			break;
-		case NEWTBAR:
-			gdata = new PathwayElement(ObjectType.LINE);
-			gdata.setMStartX(mx);
-			gdata.setMStartY(my);
-			gdata.setMEndX(mx);
-			gdata.setMEndY(my);	
-			gdata.setColor (stdRGB);
-			gdata.setLineStyle (LineStyle.SOLID);
-			gdata.setLineType (LineType.TBAR);
-			data.add (gdata); // will cause lastAdded to be set
-			h = ((Line)lastAdded).getEnd().getHandle();
-			isDragging = true;
-			break;
-		case NEWRECEPTORROUND:
-			gdata = new PathwayElement(ObjectType.LINE);
-			gdata.setMStartX(mx);
-			gdata.setMStartY(my);
-			gdata.setMEndX(mx);
-			gdata.setMEndY(my);	
-			gdata.setColor (stdRGB);
-			gdata.setLineStyle (LineStyle.SOLID);
-			gdata.setLineType (LineType.RECEPTOR_ROUND);
-			data.add (gdata); // will cause lastAdded to be set
-			h = ((Line)lastAdded).getEnd().getHandle();
-			isDragging = true;
-			break;
-		case NEWRECEPTORSQUARE:
-			gdata = new PathwayElement(ObjectType.LINE);
-			gdata.setMStartX(mx);
-			gdata.setMStartY(my);
-			gdata.setMEndX(mx);
-			gdata.setMEndY(my);	
-			gdata.setColor (stdRGB);
-			gdata.setLineStyle (LineStyle.SOLID);
-			gdata.setLineType (LineType.RECEPTOR_SQUARE);
-			data.add (gdata); // will cause lastAdded to be set
-			h = ((Line)lastAdded).getEnd().getHandle();
-			isDragging = true;
-			break;
-		case NEWLIGANDROUND:
-			gdata = new PathwayElement(ObjectType.LINE);
-			gdata.setMStartX(mx);
-			gdata.setMStartY(my);
-			gdata.setMEndX(mx);
-			gdata.setMEndY(my);	
-			gdata.setColor (stdRGB);
-			gdata.setLineStyle (LineStyle.SOLID);
-			gdata.setLineType (LineType.LIGAND_ROUND);
-			data.add (gdata); // will cause lastAdded to be set
-			h = ((Line)lastAdded).getEnd().getHandle();
-			isDragging = true;
-			break;
-		case NEWLIGANDSQUARE:
-			gdata = new PathwayElement(ObjectType.LINE);
-			gdata.setMStartX(mx);
-			gdata.setMStartY(my);
-			gdata.setMEndX(mx);
-			gdata.setMEndY(my);	
-			gdata.setColor (stdRGB);
-			gdata.setLineStyle (LineStyle.SOLID);
-			gdata.setLineType (LineType.LIGAND_SQUARE);
-			data.add (gdata); // will cause lastAdded to be set
-			h = ((Line)lastAdded).getEnd().getHandle();
-			isDragging = true;
-			break;
-		}
-		
-		newObject = gdata;
-		selectObject(lastAdded);
-		pressedObject = h;
-		
-		vPreviousX = ve.x;
-		vPreviousY = ve.y;
-				
-	}
-	
-
-	public static final int DRAW_ORDER_HANDLE = -1;
-	public static final int DRAW_ORDER_GROUP = 0;
-	public static final int DRAW_ORDER_SELECTIONBOX = 1;
-	public static final int DRAW_ORDER_SELECTED = 2;
-	public static final int DRAW_ORDER_GENEPRODUCT = 3;
-	public static final int DRAW_ORDER_LABEL = 4;
-	public static final int DRAW_ORDER_ARC = 5;
-	public static final int DRAW_ORDER_BRACE = 6;
-	public static final int DRAW_ORDER_SHAPE = 7;
-	public static final int DRAW_ORDER_LINE = 8;
-	public static final int DRAW_ORDER_LINESHAPE = 9;
-	public static final int DRAW_ORDER_MAPPINFO = 10;
-	public static final int DRAW_ORDER_DEFAULT = 11;
-	
-	public void mouseEnter(MouseEvent e) {}
-
-	public void mouseExit(MouseEvent e) {}
-	
-	/**
-	 * Responsible for drawing a tooltip displaying expression data when 
-	 * hovering over a geneproduct
-	 */
-	public void mouseHover(MouseEvent e) {
-		Visualization v = VisualizationManager.getCurrent();
-		if(v != null && v.usesToolTip()) {
-			Point2D p = new Point2D.Double(e.x, e.y);
-			
-			VPathwayElement o = getObjectAt(p);
-			if(o != null && o instanceof Graphics) {
-				Shell tip = v.visualizeToolTip(getShell(), this, (Graphics)o);
-				if(tip == null) return;
-				Point mp = toDisplay(e.x + 15, e.y + 15);
-				tip.setLocation(mp.x, mp.y);
-	            tip.setVisible(true);
-			}
-		}
-	}
-
-	private void selectGeneProducts() {
-		clearSelection();
-		for(VPathwayElement o : getDrawingObjects()) {
-			if(o instanceof GeneProduct) s.addToSelection(o);
-		}
-	}
-	
-	private void insertPressed() {
-		Set<VPathwayElement> objects = new HashSet<VPathwayElement>();
-		objects.addAll(s.getSelection());
-		for(VPathwayElement o : objects) {
-			if(o instanceof Line) {
-				PathwayElement g = ((Line)o).getGmmlData();
-				PathwayElement[] gNew = g.splitLine();
-							
-				removeDrawingObject(o); //Remove the old line
-				
-				//Clear refs on middle point (which is new)
-				gNew[0].getMEnd().setGraphRef(null);
-				gNew[1].getMStart().setGraphRef(null);
-				
-				gNew[1].setGraphId(data.getUniqueId());
-				data.add(gNew[0]);
-				Line l1 = (Line)lastAdded;
-				data.add(gNew[1]);
-				Line l2 = (Line)lastAdded;				
-				
-				l1.getEnd().link(l2.getStart());
-			}
-		}
-		s.addToSelection(lastAdded);
-	}
-	
-	public void createGroup() {
-		//GroupId is created on first getGroupId call
-		PathwayElement group = new PathwayElement(ObjectType.GROUP);
-		data.add(group);
-		
-		group.setTextLabel("new group");
-		group.setGroupStyle(GroupStyle.NONE);
-		
-		String id = group.getGroupId();
-		
-		//Add the selected pathway elements
-		List<Graphics> selection = getSelectedGraphics();
-		
-		for(Graphics g : selection) {
-			PathwayElement pe = g.getGmmlData(); 
-			String ref = pe.getGroupRef();
-			if(ref == null) {
-				pe.setGroupRef(id);
-			} else if(ref != id) {
-				PathwayElement refGroup = data.getGroupById(ref);
-				refGroup.setGroupRef(id);
-			}
-		}
-	}
-
-	public void keyPressed(KeyEvent e) { 
-		//if(e.keyCode == SWT.CTRL) ctrlPressed();
-		//if(e.keyCode == SWT.ALT) altPressed();
-		if(e.keyCode == SWT.INSERT) insertPressed();
-		if(e.keyCode == 100) //CTRL-D to select all gene-products
-			if((e.stateMask & SWT.CTRL) != 0) {
-				selectGeneProducts();
-				redraw();
-			}
-		if(e.keyCode == 103) //CTRL-G to select all gene-products
-			if((e.stateMask & SWT.CTRL) != 0) {
-				//do group thing
-				createGroup();
-			}
-	}
-
-	
-	
-	public void keyReleased(KeyEvent e) {		
-		//if(e.keyCode == SWT.CTRL) ctrlReleased();
-		//if(e.keyCode == SWT.ALT) altReleased();
-		if(e.keyCode == SWT.DEL) {
-			ArrayList<VPathwayElement> toRemove = new ArrayList<VPathwayElement>();
-			for(VPathwayElement o : drawingObjects)
-			{
-				if(!o.isSelected() || o == s || o == infoBox) continue; //Object not selected, skip
-				toRemove.add(o);
-			}
-			removeDrawingObjects(toRemove);
-		}
-	}
-	
-	/**
-	 * Removes the GmmlDrawingObjects in the ArrayList from the drawing
-	 * @param toRemove	The List containing the objects to be removed
-	 */
-	public void removeDrawingObjects(ArrayList<VPathwayElement>toRemove)
-	{
-		for(VPathwayElement o : toRemove)
-		{
-			removeDrawingObject(o);
-			
-		}
-		s.fitToSelection();
-	}
-	
-	public void removeDrawingObject(VPathwayElement toRemove) {
-		toRemove.destroy(); //Object will remove itself from the drawing
-		s.removeFromSelection(toRemove); //Remove from selection
-	}
-
-	Graphics lastAdded = null;
-	
-	public void gmmlObjectModified(PathwayEvent e) {
-		switch (e.getType())
-		{
-			case PathwayEvent.DELETED:
-				// TODO: affected object should be removed
-				addDirtyRect(null); // mark everything dirty
-				break;
-			case PathwayEvent.ADDED:
-				lastAdded = fromGmmlDataObject(e.getAffectedData());
-				addDirtyRect(null); // mark everything dirty
-				break;
-			case PathwayEvent.WINDOW:
-				int width = (int)vFromM(infoBox.getGmmlData().getMBoardWidth());
-				int height = (int)vFromM(infoBox.getGmmlData().getMBoardHeight());
-				setSize(width, height); 
-				break;
-		}
-		redrawDirtyRect();
-	}
-		
-	/**
-	 * Makes a copy of all GmmlDataObjects in current selection,
-	 * and puts them in the global clipboard.
-	 *
-	 */
-	public void copyToClipboard()
-	{
-		//Clipboard clipboard = new Clipboard (this.getDisplay());
-		
-		List<PathwayElement> result = new ArrayList<PathwayElement>();
-		for (VPathwayElement g : drawingObjects)
-		{
-			if (g.isSelected() && g instanceof Graphics
-					&& !(g instanceof SelectionBox))
-			{
-				result.add(((Graphics)g).gdata.copy());
-			}
-		}
-		if (result.size() > 0)
-		{
-			Engine.clipboard = result;
-		}
-		else
-		{
-			Engine.clipboard = null;
-		}
-		
-		//clipboard.dispose();
-	}
-	
-	/**
-	 * Aligns selected objects based on user-selected align type
-	 * @param alignType
-	 */
-	public void alignSelected(char alignType)
-	{
-		List<Graphics> selectedGraphics = getSelectedGraphics();
-		
-		int aveC = 0;
-		int minC = java.lang.Integer.MAX_VALUE;
-		int maxC = 0;
-		
-		if (selectedGraphics.size() > 0){
-			switch (alignType){
-			case AlignActions.CENTERX : 
-				for(Graphics g : selectedGraphics) {
-					int c = g.getVCenterX();
-					aveC = aveC + c;
-				}
-				aveC = aveC/selectedGraphics.size();
-				for(Graphics g : selectedGraphics) {
-					g.vMoveBy(aveC - g.getVCenterX(), 0);
-				}
-				break;
-			case AlignActions.CENTERY : 
-				for(Graphics g : selectedGraphics) {
-					int c = g.getVCenterY();
-					aveC = aveC + c;
-				}
-				aveC = aveC/selectedGraphics.size();
-				for(Graphics g : selectedGraphics) {
-					g.vMoveBy(0, aveC-g.getVCenterY());
-				}
-				break;
-			case AlignActions.LEFT :
-				for(Graphics g : selectedGraphics) {
-					int c = g.getVLeft();
-					if (c < minC){ 
-						minC = c;
-						}
-				}
-				for(Graphics g : selectedGraphics) {	
-					g.vMoveBy(minC - g.getVLeft(),0);
-				}
-				break;
-			case AlignActions.RIGHT : 
-				for(Graphics g : selectedGraphics) {
-					int c = (g.getVLeft()+g.getVWidth());
-					if (c > maxC){
-						maxC = c;
-					}	
-				}
-				for(Graphics g : selectedGraphics) {
-					g.vMoveBy(maxC - (g.getVLeft()+g.getVWidth()),0);
-				}
-				break;
-			case AlignActions.TOP : 
-				for(Graphics g : selectedGraphics) {
-					int c = g.getVTop();
-					if (c < minC){
-						minC = c;
-					}
-				}
-				for(Graphics g : selectedGraphics) {
-					g.vMoveBy(0,minC - g.getVTop());
-				}
-				break;
-			case AlignActions.BOTTOM :
-				for(Graphics g : selectedGraphics) {
-					int c = (g.getVTop()+g.getVHeight());
-					if (c > maxC){
-						maxC = c;
-					}
-				}
-				for(Graphics g : selectedGraphics) {
-					g.getGmmlData().setMCenterY(mFromV(maxC-(g.getVHeight()/2)));
-					g.vMoveBy(0,maxC - (g.getVTop()+g.getVHeight()));
-				}
-				break;
-			}
-			redrawDirtyRect();
-	}
-	}
-	/**
-	 * Scales selected objects either by max width or max height
-	 * @param alignType
-	 */
-	public void scaleSelected (char alignType){
-		
-		List<Graphics> selectedGraphics = getSelectedGraphics();
-		double maxW = 0;
-		double maxH = 0;
-		
-		if (selectedGraphics.size() > 0){
-			switch (alignType){
-			case AlignActions.WIDTH:
-				for(Graphics g : selectedGraphics) {
-					Rectangle2D.Double r = g.getVScaleRectangle();
-					double w = Math.abs(r.width);
-					if (w > maxW){
-						maxW = w;
-					}
-				}
-				for(Graphics g : selectedGraphics) {
-					Rectangle2D.Double r = g.getVScaleRectangle();
-					double oldWidth = r.width;
-					if (oldWidth <0){
-						r.setRect(r.getX(), r.getY(), -(maxW), r.getHeight());
-						g.setVScaleRectangle(r);
-						g.vMoveBy((oldWidth+maxW)/2,0);
-					}
-					else{
-						r.setRect(r.getX(), r.getY(), maxW, r.getHeight());
-						g.setVScaleRectangle(r);
-						g.vMoveBy((oldWidth - maxW)/2,0);
-					}
-				}
-				break;
-			case AlignActions.HEIGHT:
-				for(Graphics g : selectedGraphics) {
-					Rectangle2D.Double r = g.getVScaleRectangle();
-					double h = Math.abs(r.height);
-					if (h > maxH){
-						maxH = h;
-					}
-				}
-				for(Graphics g : selectedGraphics) {
-					Rectangle2D.Double r = g.getVScaleRectangle();
-					double oldHeight = r.height;
-					if (oldHeight < 0){
-						r.setRect(r.getX(), r.getY(), r.getWidth(), -(maxH));
-						g.setVScaleRectangle(r);
-						g.vMoveBy(0,(maxH+oldHeight)/2);
-					}
-					else{
-					r.setRect(r.getX(), r.getY(), r.getWidth(), maxH);
-					g.setVScaleRectangle(r);
-					g.vMoveBy(0,(oldHeight - maxH)/2);
-					}
-				}
-				break;
-			}
-			redrawDirtyRect();
-		}
-	}
-	/**
-	 * TODO: document
-	 * @return
-	 */
-	public List<Graphics> getSelectedGraphics() {
-		List<Graphics> result = new ArrayList<Graphics>();
-		for (VPathwayElement g : drawingObjects)
-		{
-			if (g.isSelected() && g instanceof Graphics
-					&& !(g instanceof SelectionBox))
-			{
-				result.add((Graphics)g);
-			}
-		}
-		return result;
-	}
-	
-	/**
-	 * If global clipboard contains GmmlDataObjects,
-	 * makes another copy of these objects, and pastes them in. 
-	 * The clipboard contents will be moved 10 pixels souteast,
-	 * so they won't exactly overlap with the original.
-	 */
-	public void pasteFromClipboad()
-	{
-		if (Engine.clipboard != null)
-		{
-			clearSelection();
-			Map<String, String> idmap = new HashMap<String, String>();
-			Set<String> newids = new HashSet<String>();
-			
-			/*
-			 * Step 1: generate new unique ids for copied items
-			 */
-			for (PathwayElement o : Engine.clipboard)
-			{
-				String id = o.getGraphId();
-				if (id != null) 
-				{
-					String x;
-					do
-					{
-						/* generate a unique id.
-						 * at the same time, check that it is not 
-						 * equal to one of the unique ids
-						 * that we generated since the start of this
-						 * method
-						 */ 
-						x = data.getUniqueId();
-					} while (newids.contains(x));
-					newids.add(x); // make sure we don't generate this one again
-					
-					idmap.put(id, x);
-				}
-			}
-			/*
-			 * Step 2: do the actual copying 
-			 */
-			for (PathwayElement o : Engine.clipboard)
-			{
-				if (o.getObjectType() == ObjectType.MAPPINFO ||
-					o.getObjectType() == ObjectType.INFOBOX)
-				{
-					// these object types we skip,
-					// because they have to be unique in a pathway
-					continue;
-				}
-				
-				lastAdded = null;
-				o.setMStartX(o.getMStartX() + M_PASTE_OFFSET);
-				o.setMStartY(o.getMStartY() + M_PASTE_OFFSET);
-				o.setMEndX(o.getMEndX() + M_PASTE_OFFSET);
-				o.setMEndY(o.getMEndY() + M_PASTE_OFFSET);
-				o.setMLeft(o.getMLeft() + M_PASTE_OFFSET);
-				o.setMTop(o.getMTop() + M_PASTE_OFFSET);
-				// make another copy to preserve clipboard contents for next paste
-				PathwayElement p = o.copy();
-				
-				// set new unique id
-				if (p.getGraphId() != null)
-				{					
-					p.setGraphId(idmap.get(p.getGraphId()));					
-				}
-				// update graphref
-				String y = p.getStartGraphRef(); 
-				if (y != null)
-				{
-					//TODO: mapping graphrefs to newly created id's 
-					// doesn't work properly yet
-				/*	if (idmap.containsKey(y))
-					{
-						p.setStartGraphRef(idmap.get(y));
-					}
-					else
-					{*/
-						p.setStartGraphRef(null);
-					//}				
-				}
-				y = p.getEndGraphRef(); 
-				if (y != null)
-				{
-				/*	if (idmap.containsKey(y))
-					{
-						p.setEndGraphRef(idmap.get(y));
-					}
-					else
-					{*/
-						p.setEndGraphRef(null);
-				//	}				
-				}
-				
-				data.add (p); // causes lastAdded to be set
-				lastAdded.select();
-				s.addToSelection(lastAdded);
-			}
-		}
-	}
-
-	public void visualizationEvent(VisualizationEvent e) {
-		switch(e.type) {
-		case(VisualizationEvent.COLORSET_MODIFIED):
-		case(VisualizationEvent.VISUALIZATION_SELECTED):
-		case(VisualizationEvent.VISUALIZATION_MODIFIED):
-		case(VisualizationEvent.PLUGIN_MODIFIED):
-			getDisplay().syncExec(new Runnable() {
-				public void run() {
-					redraw();
-				}
-			});
-		}
-	}	
-	
-	
-	/** 
-	 * helper method to convert view coordinates to model coordinates 
-	 * */
-	public double mFromV(double v) { return v / zoomFactor; }
-
-	/** 
-	 * helper method to convert view coordinates to model coordinates 
-	 * */
-	public double vFromM(double m) { return m * zoomFactor; }
-	
-} // end of class
Index: trunk/src/core/org/pathvisio/view/InfoBox.java
===================================================================
--- trunk/src/core/org/pathvisio/view/InfoBox.java	(revision 956)
+++ trunk/src/core/org/pathvisio/view/InfoBox.java	(revision 957)
@@ -1,122 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.view;
-
-import java.awt.Rectangle;
-import java.awt.Shape;
-
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.events.PaintEvent;
-import org.eclipse.swt.graphics.Font;
-import org.eclipse.swt.graphics.GC;
-import org.eclipse.swt.graphics.Point;
-
-import org.pathvisio.model.PathwayElement;
-
-public class InfoBox extends Graphics {
-	
-	//Elements not stored in gpml
-	String fontName			= "Times New Roman";
-	String fontWeight		= "regular";
-	static final double M_INITIAL_FONTSIZE	= 10.0 * 15;
-	
-	int sizeX = 1;
-	int sizeY = 1; //Real size is calculated on first call to draw()
-	
-	public InfoBox (VPathway canvas, PathwayElement o) {
-		super(canvas, o);
-		canvas.setMappInfo(this);	
-	}
-	
-	public int getDrawingOrder() {
-		return VPathway.DRAW_ORDER_MAPPINFO;
-	}
-	
-	public Point getBoardSize() { return new Point((int)gdata.getMBoardWidth(), (int)gdata.getMBoardHeight()); }
-	
-	int getVFontSize()
-	{
-		return (int)(vFromM(M_INITIAL_FONTSIZE));
-	}
-			
-	protected void vMoveBy(double vdx, double vdy)
-	{
-//		markDirty();
-		gdata.setMTop (gdata.getMTop()  + mFromV(vdy));
-		gdata.setMLeft (gdata.getMLeft() + mFromV(vdx));
-//		markDirty();
-	}
-	
-	public void draw(PaintEvent e) 
-	{
-		draw(e, e.gc);
-	}
-	
-	public void draw(PaintEvent e, GC buffer) 
-	{		
-		sizeX = 1; //Reset sizeX
-		
-		Font fBold = new Font(e.display, fontName, getVFontSize(), SWT.BOLD);
-		Font fNormal = new Font(e.display, fontName, getVFontSize(), SWT.NONE);
-		
-		if (isSelected())
-		{
-			buffer.setForeground(e.display.getSystemColor(SWT.COLOR_RED));
-		}
-		else 
-		{
-			buffer.setForeground(e.display.getSystemColor(SWT.COLOR_BLACK));
-		}
-				
-		//Draw Name, Organism, Data-Source, Version, Author, Maintained-by, Email, Availability and last modified
-		String[][] text = new String[][] {
-				{"Name: ", gdata.getMapInfoName()},
-				{"Maintained by: ", gdata.getMaintainer()},
-				{"Email: ", gdata.getEmail()},
-				{"Availability: ", gdata.getCopyright()},
-				{"Last modified: ", gdata.getLastModified()},
-				{"Organism: ", gdata.getOrganism()},
-				{"Data Source: ", gdata.getDataSource()}};
-		int shift = 0;
-		int vLeft = (int)vFromM(gdata.getMLeft());
-		int vTop = (int)vFromM(gdata.getMTop());
-		for(String[] s : text)
-		{
-			if(s[1] == null || s[1].equals("")) continue; //Skip empty labels
-			buffer.setFont(fBold);
-			Point labelSize = buffer.textExtent(s[0], SWT.DRAW_TRANSPARENT);
-			buffer.drawString(s[0], vLeft, vTop + shift, true);
-			buffer.setFont(fNormal);
-			Point infoSize = buffer.textExtent(s[1], SWT.DRAW_TRANSPARENT);
-			buffer.drawString(s[1], vLeft + labelSize.x, vTop + shift, true);
-			shift += Math.max(infoSize.y, labelSize.y);
-			sizeX = Math.max(sizeX, infoSize.x + labelSize.x);
-		}
-		sizeY = shift;
-		
-		fBold.dispose();
-		fNormal.dispose();
-	}
-
-	protected Shape getVOutline() {
-		int vLeft = (int)vFromM(gdata.getMLeft());
-		int vTop = (int)vFromM(gdata.getMTop());
-		return new Rectangle(vLeft, vTop, sizeX, sizeY);
-	}
-
-}
- 
\ No newline at end of file
Index: trunk/src/core/org/pathvisio/view/LinAlg.java
===================================================================
--- trunk/src/core/org/pathvisio/view/LinAlg.java	(revision 956)
+++ trunk/src/core/org/pathvisio/view/LinAlg.java	(revision 957)
@@ -1,103 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.view;
-
-/**
- * Helper class for rotation calculations.
- *
- */
-public class LinAlg 
-{
-	
-	public static double angle(Point p1, Point p2) 
-	{
-		//Angle:
-		//					p1.p2	
-        //cos(angle) = --------------
-        //          	||p1||*||p2||
-		double cos = dot(p1,p2) / (p1.len() * p2.len());
-		return direction(p1,p2) * Math.acos(cos);
-	}
-		
-	/**
-	 * negative: ccw positive: cw
-	 */
-	public static double direction(Point p1, Point p2) 
-	{
-		return Math.signum(p1.x * p2.y - p1.y * p2.x);
-	}
-	
-	public static double dot(Point v1, Point v2) 
-	{
-		double[] d1 = v1.asArray();
-		double[] d2 = v2.asArray();
-		double sum = 0;
-		for(int i = 0; i < Math.min(d1.length, d2.length); i++) sum += d1[i]*d2[i];
-		return sum;
-	}
-	
-	public static Point project(Point p1, Point p2) 
-	{
-		//Projection of p1 on p2:
-		// p1.p2
-		// ----- . p2
-		// p2.p2
-		double c = dot(p1, p2) / dot(p2, p2);
-		return new Point(p2.x * c, p2.y * c);
-	}
-	
-	public static double distance(Point p1, Point p2) 
-	{
-		Point dp = p2.subtract(p1);
-		return dp.len();
-	}
-	
-	public static Point rotate(Point p, double angle) 
-	{
-		Point pr = new Point(0,0);
-		pr.x = p.x * Math.cos(angle) + p.y * Math.sin(angle);
-		pr.y = -p.x * Math.sin(angle) + p.y * Math.cos(angle);
-		return pr;
-	}
-	
-	public static class Point 
-	{
-		public double x, y;
-		public Point(double x, double y) { this.x = x; this.y = y;	}
-		
-		public int[] asIntArray() { return new int[] { (int)x, (int)y }; }
-		
-		public double[] asArray() { return new double[] { x, y }; }
-		
-		public Point norm() 
-		{
-			double l = len();
-			return new Point(x / l, y / l);
-		}
-		public double len() 
-		{
-			return Math.sqrt(dot(this, this));
-		}
-		
-		public Point add(Point p) { return new Point(x + p.x, y + p.y); }
-		public Point subtract(Point p) { return new Point(x - p.x, y - p.y); }
-		public Point multiply(double d) { return new Point(x *= d, y *= d); }
-				
-		public Point clone() { return new Point(x, y); }
-		public String toString() { return "Point: " + x + ", " + y; }
-	}
-}
Index: trunk/src/core/org/pathvisio/view/Line.java
===================================================================
--- trunk/src/core/org/pathvisio/view/Line.java	(revision 956)
+++ trunk/src/core/org/pathvisio/view/Line.java	(revision 957)
@@ -1,424 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.view;
-
-import java.awt.BasicStroke;
-import java.awt.Shape;
-import java.awt.geom.Line2D;
-import java.awt.geom.Rectangle2D;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.events.PaintEvent;
-import org.eclipse.swt.graphics.Color;
-import org.eclipse.swt.graphics.GC;
-import org.eclipse.swt.graphics.RGB;
-import org.pathvisio.model.LineStyle;
-import org.pathvisio.model.PathwayElement;
-import org.pathvisio.model.PathwayEvent;
-import org.pathvisio.model.GraphLink.GraphRefContainer;
-import org.pathvisio.model.PathwayElement.MPoint;
-import org.pathvisio.preferences.swt.Preferences;
-import org.pathvisio.util.SwtUtils;
- 
-/**
- * This class implements and handles a line
- */
-public class Line extends Graphics
-{
-
-	private static final long serialVersionUID = 1L;
-	
-	private List<VPoint> points;
-	
-	/**
-	 * Constructor for this class
-	 * @param canvas - the VPathway this line will be part of
-	 */
-	public Line(VPathway canvas, PathwayElement o)
-	{
-		super(canvas, o);
-		
-		points = new ArrayList<VPoint>();
-		for(MPoint mp : o.getMPoints()) {
-			VPoint vp = canvas.getPoint(mp);
-			points.add(vp);
-			vp.addLine(this);
-			vp.setHandleLocation();
-		}
-	}
-	
-	public int getDrawingOrder() 
-	{
-		return VPathway.DRAW_ORDER_LINE;
-	}
-	
-	protected void swapPoint(VPoint pOld, VPoint pNew) 
-	{
-		int i = points.indexOf(pOld);
-		if(i > -1) {
-			points.remove(pOld);
-			points.add(i, pNew);
-		}
-	}
-			
-	public void draw(PaintEvent e, GC buffer)
-	{
-		double vEndx = getVEndX();
-		double vEndy = getVEndY();
-		double vStartx = getVStartX();
-		double vStarty = getVStartY();
-
-		Color c = null;
-		if (isSelected())
-		{
-			c = SwtUtils.changeColor(c, selectColor, e.display);
-		}
-		else if (isHighlighted())
-		{
-			RGB rgb = Preferences.getColorProperty(Preferences.PREF_COL_HIGHLIGHTED);
-			c = SwtUtils.changeColor(c, rgb, e.display);
-		}
-		else 
-		{
-			c = SwtUtils.changeColor(c, gdata.getColor(), e.display);
-		}
-		buffer.setForeground (c);
-		buffer.setBackground (c);
-		
-		buffer.setLineWidth (1);
-		int ls = gdata.getLineStyle();
-		if (ls == LineStyle.SOLID)
-		{
-			buffer.setLineStyle (SWT.LINE_SOLID);
-		}
-		else if (ls == LineStyle.DASHED)
-		{ 
-			// TODO: This works well on windows. I wonder if this is the same on all platforms
-			buffer.setLineDash (new int[] {4, 4});
-		}			
-
-		double s = Math.sqrt(((vEndx-vStartx)*(vEndx-vStartx)) + ((vEndy - vStarty)*(vEndy - vStarty)));
-		
-		switch (gdata.getLineType())
-		{
-		
-			case LINE:
-				buffer.drawLine ((int)vStartx, (int)vStarty, (int)vEndx, (int)vEndy);
-				break;
-			case ARROW:				
-				buffer.drawLine ((int)vStartx, (int)vStarty, (int)vEndx, (int)vEndy);
-				drawArrowhead(buffer);
-				break;
-			case TBAR:
-			{
-				s /= 8;
-	
-				double capx1 = ((-vEndy + vStarty)/s) + vEndx;
-				double capy1 = (( vEndx - vStartx)/s) + vEndy;
-				double capx2 = (( vEndy - vStarty)/s) + vEndx;
-				double capy2 = ((-vEndx + vStartx)/s) + vEndy;
-	
-				buffer.drawLine ((int)vStartx, (int)vStarty, (int)vEndx, (int)vEndy);
-				buffer.drawLine ((int)capx1, (int)capy1, (int)capx2, (int)capy2);
-			}
-				break;
-			case LIGAND_ROUND:
-			{
-				if (vEndx != vStartx || vEndy != vStarty)
-				{
-					double dx = (vEndx - vStartx)/s;
-					double dy = (vEndy - vStarty)/s;
-								
-					buffer.drawLine ((int)vStartx, (int)vStarty, (int)(vEndx - 6 * dx), (int)(vEndy - 6 * dy));
-					buffer.drawOval ((int)vEndx - 5, (int)vEndy - 5, 10, 10);
-					buffer.fillOval ((int)vEndx - 5, (int)vEndy - 5, 10, 10);
-				}
-			}
-				break;
-			case RECEPTOR_ROUND:
-			{
-				if (vEndx != vStartx || vEndy != vStarty)
-				{
-					double theta 	= Math.toDegrees(Math.atan2((vEndx - vStartx),(vEndy - vStarty)));
-					double dx 		= (vEndx - vStartx)/s;
-					double dy 		= (vEndy - vStarty)/s;	
-					
-					buffer.drawLine ((int)vStartx, (int)vStarty, (int)(vEndx - (8*dx)), (int)(vEndy - (8*dy)));
-					buffer.drawArc ((int)vEndx - 8, (int)vEndy - 8, 16, 16, (int)theta + 180, -180);
-				}
-			}
-				break;
-			case RECEPTOR: //TODO: implement receptor
-			case RECEPTOR_SQUARE:
-			{
-				if (vEndx != vStartx || vEndy != vStarty)
-				{
-					s /= 8;
-					
-					double x3 		= vEndx - ((vEndx - vStartx)/s);
-					double y3 		= vEndy - ((vEndy - vStarty)/s);
-					double capx1 	= ((-vEndy + vStarty)/s) + x3;
-					double capy1 	= (( vEndx - vStartx)/s) + y3;
-					double capx2 	= (( vEndy - vStarty)/s) + x3;
-					double capy2 	= ((-vEndx + vStartx)/s) + y3;			
-					double rx1		= capx1 + 1.5*(vEndx - vStartx)/s;
-					double ry1 		= capy1 + 1.5*(vEndy - vStarty)/s;
-					double rx2 		= capx2 + 1.5*(vEndx - vStartx)/s;
-					double ry2 		= capy2 + 1.5*(vEndy - vStarty)/s;
-				
-					buffer.drawLine ((int)vStartx, (int)vStarty, (int)x3, (int)y3);
-					buffer.drawLine ((int)capx1, (int)capy1, (int)capx2, (int)capy2);
-					buffer.drawLine ((int)capx1, (int)capy1, (int)rx1, (int)ry1);
-					buffer.drawLine ((int)capx2, (int)capy2, (int)rx2, (int)ry2);
-				}
-			}
-				break;
-			case LIGAND_SQUARE:
-			{
-				if (vEndx != vStartx || vEndy != vStarty)
-				{
-					s /= 6;
-					double x3 		= vEndx - ((vEndx - vStartx)/s);
-					double y3 		= vEndy - ((vEndy - vStarty)/s);
-		
-					int[] points = new int[4 * 2];
-					
-					points[0] = (int) (((-vEndy + vStarty)/s) + x3);
-					points[1] = (int) ((( vEndx - vStartx)/s) + y3);
-					points[2] = (int) ((( vEndy - vStarty)/s) + x3);
-					points[3] = (int) (((-vEndx + vStartx)/s) + y3);
-		
-					points[4] = (int) (points[2] + 1.5*(vEndx - vStartx)/s);
-					points[5] = (int) (points[3] + 1.5*(vEndy - vStarty)/s);
-					points[6] = (int) (points[0] + 1.5*(vEndx - vStartx)/s);
-					points[7] = (int) (points[1] + 1.5*(vEndy - vStarty)/s);
-					
-					buffer.drawLine ((int)vStartx, (int)vStarty, (int)x3, (int)y3);
-					buffer.drawPolygon(points);
-					buffer.fillPolygon(points);
-				}
-			}
-				break;
-		}
-		
-		c.dispose();
-
-		
-	}
-	
-	protected void draw(PaintEvent e)
-	{
-		draw(e, e.gc);
-	}
-		
-	protected Shape getVOutline()
-	{
-		//TODO: bigger than necessary, just to include the arrowhead / shape at the end
-		BasicStroke stroke = new BasicStroke(20);
-		Shape outline = stroke.createStrokedShape(getVLine());
-		return outline;
-	}	
-	
-	/**
-	 * If the line type is arrow, this method draws the arrowhead
-	 */
-	private void drawArrowhead(GC buffer) //TODO! clean up this mess.....
-	{
-		double angle = 25.0;
-		double theta = Math.toRadians(180 - angle);
-		double[] rot = new double[2];
-		double[] p = new double[2];
-		double[] q = new double[2];
-		double a, b, norm;
-		
-		rot[0] = Math.cos(theta);
-		rot[1] = Math.sin(theta);
-		
-		buffer.setLineStyle (SWT.LINE_SOLID);
-		
-		double vEndx = getVEndX();
-		double vEndy = getVEndY();
-		double vStartx = getVStartX();
-		double vStarty = getVStartY();
-		
-		if(vStartx == vEndx && vStarty == vEndy) return; //Unable to determine direction
-		
-		a = vEndx-vStartx;
-		b = vEndy-vStarty;
-		norm = 8/(Math.sqrt((a*a)+(b*b)));				
-		p[0] = ( a*rot[0] + b*rot[1] ) * norm + vEndx;
-		p[1] = (-a*rot[1] + b*rot[0] ) * norm + vEndy;
-		q[0] = ( a*rot[0] - b*rot[1] ) * norm + vEndx;
-		q[1] = ( a*rot[1] + b*rot[0] ) * norm + vEndy;
-		int[] points = {
-			(int)vEndx, (int)vEndy,
-			(int)(p[0]), (int)(p[1]),
-			(int)(q[0]), (int)(q[1])
-		};
-		
-		buffer.drawPolygon (points);
-		buffer.fillPolygon (points);
-	}
-
-	/**
-	 * Constructs the line for the coordinates stored in this class
-	 */
-	public Line2D getVLine()
-	{
-		return new Line2D.Double(getVStartX(), getVStartY(), getVEndX(), getVEndY());
-	}
-	
-	/**
-	 * Sets the line start and end to the coordinates specified
-	 * <DL><B>Parameters</B>
-	 * <DD>Double x1	- new startx 
-	 * <DD>Double y1	- new starty
-	 * <DD>Double x2	- new endx
-	 * <DD>Double y2	- new endy
-	 */
-	public void setVLine(double vx1, double vy1, double vx2, double vy2)
-	{
-		getStart().setVLocation(vx1, vy1);
-		getEnd().setVLocation(vx2, vy2);
-	}
-
-	public void setVScaleRectangle(Rectangle2D.Double r) {
-		setVLine(r.x, r.y, r.x + r.width, r.y + r.height);
-	}
-	
-	protected Rectangle2D.Double getVScaleRectangle() {
-		return new Rectangle2D.Double(getVStartXDouble(), getVStartYDouble(), getVEndXDouble()
-				- getVStartXDouble(), getVEndYDouble() - getVStartYDouble());
-	}
-	
-	public Handle[] getHandles()
-	{
-		Handle[] handles = new Handle[points.size()];
-		for(int i = 0; i < handles.length; i++) {
-			handles[i] = points.get(i).getHandle();
-		}
-		return handles;
-	}
-		
-	public List<VPoint> getPoints() { return points; }
-	
-	public VPoint getStart() {
-		return points.get(0);
-	}
-	
-	public VPoint getEnd() {
-		return points.get(points.size() - 1);
-	}
-	
-	public int getVCenterX() {
-		// TODO Auto-generated method stub
-		double start = gdata.getMStart().getX();
-		double end = gdata.getMEnd().getX();
-		return (int)vFromM(start + (end - start) / 2);
-	}
-	
-	public int getVCenterY() {
-		// TODO Auto-generated method stub
-		double start = gdata.getMStart().getY();
-		double end = gdata.getMEnd().getY();
-		return (int)vFromM(start + (end - start) / 2);
-	}
-	
-	public int getVLeft() {
-		// TODO Auto-generated method stub
-		double start = gdata.getMStart().getX();
-		double end = gdata.getMEnd().getX();
-		return (int)vFromM(Math.min(start, end));
-	}
-	
-	public int getVWidth() {
-		// TODO Auto-generated method stub
-		double start = gdata.getMStart().getX();
-		double end = gdata.getMEnd().getX();
-		return (int)vFromM(Math.abs(start-end));
-	}
-	
-	public int getVHeight() {
-		// TODO Auto-generated method stub
-		double start = gdata.getMStart().getY();
-		double end = gdata.getMEnd().getY();
-		return (int)vFromM(Math.abs(start-end));
-	}	
-	
-	public int getVTop() {
-		// TODO Auto-generated method stub
-		double start = gdata.getMStart().getY();
-		double end = gdata.getMEnd().getY();
-		return (int)vFromM(Math.min(start, end));
-	}
-	
-	protected void vMoveBy(double vdx, double vdy)
-	{
-		for(VPoint p : points) {
-			p.vMoveBy(vdx, vdy);
-		}
-		//Move graphRefs
-		Set<VPoint> toMove = new HashSet<VPoint>();
-		for(GraphRefContainer ref : gdata.getReferences()) {
-			if(ref instanceof MPoint) {
-				toMove.add(canvas.getPoint((MPoint)ref));
-			}
-		}
-		toMove.removeAll(points);
-		for(VPoint p : toMove) p.vMoveBy(vdx, vdy);
-	}
-	
-	public void gmmlObjectModified(PathwayEvent e) {		
-		markDirty();
-		for(VPoint p : points) {
-			p.markDirty();
-			p.setHandleLocation();
-		}
-	}
-	
-	protected void destroyHandles() { 
-		//Do nothing, handles will be destroyed by VPoints
-	}
-	
-	protected void destroy() {
-		//don't call super.destroy(), this will destroy handles of VPoints
-		//which may be used by other lines
-		super.destroy();
-		
-		for(VPoint p : points) {
-			p.removeLine(this);
-		}
-		for(MPoint p : gdata.getMPoints()) {
-			canvas.pointsMtoV.remove(p);
-		}
-	}
-	
-	protected int getVStartX() { return (int)(vFromM(gdata.getMStartX())); }
-	protected int getVStartY() { return (int)(vFromM(gdata.getMStartY())); }
-	protected int getVEndX() { return (int)(vFromM(gdata.getMEndX())); }
-	protected int getVEndY() { return (int)(vFromM(gdata.getMEndY())); }
-
-	protected double getVStartXDouble() { return vFromM(gdata.getMStartX()); }
-	protected double getVStartYDouble() { return vFromM(gdata.getMStartY()); }
-	protected double getVEndXDouble() { return vFromM(gdata.getMEndX()); }
-	protected double getVEndYDouble() { return vFromM(gdata.getMEndY()); }
-
-}
Index: trunk/src/core/org/pathvisio/view/Handle.java
===================================================================
--- trunk/src/core/org/pathvisio/view/Handle.java	(revision 956)
+++ trunk/src/core/org/pathvisio/view/Handle.java	(revision 957)
@@ -1,249 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.view;
-
-import java.awt.Rectangle;
-import java.awt.Shape;
-import java.awt.geom.Rectangle2D;
-
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.events.PaintEvent;
-import org.eclipse.swt.graphics.GC;
-import org.pathvisio.view.LinAlg.Point;
-
-/**
- * This class implements and handles handles for 
- * objects on the drawing which are used to 
- * resize them or change their location.
- */
-class Handle extends VPathwayElement
-{
-	private static final long serialVersionUID = 1L;
-	
-	/** 
-	 * because isSelected really doesn't make sense for GmmlHandles, 
-	 * I added this variable isVisible. It should be set automatically by its parent
-	 * through calls of show() and hide()
-	 */
-	private boolean isVisible = false;
-	
-	//The direction this handle is allowed to move in
-	int direction;
-	public static final int DIRECTION_FREE = 0;
-	public static final int DIRECTION_X	 = 1;
-	public static final int DIRECTION_Y  = 2; 
-	public static final int DIRECTION_ROT = 3;
-	public static final int DIRECTION_XY = 4;
-	public static final int DIRECTION_MINXY = 5;
-	
-	public static final int WIDTH 	= 8;
-	public static final int HEIGHT	= 8;
-	
-	VPathwayElement parent;
-	
-	double mCenterx;
-	double mCentery;
-	
-	double rotation;
-	
-	boolean visible;
-	
-	/**
-	 * Constructor for this class, creates a handle given the parent, direction and canvas
-	 * @param direction	Direction this handle can be moved in (one of DIRECTION_*)
-	 * @param parent	The object this handle belongs to
-	 * @param canvas	The {@link VPathway} to draw this handle on
-	 */
-	public Handle(int direction, VPathwayElement parent, VPathway canvas)
-	{
-		super(canvas);		
-		this.direction = direction;
-		this.parent = parent;
-	}
-
-	public int getDrawingOrder() {
-		return VPathway.DRAW_ORDER_HANDLE;
-	}
-	
-	/**
-	 * Get the direction this handle is allowed to move in
-	 * @return one of DIRECTION_*
-	 */
-	public int getDirection() { return direction; }
-	
-	public void setDirection(int direction) { this.direction = direction; }
-	
-	public void setVLocation(double vx, double vy)
-	{
-		markDirty();
-		mCenterx = mFromV(vx);
-		mCentery = mFromV(vy);
-		markDirty();
-	}
-
-	public void setMLocation(double mx, double my)
-	{
-		markDirty();
-		mCenterx = mx;
-		mCentery = my;
-		markDirty();
-	}
-	
-	public double getVCenterX() {
-		return vFromM(mCenterx);
-	}
-	
-	public double getVCenterY() {
-		return vFromM(mCentery);
-	}
-	
-	/**
-	 * returns the visibility of this handle
-	 * @see hide(), show()
-	 */
-	public boolean isVisible()
-	{
-		return isVisible;
-	}
-	
-	/**
-	 * call show() to cause this handle to show up and mark its area dirty 
-	 * A handle should show itself only if it's parent object is active / selected
-	 * @see hide(), isvisible()
-	 */
-	public void show()
-	{
-		if (!isVisible)
-		{
-			isVisible = true;
-			markDirty();
-		}
-	}
-	
-	/**
-	 * hide handle, and also mark its area dirty
-	 * @see show(), isvisible()
-	 */
-	public void hide()
-	{
-		if (isVisible)
-		{
-			isVisible = false;
-			markDirty();
-		}
-	}
-	
-	/**
-	 * draws itself, but only if isVisible() is true, there is 
-	 * no need for a check for isVisible() before calling draw().
-	 */
-	public void draw(PaintEvent e, GC buffer)
-	{
-		if (!isVisible) return;
-		double vCenterx = vFromM (mCenterx);
-		double vCentery = vFromM (mCentery);
-		
-		if(direction == DIRECTION_ROT) {
-			buffer.setLineWidth (1);
-			buffer.setLineStyle(SWT.LINE_SOLID);
-			buffer.setBackground (e.display.getSystemColor (SWT.COLOR_GREEN));
-			buffer.setForeground (e.display.getSystemColor (SWT.COLOR_BLACK));
-			buffer.fillOval(
-					(int)(vCenterx - WIDTH/2), 
-					(int)(vCentery - HEIGHT/2), 
-					(int)WIDTH, 
-					(int)HEIGHT);
-			buffer.drawOval(
-					(int)(vCenterx - WIDTH/2), 
-					(int)(vCentery - HEIGHT/2), 
-					(int)WIDTH, 
-					(int)HEIGHT);
-		} else {			
-			buffer.setLineWidth (1);
-			buffer.setLineStyle(SWT.LINE_SOLID);
-			buffer.setBackground (e.display.getSystemColor (SWT.COLOR_YELLOW));
-			buffer.setForeground (e.display.getSystemColor (SWT.COLOR_BLACK));
-			buffer.fillRectangle (
-					(int)(vCenterx - WIDTH/2), 
-					(int)(vCentery - HEIGHT/2), 
-					(int)WIDTH, 
-					(int)HEIGHT);	
-			buffer.drawRectangle (
-					(int)(vCenterx - WIDTH/2), 
-					(int)(vCentery - HEIGHT/2), 
-					(int)WIDTH, 
-					(int)HEIGHT);	
-		}
-		
-	}
-	
-	protected void draw(PaintEvent e)
-	{
-		draw(e, e.gc);
-	}
-		
-	/**
-	 * Moves this handle by the specified increments and
-	 * adjusts the {@link VPathwayElement} to the new position
-	 */
-	public void vMoveBy(double vdx, double vdy)
-	{	
-		markDirty();
-
-		if(direction != DIRECTION_FREE && direction != DIRECTION_ROT) {
-			Point v = new Point(0,0);
-			double xtraRot = 0;
-			if		(direction == DIRECTION_X) {
-				v = new Point(1,0);
-			}
-			else if	(direction == DIRECTION_Y) {
-				v = new Point(0,1);
-			}
-			else if (direction == DIRECTION_XY) {
-				Rectangle b = parent.getVBounds();
-				v = new Point(b.width + 1, b.height + 1);
-			}
-			else if (direction == DIRECTION_MINXY) {
-				xtraRot = Math.PI/2;
-				Rectangle b = parent.getVBounds();
-				v = new Point(b.height + 1, b.width + 1);
-			}
-			Point yr = LinAlg.rotate(v, -rotation + xtraRot);
-			Point prj = LinAlg.project(new Point(vdx, vdy), yr);
-			vdx = prj.x; vdy= prj.y;
-		}
-		
-		mCenterx += mFromV(vdx);
-		mCentery += mFromV(vdy);
-		
-		parent.adjustToHandle(this);
-		markDirty();
-	}
-			
-	public Shape getVOutline() {
-		return new Rectangle2D.Double(vFromM(mCenterx) - WIDTH/2, vFromM(mCentery) - HEIGHT/2, 
-				WIDTH, HEIGHT);
-	}
-		
-	public String toString() { 
-		return 	"Handle with parent: " + parent.toString() +
-		" and direction " + direction; 
-	}
-			
-} // end of class
-
-
Index: trunk/src/core/org/pathvisio/view/Group.java
===================================================================
--- trunk/src/core/org/pathvisio/view/Group.java	(revision 956)
+++ trunk/src/core/org/pathvisio/view/Group.java	(revision 957)
@@ -1,136 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.view;
-
-import java.awt.Rectangle;
-import java.awt.Shape;
-import java.awt.geom.Point2D;
-import java.awt.geom.Rectangle2D.Double;
-import java.util.ArrayList;
-
-import org.eclipse.swt.events.PaintEvent;
-import org.eclipse.swt.graphics.GC;
-import org.pathvisio.model.PathwayElement;
-
-public class Group extends Graphics {
-
-	public Group(VPathway canvas, PathwayElement pe) {
-		super(canvas, pe);
-		// TODO Auto-generated constructor stub
-	}
-
-	/**
-	 * Determines wheter a Graphics object contains the point specified
-	 * 
-	 * @param point -
-	 *            the point to check
-	 * @return True if the object contains the point, false otherwise
-	 */
-	protected boolean vContains(Point2D point) {
-		for (VPathwayElement vpe : canvas.getDrawingObjects()) {
-			if (vpe != this && vpe.vContains(point)) {
-				if (vpe instanceof Graphics) {
-					PathwayElement pe = ((Graphics) vpe).getGmmlData();
-					String ref = pe.getGroupRef();
-					if (ref != null && ref.equals(getGmmlData().getGroupId())) {
-						System.out.println("TRUE!");
-						return true;
-					}
-				}
-			}
-		}
-		return false;
-	}
-
-	@Override
-	protected boolean vIntersects(Double r) {
-		for (VPathwayElement vpe : canvas.getDrawingObjects()) {
-			if (vpe != this && vpe.vIntersects(r)) {
-				if (vpe instanceof Graphics) {
-					PathwayElement pe = ((Graphics) vpe).getGmmlData();
-					String ref = pe.getGroupRef();
-					if (ref != null && ref.equals(getGmmlData().getGroupId())) {
-						System.out.println("TRUE INTERSECTS!");
-						return true;
-					}
-				}
-			}
-		}
-		return false;
-	}
-	
-	public ArrayList<Graphics> getGroupGraphics(){
-		ArrayList<Graphics> gg = new ArrayList<Graphics>();
-		for (VPathwayElement vpe : canvas.getDrawingObjects()) {
-			if (vpe != this) {
-				if (vpe instanceof Graphics) {
-					Graphics vpeg = (Graphics) vpe;
-					PathwayElement pe =  vpeg.getGmmlData();
-					String ref = pe.getGroupRef();
-					if (ref != null && ref.equals(getGmmlData().getGroupId())) {
-						gg.add(vpeg);					
-					}
-				}
-			}
-		}
-		return gg;
-	}
-	
-	@Override
-	public void select() {
-		for(Graphics g: getGroupGraphics() ){
-			g.select();
-		}
-		super.select();
-	}
-
-	@Override
-	protected void vMoveBy(double dx, double dy) {
-		for(Graphics g: getGroupGraphics() ){
-			g.vMoveBy(dx, dy);
-		}
-		//super.vMoveBy(dx, dy);
-	}
-	
-	@Override
-	public int getDrawingOrder() {
-
-		return VPathway.DRAW_ORDER_GROUP;
-	}
-
-	@Override
-	protected void draw(PaintEvent e) {
-		// TODO make unique selection box for groups
-		
-	}
-
-	@Override
-	public void draw(PaintEvent e, GC buffer) {
-		// TODO make unique selection box for groups
-		
-	}
-
-	@Override
-	protected Shape getVOutline() {
-		// TODO Return outline of the Group members, distinct from global selection box
-		
-		Rectangle rect = new Rectangle();
-
-		return rect;
-	}
-
-}
Index: trunk/src/core/org/pathvisio/view/VPathwayElement.java
===================================================================
--- trunk/src/core/org/pathvisio/view/VPathwayElement.java	(revision 956)
+++ trunk/src/core/org/pathvisio/view/VPathwayElement.java	(revision 957)
@@ -1,276 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.view;
-
-import java.awt.Rectangle;
-import java.awt.Shape;
-import java.awt.geom.Point2D;
-import java.awt.geom.Rectangle2D;
-
-import org.eclipse.swt.events.PaintEvent;
-import org.eclipse.swt.graphics.GC;
-
-public abstract class VPathwayElement implements Comparable<VPathwayElement>
-{	
-	protected VPathway canvas;
-	
-	VPathwayElement(VPathway canvas) {
-		this.canvas = canvas;
-		canvas.addObject(this);
-	}
-	
-	private boolean isHighlighted;
-	private Rectangle oldrect = null;
-	
-	private boolean isSelected;
-		
-	protected abstract void draw(PaintEvent e);
-	
-	/**
-	 * Draws the VPathwayElement object on the VPathway
-	 * it is part of
-	 */
-	public abstract void draw(PaintEvent e, GC buffer);
-	
-	/** 
-	 * mark both the area currently and previously occupied by this object for redraw 
-	 */
-	protected void markDirty()
-	{
-		if (oldrect != null)
-		{
-			canvas.addDirtyRect(oldrect);
-		}
-		Rectangle newrect = getVBounds();
-		canvas.addDirtyRect(newrect);
-		oldrect = newrect;
-	}
-
-	/**
-	 * Get the drawing this object belongs to
-	 */
-	public VPathway getDrawing() {
-		return canvas;
-	}
-	
-	/**
-	 * Besides resetting isHighlighted, this accomplishes this:
-	 * - marking the area dirty, so the object has a chance to redraw itself in unhighlighted state
-	 */
-	public void unhighlight()
-	{
-		if(isHighlighted)
-		{
-			isHighlighted = false;
-			markDirty();
-		}
-	}
-
-	/**
-	 * Besides setting isHighlighted, this accomplishes this:
-	 * - marking the area dirty, so the object has a chance to redraw itself in highlighted state
-	 */
-	public void highlight()
-	{
-		if(!isHighlighted)
-		{
-			isHighlighted = true;
-			markDirty();
-		}
-	}
-	
-	/**
-	 * Returns true if this object is highlighted, false otherwise
-	 */
-	public boolean isHighlighted()
-	{
-		return isHighlighted;
-	}
-
-	/**
-	 * Determines whether a Graphics object intersects 
-	 * the rectangle specified
-	 * @param r - the rectangle to check
-	 * @return True if the object intersects the rectangle, false otherwise
-	 */
-	protected boolean vIntersects(Rectangle2D.Double r)
-	{
-		return getVOutline().intersects(r);
-	}
-	
-	/**
-	 * Determines wheter a Graphics object contains
-	 * the point specified
-	 * @param point - the point to check
-	 * @return True if the object contains the point, false otherwise
-	 */
-	protected boolean vContains(Point2D point)
-	{
-		return getVOutline().contains(point);
-	}	
-
-
-	public boolean isSelected()
-	{
-		return isSelected;
-	}
-	
-	/**
-	 * Besides resetting isSelected, this accomplishes this:
-	 * - marking the area dirty, so the object has a chance to redraw itself in unselected state
-	 */
-	public void deselect()
-	{
-		if (isSelected)
-		{
-			isSelected = false;
-			markDirty();			
-		}
-	}
-
-	/**
-	 * Besides setting isSelected, this accomplishes this:
-	 * - marking the area dirty, so the object has a chance to redraw itself in selected state
-	 */
-	public void select()
-	{
-		if (!isSelected)
-		{
-			isSelected = true;
-			markDirty();			
-		}
-	}
-
-	/**
-	 * Transforms this object to fit to the coordinates
-	 * of the given handle
-	 * @param h	The Handle to adjust to
-	 */
-	protected void adjustToHandle(Handle h) {}
-
-	/**
-	 * Get all the handles belonging to this object
-	 * @return an array of GmmlHandles, an empty array if the object
-	 * has no handles
-	 */
-	protected Handle[] getHandles() { return new Handle[] {}; }
-	
-	/**
-	 * Moves this object by specified increments
-	 * @param dx - the value of x-increment
-	 * @param dy - the value of y-increment
-	 */
-	// TODO: should really be mMoveBy, using model coords,
-	// because implementations do a lot of conversions anyway
-	// perhaps could even be partially implemented in PathwayElement 
-	protected void vMoveBy(double dx, double dy) { }
-	
-	/**
-	 * Get the rectangular boundary of this object
-	 */
-	protected final Rectangle getVBounds()
-	{
-		return getVOutline().getBounds();
-	}
-	
-	abstract protected Shape getVOutline();
-
-
-	/**
-	 * Scales the object to the given rectangle
-	 * @param r
-	 */
-	protected void setVScaleRectangle(Rectangle2D.Double r) { }
-	
-	/**
-	 * Gets the rectangle used to scale the object
-	 */
-	protected Rectangle2D.Double getVScaleRectangle() { return new Rectangle2D.Double(); }
-
-	public int getDrawingOrder() {
-		return VPathway.DRAW_ORDER_DEFAULT;
-	}
-	
-	/**
-	 * Orders GmmlDrawingObjects by their drawingOrder.
-	 * The comparison is consistent with "equals", i.e. it doesn't return 0 if
-	 * the objects are different, even if their drawing order is the same.
-	 * 
-	 * @param d
-	 * @see #getDrawingOrder()
-	 */
-	public int compareTo(VPathwayElement d)
-	{
-		// same object? easy...
-		if (d == this)
-			return 0;
-		
-		int az, bz;
-		az = getDrawingOrder();
-		bz = d.getDrawingOrder();
-		
-		if(isSelected() && d.isSelected()) {
-			; //objects are both selected, keep original sort order
-		}
-		else if(isSelected() || isHighlighted())
-		{
-			az = VPathway.DRAW_ORDER_SELECTED;
-		}
-		else if(d.isSelected() || d.isHighlighted())
-		{
-			bz = VPathway.DRAW_ORDER_SELECTED;
-		}
-		
-		// note, if the drawing order is equal, that doesn't mean the objects are equal
-		// the construct with hashcodes give objects a defined sort order, even if their
-		// drawing orders are equal.		
-		if (az == bz)
-		{
-			az = hashCode();
-			bz = d.hashCode();		
-		}
-		// there is still a remote possibility that although the objects are not the same,
-		// the hashcode is the same. Even still, we shouldn't return 0.
-		if (az != bz) 
-			return bz - az; 
-		else
-			return -1;
-	}
-	
-	/** 
-	 * helper method to convert view coordinates to model coordinates 
-	 * */
-	protected double mFromV(double v) { return canvas.mFromV(v); }
-
-	/** 
-	 * helper method to convert view coordinates to model coordinates 
-	 * */
-	protected double vFromM(double m) { return canvas.vFromM(m); } 
-	
-	protected void destroyHandles() {
-		for(Handle h : getHandles()) {
-			h.destroy();
-		}
-	}
-	
-	protected void destroy() { 
-		//Remove from canvas
-		canvas.getDrawingObjects().remove(this);
-		destroyHandles();
-	}
-
-}
Index: trunk/src/core/org/pathvisio/view/SelectionBox.java
===================================================================
--- trunk/src/core/org/pathvisio/view/SelectionBox.java	(revision 956)
+++ trunk/src/core/org/pathvisio/view/SelectionBox.java	(revision 957)
@@ -1,457 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.view;
-
-import java.awt.Rectangle;
-import java.awt.geom.Point2D;
-import java.awt.geom.Rectangle2D;
-import java.util.ArrayList;
-import java.util.EventObject;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.events.PaintEvent;
-import org.eclipse.swt.graphics.GC;
-import org.pathvisio.model.ObjectType;
-import org.pathvisio.model.PathwayElement;
-import org.pathvisio.model.GraphLink.GraphRefContainer;
-import org.pathvisio.model.PathwayElement.MPoint;
-
-/**
- * This class implements a selectionbox 
- */ 
-public class SelectionBox extends GraphicsShape
-{
-	private static final long serialVersionUID = 1L;
-		
-	private ArrayList<VPathwayElement> selection;
-	boolean isSelecting;
-	boolean isVisible;
-		
-	/**
-	 * Constructor for this class
-	 * @param canvas - the VPathway this selectionbox will be part of
-	 */
-	public SelectionBox(VPathway canvas)
-	{
-		// TODO: selectionbox shouldn't need a dataobject...
-		// note, not setting parent of PathwayElement here.
-		this(canvas, new PathwayElement(ObjectType.SHAPE));
-	}	
-	
-	public SelectionBox(VPathway canvas, PathwayElement pe)
-	{
-		super(canvas, pe);
-			
-		selection = new ArrayList<VPathwayElement>();
-	}	
-	
-	public int getDrawingOrder() {
-		return VPathway.DRAW_ORDER_SELECTIONBOX;
-	}
-	
-	public ArrayList<VPathwayElement> getSelection() {
-		return selection;
-	}
-	
-	/**
-	 * Add an object to the selection
-	 * @param o
-	 */
-	public void addToSelection(VPathwayElement o) {
-		if(o == this || selection.contains(o)) return; //Is selectionbox or already in selection
-		if(o instanceof VPoint) {
-			for(Line l : ((VPoint)o).getLines()) {
-				l.select();
-				doAdd(l);
-			}
-		} else {
-			o.select();
-			doAdd(o);
-		}
-		fireSelectionEvent(new SelectionEvent(this, SelectionEvent.OBJECT_ADDED, o));
-		if(isSelecting) return; //All we have to do if user is dragging selectionbox
-		if(hasMultipleSelection()) { 
-			stopSelecting(); //show and fit to SelectionBox if performed after dragging
-		}
-		 
-	}
-	
-	private void doAdd(VPathwayElement o) {
-		if(!selection.contains(o)) selection.add(o);
-	}
-	
-	/**
-	 * Remove an object from the selection
-	 * @param o
-	 */
-	public void removeFromSelection(VPathwayElement o) {
-		if(o == this) return;
-		selection.remove(o); 
-		o.deselect();
-		fireSelectionEvent(new SelectionEvent(this, SelectionEvent.OBJECT_REMOVED, o));
-		if(!isSelecting) fitToSelection();
-	}
-	
-	/**
-	 * Get the child object at the given coordinates (relative to canvas)
-	 * @param p
-	 * @return the child object or null if none is present at the given location
-	 */
-	public VPathwayElement getChild(Point2D p) {
-		//First check selection
-		for(VPathwayElement o : selection) {
-			if(o.vContains(p)) return o;
-		}
-		//Nothing in selection, check all other objects
-		for(VPathwayElement o : canvas.getDrawingObjects()) {
-			if(o.vContains(p) && o != this)
-				return o;
-		}
-		return null; //Nothing found
-	}
-	
-	/**
-	 * Removes or adds the object (if exists) at the given coordinates from the selection,
-	 * depending on its selection-state
-	 * @param p
-	 */
-	public void objectClicked(Point2D p) {
-		VPathwayElement clicked = getChild(p);
-		if(clicked == null) return; //Nothing clicked
-		if(clicked.isSelected()) 	//Object is selected, remove
-		{
-			removeFromSelection(clicked);
-		} 
-		else 						//Object is not selected, add
-		{
-			addToSelection(clicked);
-		}
-	}
-	
-	/**
-	 * Returns true if the selectionbox has multiple objects in its selection, false otherwise
-	 */
-	public boolean hasMultipleSelection() { return selection.size() > 1 ? true : false; }
-	
-	/**
-	 * Resets the selectionbox (unselect selected objects, clear selection, reset rectangle
-	 * to upperleft corner
-	 */
-	public void reset() { 
-		reset(0, 0, true);
-	}
-	
-	
-	/**
-	 * Resets the selectionbox (unselect selected objects, clear selection, reset rectangle
-	 * to upperleft corner
-	 * @param clearSelection if true the selection is cleared
-	 */
-	public void reset(boolean clearSelection) { 
-		reset(0, 0, clearSelection);
-	}
-	
-	public void reset(double vStartX, double vStartY) {
-		reset(vStartX, vStartY, true);
-	}
-	
-	private void reset(double vStartX, double vStartY, boolean clearSelection) {
-		for(VPathwayElement o : selection) o.deselect();
-		if(clearSelection) {
-			selection.clear();
-			fireSelectionEvent(
-					new SelectionEvent(this, SelectionEvent.SELECTION_CLEARED));
-		}
-		
-		gdata.setMLeft(mFromV(vStartX));
-		gdata.setMTop(mFromV(vStartY));
-		gdata.setMWidth(0);
-		gdata.setMHeight(0);
-	}
-
-	/**
-	 * Returns true if this selectionbox is in selecting state (selects containing objects when resized)
-	 */
-	public boolean isSelecting() { return isSelecting; }
-	
-	/**
-	 * Start selecting
-	 */
-	public void startSelecting() {
-		isSelecting = true;
-		setHandleRestriction(false);
-		show();
-	}
-	
-	/**
-	 * Stop selecting
-	 */
-	public void stopSelecting() {
-		isSelecting = false;
-		if(!hasMultipleSelection()) {
-			if(selection.size() == 1) {
-				VPathwayElement passTo = selection.get(0);
-				reset();
-				passTo.select();
-			} else {
-				reset();
-			}
-		} else {
-			select();
-			fitToSelection();
-			setHandleRestriction(true);
-		}
-	}
-	
-	/**
-	 * Sets movement direction restriction for this object's handles
-	 * @param restrict if true, handle movement is restricted in XY direction,
-	 * else handles can move freely
-	 */
-	private void setHandleRestriction(boolean restrict) {
-		if(restrict) {
-			handleNE.setDirection(Handle.DIRECTION_MINXY);
-			handleSW.setDirection(Handle.DIRECTION_MINXY);
-			handleNW.setDirection(Handle.DIRECTION_XY);
-			handleSE.setDirection(Handle.DIRECTION_XY);
-		} else {
-			for(Handle h : getHandles()) 
-				h.setDirection(Handle.DIRECTION_FREE); 
-		}
-	}
-	
-	public void select() {
-		super.select();
-		for(VPathwayElement o : selection) {
-			o.select();
-			for(Handle h : o.getHandles()) h.hide();
-		}
-	}
-	
-	/**
-	 * Fit the size of this object to the selected objects
-	 */
-	public void fitToSelection() {
-		if(selection.size() == 0) { //No objects in selection
-			hide(); 
-			return;
-		}
-		if(! hasMultipleSelection()) { //Only one object in selection, hide selectionbox
-			VPathwayElement passTo = selection.get(0);
-			hide(false);
-			passTo.select();
-			return;
-		}
-
-		Rectangle vr = null;
-		for(VPathwayElement o : selection) {
-			if(vr == null) vr = o.getVBounds();
-			else vr.add(o.getVBounds());
-			for(Handle h : o.getHandles()) h.hide();
-		}
-
-		gdata.setMWidth(mFromV(vr.width));
-		gdata.setMHeight(mFromV(vr.height));
-		gdata.setMLeft(mFromV(vr.x));
-		gdata.setMTop(mFromV(vr.y));
-		setHandleLocation();		
-	}
-			
-	/**
-	 * Show the selectionbox
-	 */
-	public void show() { 
-		isVisible = true; 
-		markDirty();
-	}
-	
-	/**
-	 * Hide the selectionbox
-	 */
-	public void hide() {
-		hide(true);
-	}
-	
-	public void hide(boolean reset) {
-		for(Handle h : getHandles()) h.hide();
-		isVisible = false;
-		if(reset) reset();
-	}
-	
-	/**
-	 * Gets the corner handle (South east) for start dragging
-	 */
-	public Handle getCornerHandle() { return handleSE; }
-	
-	public void adjustToHandle(Handle h) {	
-		//Store original size and location before adjusting to handle
-		double vWidthOld = getVWidthDouble();
-		double vHeightOld = getVHeightDouble();
-		double vCenterXOld = getVCenterXDouble();
-		double vCenterYOld = getVCenterYDouble();
-		
-		super.adjustToHandle(h);
-		if(isSelecting) { //Selecting, so add containing objects to selection
-			Rectangle vr = getVBounds();
-			Rectangle2D.Double bounds = new Rectangle2D.Double(vr.x, vr.y, vr.width, vr.height);
-			for(VPathwayElement o : canvas.getDrawingObjects()) {
-				if((o == this) || (o instanceof Handle)) continue;
-				if(o.vIntersects(bounds)) { 
-					addToSelection(o);
-				} else if(o.isSelected()) removeFromSelection(o);
-			}
-		} else { //Resizing, so resize child objects too
-			double widthRatio = getVWidthDouble() / vWidthOld;
-			double heightRatio = getVHeightDouble() / vHeightOld;
-			//Scale all selected objects in x and y direction, treat points seperately
-			Set<VPoint> points = new HashSet<VPoint>();
-			for(VPathwayElement o : selection) { 
-				if(o instanceof Line) {
-					points.addAll(((Line)o).getPoints());
-				} else { 
-					Rectangle2D.Double vr = o.getVScaleRectangle();
-					double newObjectWidth = vr.width * widthRatio;
-					double newObjectHeight = vr.height * heightRatio;
-					double objectFromCenterX = (vr.x - vCenterXOld) * widthRatio;
-					double objectFromCenterY = (vr.y - vCenterYOld) * heightRatio;
-					o.setVScaleRectangle(new Rectangle2D.Double(
-							getVCenterXDouble() + objectFromCenterX, 
-							getVCenterYDouble() + objectFromCenterY, 
-							newObjectWidth, 
-							newObjectHeight));
-				}
-			}
-			for(VPoint p : points) {
-				double dx = (p.getVX() - vCenterXOld) * widthRatio;
-				double dy = (p.getVY() - vCenterYOld) * heightRatio;
-				p.setVLocation(getVCenterXDouble() + dx, getVCenterYDouble() + dy);
-			}
-		}
-	}
-	
-	public void vMoveBy(double vdx, double vdy) 
-	{
-
-		gdata.setMLeft(gdata.getMLeft() + mFromV(vdx)); 
-		gdata.setMTop(gdata.getMTop() + mFromV(vdy));
-
-		//Move selected object and their references
-		Set<GraphRefContainer> not = new HashSet<GraphRefContainer>(); //Will be moved by linking object
-		Set<VPoint> points = new HashSet<VPoint>(); //Will not be moved by linking object
-		
-		for(VPathwayElement o : selection) 
-		{
-			if (o instanceof Graphics)
-			{
-				PathwayElement g = ((Graphics)o).getGmmlData();
-				if(!(o instanceof Line)) {
-					o.vMoveBy(vdx, vdy);
-					not.addAll(g.getReferences());
-				}
-				if(g.getObjectType() == ObjectType.LINE) {
-					points.addAll(((Line)o).getPoints());
-				}
-			}
-
-		}
-		
-		for(GraphRefContainer ref : not) {
-			if(ref instanceof MPoint) {
-				points.remove(canvas.getPoint((MPoint)ref));
-			}
-		}
-			
-		for(VPoint p : points) {
-			p.vMoveBy(vdx, vdy);
-		}
-	}
-	
-	public void draw(PaintEvent e, GC buffer)
-	{
-		if(isVisible) {
-			buffer.setAntialias(SWT.OFF);
-			buffer.setForeground (e.display.getSystemColor (SWT.COLOR_BLACK));
-			buffer.setBackground (e.display.getSystemColor (SWT.COLOR_BLACK));
-			buffer.setLineStyle (SWT.LINE_DOT);
-			buffer.setLineWidth (1);
-			buffer.drawRectangle (getVLeft(), getVTop(), getVWidth(), getVHeight());
-			buffer.setAntialias(SWT.ON);
-		}
-	}
-	
-	protected void draw(PaintEvent e)
-	{
-		draw(e, e.gc);
-	}
-	
-	public void adjustToZoom(double factor) { fitToSelection(); }
-	
-	static List<SelectionListener> listeners;
-
-	/**
-	 * Add a {@link SelectionListener}, that will be notified if a selection event occurs
-	 * @param l The {@link SelectionListener} to add
-	 */
-	public static void addListener(SelectionListener l) {
-		if(listeners == null)
-			listeners = new ArrayList<SelectionListener>();
-		listeners.add(l);
-	}
-
-	/**
-	 * Fire a {@link SelectionEvent} to notify all {@link SelectionListener}s registered
-	 * to this class
-	 * @param e
-	 */
-	public static void fireSelectionEvent(SelectionEvent e) {
-		for(SelectionListener l : listeners) {
-			l.drawingEvent(e);
-		}
-	}
-
-	public interface SelectionListener {
-		public void drawingEvent(SelectionEvent e);
-	}
-
-	public static class SelectionEvent extends EventObject {
-		private static final long serialVersionUID = 1L;
-		public static final int OBJECT_ADDED = 0;
-		public static final int OBJECT_REMOVED = 1;
-		public static final int SELECTION_CLEARED = 2;
-
-		public SelectionBox source;
-		public VPathwayElement affectedObject;
-		public int type;
-		public List<VPathwayElement> selection;
-
-		public SelectionEvent(SelectionBox source, int type, VPathwayElement affectedObject) {
-			super(source);
-			this.source = source;
-			this.type = type;
-			this.selection = source.selection;
-			this.affectedObject = affectedObject;
-		}
-		
-		public SelectionEvent(SelectionBox source, int type) {
-			this(source, type, null);
-		}
-	}	
-	
-}
\ No newline at end of file
Index: trunk/src/core/org/pathvisio/view/VPathwayEvent.java
===================================================================
--- trunk/src/core/org/pathvisio/view/VPathwayEvent.java	(revision 0)
+++ trunk/src/core/org/pathvisio/view/VPathwayEvent.java	(revision 957)
@@ -0,0 +1,34 @@
+package org.pathvisio.view;
+
+import java.util.EventObject;
+
+public class VPathwayEvent extends EventObject {
+	public static final int NEW_ELEMENT_ADDED = 0;
+	public static final int EDIT_MODE_ON = 1;
+	public static final int EDIT_MODE_OFF = 2;
+	
+	int type;
+	VPathwayElement affectedElement;
+	
+	public VPathwayEvent(VPathway source, int type) {
+		super(source);
+		this.type = type;
+	}
+	
+	public VPathwayEvent(VPathway source, VPathwayElement affectedElement, int type) {
+		this(source, type);
+		this.affectedElement = affectedElement;
+	}
+	
+	public VPathwayElement getAffectedElement() {
+		return affectedElement;
+	}
+	
+	public int getType() {
+		return type;
+	}
+	
+	public VPathway getVPathway() {
+		return (VPathway)getSource();
+	}
+}
Index: trunk/src/core/org/pathvisio/view/VPathwayListener.java
===================================================================
--- trunk/src/core/org/pathvisio/view/VPathwayListener.java	(revision 0)
+++ trunk/src/core/org/pathvisio/view/VPathwayListener.java	(revision 957)
@@ -0,0 +1,5 @@
+package org.pathvisio.view;
+
+public interface VPathwayListener {
+	public void vPathwayEvent(VPathwayEvent e);
+}
Index: trunk/src/core/org/pathvisio/util/FileUtils.java
===================================================================
--- trunk/src/core/org/pathvisio/util/FileUtils.java	(revision 956)
+++ trunk/src/core/org/pathvisio/util/FileUtils.java	(revision 957)
@@ -24,7 +24,7 @@
 import java.io.RandomAccessFile;
 import java.util.ArrayList;
 
-import org.pathvisio.gui.swt.Engine;
+import org.pathvisio.Engine;
 
 public class FileUtils {	
 	/**
Index: trunk/src/core/org/pathvisio/util/Utils.java
===================================================================
--- trunk/src/core/org/pathvisio/util/Utils.java	(revision 956)
+++ trunk/src/core/org/pathvisio/util/Utils.java	(revision 957)
@@ -23,7 +23,7 @@
 import java.util.Collection;
 import java.util.List;
 
-import org.pathvisio.gui.swt.Engine;
+import org.pathvisio.Engine;
 
 public class Utils {
 	
Index: trunk/src/core/org/pathvisio/util/SuggestCombo.java
===================================================================
--- trunk/src/core/org/pathvisio/util/SuggestCombo.java	(revision 956)
+++ trunk/src/core/org/pathvisio/util/SuggestCombo.java	(revision 957)
@@ -16,25 +16,24 @@
 //
 package org.pathvisio.util;
 
-import java.util.ArrayList;
+import java.util.ArrayList;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.DisposeEvent;
+import org.eclipse.swt.events.DisposeListener;
+import org.eclipse.swt.events.ShellAdapter;
+import org.eclipse.swt.events.ShellEvent;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.List;
+import org.eclipse.swt.widgets.Listener;
+import org.eclipse.swt.widgets.Shell;
+import org.eclipse.swt.widgets.Text;
+import org.pathvisio.util.SuggestCombo.SuggestionProvider.SuggestThread;
 
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.events.DisposeEvent;
-import org.eclipse.swt.events.DisposeListener;
-import org.eclipse.swt.events.ShellAdapter;
-import org.eclipse.swt.events.ShellEvent;
-import org.eclipse.swt.graphics.Point;
-import org.eclipse.swt.layout.FillLayout;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Control;
-import org.eclipse.swt.widgets.Event;
-import org.eclipse.swt.widgets.List;
-import org.eclipse.swt.widgets.Listener;
-import org.eclipse.swt.widgets.Shell;
-import org.eclipse.swt.widgets.Text;
-
-import org.pathvisio.util.SuggestCombo.SuggestionProvider.SuggestThread;
-
 public class SuggestCombo extends Composite {
 	protected boolean ignoreModify;
 	protected boolean ignoreFocusOut;
Index: trunk/src/core/org/pathvisio/util/ColorConverter.java
===================================================================
--- trunk/src/core/org/pathvisio/util/ColorConverter.java	(revision 956)
+++ trunk/src/core/org/pathvisio/util/ColorConverter.java	(revision 957)
@@ -16,10 +16,11 @@
 //
 package org.pathvisio.util;
 
+import java.awt.Color;
+
 import org.eclipse.swt.graphics.RGB;
 import org.jdom.Element;
-import org.pathvisio.gui.swt.Engine;
-import org.pathvisio.model.Color;
+import org.pathvisio.Engine;
 
 public abstract class ColorConverter
 {		    
@@ -33,8 +34,12 @@
 		return rgb.red + "," + rgb.green + "," + rgb.blue;
 	}
 	
+	public static String getRgbString(java.awt.Color c) {
+		return c.getRed() + "," + c.getGreen() + "," + c.getBlue();
+	}
+	
 	public static RGB toRGB(Color c) {
-		return new RGB(c.red, c.green, c.blue);
+		return new RGB(c.getRed(), c.getGreen(), c.getBlue());
 	}
 	
 	public static Color fromRGB(RGB rgb) {
@@ -64,24 +69,40 @@
 		}
 	}
 	    
+	public static java.awt.Color parseColorString(String colorString)
+	{
+		String[] s = colorString.split(",");
+		try 
+		{
+			return new java.awt.Color(
+					Integer.parseInt(s[0]), 
+					Integer.parseInt(s[1]), 
+					Integer.parseInt(s[2]));
+		}
+		catch(Exception e)
+		{
+			throw new IllegalArgumentException("Unable to parse color from '" + colorString + "'", e);
+		}
+	}
+	    
     final static String XML_ELEMENT_COLOR = "color";
 	final static String XML_COLOR_R = "red";
 	final static String XML_COLOR_G = "green";
 	final static String XML_COLOR_B = "blue";
-    public static Element createColorElement(String name, RGB rgb) {
+    public static Element createColorElement(String name, Color rgb) {
     	Element elm = new Element(XML_ELEMENT_COLOR);
     	elm.setName(name);
-    	elm.setAttribute(XML_COLOR_R, Integer.toString(rgb.red));
-    	elm.setAttribute(XML_COLOR_G, Integer.toString(rgb.green));
-    	elm.setAttribute(XML_COLOR_B, Integer.toString(rgb.blue));
+    	elm.setAttribute(XML_COLOR_R, Integer.toString(rgb.getRed()));
+    	elm.setAttribute(XML_COLOR_G, Integer.toString(rgb.getGreen()));
+    	elm.setAttribute(XML_COLOR_B, Integer.toString(rgb.getBlue()));
     	
     	return elm;
     }
     
-    public static RGB parseColorElement(Element xml) {
+    public static Color parseColorElement(Element xml) {
     	int r = Integer.parseInt(xml.getAttributeValue(XML_COLOR_R));
     	int g = Integer.parseInt(xml.getAttributeValue(XML_COLOR_G));
     	int b = Integer.parseInt(xml.getAttributeValue(XML_COLOR_B));
-    	return new RGB(r,g,b);
+    	return new Color(r,g,b);
     }
 }
Index: trunk/src/core/org/pathvisio/util/Converter.java
===================================================================
--- trunk/src/core/org/pathvisio/util/Converter.java	(revision 956)
+++ trunk/src/core/org/pathvisio/util/Converter.java	(revision 957)
@@ -24,9 +24,9 @@
 
 import java.io.File;
 
+import org.pathvisio.debug.Logger;
 import org.pathvisio.model.ConverterException;
 import org.pathvisio.model.Pathway;
-import org.pathvisio.debug.Logger;
 
 /**
  * @author Thomas Kelder (t.a.j.kelder@student.tue.nl)
Index: trunk/src/core/org/pathvisio/util/SuggestCellEditor.java
===================================================================
--- trunk/src/core/org/pathvisio/util/SuggestCellEditor.java	(revision 956)
+++ trunk/src/core/org/pathvisio/util/SuggestCellEditor.java	(revision 957)
@@ -16,16 +16,15 @@
 //
 package org.pathvisio.util;
 
-import org.eclipse.jface.viewers.CellEditor;
-import org.eclipse.swt.events.FocusAdapter;
-import org.eclipse.swt.events.FocusEvent;
-import org.eclipse.swt.events.KeyAdapter;
-import org.eclipse.swt.events.KeyEvent;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Control;
+import org.eclipse.jface.viewers.CellEditor;
+import org.eclipse.swt.events.FocusAdapter;
+import org.eclipse.swt.events.FocusEvent;
+import org.eclipse.swt.events.KeyAdapter;
+import org.eclipse.swt.events.KeyEvent;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.pathvisio.util.SuggestCombo.SuggestionProvider;
 
-import org.pathvisio.util.SuggestCombo.SuggestionProvider;
-
 public abstract class SuggestCellEditor extends CellEditor {
 	protected SuggestCombo suggestCombo;
 	
Index: trunk/src/core/org/pathvisio/util/tableviewer/PathwayTable.java
===================================================================
--- trunk/src/core/org/pathvisio/util/tableviewer/PathwayTable.java	(revision 956)
+++ trunk/src/core/org/pathvisio/util/tableviewer/PathwayTable.java	(revision 957)
@@ -38,12 +38,12 @@
 import org.eclipse.swt.widgets.FileDialog;
 import org.eclipse.swt.widgets.Table;
 import org.eclipse.swt.widgets.TableColumn;
-
-import org.pathvisio.gui.swt.Engine;
-import org.pathvisio.preferences.swt.Preferences;
+import org.pathvisio.Engine;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
 import org.pathvisio.util.TableColumnResizer;
+import org.pathvisio.util.SwtUtils.FileInputDialog;
 import org.pathvisio.util.tableviewer.TableData.Row;
-import org.pathvisio.util.SwtUtils.FileInputDialog;
 
 
 /**
@@ -139,7 +139,7 @@
 				File pwFile = new File(pw);
 				if(!pwFile.canRead()) {
 					FileDialog fd = new FileDialog(getShell(), SWT.OPEN);
-					fd.setFilterPath(Engine.getPreferences().getString(Preferences.PREF_DIR_PWFILES));
+					fd.setFilterPath(SwtPreference.SWT_DIR_PWFILES.getValue());
 					FileInputDialog fid = new FileInputDialog(getShell(), "Specify pathway file", 
 							"Couldn't find pathway file, please specify which pathway to open",
 							pwFile.getAbsolutePath(), null, fd);
@@ -147,7 +147,7 @@
 						pw = fid.getValue();
 					}
 				}
-				Engine.openPathway(pw);
+				SwtEngine.openPathway(pw);
 			} catch(Exception ex) { 
 				Engine.log.error("when trying to open pathway from pathway table", ex);
 			}
Index: trunk/src/core/org/pathvisio/util/PathwayParser.java
===================================================================
--- trunk/src/core/org/pathvisio/util/PathwayParser.java	(revision 956)
+++ trunk/src/core/org/pathvisio/util/PathwayParser.java	(revision 957)
@@ -18,17 +18,15 @@
 
 import java.util.ArrayList;
 
+import org.pathvisio.Engine;
+import org.pathvisio.data.DataSources;
+import org.pathvisio.data.Gdb.IdCodePair;
 import org.xml.sax.Attributes;
 import org.xml.sax.SAXException;
 import org.xml.sax.SAXParseException;
 import org.xml.sax.XMLReader;
 import org.xml.sax.helpers.DefaultHandler;
 
-import org.pathvisio.gui.swt.Engine;
-import org.pathvisio.data.DataSources;
-import org.pathvisio.data.Gdb.IdCodePair;
-import org.pathvisio.model.MappFormat;
-
 /**
  * This sax handler can be used to quickly parse pathway information from
  * a gpml file
Index: trunk/src/core/org/pathvisio/util/JarUtils.java
===================================================================
--- trunk/src/core/org/pathvisio/util/JarUtils.java	(revision 956)
+++ trunk/src/core/org/pathvisio/util/JarUtils.java	(revision 957)
@@ -30,8 +30,9 @@
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 
-import org.pathvisio.gui.swt.Engine;
+import org.pathvisio.Engine;
 import org.pathvisio.Globals;
+import org.pathvisio.gui.swt.SwtEngine;
 
 public class JarUtils {
 	static final String PREFIX_TMP = Globals.APPLICATION_NAME;
@@ -75,7 +76,7 @@
 	public static List<String> listResources(String path) throws IOException {
 		List<String> resNames = new ArrayList<String>();
 
-		URL url = Engine.class.getClassLoader().getResource(path);
+		URL url = SwtEngine.class.getClassLoader().getResource(path);
 		if(url != null) {
 			if(url.getProtocol().equals("jar")) {
 				JarURLConnection conn = (JarURLConnection)url.openConnection();
@@ -97,7 +98,7 @@
 	 * @return the URL pointing to the resource
 	 */
 	public static URL getResourceURL(String name) {
-		URL url = Engine.class.getClassLoader().getResource(name);
+		URL url = SwtEngine.class.getClassLoader().getResource(name);
 		if(url == null) Engine.log.error("Couldn't load resource '" + name + "'");
 		return url;
 	}
@@ -108,7 +109,7 @@
 	 * @return the URL pointing to the resource
 	 */
 	public static InputStream getResourceInputStream(String name) {
-		InputStream in = Engine.class.getClassLoader().getResourceAsStream(name);
+		InputStream in = SwtEngine.class.getClassLoader().getResourceAsStream(name);
 		if(in == null) Engine.log.error("Couldn't load resource '" + name + "'");
 		return in;
 	}
Index: trunk/src/core/org/pathvisio/util/SwtUtils.java
===================================================================
--- trunk/src/core/org/pathvisio/util/SwtUtils.java	(revision 956)
+++ trunk/src/core/org/pathvisio/util/SwtUtils.java	(revision 957)
@@ -16,6 +16,10 @@
 //
 package org.pathvisio.util;
 
+import java.awt.image.BufferedImage;
+import java.awt.image.DirectColorModel;
+import java.awt.image.IndexColorModel;
+import java.awt.image.WritableRaster;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 
@@ -33,6 +37,7 @@
 import org.eclipse.swt.graphics.GC;
 import org.eclipse.swt.graphics.Image;
 import org.eclipse.swt.graphics.ImageData;
+import org.eclipse.swt.graphics.PaletteData;
 import org.eclipse.swt.graphics.Point;
 import org.eclipse.swt.graphics.RGB;
 import org.eclipse.swt.graphics.Transform;
@@ -43,10 +48,10 @@
 import org.eclipse.swt.widgets.Display;
 import org.eclipse.swt.widgets.FileDialog;
 import org.eclipse.swt.widgets.Shell;
-
-import org.pathvisio.gui.swt.Engine;
+import org.pathvisio.Engine;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.model.Pathway;
 import org.pathvisio.view.VPathway;
-import org.pathvisio.model.Pathway;
 
 public class SwtUtils {
 
@@ -74,6 +79,14 @@
 		return new Color(display, rgbNew);
 	}
 	
+	public static RGB color2rgb(java.awt.Color c) {
+		return new RGB(c.getRed(), c.getGreen(), c.getBlue());
+	}
+	
+	public static java.awt.Color rgb2color(RGB rgb) {
+		return new java.awt.Color(rgb.red, rgb.green, rgb.blue);
+	}
+	
 	/**
 	 * Change the given {@link Color}; this method disposes the old color for you
 	 * @param cOld	the old {@link Color}
@@ -81,14 +94,14 @@
 	 * @param display	the display to assign the color to
 	 * @return	a brand new {@link Color}
 	 */
-	public static Color changeColor(Color cOld, org.pathvisio.model.Color rgbNew, Display display)
+	public static Color changeColor(Color cOld, java.awt.Color rgbNew, Display display)
 	{
 		if(cOld != null && !cOld.isDisposed())
 		{
 			cOld.dispose();
 			cOld = null;
 		}
-		if(rgbNew == null) rgbNew = new org.pathvisio.model.Color(0,0,0);
+		if(rgbNew == null) rgbNew = new java.awt.Color(0,0,0);
 		return new Color(display, ColorConverter.toRGB(rgbNew));
 	}
 	
@@ -117,6 +130,59 @@
 		return iNew != null ? new Image(display, iNew) : null;
 	}
 	
+	  public static ImageData convertImageToSWT(BufferedImage bufferedImage) {
+		    if (bufferedImage.getColorModel() instanceof DirectColorModel) {
+		      DirectColorModel colorModel = (DirectColorModel) bufferedImage
+		          .getColorModel();
+		      PaletteData palette = new PaletteData(colorModel.getRedMask(),
+		          colorModel.getGreenMask(), colorModel.getBlueMask());
+		      ImageData data = new ImageData(bufferedImage.getWidth(),
+		          bufferedImage.getHeight(), colorModel.getPixelSize(),
+		          palette);
+		      WritableRaster raster = bufferedImage.getRaster();
+		      int[] pixelArray = new int[4];
+		      for (int y = 0; y < data.height; y++) {
+		        for (int x = 0; x < data.width; x++) {
+		          raster.getPixel(x, y, pixelArray);
+		          int pixel = palette.getPixel(new RGB(pixelArray[0],
+		              pixelArray[1], pixelArray[2]));
+		          data.setPixel(x, y, pixel);
+		        }
+		      }
+		      return data;
+		    } else if (bufferedImage.getColorModel() instanceof IndexColorModel) {
+		      IndexColorModel colorModel = (IndexColorModel) bufferedImage
+		          .getColorModel();
+		      int size = colorModel.getMapSize();
+		      byte[] reds = new byte[size];
+		      byte[] greens = new byte[size];
+		      byte[] blues = new byte[size];
+		      colorModel.getReds(reds);
+		      colorModel.getGreens(greens);
+		      colorModel.getBlues(blues);
+		      RGB[] rgbs = new RGB[size];
+		      for (int i = 0; i < rgbs.length; i++) {
+		        rgbs[i] = new RGB(reds[i] & 0xFF, greens[i] & 0xFF,
+		            blues[i] & 0xFF);
+		      }
+		      PaletteData palette = new PaletteData(rgbs);
+		      ImageData data = new ImageData(bufferedImage.getWidth(),
+		          bufferedImage.getHeight(), colorModel.getPixelSize(),
+		          palette);
+		      data.transparentPixel = colorModel.getTransparentPixel();
+		      WritableRaster raster = bufferedImage.getRaster();
+		      int[] pixelArray = new int[1];
+		      for (int y = 0; y < data.height; y++) {
+		        for (int x = 0; x < data.width; x++) {
+		          raster.getPixel(x, y, pixelArray);
+		          data.setPixel(x, y, pixelArray[0]);
+		        }
+		      }
+		      return data;
+		    }
+		    return null;
+		  }
+	  
 	public static void setCompositeAndChildrenEnabled(Composite comp, boolean enable) {
 		comp.setEnabled(enable);
 		for(Control c : comp.getChildren()) {
@@ -139,7 +205,7 @@
 	static int ii;
 	static int pixratio;
 	public static Font adjustFontSize(Font f, Point toFit, String text, GC gc, Display display) {
-		VPathway d = Engine.getVPathway();
+		VPathway d = Engine.getActiveVPathway();
 		pixratio = (int)Math.ceil(3 * (d == null ? 1 : d.getZoomFactor()));
 		ii = 3;
 		incrs = new int[3];
@@ -196,6 +262,20 @@
 		return pix / pixratio; 
 	}
 	
+	public static FontData awtFont2FontData(java.awt.Font f) {
+		int style = SWT.NORMAL;
+		if(f.isBold()) style |= SWT.BOLD;
+		if(f.isItalic()) style |= SWT.ITALIC;
+		return new FontData(f.getName(), f.getSize(), style);
+	}
+	
+	public static java.awt.Font fontData2awtFont(FontData fd) {
+		int style = java.awt.Font.PLAIN;
+		if((fd.style & SWT.BOLD) != 0) style |= java.awt.Font.BOLD;
+		if((fd.style & SWT.ITALIC) != 0) style |= java.awt.Font.ITALIC;
+		return new java.awt.Font(fd.getName(), fd.getHeight(), style);		
+	}
+	
 	static Font setFontSize(int size, Font f, GC gc, Display display) {
 		FontData fd = f.getFontData()[0];
 		fd.setHeight(size);
@@ -378,7 +458,7 @@
 
 			runException = null;
 			if(runAsSyncExec) {//Invoke in syncExec, method may access widgets from this thread
-				Engine.getWindow().getShell().getDisplay().syncExec(new Runnable() {
+				SwtEngine.getWindow().getShell().getDisplay().syncExec(new Runnable() {
 					public void run() {
 						runException = doInvoke();
 					}
@@ -420,7 +500,7 @@
 		 * @param w
 		 */
 		public static void monitorWorked(final int w) {
-			Engine.getWindow().getShell().getDisplay().asyncExec(new Runnable() {
+			SwtEngine.getWindow().getShell().getDisplay().asyncExec(new Runnable() {
 				public void run() {
 					if(monitor != null) monitor.worked(w);
 				}
@@ -433,7 +513,7 @@
 		 * @see IProgressMonitor#setTaskName(String)
 		 */
 		public static void monitorSetTaskName(final String taskName) {
-			Engine.getWindow().getShell().getDisplay().asyncExec(new Runnable() {
+			SwtEngine.getWindow().getShell().getDisplay().asyncExec(new Runnable() {
 				public void run() {
 					if(monitor != null) monitor.setTaskName(taskName);
 				}
@@ -447,9 +527,9 @@
 		 * @see MessageDialog#openInformation(org.eclipse.swt.widgets.Shell, String, String)
 		 */
 		public void openMessageDialog(final String title, final String msg) {
-			Engine.getWindow().getShell().getDisplay().asyncExec(new Runnable() {
+			SwtEngine.getWindow().getShell().getDisplay().asyncExec(new Runnable() {
 				public void run() {
-					MessageDialog.openInformation(Engine.getWindow().getShell(), title, msg);
+					MessageDialog.openInformation(SwtEngine.getWindow().getShell(), title, msg);
 				}
 			});
 		}
Index: trunk/src/g2d_swt/org/pathvisio/preferences/swt/SwtPreferences.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/preferences/swt/SwtPreferences.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/preferences/swt/SwtPreferences.java	(revision 957)
@@ -0,0 +1,195 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.preferences.swt;
+
+import java.io.File;
+import java.io.IOException;
+
+import org.eclipse.jface.preference.PreferenceStore;
+import org.eclipse.jface.util.IPropertyChangeListener;
+import org.eclipse.jface.util.PropertyChangeEvent;
+import org.pathvisio.Engine;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.Preference;
+import org.pathvisio.preferences.PreferenceCollection;
+import org.pathvisio.util.ColorConverter;
+import org.pathvisio.view.Graphics;
+
+import com.sun.org.apache.xpath.internal.operations.Bool;
+
+/**
+ * This class contains all user preferences used in this application
+ */
+public class SwtPreferences extends PreferenceStore implements PreferenceCollection, IPropertyChangeListener {
+	private static final File preferenceFile = new File(SwtEngine.getApplicationDir(), ".PathVisio");
+	
+	public SwtPreferences() {
+		this(preferenceFile.toString());
+	}
+	
+	public SwtPreferences(String fileName) {
+		super(fileName);
+		loadPreferences();
+	}
+	
+	public Preference byName(String name) {
+		Preference p = null;
+		if(name.startsWith("SWT")) {
+			p = SwtPreference.valueOf(name);
+		} else {
+			p = GlobalPreference.valueOf(name);
+		}
+		return p;
+	}
+	
+	protected void toEnums(Preference[] enumPrefs) {
+		for(Preference p : enumPrefs) {
+			p.setValue(getString(p.name()));
+		}
+	}
+	
+	protected void toEnums() {
+		toEnums(SwtPreference.values());
+		toEnums(GlobalPreference.values());
+	}
+	
+	protected void fromEnums(Preference[] enumPrefs) {
+		for(Preference p : enumPrefs) {
+			setValue(p.name(), p.getValue());
+		}
+	}
+	
+	protected void fromEnums() {
+		fromEnums(SwtPreference.values());
+		fromEnums(GlobalPreference.values());
+	}
+	
+	public void save() throws IOException {
+		fromEnums();
+		super.save();
+	}
+	
+	/**
+	 * Loads all stored users preferences and set defaults
+	 */
+	private void loadPreferences()
+	{
+		addPropertyChangeListener(this);
+		
+		for(Preference p : GlobalPreference.values()) {
+			setDefault(p);
+		}
+		
+		for(Preference p : SwtPreference.values()) {
+			setDefault(p);
+		}
+		
+		try {
+			load();
+		} catch(Exception e) { 
+			Engine.log.error("Unable to load preferences", e);
+		}
+		
+		toEnums();
+		
+		createDataDirectories();
+		
+	}
+	
+	private void setDefault(Preference p) {
+		setDefault(p.name(), p.getDefault());
+	}
+	
+	private void createDataDirectories() {
+		// For the data directories: if not defined by user, create default directories
+		Preference[] dataProps = new Preference[] 
+		{ 
+			SwtPreference.SWT_DIR_EXPR, SwtPreference.SWT_DIR_GDB, 
+			SwtPreference.SWT_DIR_PWFILES, SwtPreference.SWT_DIR_RDATA 
+		};
+		
+		for(Preference prop : dataProps) {
+			File dir = new File(prop.getValue());
+			if(!dir.exists()) dir.mkdirs();
+		}
+	}
+	
+	public void propertyChange(PropertyChangeEvent e) {
+		Preference p = byName(e.getProperty());
+		if(p != null) {
+			p.setValue(e.getNewValue().toString());
+		}
+		
+		if(e.getProperty().equals(GlobalPreference.COLOR_SELECTED.name())) { 
+			//if(e.getNewValue() instanceof RGB) Graphics.selectColor = (RGB)e.getNewValue();
+			//else 
+				Graphics.selectColor = ColorConverter.parseColorString((String)e.getNewValue());
+			Engine.getActiveVPathway().redraw();
+		}
+		else if(e.getProperty().equals(GlobalPreference.COLOR_HIGHLIGHTED.name())) {
+			//if(e.getNewValue() instanceof RGB) Graphics.highlightColor = (RGB)e.getNewValue();
+			//else 
+				Graphics.highlightColor = ColorConverter.parseColorString((String)e.getNewValue());
+				Engine.getActiveVPathway().redraw();
+		}
+		else if(e.getProperty().startsWith("directories")) {
+			createDataDirectories();
+		}
+	}
+	
+	public enum SwtPreference implements Preference {
+		SWT_DIR_PWFILES(new File(SwtEngine.getDataDir().toString(), "pathways").toString()),
+		SWT_DIR_GDB(new File(SwtEngine.getDataDir().toString(), "gene databases").toString()),
+		SWT_DIR_EXPR(new File(SwtEngine.getDataDir().toString(), "expression datasets").toString()),
+		SWT_DIR_RDATA(new File(SwtEngine.getDataDir().toString(), "R data").toString()),
+
+		SWT_CURR_GDB("none"),
+		SWT_DB_ENGINE_GDB("org.pathvisio.data.DBConnDerby"),
+		SWT_DB_ENGINE_EXPR("org.pathvisio.data.DBConnDerby"),
+		SWT_SIDEPANEL_SIZE("30"),
+		
+		SWT_SHOW_ADVANCED_ATTR(Boolean.toString(false));
+		
+		SwtPreference(String defaultValue) {
+			this.defaultValue = defaultValue;
+		}
+
+		private String defaultValue;
+		private String value;
+		
+		public String getDefault() {
+			return defaultValue;
+		}
+		
+		public void setDefault(String defValue) {
+			defaultValue = defValue;
+		}
+		
+		public void setValue(String newValue) {
+			value = newValue;
+		}
+		
+		public String getValue() {
+			if(value != null) {
+				return value;
+			} else {
+				return defaultValue;
+			}
+		}
+	}
+}
\ No newline at end of file
Index: trunk/src/g2d_swt/org/pathvisio/preferences/swt/PreferenceDlg.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/preferences/swt/PreferenceDlg.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/preferences/swt/PreferenceDlg.java	(revision 957)
@@ -0,0 +1,145 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.preferences.swt;
+
+import org.eclipse.jface.preference.BooleanFieldEditor;
+import org.eclipse.jface.preference.ColorFieldEditor;
+import org.eclipse.jface.preference.DirectoryFieldEditor;
+import org.eclipse.jface.preference.FieldEditorPreferencePage;
+import org.eclipse.jface.preference.FileFieldEditor;
+import org.eclipse.jface.preference.IntegerFieldEditor;
+import org.eclipse.jface.preference.PreferenceManager;
+import org.eclipse.jface.preference.PreferenceNode;
+import org.eclipse.jface.preference.StringFieldEditor;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+
+public class PreferenceDlg extends PreferenceManager {
+	
+	public PreferenceDlg() {
+		super();
+
+		PreferenceNode display = new PreferenceNode("display", new DisplayPage());
+	    PreferenceNode colors = new PreferenceNode("colors", new ColorsPage());
+	    PreferenceNode directories = new PreferenceNode("directories", new DirectoriesPage());
+	    PreferenceNode files = new PreferenceNode("files", new FilesPage());
+	    PreferenceNode database = new PreferenceNode("database", new DatabasePage());
+	    
+	    addToRoot(display);
+	    addTo("display", colors);
+	    addToRoot(directories);
+	    addToRoot(files);
+	    addToRoot(database);
+	}
+	
+	private class FilesPage extends FieldEditorPreferencePage {
+		public FilesPage() {
+			super("Files", GRID);
+		}
+		
+		protected void createFieldEditors() {
+			FileFieldEditor f1 = new FileFieldEditor(GlobalPreference.FILE_LOG.name(), "Log file:", getFieldEditorParent());
+			addField(f1);
+		}
+	}
+	
+	private class DirectoriesPage extends FieldEditorPreferencePage {
+		public DirectoriesPage() {
+			super("Directories", GRID);
+			noDefaultAndApplyButton();
+		}
+		
+		protected void createFieldEditors() {
+			DirectoryFieldEditor d1 = new DirectoryFieldEditor(SwtPreference.SWT_DIR_PWFILES.name(),
+					"Gpml pathways:", getFieldEditorParent());
+			addField(d1);
+			
+			DirectoryFieldEditor d2 = new DirectoryFieldEditor(SwtPreference.SWT_DIR_GDB.name(),
+					"Gene databases:", getFieldEditorParent());
+			addField(d2);
+			
+			DirectoryFieldEditor d3 = new DirectoryFieldEditor(SwtPreference.SWT_DIR_EXPR.name(),
+					"Expression datasets:", getFieldEditorParent());
+			addField(d3);
+
+			if(SwtEngine.isUseR()) {
+				DirectoryFieldEditor d4 = new DirectoryFieldEditor(SwtPreference.SWT_DIR_RDATA.name(),
+						"Results from pathway statistics:", getFieldEditorParent());
+				addField(d4);
+			}
+		}
+	}
+	
+	private class DisplayPage extends FieldEditorPreferencePage {
+		public DisplayPage() {
+			super("Display", GRID);
+		}
+		
+		protected void createFieldEditors() {
+			IntegerFieldEditor f = new IntegerFieldEditor(SwtPreference.SWT_SIDEPANEL_SIZE.name(),
+					"Initial side panel size (percent of window size):", getFieldEditorParent());
+			f.setValidRange(0, 100);
+			addField(f);
+			
+			BooleanFieldEditor f2 =	new BooleanFieldEditor (
+					SwtPreference.SWT_SHOW_ADVANCED_ATTR.name(),									   
+					"Show advanced attributes (e.g. references):", getFieldEditorParent());
+				addField (f2);
+		}
+	}
+	private class ColorsPage extends FieldEditorPreferencePage {
+		public ColorsPage() {
+			super("Colors", GRID);
+		}
+		
+		protected void createFieldEditors() {
+			ColorFieldEditor f1 = new ColorFieldEditor(GlobalPreference.COLOR_NO_CRIT_MET.name(), 
+					"Default color for 'no criteria met':", getFieldEditorParent());
+			addField(f1);
+			ColorFieldEditor f2 = new ColorFieldEditor(GlobalPreference.COLOR_NO_GENE_FOUND.name(), 
+					"Default color for 'gene not found':", getFieldEditorParent());
+			addField(f2);
+			ColorFieldEditor f3 = new ColorFieldEditor(GlobalPreference.COLOR_NO_DATA_FOUND.name(), 
+					"Default color for 'no data found':", getFieldEditorParent());
+			addField(f3);
+			ColorFieldEditor f4 = new ColorFieldEditor(GlobalPreference.COLOR_SELECTED.name(), 
+					"Line color for selected objects:", getFieldEditorParent());
+			addField(f4);
+			ColorFieldEditor f5 = new ColorFieldEditor(GlobalPreference.COLOR_HIGHLIGHTED.name(), 
+					"Line color for highlighted objects:", getFieldEditorParent());
+			addField(f5);
+			
+		}
+	}
+	
+	private class DatabasePage extends FieldEditorPreferencePage {
+		public DatabasePage() {
+			super("Database", GRID);
+		}
+		
+		protected void createFieldEditors() {
+			StringFieldEditor f1 = new StringFieldEditor(SwtPreference.SWT_DB_ENGINE_GDB.name(),
+					"Database connector class for gene database:", getFieldEditorParent());
+			addField(f1);
+			StringFieldEditor f2 = new StringFieldEditor(SwtPreference.SWT_DB_ENGINE_EXPR.name(),
+					"Database connector class for expression dataset:", getFieldEditorParent());
+			addField(f2);
+		}
+	}
+	
+}
\ No newline at end of file

Property changes on: trunk/src/g2d_swt/org/pathvisio/preferences/swt/PreferenceDlg.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/visualization/Visualization.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/visualization/Visualization.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/visualization/Visualization.java	(revision 957)
@@ -0,0 +1,612 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization;
+
+import java.awt.Graphics2D;
+import java.awt.Rectangle;
+import java.awt.Shape;
+import java.awt.geom.Area;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.ShellAdapter;
+import org.eclipse.swt.events.ShellEvent;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.layout.RowLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.Group;
+import org.eclipse.swt.widgets.Listener;
+import org.eclipse.swt.widgets.Shell;
+import org.jdom.Element;
+import org.pathvisio.Engine;
+import org.pathvisio.data.Gex;
+import org.pathvisio.data.Gex.ExpressionDataEvent;
+import org.pathvisio.data.Gex.ExpressionDataListener;
+import org.pathvisio.util.Utils;
+import org.pathvisio.view.Graphics;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+import org.pathvisio.visualization.VisualizationManager.VisualizationListener;
+import org.pathvisio.visualization.plugins.PluginManager;
+import org.pathvisio.visualization.plugins.VisualizationPlugin;
+
+/**
+ * Represents a set of configured visualization plugins
+ * @author thomas
+ */
+public class Visualization implements ExpressionDataListener, VisualizationListener {
+	public static final String XML_ELEMENT = "visualization";
+	public static final String XML_ATTR_NAME = "name";
+	
+	String name;
+	HashMap<Class, PluginSet> plugins;
+	List<PluginSet> pluginPlacement;
+	
+	Composite sidePanel;
+	
+	/**
+	 * Constructor for this class. Creates an instance of {@link Visualization} with the
+	 * given name
+	 * @param name The name of this {@link Visualization}
+	 */
+	public Visualization(String name) {
+		initPlugins();
+		this.name = name;
+		Gex.addListener(this);
+		VisualizationManager.addListener(this);
+	}
+	
+	/**
+	 * Create initial instances of {@link PluginSet} for each visualization
+	 * plugin class
+	 */
+	void initPlugins() {
+		plugins = new HashMap<Class, PluginSet>();
+		pluginPlacement = new ArrayList<PluginSet>();
+		for(Class c : PluginManager.getPlugins()) {
+			addPluginClass(c);
+		}
+	}
+	
+	/**
+	 * Refresh the available subclasses of {@link VisualizationPlugin}.
+	 */
+	void refreshPluginClasses() {
+		for(Class c : PluginManager.getPlugins()) {
+			if(!plugins.containsKey(c)) {
+				addPluginClass(c);
+			}
+		}
+	}
+	
+	/**
+	 * Add a subclass of {@link VisualizationPlugin} to the available
+	 * visualization plugin classes
+	 * @param c	The class of the visualization plugin to add
+	 */
+	void addPluginClass(Class c) {
+		try {
+			PluginSet pr = new PluginSet(c, this);
+			plugins.put(c, pr);
+			pluginPlacement.add(pr);
+		} catch(Throwable e) {
+			Engine.log.error("Unable to create instance of plugin " + c, e);
+		}
+	}
+
+	/**
+	 * Get the name of this {@link Visualization}
+	 * @return the name
+	 */
+	public String getName() { return name; }
+	
+	/**
+	 * Set the name of this {@link Visualization}
+	 * @param name the name for this visualization
+	 */
+	public void setName(String name) { 
+		this.name = name;
+		fireVisualizationEvent(VisualizationEvent.VISUALIZATION_MODIFIED);
+	}
+	
+	/**
+	 * Fire an {@link VisualizationEvent} for this visualization and the given type
+	 * @param type The type of the {@link VisualizationEvent} to fire
+	 */
+	private final void fireVisualizationEvent(int type) {
+		VisualizationManager.fireVisualizationEvent(
+				new VisualizationEvent(this, type));
+	}
+	
+	/**
+	 * Returnts whether this visualization is generic or not. A visualization is
+	 * generic only if all of its active plugins are generic.
+	 * @see VisualizationPlugin#isGeneric()
+	 * @return true if this visualization is generic, false otherwise
+	 */
+	public boolean isGeneric() {
+		for(PluginSet pr : getPluginSets())
+			if(pr.isActive() && !pr.isGeneric()) return false; //One or more active non-generic plugins, so not generic
+		return true;
+	}
+	
+	/**
+	 * Get the {@link PluginSet}s of this visualization
+	 * @return An ordered list of {@link PluginSet}s
+	 */
+	public List<PluginSet> getPluginSets() {
+		return pluginPlacement;
+	}
+	
+	/**
+	 * Get the {@link PluginSet} for the given plugin class
+	 */
+	public PluginSet getPluginSet(Class c) {
+		return plugins.get(c);
+	}
+	
+	/**
+	 * Set the {@link PluginSet} for the given subclass of {@link VisualizationPlugin}
+	 * @param pluginClass	The class to set the given {@link PluginSet} for
+	 * @param ps			The {@link PluginSet} to set
+	 */
+	private void setPluginSet(Class pluginClass, PluginSet ps) {
+		pluginPlacement.remove(ps);
+		plugins.put(pluginClass, ps);
+		pluginPlacement.add(ps);
+		fireVisualizationEvent(VisualizationEvent.VISUALIZATION_MODIFIED);
+	}
+	
+	/**
+	 * Draw this visualization to the pathway drawing for the given {@link Graphics} object.
+	 * @see VisualizationPlugin#visualizeOnDrawing(Graphics, Graphics2D)
+	 * @param g	The {@link Graphics} object the visualization applies to
+	 * @param g2d Graphical context on which drawing operations can be performed
+	 */
+	public void visualizeDrawing(Graphics g, Graphics2D g2d) {
+		for(PluginSet pr : getPluginSetsDrawingOrder()) {
+			if(pr.isDrawing()) pr.getDrawingPlugin().visualizeOnDrawing(g, g2d);
+		}
+	}
+	
+	/**
+	 * Provide an drawing area on the given Graphics for the given VisualizationPlugin (only
+	 * when {@link VisualizationPlugin#isUseProvidedArea()})
+	 * @param p the VisualizationPlugin to provide the area for
+	 * @param g the Graphics on which the area is created
+	 * @return A {@link Shape} object that contains the area in which the
+	 * VisualizationPlugin can draw its visualization
+	 */
+	public Area provideDrawArea(VisualizationPlugin p, Graphics g) {
+		if(!p.isUseProvidedArea()) 
+			throw new IllegalArgumentException("useProvidedArea set to false for this plug-in");
+		
+		//Determine number of active plugins that to reserve a region
+		int nrRes = 0;
+		int index = 0;
+		for(PluginSet pr : getPluginSetsDrawingOrder()) {
+			if(pr.getDrawingPlugin() == p) index = nrRes;
+			nrRes += (pr.getDrawingPlugin().isActive() && pr.getDrawingPlugin().isUseProvidedArea()) ? 1 : 0;
+		}
+		
+		Area area = g.createVisualizationRegion();
+		//Distribute space over plugins
+		Rectangle bounds = area.getBounds();
+		
+		//Adjust width so we can divide into equal rectangles
+		bounds.width += bounds.width % nrRes;
+		int w = bounds.width / nrRes;
+		bounds.x += w * index;
+		bounds.width = w;
+		
+		Area barea = new Area(bounds);
+		area.intersect(barea);
+		
+		return area;
+	}
+	
+	/**
+	 * Set the display order of the given plugin-set. {@link Utils#ORDER_FIRST} makes the
+	 * plug-in to be drawn last (so displayed on top of the visualization).
+	 * @param pr The plugin-set to set the drawing order for
+	 * @param order The order constant (as specified in {@link Utils#changeOrder(List, Object, int)}
+	 * @see Utils#changeOrder(List, Object, int)
+	 */
+	public void setDisplayOrder(PluginSet pr, int order) {
+		Utils.changeOrder(pluginPlacement, pr, order);
+		fireVisualizationEvent(VisualizationEvent.VISUALIZATION_MODIFIED);
+	}
+	
+	/**
+	 * Get the plugin-sets in the order of which they are to be drawn
+	 * @return a list of plugin-sets in the order of which they are to be drawn
+	 */
+	public List<PluginSet> getPluginSetsDrawingOrder() {
+		List<PluginSet> sorted = new ArrayList<PluginSet>(pluginPlacement);
+		Collections.reverse(sorted);
+		return sorted;
+	}
+	
+	/**
+	 * Update the side-panel for all plug-ins that are activated
+	 * in the side-panel to visualize the given pathway elements
+	 * @param objects The pathway elements to visualize
+	 */
+	void visualizeSidePanel(Collection<Graphics> objects) {
+		for(PluginSet pr : getPluginSetsDrawingOrder()) {
+			if(pr.isSidePanel())
+				pr.getSidePanelPlugin().visualizeOnSidePanel(objects);
+		}
+	}
+	
+	/**
+	 * Create the side-panel composite for plug-ins that are activated
+	 * in the side-panel.
+	 * @param parent The parent Composite to create the new Composite on
+	 * @return A Composite that displays the side-panel visualization for the plug-ins
+	 * that are activated in the side-panel
+	 */
+	Composite createSideSidePanel(Composite parent) {
+		sidePanel = new Composite(parent, SWT.NULL);
+		sidePanel.setLayout(new FillLayout(SWT.VERTICAL));
+		
+		for(PluginSet pr : getPluginSetsDrawingOrder()) {
+			if(pr.isSidePanel()) {
+				Group group = new Group(sidePanel, SWT.NULL);
+				group.setBackground(group.getDisplay().getSystemColor(SWT.COLOR_WHITE));
+				group.setLayout(new FillLayout());
+				group.setText(pr.getSidePanelPlugin().getName());
+				pr.getSidePanelPlugin().initSidePanel(group);
+			}
+		}
+		return sidePanel;
+	}
+	
+	/**
+	 * Disposes the side-panel composite created with {@link #createSideSidePanel(Composite)}
+	 */
+	void disposeSidePanel() {
+		if(sidePanel != null && !sidePanel.isDisposed())
+			sidePanel.dispose();
+	}
+	
+	/**
+	 * Checks whether this visualization has one or more plug-ins activated on
+	 * the tool-tip
+	 * @return true if one or more plug-ins are activated on the tool-tip, false if not
+	 */
+	public boolean usesToolTip() {
+		for(PluginSet pr : pluginPlacement) {
+			if(pr.isToolTip()) return true;
+		}
+		return false;
+	}
+	
+	/**
+	 * Create a tool-tip for the given pathway element
+	 * @param parent The parent shell
+	 * @param control The control on which the tool-tip is created
+	 * @param g The pathway element to create the tool-tip for
+	 * @return A tool-tip that displays visualizations for the given gene-product 
+	 * by the plug-ins activated on the tool-tip
+	 */
+	public Shell visualizeToolTip(Shell parent, Control control, Graphics g) {
+		final Shell tip = new Shell(parent, SWT.ON_TOP | SWT.TOOL);  
+		tip.setBackground(parent.getDisplay().getSystemColor(SWT.COLOR_INFO_BACKGROUND));
+		tip.setLayout(new RowLayout(SWT.VERTICAL));
+		
+		Listener hideListener = new Listener() {
+			public void handleEvent(Event event) {
+	 			switch (event.type) {
+	 			case SWT.MouseDown:
+	 			case SWT.MouseExit:
+	 			case SWT.MouseMove:
+	 			case SWT.FocusOut:
+	 				tip.dispose();
+	 			}
+			}
+		};
+		
+		tip.addListener(SWT.MouseDown, hideListener);
+		tip.addListener(SWT.MouseExit, hideListener);
+		control.addListener(SWT.MouseMove, hideListener);
+		parent.addShellListener(new ShellAdapter() {
+			public void shellClosed(ShellEvent e) {
+				tip.dispose();	
+			}
+			public void shellDeactivated(ShellEvent e) {
+				tip.dispose();
+			}
+		});
+				
+		boolean hasOne = false;
+		for(PluginSet pr : getPluginSetsDrawingOrder()) {
+			if(pr.isToolTip()) {
+				Composite ttc = pr.getToolTipPlugin().visualizeOnToolTip(tip, g);
+				if(ttc != null) hasOne = true;
+			}
+		}
+		tip.pack();
+		return hasOne ? tip : null;
+	}
+	
+	/**
+	 * Save the information to re-build this visualization to an
+	 * XML element
+	 * @return The XML element containing the information to re-build this visualization
+	 */
+	public Element toXML() {
+		Element vis = new Element(XML_ELEMENT);
+		vis.setAttribute(XML_ATTR_NAME, getName());
+		for(PluginSet pr : pluginPlacement)
+			if(pr.isActive()) 
+				vis.addContent(pr.toXML());
+		return vis;
+	}
+	
+	/**
+	 * Re-build a visualization based on the information in the given XML element
+	 * @param xml The XML element that contains the information to re-build the visualization
+	 * @return The visualization that is re-build based on the information in the XML element
+	 */
+	public static Visualization fromXML(Element xml) {
+		String name = xml.getAttributeValue(XML_ATTR_NAME);
+		if(name == null) name = VisualizationManager.getNewName();
+		
+		Visualization v = new Visualization(name);
+		for(Object o : xml.getChildren(PluginSet.XML_ELEMENT)) {
+			try {
+				PluginSet pr = PluginSet.fromXML((Element)o, v);
+				v.setPluginSet(pr.getClass(), pr);
+			} catch(Throwable e) {
+				Engine.log.error("Unable to load plugin", e);
+			}
+		}		
+		return v;
+	}
+	
+	public boolean equals(Object o) {
+		if(o instanceof Visualization) return ((Visualization)o).getName().equals(name);
+		return false;
+	}
+
+	public void expressionDataEvent(ExpressionDataEvent e) {
+		switch(e.type) {
+		case ExpressionDataEvent.CONNECTION_OPENED:
+			refreshPluginClasses();
+		}
+		
+	}
+
+	public void visualizationEvent(VisualizationEvent e) {
+		switch(e.type) {
+		case VisualizationEvent.PLUGIN_ADDED: 
+			refreshPluginClasses();
+			break;
+		}
+	}
+	
+	/**
+	 * Set of instances from subclass of {@link VisualizationPlugin} (all instances
+	 * have the same class).
+	 * The set contains one instance for each display option (drawing, side panel, tool tip)
+	 * @author Thomas
+	 */
+	public static class PluginSet {
+		static final int NR = 3; //Number of display options
+		static final int TOOLTIP = 0;
+		static final int DRAWING = 1;
+		static final int SIDEPANEL = 2;
+		
+		Visualization vis;
+		Class pluginClass;
+		VisualizationPlugin[] reps;
+		
+		private PluginSet(Visualization v) {
+			vis = v;
+			reps = new VisualizationPlugin[NR];
+		}
+		
+		/**
+		 * Constructor for this class
+		 * @param pluginClass The class of the plug-in this set will contain
+		 * @param v The visualization this plugin-set belongs to
+		 * @throws Throwable
+		 */
+		public PluginSet(Class pluginClass, Visualization v) throws Throwable {
+			this(v);
+			this.pluginClass = pluginClass;
+			for(int i = 0; i < NR; i++) {
+				reps[i] = PluginManager.getInstance(pluginClass, v);
+			}
+		}
+		
+		void setPluginClass(Class pluginClass) throws Throwable {
+			this.pluginClass = pluginClass;
+			for(int i = 0; i < reps.length; i++) {
+				if(reps[i] == null || !pluginClass.isInstance(reps[i]))
+					reps[i] = PluginManager.getInstance(pluginClass, vis);
+			}
+		}
+		
+		void setPlugin(VisualizationPlugin p, int representation) throws Throwable {
+			p.setActive(true);
+			reps[representation] = p;
+			if(pluginClass == null || !pluginClass.equals(p.getClass())) 
+				setPluginClass(p.getClass());
+		}
+		
+		void checkIndex(int index) {
+			if(index < 0 || index > reps.length) 
+				throw new IllegalArgumentException("invalid representation index");
+		}
+		
+		/**
+		 * Get the plug-in instance that will be used for visualization on the pahtway drawing
+		 * @return The plug-in instance for visualization on the drawing
+		 */
+		public VisualizationPlugin getDrawingPlugin() { return reps[DRAWING]; }
+		/**
+		 * Get the plug-in instance that will be used for visualization on the pahtway tool-tip
+		 * @return The plug-in instance for visualization on the tool-tip
+		 */
+		public VisualizationPlugin getToolTipPlugin() { return reps[TOOLTIP]; }
+		/**
+		 * Get the plug-in instance that will be used for visualization on the pahtway side-panel
+		 * @return The plug-in instance for visualization on the side-panel
+		 */
+		public VisualizationPlugin getSidePanelPlugin() { return reps[SIDEPANEL]; }
+		
+		/**
+		 * Get the plug-in instance for the given representation
+		 * @param representation one of {@link #TOOLTIP}, {@link #SIDEPANEL}, {@link #DRAWING})
+		 * @return The instance of the plug-in for the given representation
+		 */
+		public VisualizationPlugin getPlugin(int representation) { 
+			checkIndex(representation);
+			return reps[representation]; 
+		}
+		
+		/**
+		 * Get an instance of the plugin-class this plugin-set contains.
+		 * Convenience method to query information about the plug-in, don't use
+		 * the instance for visualization!
+		 * @return An instance of the plugin-class
+		 */
+		VisualizationPlugin getInstance() { return reps[0]; }
+		
+		/**
+		 * Check whether one or more of the plug-ins in this set are activated
+		 * @return true if one or more of the plug-ins are activated, false if not
+		 * @see VisualizationPlugin#isActive()
+		 */
+		public boolean isActive() {
+			for(VisualizationPlugin p : reps) 
+				if(p.isActive()) return true;
+			return false;
+		}
+		
+		/**
+		 * Check whether all plug-ins in this set are generic
+		 * @return true if all plug-ins in this set are generic, false if not
+		 * @see VisualizationPlugin#isGeneric()
+		 */
+		public boolean isGeneric() {
+			for(VisualizationPlugin p : reps) 
+				if(!p.isGeneric()) return false;
+			return true;
+		}
+		
+		/**
+		 * Check whether the pathway drawing representation in this set is activated
+		 * @return true if the drawing representation is active, false if not
+		 */
+		public boolean isDrawing() { return getDrawingPlugin().isActive(); }
+		/**
+		 * Check whether the side-panel representation in this set is activated
+		 * @return true if the sice-panel representation is active, false if not
+		 */
+		public boolean isSidePanel() { return getSidePanelPlugin().isActive(); }
+		/**
+		 * Check whether the tool-tip representation in this set is activated
+		 * @return true if the tool-tip representation is active, false if not
+		 */
+		public boolean isToolTip() { return getToolTipPlugin().isActive(); }
+
+		/**
+		 * Set the activation state of the instance of the plug-in for the given representaion
+		 * @param representation The representation (one of {@link #DRAWING}, {@link #SIDEPANEL}, {@link #TOOLTIP})
+		 * @param active true to activate, false to de-activate
+		 */
+		public void setActive(int representation, boolean active) {
+			checkIndex(representation);
+			reps[representation].setActive(active);
+			if(representation == SIDEPANEL) VisualizationManager.fireVisualizationEvent(
+					new VisualizationEvent(this, VisualizationEvent.PLUGIN_SIDEPANEL_ACTIVATED));
+		}
+		
+		static final String XML_ELEMENT = "plugin-representations";
+		static final String XML_ATTR_CLASS = "class";
+		static final String XML_ELM_DRAWING = "drawing";
+		static final String XML_ELM_TOOLTIP = "tooltip";
+		static final String XML_ELM_SIDEPANEL = "sidepanel";
+		
+		/**
+		 * Save the information to re-build this plugin-ste to an
+		 * XML element
+		 * @return The XML element containing the information to re-build this plugin-set
+		 */
+		public Element toXML() {
+			Element e = new Element(XML_ELEMENT);
+			e.setAttribute(XML_ATTR_CLASS, pluginClass.getCanonicalName());		 
+			
+			if(reps[DRAWING].isActive()) {
+				Element dr = new Element(XML_ELM_DRAWING);
+				dr.addContent(reps[DRAWING].toXML());
+				e.addContent(dr);
+			}
+			if(reps[SIDEPANEL].isActive()) {
+				Element sp = new Element(XML_ELM_SIDEPANEL);
+				sp.addContent(reps[SIDEPANEL].toXML());
+				e.addContent(sp);
+			}
+			if(reps[TOOLTIP].isActive()) { 
+				Element tt = new Element(XML_ELM_TOOLTIP);
+				tt.addContent(reps[TOOLTIP].toXML());
+				e.addContent(tt);
+			}
+			return e;
+		}
+		
+		/**
+		 * Re-build a plugin-set based on the information in the given XML element
+		 * @param xml The XML element that contains the information to re-build the plugin-set
+		 * @return The plugin-set that is re-build based on the information in the XML element
+		 */
+		public static PluginSet fromXML(Element xml, Visualization v) throws Throwable {
+			PluginSet pr = new PluginSet(v);
+			
+			Element drawing = xml.getChild(XML_ELM_DRAWING);
+			Element tooltip = xml.getChild(XML_ELM_TOOLTIP);
+			Element sidepanel = xml.getChild(XML_ELM_SIDEPANEL);
+			if(drawing != null) 
+				pr.setPlugin(PluginManager.instanceFromXML(
+						drawing.getChild(VisualizationPlugin.XML_ELEMENT), v), DRAWING);
+			if(tooltip != null)
+				pr.setPlugin(PluginManager.instanceFromXML(
+						tooltip.getChild(VisualizationPlugin.XML_ELEMENT), v), TOOLTIP);
+			if(sidepanel != null)
+				pr.setPlugin(PluginManager.instanceFromXML(
+						sidepanel.getChild(VisualizationPlugin.XML_ELEMENT), v), SIDEPANEL);
+			return pr;
+		}
+		
+		public int hashCode() {
+			return pluginClass.hashCode();
+		}
+		public boolean equals(Object obj) {
+			if(obj instanceof PluginSet) 
+				return pluginClass.equals(((PluginSet)obj).pluginClass);
+			return false;
+		}
+	}
+}

Property changes on: trunk/src/g2d_swt/org/pathvisio/visualization/Visualization.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/visualization/VisualizationDialog.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/visualization/VisualizationDialog.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/visualization/VisualizationDialog.java	(revision 957)
@@ -0,0 +1,664 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization;
+
+import java.io.File;
+import java.util.List;
+
+import org.eclipse.jface.dialogs.IInputValidator;
+import org.eclipse.jface.dialogs.InputDialog;
+import org.eclipse.jface.dialogs.MessageDialog;
+import org.eclipse.jface.viewers.CellEditor;
+import org.eclipse.jface.viewers.CheckboxCellEditor;
+import org.eclipse.jface.viewers.ICellModifier;
+import org.eclipse.jface.viewers.ILabelProviderListener;
+import org.eclipse.jface.viewers.ISelectionChangedListener;
+import org.eclipse.jface.viewers.IStructuredContentProvider;
+import org.eclipse.jface.viewers.IStructuredSelection;
+import org.eclipse.jface.viewers.ITableLabelProvider;
+import org.eclipse.jface.viewers.LabelProvider;
+import org.eclipse.jface.viewers.ListViewer;
+import org.eclipse.jface.viewers.SelectionChangedEvent;
+import org.eclipse.jface.viewers.StructuredSelection;
+import org.eclipse.jface.viewers.TableViewer;
+import org.eclipse.jface.viewers.Viewer;
+import org.eclipse.jface.window.ApplicationWindow;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.CTabFolder;
+import org.eclipse.swt.custom.CTabItem;
+import org.eclipse.swt.custom.StackLayout;
+import org.eclipse.swt.events.ModifyEvent;
+import org.eclipse.swt.events.ModifyListener;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.events.SelectionListener;
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.layout.RowLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.FileDialog;
+import org.eclipse.swt.widgets.Group;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Shell;
+import org.eclipse.swt.widgets.Table;
+import org.eclipse.swt.widgets.TableColumn;
+import org.eclipse.swt.widgets.TableItem;
+import org.eclipse.swt.widgets.Text;
+import org.pathvisio.Engine;
+import org.pathvisio.data.Gex;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.util.TableColumnResizer;
+import org.pathvisio.util.Utils;
+import org.pathvisio.visualization.Visualization.PluginSet;
+import org.pathvisio.visualization.colorset.ColorSetComposite;
+import org.pathvisio.visualization.plugins.PluginManager;
+
+/**
+ * Dialog to configure visualizations
+ * @author thomas
+ *
+ */
+public class VisualizationDialog extends ApplicationWindow {
+	VisualizationSettings settingsComp;
+	Composite noneSelectedComp;
+	
+	StackLayout settingsStack;
+	ListViewer visList;
+	
+	Color nonGenericColor;
+	Color genericColor;
+	
+	int tabItemOnOpen = 0;
+	
+	public static final int TABITEM_VISUALIZATIONS = 0;
+	public static final int TABITEM_COLORSETS = 1;
+	final String[] tabItemNames = new String[] {
+		"Visualizations", "Color sets"	
+	};
+	final String[] columnNames = new String[] {
+			"Name", "Drawing", "Side panel", "Tooltip"
+	};
+	final String[] columnTips = new String[] {
+			"Plugin name",
+			"Show this plugin on drawing", "Show this plugin in side panel", 
+			"Show this plugin in tooltip"
+	};
+	
+	public VisualizationDialog(Shell shell) {
+		super(shell);
+		setBlockOnOpen(true);
+	}
+	
+	public boolean close() {
+		Gex.saveXML();
+		return super.close();
+	}
+	
+	public void setTabItemOnOpen(int index) {
+		tabItemOnOpen = index;
+	}
+	
+	public Control createContents(Composite parent) {
+		Shell shell = getShell();
+		shell.setSize(700, 600);
+		
+		Composite content = new Composite(parent, SWT.NULL);
+		content.setLayout(new GridLayout());
+		
+		CTabFolder tabs = new CTabFolder(content, SWT.BORDER);
+		tabs.setSimple(false);
+		tabs.setSelectionBackground(new Color[] {
+				tabs.getSelectionBackground(),
+				tabs.getDisplay().getSystemColor(SWT.COLOR_WIDGET_BACKGROUND) }, 
+				new int[] { 100 }, true);
+		CTabItem visTab = new CTabItem(tabs, SWT.NULL);
+		visTab.setControl(createVisualizationComp(tabs));
+		visTab.setText(tabItemNames[0]);
+
+		if(Gex.isConnected()) {
+			CTabItem colorTab = new CTabItem(tabs, SWT.NULL);
+			colorTab.setControl(new ColorSetComposite(tabs, SWT.NULL));
+			colorTab.setText(tabItemNames[1]);
+		}
+
+		tabs.setLayoutData(new GridData(GridData.FILL_BOTH));
+		
+		final Button ok = new Button(content, SWT.NULL);
+		ok.setText("  Ok  ");
+		ok.addSelectionListener(new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				close();
+			}
+		});
+		ok.setLayoutData(new GridData(GridData.HORIZONTAL_ALIGN_END));
+		
+		Visualization v = VisualizationManager.getCurrent();
+		if(v != null) visList.setSelection(new StructuredSelection(v));
+		
+		tabs.setSelection(tabItemOnOpen);
+		content.setFocus();
+		return tabs;
+	}
+
+	Composite createVisualizationComp(Composite parent) {
+		Composite content = new Composite(parent, SWT.NULL);
+		content.setLayout(new GridLayout(2, false));
+		
+		createVisualizationsList(content);
+		Composite rightComp = new Composite(content, SWT.NULL);
+		rightComp.setLayoutData(new GridData(GridData.FILL_BOTH));
+		
+		settingsStack = new StackLayout();
+		rightComp.setLayout(settingsStack);
+		createNoneSelectedComp(rightComp);
+		settingsComp = new VisualizationSettings(rightComp, SWT.NULL);
+		settingsStack.topControl = noneSelectedComp;
+		
+		return content;
+	}
+	
+	private void createNoneSelectedComp(Composite parent) {
+		noneSelectedComp = new Composite(parent, SWT.NULL);
+		RowLayout layout = new RowLayout(SWT.VERTICAL);
+		layout.justify = true;
+		layout.marginLeft = 30;
+		noneSelectedComp.setLayout(layout);
+		Label l = new Label(noneSelectedComp, SWT.CENTER | SWT.WRAP);
+		l.setText("No visualization selected, click 'Add' to add a visualization or select " +
+				"one from the list to configure");
+	}
+	
+	private void createVisualizationsList(Composite parent) {
+		Composite comp = new Composite(parent, SWT.NULL);
+		comp.setLayoutData(new GridData(GridData.FILL_VERTICAL));
+		comp.setLayout(new GridLayout());
+		
+		Label label = new Label(comp, SWT.CENTER);
+		label.setText("Visualizations");
+		
+		visList = new ListViewer(comp, SWT.SINGLE | SWT.BORDER);
+		visList.getList().setLayoutData(new GridData(GridData.FILL_BOTH));
+		setListProviders();
+		setListListeners();
+				
+		Composite bComp = new Composite(comp, SWT.NULL);
+		bComp.setLayout(new RowLayout(SWT.HORIZONTAL));
+		final Button add = new Button(bComp, SWT.PUSH);
+		add.setText("Add");
+		add.addSelectionListener(new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				newVisualization();
+			}
+		});
+		final Button remove = new Button(bComp, SWT.PUSH);
+		remove.setText("Remove");
+		remove.addSelectionListener(new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				removeVisualization(visList.getList().getSelectionIndex());
+			}
+		});
+		bComp.pack();
+	}
+	
+	private void setListProviders() {
+		visList.setLabelProvider(new LabelProvider() {
+			public String getText(Object element) {
+				return ((Visualization)element).getName();
+			}
+		});
+		visList.setContentProvider(new IStructuredContentProvider() {
+			public Object[] getElements(Object input) {
+				return ((List)input).toArray();
+			}
+			public void dispose() {}
+			public void inputChanged(Viewer v, Object oldInput, Object newInput) {}
+			
+		});
+		visList.setInput(VisualizationManager.getVisualizations()); 
+	}
+	
+	private void setListListeners() {
+		visList.addSelectionChangedListener(new ISelectionChangedListener() {
+			public void selectionChanged(SelectionChangedEvent e) {
+				Visualization v = getSelectedVisualization();
+				VisualizationManager.setCurrent(v);
+				showVisualizationSettings(v);
+			}
+		});
+	}
+	
+	private void showVisualizationSettings(Visualization v) {
+		if(v == null) hideVisualizationSettings();
+		settingsStack.topControl = settingsComp;
+		((Composite)settingsComp.getParent()).layout();
+		settingsComp.setInput(v);
+	}
+	
+	private void hideVisualizationSettings() {
+		settingsStack.topControl = noneSelectedComp;
+		((Composite)noneSelectedComp.getParent()).layout();
+	}
+	
+	private void newVisualization() {
+		InputDialog d = new InputDialog(getShell(), 
+				"New visualization", "Name: ",
+				VisualizationManager.getNewName(), new IInputValidator() {
+					public String isValid(String name) {
+						return VisualizationManager.nameExists(name) ? "Name already exists" : null;
+					}
+		});
+		if(d.open() == InputDialog.OK) {
+			Visualization v = new Visualization(d.getValue());
+			VisualizationManager.addVisualization(v);
+			visList.refresh();
+			visList.setSelection(new StructuredSelection(v));
+		}
+	}
+	
+	private void removeVisualization(int index) {
+		VisualizationManager.removeVisualization(index);
+		visList.refresh();
+	}
+		
+	private Visualization getSelectedVisualization() {
+		return (Visualization)
+		((IStructuredSelection)visList.getSelection()).getFirstElement();
+	}
+	
+	TableViewer pluginTable;
+	class VisualizationSettings extends Composite {		
+		Visualization input;
+		Text nameText;
+		Label description;
+		Button ttConfig, drConfig, spConfig, firstButton, upButton, downButton, lastButton;
+		
+		VisualizationSettings(Composite parent, int style) {
+			super(parent, style);
+			createContents();
+		}
+		
+		void createContents() {
+			setLayoutData(new GridData(GridData.FILL_BOTH));
+			setLayout(new GridLayout());
+			
+			createNameComposite(this);
+			Group pluginGroup = new Group(this, SWT.NULL);
+			pluginGroup.setLayout(new FillLayout());
+			pluginGroup.setLayoutData(new GridData(GridData.FILL_BOTH));
+			pluginGroup.setText("Visualization plugins");
+			createPluginComp(pluginGroup);
+		}
+		
+		void createNameComposite(Composite parent) {
+			Composite comp = new Composite(parent, SWT.NULL);
+			comp.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+			comp.setLayout(new GridLayout(2, false));
+			Label l = new Label(comp, SWT.NULL);
+			l.setText("Name: ");
+			nameText = new Text(comp, SWT.SINGLE | SWT.BORDER);
+			nameText.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+			nameText.addModifyListener(new ModifyListener() {
+				public void modifyText(ModifyEvent e) {
+					if(input != null) {
+						input.setName(nameText.getText());
+						visList.update(input, null);
+					}
+				}
+			});
+		}
+		
+		void createPluginComp(Composite parent) {
+			Composite comp = new Composite(parent, SWT.NULL);
+			comp.setLayout(new GridLayout(2, false));
+			
+			pluginTable = new TableViewer(createPluginTable(comp));
+			pluginTable.setContentProvider(new IStructuredContentProvider() {
+				public Object[] getElements(Object input) {
+					return ((Visualization)input).getPluginSets().toArray();
+				}
+				public void dispose() {}
+				public void inputChanged(Viewer arg0, Object arg1, Object arg2) {}
+			});
+			pluginTable.setLabelProvider(new PluginTableLabelProvider());
+			pluginTable.setCellModifier(new PluginTableModifier());
+			CellEditor[] editors = new CellEditor[columnNames.length];
+			editors[0] = null;
+			editors[1] = editors[2] = editors[3] = new CheckboxCellEditor();
+			pluginTable.setCellEditors(editors);
+			pluginTable.setColumnProperties(columnNames);
+			
+			pluginTable.addSelectionChangedListener(new ISelectionChangedListener() {
+				public void selectionChanged(SelectionChangedEvent event) {
+					PluginSet p = getSelectedPluginSet();
+					description.setText(p == null ? "" : p.getInstance().getDescription());
+					layout(true, true);
+					setPluginButtonsEnabled(true);
+				}
+			});
+			
+			createPluginButtonComp(comp);
+			
+			Composite descrComp = createDescriptionComp(comp);
+			GridData span = new GridData(GridData.FILL_HORIZONTAL);
+			span.horizontalSpan= 2;
+			descrComp.setLayoutData(span);
+
+			Button loadJar = new Button(comp, SWT.NULL);
+			loadJar.setText("Load plugin");
+			loadJar.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					loadPluginJar();
+				}
+			});
+		}
+		
+		Composite createDescriptionComp(Composite parent) {
+			Group group = new Group(parent, SWT.NULL);
+			group.setLayout(new FillLayout());
+			group.setText("Plugin description");
+			description = new Label(group, SWT.NULL);
+			return group;
+		}
+		
+		Composite createPluginButtonComp(Composite parent) {
+			Composite comp = new Composite(parent, SWT.NULL);
+			comp.setLayout(new RowLayout(SWT.VERTICAL));
+			
+			createPluginConfigGroup(comp);
+			
+			Group group = new Group(comp, SWT.NULL);
+			group.setText("Drawing order");
+			RowLayout rl = new RowLayout(SWT.VERTICAL);
+			rl.fill = true;
+			group.setLayout(rl);
+			firstButton = new Button(group, SWT.PUSH);
+			firstButton.setText("First");
+			firstButton.addSelectionListener(getDrawingOrderListener());
+			upButton = new Button(group, SWT.PUSH);
+			upButton.setText("Up");
+			upButton.addSelectionListener(getDrawingOrderListener());
+			downButton = new Button(group, SWT.PUSH);
+			downButton.setText("Down");
+			downButton.addSelectionListener(getDrawingOrderListener());
+			lastButton = new Button(group, SWT.PUSH);
+			lastButton.setText("Last");
+			lastButton.addSelectionListener(getDrawingOrderListener());
+			
+			setPluginButtonsEnabled(false);
+			return comp;
+		}
+		
+		Composite createPluginConfigGroup(Composite parent) {
+			Group configGroup = new Group(parent, SWT.NULL);
+			configGroup.setText("Selected plugin configuration");
+			RowLayout rl = new RowLayout(SWT.VERTICAL);
+			rl.fill = true;
+			configGroup.setLayout(rl);
+			
+			drConfig = new Button(configGroup, SWT.PUSH);
+			drConfig.setText("Drawing object...");
+			ttConfig = new Button(configGroup, SWT.PUSH);
+			ttConfig.setText("Tool tip...");
+			spConfig = new Button(configGroup, SWT.PUSH);
+			spConfig.setText("Side panel...");
+			
+			SelectionAdapter sa = new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					if		(e.widget == drConfig) 
+						openPluginConfiguration(PluginSet.DRAWING);
+					else if	(e.widget == ttConfig) 
+						openPluginConfiguration(PluginSet.TOOLTIP);
+					else if	(e.widget == spConfig) 
+						openPluginConfiguration(PluginSet.SIDEPANEL);
+					pluginTable.refresh();
+				}
+			};
+			
+			drConfig.addSelectionListener(sa);
+			ttConfig.addSelectionListener(sa);
+			spConfig.addSelectionListener(sa);
+			return configGroup;
+		}
+		
+		SelectionListener getDrawingOrderListener() {
+			return new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					Visualization v = getSelectedVisualization();
+					PluginSet ps = getSelectedPluginSet();
+					if(ps == null || v == null) return; //Shouldn't happen
+					
+					int order = 0;
+					if		(e.widget == firstButton)
+						order = Utils.ORDER_FIRST;
+					else if (e.widget == lastButton)
+						order = Utils.ORDER_LAST;
+					else if (e.widget == upButton) 
+						order = Utils.ORDER_UP;
+					else if (e.widget == downButton) 
+						order = Utils.ORDER_DOWN;
+					v.setDisplayOrder(ps, order);
+					pluginTable.refresh();
+					colorPluginTable();
+				}
+			};
+		}
+				
+		void loadPluginJar() {
+			FileDialog fd = new FileDialog(getShell());
+			fd.setFilterExtensions(new String[] { "*.jar" });
+			fd.setFilterNames(new String[] { "jar file" });
+			String jar = fd.open();
+			if(jar != null) {
+				try {
+					PluginManager.loadAdditionalPlugin(new File(jar));
+					pluginTable.refresh();
+				} catch(Throwable e) {
+					MessageDialog.openError(getShell(), "Unable to load plugin", e.toString() + "\n" + e.getMessage());
+					Engine.log.error("Unable to load plugin", e);
+				}
+			}
+		}
+		
+		void setPluginButtonsEnabled(boolean enable) {
+			
+			PluginSet ps = getSelectedPluginSet();
+		
+			setConfigButtonsEnabled(enable, ps);
+			setOrderButtonsEnabled(enable);
+		}
+		
+		void setConfigButtonsEnabled(boolean doEnable, PluginSet ps) {
+			if(ps == null) {
+				drConfig.setEnabled(false);
+				ttConfig.setEnabled(false);
+				spConfig.setEnabled(false);
+			} else {
+				doEnable = doEnable && ps.getInstance().isConfigurable();
+				drConfig.setEnabled(doEnable && ps.isDrawing());
+				ttConfig.setEnabled(doEnable && ps.isToolTip());
+				spConfig.setEnabled(doEnable && ps.isSidePanel());
+			}
+		}
+		
+		void setOrderButtonsEnabled(boolean enable) {
+			firstButton.setEnabled(enable);
+			upButton.setEnabled(enable);
+			downButton.setEnabled(enable);
+			lastButton.setEnabled(enable);
+		}
+		
+		PluginSet getSelectedPluginSet() {
+			return (PluginSet)
+				((IStructuredSelection)pluginTable.getSelection()).getFirstElement();
+		}
+		
+		void openPluginConfiguration(int representation) {
+			PluginSet ps = getSelectedPluginSet();
+			if(ps.isActive()) 
+				ps.getPlugin(representation).openConfigDialog(getShell());
+		}
+		
+		Table createPluginTable(Composite parent) {
+			Composite tableComp = new Composite(parent, SWT.NULL);
+			tableComp.setLayoutData(new GridData(GridData.FILL_BOTH));
+			tableComp.setLayout(new FillLayout());
+			Table t = new Table(tableComp, SWT.BORDER | SWT.FULL_SELECTION);
+			t.setHeaderVisible(true);
+				
+			int[] alignment = new int[] { 
+					SWT.LEFT, SWT.CENTER,
+					SWT.CENTER, SWT.CENTER, SWT.CENTER };
+			boolean[] resizable = new boolean[] { 
+					true, false,
+					false, false, false };
+			int[] width = new int[] {
+					50, 60, 60, 78, 60
+			};
+			for(int i = 0; i < columnNames.length; i++) {
+				TableColumn tc = new TableColumn(t, alignment[i]);
+				tc.setText(columnNames[i]);
+				tc.setToolTipText(columnTips[i]);
+				tc.setWidth(width[i]);
+				tc.setResizable(resizable[i]);
+			}
+				
+			t.addControlListener(new TableColumnResizer(t, tableComp));
+			return t;
+		}
+		
+		void setInput(Visualization v) { 
+			input = v;
+			refresh();
+		}
+		
+		void refresh() {
+			if(input != null) {
+				nameText.setText(input.getName());
+				pluginTable.setInput(input);
+				colorPluginTable();
+			} else {
+				nameText.setText("");
+				pluginTable.setInput(null);
+				hideVisualizationSettings();
+			}
+		}
+		
+	}
+	
+	void colorPluginTable() {
+		if(genericColor == null) 
+			genericColor = pluginTable.getTable().getBackground();
+		if(nonGenericColor == null) 
+			nonGenericColor = pluginTable.getTable().getDisplay().getSystemColor(
+					SWT.COLOR_INFO_BACKGROUND);
+		for(TableItem ti : pluginTable.getTable().getItems()) {			
+			PluginSet ps = (PluginSet)ti.getData();
+			ti.setBackground(ps.isGeneric() ? genericColor : nonGenericColor);
+		}
+	}
+	
+	class PluginTableLabelProvider implements ITableLabelProvider {
+		final Image checkTrue = SwtEngine.getImageRegistry().get("checkbox.checked");
+		final Image checkFalse = SwtEngine.getImageRegistry().get("checkbox.unchecked");
+		final Image checkUnavailable = SwtEngine.getImageRegistry().get("checkbox.unavailable");
+		
+		public String getColumnText(Object element, int columnIndex) {
+			PluginSet ps = (PluginSet)element;
+			
+			if(columnIndex == 0) return ps.getInstance().getName();
+			return null;
+		}
+
+		public Image getColumnImage(Object element, int columnIndex) {
+			PluginSet ps = (PluginSet)element;
+			
+			switch(columnIndex) {
+			case 1: 
+				if(ps.getInstance().canDrawing())
+					return ps.isDrawing() ? checkTrue : checkFalse;
+				else return checkUnavailable;
+			case 2: 
+				if(ps.getInstance().canSidePanel()) 
+					return ps.isSidePanel() ? checkTrue : checkFalse;
+				else return checkUnavailable;
+			case 3: 
+				if(ps.getInstance().canToolTip())
+					return ps.isToolTip() ? checkTrue : checkFalse;
+				else return checkUnavailable;
+			default: return null; 
+			}
+		}
+		
+		public void addListener(ILabelProviderListener arg0) { }
+		
+		public void dispose() {	}
+		public boolean isLabelProperty(Object arg0, String arg1) { return false; }
+		public void removeListener(ILabelProviderListener arg0) { }		
+	}
+	
+	class PluginTableModifier implements ICellModifier {
+		public boolean canModify(Object element, String property) {
+			PluginSet ps = (PluginSet)element;
+			int index = getColumnIndex(property);
+			switch(index) {
+			case 0: return false;
+			case 1: return ps.getInstance().canDrawing();
+			case 2: return ps.getInstance().canSidePanel();
+			case 3: return ps.getInstance().canToolTip();
+			default: return false;
+			}
+		}
+
+		public Object getValue(Object element, String property) {
+			PluginSet ps = (PluginSet)element;
+			int index = getColumnIndex(property);
+			switch(index) {
+			case 0: return ps.getInstance().getName();
+			case 1: return ps.isDrawing();
+			case 2: return ps.isSidePanel();
+			case 3: return ps.isToolTip();
+			default: return null; //Shouldn't happen
+			}
+		}
+
+		public void modify(Object element, String property, Object value) {
+			int index = getColumnIndex(property);
+			TableItem ti = (TableItem) element;
+			PluginSet ps = (PluginSet) ti.getData();
+
+			switch(index) {
+			case 1: ps.setActive(PluginSet.DRAWING, (Boolean)value); break;
+			case 2: ps.setActive(PluginSet.SIDEPANEL, (Boolean)value); break;
+			case 3: ps.setActive(PluginSet.TOOLTIP, (Boolean)value); break;
+			}
+			
+			pluginTable.refresh();
+		}
+	}
+	
+	int getColumnIndex(String property) {
+		for(int i = 0; i < columnNames.length; i++) 
+			if(columnNames[i].equals(property)) return i;
+		return -1;
+	}
+
+}

Property changes on: trunk/src/g2d_swt/org/pathvisio/visualization/VisualizationDialog.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/visualization/plugins/VisualizationPlugin.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/visualization/plugins/VisualizationPlugin.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/visualization/plugins/VisualizationPlugin.java	(revision 957)
@@ -0,0 +1,355 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.plugins;
+
+import java.awt.Graphics2D;
+import java.util.Collection;
+
+import org.eclipse.jface.window.ApplicationWindow;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Shell;
+import org.jdom.Element;
+import org.pathvisio.view.Graphics;
+import org.pathvisio.visualization.Visualization;
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+
+/**
+ * The VisualizationPlugin class can be extended to create a visualization plugin for
+ * the visualization of experimental data on GPML pathways
+ * @author Thomas
+ */
+public abstract class VisualizationPlugin implements Comparable {
+	public static String XML_ELEMENT = "plugin";
+	public static String XML_ATTR_CLASS = "class";
+	
+	protected static final int SIDEPANEL = 2;
+	protected static final int TOOLTIP = 4;
+	protected static final int DRAWING = 8;
+	
+	private int DISPLAY_OPT; //Where on the display cann this plugin be used (SIDEPANEL | TOOLTIP | DRAWING)
+	private boolean CONFIGURABLE; //Configurable (if true, override createConfigComposite)
+	private boolean GENERIC; //For generic use, or expression dataset specific
+	private boolean USE_PROVIDED_AREA; //Does this plugin use reserved region in GmmlGraphicsObject
+	
+	private boolean isActive;
+		
+	private Visualization visualization;
+	
+	/**
+	 * Constructor for this class. Create an instance of this {@link VisualizationPlugin}
+	 * @param v The {@link Visualization} the instance is part of
+	 */
+	public VisualizationPlugin(Visualization v) {
+		visualization = v;
+	}
+	
+	/**
+	 * Get the {@link Visualization} this instance belongs to
+	 * @return The {@link Visualization} this plugin belongs to
+	 */
+	protected final Visualization getVisualization() { return visualization; }
+	
+	/**
+	 * Gets the name of this visualization plugin class
+	 * @return the name of this visualization plugin class
+	 */
+	public abstract String getName();
+	
+	/**
+	 * Gets the description of this visualization plugin class
+	 * @return the description of this visualization plugin class
+	 */
+	public abstract String getDescription();
+	
+	//TODO: Update javadoc
+	/**
+	 * Create a visualization on the pathway drawing for the given {@link Graphics} object.
+	 * This method will only be called when the plugin display options contains {@link VisualizationPlugin#DRAWING}.
+	 * @param g	The {@link Graphics} object on which the visualization applies
+	 * @param e	{@link PaintEvent} containing information about the paint
+	 * @param gc Graphical context on which drawing operations can be performed
+	 * @see <a href=http://www.eclipse.org/articles/Article-SWT-graphics/SWT_graphics.html>
+	 * Introduction in SWT graphics</a>
+	 */
+	public abstract void visualizeOnDrawing(Graphics g, Graphics2D g2d);
+	
+	/**
+	 * Create a visualization on the side panel for the given {@link Graphics} objects
+	 * This method will only be called when the plugin display options contains {@link VisualizationPlugin#SIDEPANEL}.
+	 * @param objects List of {@link Graphics} objects to create the visualization for
+	 */
+	public abstract void visualizeOnSidePanel(Collection<Graphics> objects);
+	
+	/**
+	 * Create a visualization on the Tool Tip for the given {@link Graphics} object.
+	 * This method will only be called when the plugin display options contains {@link VisualizationPlugin#TOOLTIP}.
+	 * @param parent The parent of the {@link Composite} that will be displayed on the Tool Tip
+	 * @param g The {@link Graphics} object to create the visualization for
+	 * @return A {@link Composite} that will be displayed in the Tool Tip
+	 */
+	public abstract Composite visualizeOnToolTip(Composite parent, Graphics g);
+	
+	/**
+	 * Initialize a Composite for visualization on the side panel
+	 * This method will only be called when the plugin display options contains {@link VisualizationPlugin#SIDEPANEL}.
+	 * @param parent The parent of the new {@link Composite}
+	 */
+	public abstract void initSidePanel(Composite parent);
+	
+	/**
+	 * Create a {@link Composite} that is displayed in the legend for every plug-in that is
+	 * activated on the pathway drawing.
+	 * This method may be overridden if the plug-in needs to show a legend item when it is
+	 * active on the pathway drawing.
+	 * @param parent The parent of the new {@link Composite} to return
+	 * @return A {@link Composite} that displays the legend information for this plug-in
+	 */
+	public Composite createLegendComposite(Composite parent) {
+		return null;
+	}
+	
+	/**
+	 * Create a {@link Composite} that can be used to configure this visualization plugin
+	 * Override this method when the visualization plugin can be configured by the user
+	 * @see  VisualizationPlugin#isConfigurable() VisualizationPlugin#openConfigDialog(Shell)
+	 * @param parent The parent of the {@link Composite} to create
+	 * @return A {@link Composite} that will be displayed when the user wants to configure the plugin
+	 */
+	protected Composite createConfigComposite(Composite parent) {
+		return new Composite(parent, SWT.NULL); //Empty composite
+	}
+	
+	/**
+	 * Opens the configuration dialog (only when isConfigurable returnst true) that
+	 * will display the {@link Composite} created in {@link VisualizationPlugin#createConfigComposite(Composite)}.
+	 * @param shell The parent {@link Shell} of the dialog to open
+	 */
+	public final void openConfigDialog(Shell shell) {
+		if(!CONFIGURABLE) return; //Not configurable, so don't open config dialog
+		ApplicationWindow d = new ConfigurationDialog(shell);
+		d.open();
+	}
+	
+	
+	/**
+	 * Save the configuration of the current instance of this class to an XML element.<br>
+	 * Override this method to save custom configuration settings:<br>
+	 * <code>
+	 * public Element toXML() {								<br>
+	 * &nbsp;Element elm = super.toXML();					<br>
+	 * &nbsp;//Add custom attributes and elements to elm, e.g.:	<br>
+	 * &nbsp;elm.setAttribute("fontsize", fontsize)			<br>
+	 * <br>
+	 * &nbsp;return elm;									<br>
+	 * }
+	 * </code>
+	 */
+	public Element toXML() {
+		Element elm = new Element(XML_ELEMENT);
+		elm.setAttribute(XML_ATTR_CLASS, getClass().getCanonicalName());
+		return elm;
+	}
+	
+	/**
+	 * Load the configuration of the current instance of this class from an XML element.<br>
+	 * Override this method to load custom configuration settings:<br>
+	 * <code>
+	 * public Element loadXML(Element xml) {				<br>
+	 * &nbsp;super.loadXML(xml)								<br>
+	 * &nbsp;//Load custom attributes and elements to elm, e.g.:	<br>
+	 * &nbsp;fontSize = xml.getAttributeValue("fontsize")			<br>
+	 * }
+	 * </code>
+	 * @param xml The {@link Element} that contains the configuration for this plugin
+	 */
+	public void loadXML(Element xml) { }
+	
+	/**
+	 * Returns whether the current instance of this visualization plugin is activated or not
+	 * @return true if this instance is activated, false otherwise
+	 */
+	public final boolean isActive() { return isActive; }
+	
+	/**
+	 * Set the activation state of this instance. If set to active, the visualization methods
+	 * of this plugin will be called from the {@link Visualization} this instance belongs to.
+	 * @param active true to activate this instance, false to de-activate
+	 */
+	public final void setActive(boolean active) { 
+		if(isActive != active) {
+			isActive = active;
+			fireModifiedEvent();
+		}	
+	}
+	
+	/**
+	 * Returns whether this plugin can be displayed in the side panel
+	 * @return true when this plugin can be displayed in the side panel, false otherwise
+	 */
+	public final boolean canSidePanel() { return (DISPLAY_OPT & SIDEPANEL) != 0; }
+	
+	/**
+	 * Returns whether this plugin can be displayed in the Tool Tip
+	 * @return true when this plugin can be displayed in the Tool Tip, false otherwise
+	 */
+	public final boolean canToolTip() { return (DISPLAY_OPT & TOOLTIP) != 0; }
+	
+	/**
+	 * Returns whether this plugin can be displayed in the pathway drawing
+	 * @return true when this plugin can be displayed in the pathway drawing, false otherwise
+	 */
+	public final boolean canDrawing() { return (DISPLAY_OPT & DRAWING) != 0; }
+	
+	/**
+	 * Specify where this plugin can be displayed.
+	 * One of:<BR><UL>
+	 * <LI><CODE>DRAWING</CODE>: this plugin implements visualization on drawing objects
+	 * <LI><CODE>TOOLTIP</CODE>: this plugins implements visualization in the tooltip showed
+	 * when hovering over GeneProducts
+	 * <LI><CODE>SIDEPANEL</CODE>: this plugin implements visualization to be displayed in the side panel
+	 * </UL><BR>
+	 * When multiple visualization options are implemented, 
+	 * use bitwise OR (e.g. <CODE>SIDEPANEL | DRAWING</CODE>)
+	 * @param options
+	 */
+	protected void setDisplayOptions(int options) {
+		DISPLAY_OPT = options;
+	}
+	
+	/**
+	 * Specify whether the parent {@link Visualization} needs to provide an area on the 
+	 * {@link Graphics} objects.
+	 * When multiple visualization plugins apply visualizations on the same {@link Graphics}
+	 * object, the available space will be divided over the plugins for which this method is called
+	 * with true as argument.
+	 * The provided area can be obtained by calling {@link Visualization#provideDrawArea(VisualizationPlugin, Graphics)}
+	 * @param use	true if this plugin uses the provided area, false if not
+	 * @see Visualization#provideDrawArea(VisualizationPlugin, Graphics)
+	 */
+	protected void setUseProvidedArea(boolean use) {
+		USE_PROVIDED_AREA = use;
+	}
+	
+	/**
+	 * Specify whether this visualization plugin is configurable or not.
+	 * When the plugin is set to be configurable, override {@link VisualizationPlugin#createConfigComposite(Composite)}.
+	 * @param configurable
+	 * @see VisualizationPlugin#createConfigComposite(Composite)
+	 */
+	protected void setIsConfigurable(boolean configurable) {
+		CONFIGURABLE = configurable;
+	}
+	
+	/**
+	 * Specify whether this visualization plugin is generic or not.
+	 * Generic plugins are independent of expression data. Non-generic plugin configurations
+	 * depend on an expression dataset and will be loaded/saved together with this expression dataset.
+	 * @param generic true if this plugin is generic, false otherwise
+	 */
+	protected void setIsGeneric(boolean generic) {
+		GENERIC = generic;
+	}
+	
+	/**
+	 * Returns whether this visualiazation plugin is generic or not
+	 * Generic plugins are independent of expression data. Non-generic plugin configurations
+	 * depend on an expression dataset and will be loaded/saved together with this expression dataset.
+	 * @see VisualizationPlugin#setIsGeneric(boolean)
+	 * @return true if this plugin is generic, false otherwise
+	 */
+	public final boolean isGeneric() { return GENERIC; }
+	
+	/**
+	 * Returns whether this visualization plugin is configurable or not
+	 * @see VisualizationPlugin#setIsConfigurable(boolean)
+	 * @return true if this plugin is configurable, false otherwise
+	 */
+	public final boolean isConfigurable() { return CONFIGURABLE; }
+	
+	/**
+	 * Returns whether this visualization plugin uses the area provided by
+	 * the {@link Visualization} it belongs to.
+	 * @see VisualizationPlugin#setUseProvidedArea(boolean)
+	 * @return true if this plugin uses the provided area, false otherwise
+	 */
+	public final boolean isUseProvidedArea() { 
+		return USE_PROVIDED_AREA; 
+	}
+		
+	/**
+	 * Fire a {@link VisualizationEvent} with type {@link VisualizationEvent#PLUGIN_MODIFIED}
+	 */
+	protected final void fireModifiedEvent() {
+		VisualizationManager.fireVisualizationEvent(
+				new VisualizationEvent(this, VisualizationEvent.PLUGIN_MODIFIED));
+	}
+	
+	/**
+	 * The configuration dialog that displays the configuration settings for a 
+	 * visualization plugin
+	 * @author Thomas
+	 */
+	private class ConfigurationDialog extends ApplicationWindow {
+		public ConfigurationDialog(Shell shell) {
+			super(shell);
+			setBlockOnOpen(true);
+		}
+		
+		public Control createContents(Composite parent) {
+			Composite contents = new Composite(parent, SWT.NULL);
+			contents.setLayout(new GridLayout());
+			
+			Composite config = createConfigComposite(contents);
+			config.setLayoutData(new GridData(GridData.FILL_BOTH));
+			
+			Composite buttonComp = createButtonComposite(contents);
+			buttonComp.setLayoutData(new GridData(GridData.HORIZONTAL_ALIGN_END));
+			
+			return contents;
+		}
+		
+		public Composite createButtonComposite(Composite parent) {
+			Composite comp = new Composite(parent, SWT.NULL);
+			comp.setLayout(new GridLayout(2, false));
+			
+			Button ok = new Button(comp, SWT.PUSH);
+			ok.setText(" Ok ");
+			ok.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent arg0) {
+					close();
+				}
+			});
+			
+			return comp;
+		}
+	}
+	
+	public int compareTo(Object o) {
+		if(o instanceof VisualizationPlugin)
+			return getName().compareTo(((VisualizationPlugin)o).getName());
+		return -1;
+	}
+}

Property changes on: trunk/src/g2d_swt/org/pathvisio/visualization/plugins/VisualizationPlugin.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/visualization/plugins/PluginManager.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/visualization/plugins/PluginManager.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/visualization/plugins/PluginManager.java	(revision 957)
@@ -0,0 +1,326 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.plugins;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.FilenameFilter;
+import java.io.IOException;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Modifier;
+import java.net.JarURLConnection;
+import java.net.URL;
+import java.net.URLDecoder;
+import java.util.Enumeration;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.jar.JarFile;
+import java.util.zip.ZipEntry;
+
+import org.jdom.Document;
+import org.jdom.Element;
+import org.jdom.input.SAXBuilder;
+import org.jdom.output.Format;
+import org.jdom.output.XMLOutputter;
+import org.pathvisio.Engine;
+import org.pathvisio.data.Gex;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.util.Utils;
+import org.pathvisio.visualization.Visualization;
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+
+public abstract class PluginManager {
+	//static final String PLUGIN_PKG = "org.pathvisio.visualization.plugins";
+	//static final String PKG_DIR = PLUGIN_PKG.replace('.', '/');
+	static final String FILE_ADD_PLUGINS = "visplugins.xml";
+	static final String XML_ELEMENT = "additional-plugins";
+	static final String XML_ELM_PLUGIN = "plugin";
+	static final String XML_ATTR_URL = "url";
+	
+	static Document addDoc;
+	static final Set<Class> plugins = new LinkedHashSet<Class>();
+	
+	public static VisualizationPlugin getInstance(Class pluginClass, Visualization v) throws Throwable {
+		Constructor c = pluginClass.getConstructor(new Class[] { Visualization.class });
+		return (VisualizationPlugin)c.newInstance(new Object[] { v });
+	}
+		
+	public static VisualizationPlugin instanceFromXML(Element xml, Visualization v) throws Throwable {
+		String className = xml.getAttributeValue(VisualizationPlugin.XML_ATTR_CLASS);
+		
+		if(className == null) throw new IllegalArgumentException(
+				"Element has no '" + VisualizationPlugin.XML_ATTR_CLASS + "' attribute");
+		
+		Class pluginClass = Class.forName(className);
+		VisualizationPlugin p = getInstance(pluginClass, v);
+		p.loadXML(xml);
+		return p;
+	}
+	
+	public static Class[] getPlugins() {
+		return Gex.isConnected() ?
+				plugins.toArray(new Class[plugins.size()]) :
+				getGenericPlugins();
+	}
+	
+	public static Class[] getGenericPlugins() {
+		Set<Class> generic = new LinkedHashSet<Class>();
+		for(Class pc : plugins) {
+			if(isGeneric(pc)) generic.add(pc);
+		}
+		return generic.toArray(new Class[generic.size()]);
+	}
+	
+	public static boolean isGeneric(Class pluginClass) {
+		try {
+			return getInstance(pluginClass, null).isGeneric();
+		} catch(Throwable e) { 
+			e.printStackTrace();
+			Engine.log.error("Unable to determine if plugin is generic", e);
+			return false; 
+		}
+	}
+	
+	public static String[] getPluginNames() {
+		String[] names = new String[plugins.size()];
+		int i = 0;
+		for(Class p : plugins) {
+			names[i++] = getPluginName(p);
+		}
+		return names;
+	}
+	
+	public static String getPluginName(Class pluginClass) {
+		try {
+			VisualizationPlugin p = getInstance(pluginClass, null);
+			return p.getName();
+		} catch(Throwable e) {
+			Engine.log.error("Unable to get plugin name for " + pluginClass, e);
+			return pluginClass.getName();
+		}
+	}
+
+	public static void loadPlugins() throws Throwable {	
+		Engine.log.trace("> Loading visualization plugins");
+		Enumeration<URL> resources = 
+			SwtEngine.class.getClassLoader().getResources(".");
+        while (resources.hasMoreElements()) {
+        	URL url = resources.nextElement();
+        	Engine.log.trace("visualization.plugins package found in: " + url);
+        	try {
+        		loadPlugin(url);
+        	} catch(Throwable e) {
+        		Engine.log.error("Error when loading plugins from " + url, e);
+        	}
+        }
+        loadAdditional();
+  	}
+	    
+	static void loadPlugin(File f) throws Throwable {
+			loadPlugin(f.toURL());
+	}
+	
+	public static void loadAdditionalPlugin(File file) throws Throwable {
+		loadPlugin(file);
+		saveAdditional(file.toURL());
+		VisualizationManager.fireVisualizationEvent(
+				new VisualizationEvent(PluginManager.class, VisualizationEvent.PLUGIN_ADDED));
+	}
+		
+	static void loadPlugin(URL url) throws Throwable {
+    	if(url.getProtocol().equals("jar")) {
+    		loadFromJar(url);
+    	} else if(url.getProtocol().equals("file")) {
+    		File f = new File(url.getFile());
+    		if(f.getName().endsWith(".jar")) 
+    			loadFromJar(url);
+    		else loadFromDir(url);
+    	}
+		else Engine.log.error("Unable to load additional plugin", new Exception("Unsupported URL protocol"));
+	}
+	
+	static Document getAdditionalXML() {
+		if(addDoc == null) {
+			File f = new File(SwtEngine.getApplicationDir(), FILE_ADD_PLUGINS);
+			if(!f.exists()) {
+				return createXML();
+			} else {
+				SAXBuilder parser = new SAXBuilder();
+				try {
+					Document doc = parser.build(f);
+					return doc;
+				} catch(Exception e) {
+					Engine.log.error("Unable to load additional plugins file", e);
+					return createXML();
+				}
+			}
+		} else return addDoc;
+		
+	}
+	
+	static Document createXML() {
+		Document doc = new Document();
+		doc.setRootElement(new Element(XML_ELEMENT));
+		return doc;
+	}
+
+	static void loadAdditional() {
+		Document doc = getAdditionalXML();
+		Element root = doc.getRootElement();
+		for(Object o : root.getChildren(XML_ELM_PLUGIN)) {
+			URL url = null;
+			try {
+				url = new URL(((Element)o).getAttributeValue(XML_ATTR_URL));
+				loadPlugin(new File(url.getFile()));
+			} catch(Throwable ex) {
+				Engine.log.error("Unable to load additional plugin", ex);
+				if(url != null) removeAdditional(url);
+			}
+		}
+	}
+	
+	static void saveAdditional(URL url) {
+		Document doc = getAdditionalXML();
+		Element root = doc.getRootElement();
+		
+		if(containsElement(root, url)) return;
+		
+		Element elm = new Element(XML_ELM_PLUGIN);
+		elm.setAttribute(XML_ATTR_URL, url.toString());
+		root.addContent(elm);
+		saveXML(doc);
+	}
+	
+	static void removeAdditional(URL url) {
+		Document doc = getAdditionalXML();
+		Element root = doc.getRootElement();
+		
+		Element toRemove = null;
+		for(Object o : root.getChildren(XML_ELM_PLUGIN)) {
+			Element e = (Element) o;
+			String url1 = e.getAttributeValue(XML_ATTR_URL);
+			if(url1.equals(url.toString())) {
+				toRemove = e;
+				break;
+			}
+		}
+		root.removeContent(toRemove);
+		saveXML(doc);
+	}
+	
+	static void saveXML(Document doc) {
+		XMLOutputter out = new XMLOutputter(Format.getPrettyFormat());
+		try {
+			FileWriter fw = new FileWriter(new File(SwtEngine.getApplicationDir(), FILE_ADD_PLUGINS));
+			out.output(doc, fw);
+			fw.close();
+		} catch(IOException e) {
+			Engine.log.error("Unable to save additional plugins", e);
+		}
+	}
+	
+	static boolean containsElement(Element root, URL url) {
+		for(Object o : root.getChildren(XML_ELM_PLUGIN)) {
+			String url1 = ((Element)o).getAttributeValue(XML_ATTR_URL);
+			if(url1.equals(url.toString())) return true;
+		}
+		return false;
+	}
+	
+	static void loadFromDir(URL url) throws Throwable {
+		Engine.log.trace("\tLoading from directory " + url);
+		File directory = new File(URLDecoder.decode(url.getPath(), "UTF-8"));
+		if (directory.exists()) {
+           processFile(directory, directory.toString());
+        }
+	}
+	
+	static private void processFile(File f, String base) throws Throwable {
+		if(f.isDirectory()) {
+			File[] files = f.listFiles();
+            for (File file : files)
+            	processFile(file, base);
+		} else {
+			String fn = f.toString();
+			if(fn.endsWith(".class") && !fn.contains("$")) { //Ignore inner classes for now
+				String cn = fn.substring(base.length() + 1);
+				cn = removeClassExt(cn.replace('/', '.'));
+				addPlugin(Class.forName(cn, false, SwtEngine.class.getClassLoader()));
+			}
+		}
+	}
+	static void loadFromJar(URL url) throws Throwable {
+		Engine.log.trace("\tLoading from jar connection " + url);
+		JarFile f = null;
+		if(url.getProtocol().equals("jar")) {
+			JarURLConnection conn = (JarURLConnection)url.openConnection();
+			f = conn.getJarFile();
+		} else {
+			f = new JarFile(url.getFile());
+		}
+		loadFromJar(f);
+	}
+		
+	static void loadFromJar(JarFile jfile) throws Throwable {
+		Throwable error = null;
+		Engine.log.trace("\tLoading from jar file " + jfile);
+		Enumeration e = jfile.entries();
+		while (e.hasMoreElements()) {
+			ZipEntry entry = (ZipEntry)e.nextElement();
+			Engine.log.trace("Checking " + entry);
+			String entryname = entry.getName();
+			if(entryname.endsWith(".class")) {
+				try {
+					String cn = removeClassExt(entryname.replace('/', '.').replace('$', '.'));
+					Class pluginClass = Class.forName(cn);
+					addPlugin(pluginClass);
+				} catch(Throwable ex) {
+					Engine.log.error("Unable to load plugin", ex);
+					error = ex;
+				}
+			}
+		}
+		if(error != null) throw error;
+	}
+	
+	static String removeClassExt(String fn) {
+		return fn.substring(0, fn.length() - 6);
+	}
+	
+	static void addPlugin(Class c) {
+		Engine.log.trace("\t\tTrying to add " + c);
+		if(isPlugin(c)) {
+			Engine.log.trace("\t\t\t!> Adding " + c);
+			plugins.add(c);
+		}
+	}
+	
+	static boolean isPlugin(Class c) {
+		if(Modifier.isAbstract(c.getModifiers())) {
+			Engine.log.trace("\t\t> Class " + c + " is not a visualization plugin (is abstract)");
+			return false;
+		}
+		return Utils.isSubClass(c, VisualizationPlugin.class);
+	}
+			
+	static  FilenameFilter classFilter = new FilenameFilter() {
+		public boolean accept(File f, String name) {
+			return name.endsWith(".class");
+		}
+    };
+}

Property changes on: trunk/src/g2d_swt/org/pathvisio/visualization/plugins/PluginManager.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorSetObject.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorSetObject.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorSetObject.java	(revision 957)
@@ -0,0 +1,166 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.colorset;
+import java.util.HashMap;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.ModifyEvent;
+import org.eclipse.swt.events.ModifyListener;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Text;
+import org.jdom.Element;
+import java.awt.Color;
+
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+
+/**
+ * This class represent any object that can be present in a colorset
+ * e.g. a gradient or boolean expression.
+ */
+public abstract class ColorSetObject {
+	
+	/**
+	 * The parent colorset, that this colorSetObject is a part of.
+	 */
+	private ColorSet parent;
+	
+	/**
+	 * The display name of this colorSetObject
+	 */
+	private String name;
+	
+	/**
+	 * getter for name, the name of this colorSetObject
+	 */
+	public void setName(String _name) 
+	{
+		this.name = _name; 
+	}
+	
+	/**
+	 * setter for name, the name of this colorSetObject
+	 */
+	public String getName() { return name; }
+	
+	public ColorSet getColorSet() { return parent; }
+	
+	/**
+	 * Constructor for this class
+	 * @param parent 		colorset this gradient belongs to
+	 * @param name 			name of the gradient
+	 */
+	public ColorSetObject(ColorSet parent, String name) 
+	{	
+		this.parent = parent;
+		this.name = name;
+	}
+	
+	public ColorSetObject(ColorSet parent, Element xml) {
+		this.parent = parent;
+		loadXML(xml);
+	}
+				
+	/**
+	 * get the color defined by the colorset object for the given data
+	 * @param data {@link HashMap}<Integer, Object> containing data (String or double) for every sampleId 
+	 * @param sample id of the sample that is visualized using this color
+	 * @return {@link RGB} with the color returned by the colorset object after evaluating the input data,
+	 * null if the input data doesn't result in a valid color
+	 * @throws Exception 
+	 */
+	abstract Color getColor(HashMap<Integer, Object> data, int idSample) throws Exception;
+	
+	/**
+	 * Returns the parent colorset
+	 */
+	public ColorSet getParent()
+	{
+		return parent;
+	}
+
+	protected void fireModifiedEvent() {
+		VisualizationManager.fireVisualizationEvent(
+				new VisualizationEvent(this, VisualizationEvent.COLORSET_MODIFIED));
+	}
+	
+	abstract String getXmlElementName();
+	
+	static final String XML_ATTR_NAME = "name";
+	
+	public Element toXML() {
+		Element elm = new Element(getXmlElementName());
+		elm.setAttribute(XML_ATTR_NAME, name);
+		return elm;
+	}
+	
+	protected void loadXML(Element xml) {
+		name = xml.getAttributeValue(XML_ATTR_NAME);
+	}
+				
+	public static abstract class ConfigComposite extends Composite {
+		final int colorLabelSize = 15;
+		ColorSetObject input;
+		Text nameText;
+		
+		public ConfigComposite(Composite parent, int style) {
+			super(parent, style);
+			createContents();
+		}
+		
+		public void setInput(ColorSetObject input) {
+			this.input = input;
+			refresh();
+		}
+		
+		public boolean save() {
+			return true;
+		}
+		
+		void refresh() {
+			String nm = "";
+			if(input != null) nm = input.getName();
+			nameText.setText(nm);
+		}
+				
+		void changeName(String name) {
+			input.setName(name);
+		}
+		
+		abstract void createContents();
+		
+		protected Composite createNameComposite(Composite parent) {
+			Composite comp = new Composite(parent, SWT.NULL);
+			comp.setLayout(new GridLayout(2, false));
+			
+			Label nameLabel = new Label(comp, SWT.CENTER);
+			nameLabel.setText("Name:");
+		
+			nameText = new Text(comp, SWT.SINGLE | SWT.BORDER);
+			nameText.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+		    nameText.addModifyListener(new ModifyListener() {
+		    	public void modifyText(ModifyEvent e) {
+		    		changeName(nameText.getText());
+		    	}
+		    });
+		    return comp;
+		}
+	}
+}

Property changes on: trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorSetObject.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/visualization/colorset/CriterionComposite.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/visualization/colorset/CriterionComposite.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/visualization/colorset/CriterionComposite.java	(revision 957)
@@ -0,0 +1,170 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.colorset;
+
+import java.sql.Types;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.ModifyEvent;
+import org.eclipse.swt.events.ModifyListener;
+import org.eclipse.swt.events.MouseAdapter;
+import org.eclipse.swt.events.MouseEvent;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.layout.RowLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Group;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.List;
+import org.eclipse.swt.widgets.Text;
+import org.pathvisio.data.Gex;
+
+public class CriterionComposite extends Composite {
+	ErrorArea errorArea;
+	Criterion criterion;
+	List symbolList;
+	Text exprText;
+	
+	public CriterionComposite(Composite parent, Criterion criterion) {
+		super(parent, SWT.NULL);
+		this.criterion = criterion;
+		createContents();
+	}
+	
+	public void setAvailableSymbols(String[] symbols) {
+		symbolList.setItems(symbols);
+	}
+	
+	public void fetchSymbolsFromGex() {
+		if(Gex.isConnected()) {
+			java.util.List<String> numSmp = Gex.getSampleNames(Types.REAL);
+			symbolList.setItems(numSmp.toArray(new String[numSmp.size()]));	
+		} else {
+			symbolList.setItems(new String[] {});
+		}
+	}
+	
+	void setExpression(String expression) {
+		if(criterion != null) {
+			criterion.setExpression(expression, symbolList.getItems());
+			Exception e = criterion.getParseException();
+			if(e == null) {
+				errorArea.setErrorMessage(null);
+			} else if(expression.equals("")) {
+				errorArea.setWarningMessage("Please specify a boolean expression");
+			} else {
+				errorArea.setErrorMessage(
+						"Invalid boolean expression: " + e.getMessage());
+				e.printStackTrace();
+			}
+		}
+	}
+	
+	public void setInput(Criterion input) {
+		criterion = input;
+		refresh();
+	}
+	
+	public Criterion getCriterion() { return criterion; }
+	
+	public void refresh() {
+		if(criterion == null) exprText.setText("");
+		else exprText.setText(criterion.getExpression());
+	}
+	
+	protected void createContents() {
+		setLayout(new GridLayout());
+		
+		errorArea = new ErrorArea(this, SWT.NULL);
+		
+		Group criterionGroup = new Group(this, SWT.SHADOW_IN);
+		criterionGroup.setLayoutData(new GridData(GridData.FILL_BOTH));
+	    criterionGroup.setLayout(new GridLayout(2, false));
+	    
+	    Label expressionLabel = new Label(criterionGroup, SWT.CENTER);
+	    expressionLabel.setText("Boolean expression:");
+	    exprText = new Text(criterionGroup, SWT.SINGLE | SWT.BORDER);
+	    exprText.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+
+	    Label opsLabel = new Label(criterionGroup, SWT.CENTER);
+	    opsLabel.setText("Operators:");
+	    Label sampleLabel = new Label(criterionGroup, SWT.CENTER);
+	    sampleLabel.setText("Samples:");
+
+	    final List opsList = new List
+		(criterionGroup, SWT.SINGLE | SWT.BORDER | SWT.V_SCROLL | SWT.H_SCROLL);
+	    opsList.setLayoutData(new GridData(GridData.FILL_VERTICAL));
+	    opsList.setItems(Criterion.tokens);
+	    opsList.addMouseListener(new MouseAdapter() {
+	    	public void mouseDoubleClick(MouseEvent e) {
+	    		String[] selection = opsList.getSelection();
+	    		if(selection != null && selection.length > 0) exprText.insert(" " + selection[0] + " ");
+	    	}
+	    });
+	    
+	    symbolList = new List
+	    	(criterionGroup, SWT.SINGLE | SWT.BORDER | SWT.V_SCROLL | SWT.H_SCROLL);
+	    symbolList.setLayoutData(new GridData(GridData.FILL_BOTH));
+	    symbolList.addMouseListener(new MouseAdapter() {
+	    	public void mouseDoubleClick(MouseEvent e) {
+	    		String[] selection = symbolList.getSelection();
+	    		if(selection != null && selection.length > 0)
+	    			exprText.insert(" [" + selection[0] + "] ");
+	    	}
+	    });
+	    	    
+	    exprText.addModifyListener(new ModifyListener() {
+			public void modifyText(ModifyEvent e) {
+				setExpression(exprText.getText());
+			}
+	    });
+	}
+	
+	class ErrorArea extends Composite {
+		Label errorImage;
+		Label errorText;
+		
+		public ErrorArea(Composite parent, int style) {
+			super(parent, style);
+			setLayout(new RowLayout());
+			errorImage = new Label(this, SWT.NULL);
+			errorText = new Label(this, SWT.WRAP | SWT.CENTER);
+		}
+		
+		public void setErrorMessage(String error) {
+			if(error == null) {
+				errorImage.setImage(null);
+				errorText.setText("");
+			} else {
+				errorImage.setImage(getDisplay().getSystemImage(SWT.ICON_ERROR));
+				errorText.setText(error);
+			}
+			getParent().layout(true, true);
+		}
+		
+		public void setWarningMessage(String warning) {
+			if(warning == null) {
+				errorImage.setImage(null);
+				errorText.setText("");
+			} else {
+				errorImage.setImage(getDisplay().getSystemImage(SWT.ICON_WARNING));
+				errorText.setText(warning);
+			}
+			getParent().layout(true, true);
+		}
+	}
+}

Property changes on: trunk/src/g2d_swt/org/pathvisio/visualization/colorset/CriterionComposite.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorSetManager.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorSetManager.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorSetManager.java	(revision 957)
@@ -0,0 +1,139 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.colorset;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.jdom.Document;
+import org.jdom.Element;
+import org.jdom.JDOMException;
+import org.jdom.input.SAXBuilder;
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+
+public class ColorSetManager {
+	public final static String XML_ELEMENT = "color-sets";
+
+	private static List<ColorSet> colorSets = new ArrayList<ColorSet>();
+
+	/**
+	 * Gets the {@link ColorSet}s used for the currently loaded Expression data
+	 */
+	public static List<ColorSet> getColorSets() { return colorSets; }
+
+	public static boolean nameExists(String name) {
+		for(ColorSet cs : colorSets) 
+			if(cs.getName().equalsIgnoreCase(name)) return true;
+		return false;
+	}
+
+	public static String getNewName() {
+		String prefix = "color set";
+		int i = 1;
+		String name = prefix;
+		while(nameExists(name)) name = prefix + "-" + i++;
+		return name;
+	}
+
+	public static void newColorSet(String name) {
+		if(name == null) name = getNewName();
+		addColorSet(new ColorSet(name));
+		
+	}
+	
+	public static void addColorSet(ColorSet cs) {
+		colorSets.add(cs);
+		VisualizationManager.fireVisualizationEvent(
+				new VisualizationEvent(null, VisualizationEvent.COLORSET_ADDED));
+	}
+
+	/**
+	 * Removes this {@link ColorSet}
+	 * @param cs Colorset to remove
+	 */
+	public static void removeColorSet(ColorSet cs) {
+		if(colorSets.contains(cs)) {
+			colorSets.remove(cs);
+			VisualizationManager.fireVisualizationEvent(
+					new VisualizationEvent(null, VisualizationEvent.COLORSET_REMOVED));
+		}
+	}
+	
+	/**
+	 * Clears all color-set information
+	 */
+	public static void clearColorSets() {
+		colorSets.clear();
+		VisualizationManager.fireVisualizationEvent(
+				new VisualizationEvent(null, VisualizationEvent.COLORSET_REMOVED));
+	}
+	
+	public static ColorSet getColorSet(int index) {
+		if(index >= 0 && index < colorSets.size())
+			return colorSets.get(index);
+		else return null;
+	}
+
+	/**
+	 * Removes this {@link ColorSet}
+	 * @param i index of ColorSet to remove
+	 */
+	public static void removeColorSet(int i) {
+		if(i > -1 && i < colorSets.size()) {
+			removeColorSet(colorSets.get(i));
+		}
+	}
+
+	/**
+	 * Gets the names of all {@link ColorSet}s used 
+	 */
+	public static String[] getColorSetNames()
+	{
+		String[] colorSetNames = new String[colorSets.size()];
+		for(int i = 0; i < colorSetNames.length; i++)
+		{
+			colorSetNames[i] = ((ColorSet)colorSets.get(i)).getName();
+		}
+		return colorSetNames;
+	}
+
+	public static Element getXML() {
+		Element cse = new Element(XML_ELEMENT);
+				
+		for(ColorSet cs : colorSets) cse.addContent(cs.toXML());
+		
+		return cse;
+	}
+
+	public static void fromXML(Element xml) {
+		clearColorSets();
+		
+		if(xml == null) return;
+
+		for(Object o : xml.getChildren(ColorSet.XML_ELEMENT)) {
+			addColorSet(ColorSet.fromXML((Element) o));				
+		}
+	}
+
+	static Document parseInput(InputStream in) throws JDOMException, IOException {
+		SAXBuilder parser = new SAXBuilder();
+		return parser.build(in);
+	}
+}

Property changes on: trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorSetManager.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorSet.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorSet.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorSet.java	(revision 957)
@@ -0,0 +1,224 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.colorset;
+
+import java.awt.Color;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+
+import org.eclipse.jface.dialogs.MessageDialog;
+import org.eclipse.swt.graphics.RGB;
+import org.jdom.Element;
+import org.pathvisio.Engine;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.util.ColorConverter;
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+
+/**
+ * This class represents a colorset, a set of criteria that can be evaluated and 
+ * results in a color given a collection of data
+ */
+public class ColorSet {	
+	public static final int ID_COLOR_NO_CRITERIA_MET = 1;
+	public static final int ID_COLOR_NO_GENE_FOUND = 2;
+	public static final int ID_COLOR_NO_DATA_FOUND = 3;
+	
+	Color color_no_criteria_met = GlobalPreference.getValueColor(GlobalPreference.COLOR_NO_CRIT_MET);
+	Color color_no_gene_found = GlobalPreference.getValueColor(GlobalPreference.COLOR_NO_GENE_FOUND);
+	Color color_no_data_found = GlobalPreference.getValueColor(GlobalPreference.COLOR_NO_DATA_FOUND);
+		
+	String name;
+	
+	public List<ColorSetObject> colorSetObjects;
+		
+	/**
+	 * Constructor of this class
+	 * @param name		name of the colorset
+	 */
+	public ColorSet(String name)
+	{
+		this.name = name;
+		colorSetObjects = new ArrayList<ColorSetObject>();
+	}
+		
+	public String getName() { return name; }
+	
+	public void setName(String n) { 
+		name = n;
+		fireModifiedEvent();
+	}
+	
+	public void setColor(int id, Color rgb) {
+		switch(id) {
+		case ID_COLOR_NO_CRITERIA_MET:
+			color_no_criteria_met = rgb;
+			break;
+		case ID_COLOR_NO_DATA_FOUND:
+			color_no_data_found = rgb;
+			break;
+		case ID_COLOR_NO_GENE_FOUND:
+			color_no_gene_found = rgb;
+			break;
+		}
+		fireModifiedEvent();
+	}
+	
+	public Color getColor(int id) {
+		switch(id) {
+		case ID_COLOR_NO_CRITERIA_MET:
+			return color_no_criteria_met;
+		case ID_COLOR_NO_DATA_FOUND:
+			return color_no_data_found;
+		case ID_COLOR_NO_GENE_FOUND:
+			return color_no_gene_found;
+		default: return null;
+		}
+	}
+	
+	/**
+	 * Adds a new {@link ColorSetObject} to this colorset
+	 * @param o the {@link ColorSetObject} to add
+	 */
+	public void addObject(ColorSetObject o)
+	{
+		colorSetObjects.add(o);
+		fireModifiedEvent();
+	}
+	
+	public void removeObject(ColorSetObject o) {
+		colorSetObjects.remove(o);
+		fireModifiedEvent();
+	}
+	
+	public List<ColorSetObject> getObjects() {
+		return colorSetObjects;
+	}
+	
+	/**
+	 * Checks whether this color-set contains one or more color gradients
+	 * (instances of class {@link ColorGradient}
+	 * @return true if one or more of the objects of this color-set is an instance of
+	 * {@link ColorGradient}
+	 */
+	public boolean hasColorGradient() {
+		for(ColorSetObject o : colorSetObjects) {
+			if(o instanceof ColorGradient) return true;
+		}
+		return false;
+	}
+
+	public boolean nameExists(String name) {
+		for(ColorSetObject o : colorSetObjects) 
+			if(o.getName().equalsIgnoreCase(name)) return true;
+		return false;
+	}
+	
+	public String getNewName(String prefix) {
+		int i = 1;
+		String name = prefix;
+		while(nameExists(name)) name = prefix + "-" + i++;
+		return name;
+	}
+		
+	/**
+	 * Get the color for the given expression data by evaluating all colorset objects
+	 * @param data		the expression data to get the color for
+	 * @param sampleId	the id of the sample that will be visualized
+	 * @return	an {@link RGB} object representing the color for the given data
+	 */
+	public Color getColor(HashMap<Integer, Object> data, int sampleId)
+	{
+		if(data == null) return color_no_data_found;
+		Object value = data.get(sampleId);
+		if(value == null || value.equals(Double.NaN)) return color_no_data_found;
+		
+		Color rgb = color_no_criteria_met; //The color to return
+		Iterator it = colorSetObjects.iterator();
+		//Evaluate all colorset objects, return when a valid color is found
+		while(it.hasNext())
+		{
+			ColorSetObject gc = (ColorSetObject)it.next();
+			try{ 
+				Color gcRgb = gc.getColor(data, sampleId);
+				if(gcRgb != null) {
+					return gcRgb;
+				}
+			} catch(Exception e) {
+				Engine.log.error("ColorSetObject " + gc + " could not evaluate data: " + e.getMessage());
+			}
+		}
+		return rgb;
+	}
+	
+	final static String XML_ELEMENT = "ColorSet";
+	final static String XML_ATTR_NAME = "name";
+	final static String XML_ELM_COLOR_NCM = "no-criteria-met";
+	final static String XML_ELM_COLOR_NGF = "no-gene-found";
+	final static String XML_ELM_COLOR_NDF = "no-data-found";
+	
+	public Element toXML() {
+		Element elm = new Element(XML_ELEMENT);
+		elm.setAttribute(XML_ATTR_NAME, name);
+		
+		elm.addContent(ColorConverter.createColorElement(XML_ELM_COLOR_NCM, color_no_criteria_met));
+		elm.addContent(ColorConverter.createColorElement(XML_ELM_COLOR_NGF, color_no_gene_found));
+		elm.addContent(ColorConverter.createColorElement(XML_ELM_COLOR_NDF, color_no_data_found));
+		
+		for(ColorSetObject cso : colorSetObjects)
+			elm.addContent(cso.toXML());
+		return elm;
+	}
+	
+	public static ColorSet fromXML(Element e) {
+		ColorSet cs = new ColorSet(e.getAttributeValue(XML_ATTR_NAME));
+		for(Object o : e.getChildren()) {
+			try {
+				Element elm = (Element) o;
+				String name = elm.getName();
+				if(name.equals(ColorGradient.XML_ELEMENT_NAME))
+					cs.addObject(new ColorGradient(cs, elm));
+				else if(name.equals(ColorCriterion.XML_ELEMENT_NAME))
+					cs.addObject(new ColorCriterion(cs, elm));
+				else if(name.equals(XML_ELM_COLOR_NCM))
+					cs.setColor(ID_COLOR_NO_CRITERIA_MET, ColorConverter.parseColorElement(elm));
+				else if(name.equals(XML_ELM_COLOR_NGF))
+					cs.setColor(ID_COLOR_NO_GENE_FOUND, ColorConverter.parseColorElement(elm));
+				else if(name.equals(XML_ELM_COLOR_NDF))
+					cs.setColor(ID_COLOR_NO_DATA_FOUND, ColorConverter.parseColorElement(elm));
+			} catch(Exception ex) {
+				Engine.log.error("Unable to parse colorset xml", ex);
+			}
+		}
+		return cs;
+	}
+			
+	static void printParseError(String criterion, Exception e) {
+		Engine.log.error("Unable to parse colorset data stored in " +
+				"expression database: " + criterion, e);
+		MessageDialog.openWarning(SwtEngine.getWindow().getShell(), 
+					"Warning", "Unable to parse the colorset data in this expression dataset");
+	}
+	
+	void fireModifiedEvent() {
+		VisualizationManager.fireVisualizationEvent(
+				new VisualizationEvent(this, VisualizationEvent.COLORSET_MODIFIED));
+	}
+}

Property changes on: trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorSet.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorGradient.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorGradient.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorGradient.java	(revision 957)
@@ -0,0 +1,414 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.colorset;
+
+import java.awt.Color;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+
+import org.eclipse.jface.viewers.CellEditor;
+import org.eclipse.jface.viewers.ColorCellEditor;
+import org.eclipse.jface.viewers.ICellModifier;
+import org.eclipse.jface.viewers.ILabelProviderListener;
+import org.eclipse.jface.viewers.IStructuredContentProvider;
+import org.eclipse.jface.viewers.IStructuredSelection;
+import org.eclipse.jface.viewers.ITableLabelProvider;
+import org.eclipse.jface.viewers.TableViewer;
+import org.eclipse.jface.viewers.TextCellEditor;
+import org.eclipse.jface.viewers.Viewer;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.events.SelectionListener;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.graphics.RGB;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.layout.RowLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Table;
+import org.eclipse.swt.widgets.TableColumn;
+import org.eclipse.swt.widgets.TableItem;
+import org.jdom.Element;
+import org.pathvisio.Engine;
+import org.pathvisio.util.ColorConverter;
+import org.pathvisio.util.SwtUtils;
+import org.pathvisio.util.TableColumnResizer;
+
+/**
+ * This class represent a color gradient used for data visualization
+ */
+public class ColorGradient extends ColorSetObject {
+	public static final String XML_ELEMENT_NAME = "ColorGradient";
+
+	private ArrayList<ColorValuePair> colorValuePairs;
+	
+	/**
+	 * Constructor for this class
+	 * @param parent 		colorset this gradient belongs to
+	 * @param name 			name of the gradient
+	 */
+	public ColorGradient(ColorSet parent, String name)
+	{
+		super(parent, name);
+		getColorValuePairs();
+	}
+		
+	public ColorGradient(ColorSet parent, Element xml) {
+		super(parent, xml);
+	}
+	
+	/**
+	 * Get the the colors and corresponding values used in this gradient as {@link ColorValuePair}
+	 * @return ArrayList containing the ColorValuePairs
+	 */
+	public ArrayList<ColorValuePair> getColorValuePairs() 
+	{ 
+		if(colorValuePairs == null) {//Not initialized yet, use defaults
+			colorValuePairs = new ArrayList<ColorValuePair>();
+			colorValuePairs.add(new ColorValuePair(new Color(0,255,0), -1));
+			colorValuePairs.add(new ColorValuePair(new Color(255,255,0), 0));
+			colorValuePairs.add(new ColorValuePair(new Color(255,0,0), 1));
+		}
+		return colorValuePairs;
+	}
+	/**
+	 * Add a {@link ColorValuePair} to this gradient
+	 */
+	public void addColorValuePair(ColorValuePair cvp)
+	{
+		if(colorValuePairs == null) { 
+			colorValuePairs = new ArrayList<ColorValuePair>();
+		}
+		colorValuePairs.add(cvp);
+		fireModifiedEvent();
+	}
+	/**
+	 * Remove a {@link ColorValuePair} from this gradient
+	 */
+	public void removeColorValuePair(ColorValuePair cvp)
+	{
+		if(colorValuePairs == null || !colorValuePairs.contains(cvp)) return;
+		colorValuePairs.remove(cvp);
+		fireModifiedEvent();
+	}
+			
+	/**
+	 * get the color of the gradient for this value
+	 * @param value
+	 * @return	{@link RGB} containing the color information for the corresponding value
+	 * or null if the value does not have a valid color for this gradient
+	 */
+	public Color getColor(double value)
+	{
+		double[] minmax = getMinMax(); //Get the minimum and maximum values of the gradient
+		double valueStart = 0;
+		double valueEnd = 0;
+		Color colorStart = null;
+		Color colorEnd = null;
+		Collections.sort(colorValuePairs);
+		//If value is larger/smaller than max/min then set the value to max/min
+		//TODO: make this optional
+		if(value < minmax[0]) value = minmax[0]; else if(value > minmax[1]) value = minmax[1];
+		
+		//Find what colors the value is in between
+		for(int i = 0; i < colorValuePairs.size() - 1; i++)
+		{
+			ColorValuePair cvp = colorValuePairs.get(i);
+			ColorValuePair cvpNext = colorValuePairs.get(i + 1);
+			if(value >= cvp.value && value <= cvpNext.value)
+			{
+				valueStart = cvp.getValue();
+				colorStart = cvp.getColor();
+				valueEnd = cvpNext.getValue();
+				colorEnd = cvpNext.getColor();
+			}
+		}
+		if(colorStart == null || colorEnd == null) return null; //Check if the values/colors are found
+		// Interpolate to find the color belonging to the given value
+		double alpha = (value - valueStart) / (valueEnd - valueStart);
+		double red = colorStart.getRed() + alpha*(colorEnd.getRed() - colorStart.getRed());
+		double green = colorStart.getGreen() + alpha*(colorEnd.getGreen() - colorStart.getGreen());
+		double blue = colorStart.getBlue() + alpha*(colorEnd.getBlue() - colorStart.getBlue());
+		Color rgb = null;
+		
+		//Try to create an RGB, if the color values are not valid (outside 0 to 255)
+		//This method returns null
+		try {
+			rgb = new Color((int)red, (int)green, (int)blue);
+		} catch (Exception e) { 
+			Engine.log.error("GmmlColorGradient:getColor: " + 
+					red + "," + green + "," +blue + ", for value " + value, e);
+		}
+		return rgb;
+	}
+	
+	public Color getColor(HashMap<Integer, Object> data, int idSample) throws NumberFormatException
+	{
+		double value = (Double)data.get(idSample);
+		return getColor(value);
+	}
+	
+	String getXmlElementName() {
+		return XML_ELEMENT_NAME;
+	}
+	
+	public Element toXML() {
+		Element elm = super.toXML();
+		for(ColorValuePair cvp : colorValuePairs)
+			elm.addContent(cvp.toXML());
+		return elm;
+	}
+	
+	protected void loadXML(Element xml) {
+		super.loadXML(xml);
+		colorValuePairs = new ArrayList<ColorValuePair>();
+		for(Object o : xml.getChildren(ColorValuePair.XML_ELEMENT))
+			colorValuePairs.add(new ColorValuePair((Element) o));
+	}
+	
+	/**
+	 * Find the minimum and maximum values used in this gradient
+	 * @return a double[] of length 2 with respecively the minimum and maximum values
+	 */
+	public double[] getMinMax()
+	{
+		double[] minmax = new double[] { Double.MAX_VALUE, Double.MIN_VALUE };
+		for(ColorValuePair cvp : colorValuePairs)
+		{
+			minmax[0] = Math.min(cvp.value, minmax[0]);
+			minmax[1] = Math.max(cvp.value, minmax[1]);
+		}
+		return minmax;
+	}
+	
+	/**
+	 * This class contains a color and its corresponding value used for the {@link ColorGradient}
+	 */
+	public class ColorValuePair implements Comparable<ColorValuePair> {
+		static final String XML_ELEMENT = "color-value";
+		static final String XML_ATTR_VALUE = "value";
+		static final String XML_ELM_COLOR = "color";
+		private Color color;
+		private double value;
+		
+		public ColorValuePair(Color color, double value)
+		{
+			this.color = color;
+			this.value = value;
+		}
+		
+		public ColorValuePair(Element xml) {
+			Object o = xml.getChildren(XML_ELM_COLOR).get(0);
+			color = ColorConverter.parseColorElement((Element)o);
+			value = Double.parseDouble(xml.getAttributeValue(XML_ATTR_VALUE));
+		}
+		
+		public Color getColor() { return color; }
+		public void setColor(Color rgb) {
+			color = rgb;
+			fireModifiedEvent();
+		}
+		
+		public double getValue() { return value; }
+		public void setValue(double v) {
+			value = v;
+			fireModifiedEvent();
+		}
+		
+		public int compareTo(ColorValuePair o)
+		{
+			return (int)(value - o.value);
+		}
+		
+		public Element toXML() {
+			Element elm = new Element(XML_ELEMENT);
+			elm.setAttribute(XML_ATTR_VALUE, Double.toString(value));
+			elm.addContent(ColorConverter.createColorElement(XML_ELM_COLOR, color));
+			return elm;
+		}
+	}
+	
+	public static class ColorGradientComposite extends ConfigComposite {	
+		static final String[] tableColumns = new String[] {"Color", "Value"};
+		TableViewer colorTable;
+		
+		public ColorGradientComposite(Composite parent, int style) {
+			super(parent, style);
+		}
+		
+		ColorGradient getInput() {
+			return (ColorGradient)input;
+		}
+		
+		public void setInput(ColorSetObject o) {
+			super.setInput(o);
+			colorTable.setInput(o);
+		}
+				
+		void addColor() {
+			getInput().addColorValuePair(getInput().new ColorValuePair(Color.RED, 0));
+    		colorTable.refresh();
+		}
+		
+		void removeColor() {
+    		ColorValuePair cvp = (ColorValuePair)
+    		((IStructuredSelection)colorTable.getSelection()).getFirstElement();
+    		getInput().removeColorValuePair(cvp);
+    		colorTable.refresh();
+		}
+		
+		void createContents() {
+			setLayout(new GridLayout());
+			Composite nameComp = createNameComposite(this);
+			nameComp.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+			
+			Composite buttonComp = createButtonComp(this);
+
+			Composite tableComp = createColorTable(this);
+			tableComp.setLayoutData(new GridData(GridData.FILL_BOTH));
+		}
+		
+		Composite createButtonComp(Composite parent) {
+			Composite comp = new Composite(parent, SWT.NULL);
+			comp.setLayout(new RowLayout(SWT.HORIZONTAL));
+			
+			
+			final Button addColor = new Button(comp, SWT.PUSH);
+			addColor.setText("Add color");
+		    final Button removeColor = new Button(comp, SWT.PUSH);
+		    removeColor.setText("Remove color");
+		    
+			SelectionListener buttonAdapter = new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					if(e.widget == addColor) addColor();
+					else removeColor();
+				}
+			};
+			addColor.addSelectionListener(buttonAdapter);
+		    removeColor.addSelectionListener(buttonAdapter);
+		    return comp;
+		}
+
+		Composite createColorTable(Composite parent) {
+			Composite tableComp = new Composite(parent, SWT.NULL);
+			tableComp.setLayout(new GridLayout());
+					    			
+		    Table table = new Table(tableComp, SWT.BORDER | SWT.SINGLE | SWT.FULL_SELECTION);
+		    
+		    table.setHeaderVisible(true);
+		    TableColumn colorCol = new TableColumn(table, SWT.LEFT);
+		    TableColumn valueCol = new TableColumn(table, SWT.LEFT);
+		    valueCol.setText(tableColumns[1]);
+		    colorCol.setText(tableColumns[0]);
+
+		    colorCol.setWidth(45);
+		    colorCol.setResizable(false);
+		    
+		    table.addControlListener(
+		    		new TableColumnResizer(table, tableComp, new int[] { 0, 100 }));
+		    
+		    colorTable = new TableViewer(table);
+		    colorTable.setColumnProperties(tableColumns);
+		    
+		    colorTable.setLabelProvider(createLabelProvider());
+		    colorTable.setContentProvider(createContentProvider());
+		    colorTable.setCellModifier(createCellModifier());
+		    
+		    CellEditor[] cellEditors = new CellEditor[2];
+		    cellEditors[1] = new TextCellEditor(table);
+		    cellEditors[0] = new ColorCellEditor(table);
+		    colorTable.setCellEditors(cellEditors);
+		    
+		    return tableComp;
+		}
+		
+		IStructuredContentProvider createContentProvider() {
+			return new IStructuredContentProvider() {
+				public Object[] getElements(Object inputElement) {
+					return ((ColorGradient)inputElement).getColorValuePairs().toArray();
+				}
+				public void dispose() {	}
+				public void inputChanged(Viewer viewer, Object oldInput, Object newInput) { }
+			};
+		}
+		
+		ITableLabelProvider createLabelProvider() {
+			return new ITableLabelProvider() {
+				private Image colorImage;
+				
+				public void dispose() {
+					if(colorImage != null) colorImage.dispose();
+				}
+				
+				public Image getColumnImage(Object element, int columnIndex) { 
+					if(columnIndex == 0) {
+						RGB rgb = SwtUtils.color2rgb(((ColorValuePair)element).color);
+						colorImage = new Image(null, ColorSetComposite.createColorImage(rgb));
+						return colorImage;
+					}
+					return null;
+				}
+				
+				public String getColumnText(Object element, int columnIndex) {
+					if(columnIndex == 1) {
+						return Double.toString(((ColorValuePair)element).getValue());
+					}
+					return null;
+				}
+
+				public void addListener(ILabelProviderListener listener) {}
+				public boolean isLabelProperty(Object element, String property) {
+					return false;
+				}
+				public void removeListener(ILabelProviderListener listener) {}
+			};
+		}
+
+		ICellModifier createCellModifier() {
+			return new ICellModifier() {
+				public boolean canModify(Object element, String property) {
+					return true;
+				}
+
+				public Object getValue(Object element, String property) {
+					ColorValuePair cvp = (ColorValuePair)element;
+					if(property.equals(tableColumns[0])) {
+						return cvp.getColor();
+					} else {
+						return Double.toString(cvp.getValue());
+					}
+				}
+
+				public void modify(Object element, String property, Object value) {
+					if(element instanceof TableItem) {
+						element = ((TableItem)element).getData();
+					}
+					ColorValuePair cvp = (ColorValuePair)element;
+					if(property.equals(tableColumns[0])) {
+						cvp.setColor(SwtUtils.rgb2color((RGB)value));
+					} else {
+						cvp.setValue(Double.parseDouble((String)value));
+					}
+					colorTable.refresh();
+				}
+			};
+		}
+	}
+}

Property changes on: trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorGradient.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorCriterion.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorCriterion.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorCriterion.java	(revision 957)
@@ -0,0 +1,204 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.colorset;
+
+import java.awt.Color;
+import java.util.HashMap;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.CLabel;
+import org.eclipse.swt.graphics.RGB;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.ColorDialog;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Listener;
+import org.eclipse.swt.widgets.Text;
+import org.jdom.Element;
+import org.pathvisio.Engine;
+import org.pathvisio.util.ColorConverter;
+import org.pathvisio.util.SwtUtils;
+
+public class ColorCriterion extends ColorSetObject {	
+	public static final String XML_ELEMENT_NAME = "ColorCriterion";
+	
+	Criterion criterion;
+	
+	public static final Color INITIAL_COLOR = Color.WHITE;
+	private Color color;
+	public void setColor(Color color) { 
+		this.color = color;
+		fireModifiedEvent();
+	}
+	
+	public Color getColor() { return color == null ? INITIAL_COLOR : color; }
+	
+	public Criterion getCriterion() { return criterion; }
+	
+	public ColorCriterion(ColorSet parent, String name) {
+		super(parent, name);
+		criterion = new Criterion();
+	}
+
+	public ColorCriterion(ColorSet parent, Element xml) {
+		super(parent, xml);
+	}
+	
+	Color getColor(HashMap<Integer, Object> data, int idSample) throws Exception {
+		if(criterion.evaluate(data, idSample)) return color;
+		return null;
+	}
+	
+	public String getXmlElementName() {
+		return XML_ELEMENT_NAME;
+	}
+	
+	protected void loadXML(Element xml) {
+		super.loadXML(xml);
+		try {
+			String expression = xml.getAttributeValue(XML_ATTR_EXPRESSION);
+			criterion = new Criterion();
+			criterion.setExpression(expression);
+			Element ce = xml.getChild(XML_ELM_COLOR);
+			if(ce != null) color = ColorConverter.parseColorElement(ce);
+		} catch(Exception e) {
+			Engine.log.error("Unable to load ColorCriterion", e);
+		}
+	}
+	
+	static final String XML_ELM_COLOR = "color";
+	static final String XML_ATTR_EXPRESSION = "expression";
+	public Element toXML() {
+		Element elm = super.toXML();
+		Element ce = ColorConverter.createColorElement(XML_ELM_COLOR, getColor());
+		elm.addContent(ce);
+		elm.setAttribute(XML_ATTR_EXPRESSION, criterion.getExpression());
+		
+		return elm;
+	}
+		
+	public static class ColorCriterionComposite extends ConfigComposite {
+		final int colorLabelSize = 15;
+		CriterionComposite critComp;
+		Text exprText;
+		CLabel colorLabel;
+		org.eclipse.swt.graphics.Color color;
+		
+		public ColorCriterionComposite(Composite parent, int style) {
+			super(parent, style);
+		}
+		
+		void refresh() {
+			super.refresh();
+			critComp.refresh();
+			changeColorLabel(getInput() == null ? null : SwtUtils.color2rgb(getInput().getColor()));
+		}
+		
+		ColorCriterion getInput() {
+			return (ColorCriterion)input;
+		}
+		
+//		public boolean save() {
+//			if(input != null) try {
+//				critComp.saveToCriterion();
+//			} catch(Exception e) {
+//				return false;
+//			}
+//			return true;
+//		}
+			
+		public void setInput(ColorSetObject o) {
+			super.setInput(o);
+			if(o == null) critComp.setInput(null);
+			else critComp.setInput(((ColorCriterion)o).getCriterion());
+			refresh();
+		}
+		
+		RGB askColor() {
+			ColorDialog dg = new ColorDialog(getShell());
+			dg.setRGB(SwtUtils.color2rgb(getInput().getColor()));
+			return dg.open();
+		}
+		
+		void changeColor(RGB rgb) {
+			if(rgb != null) {
+				ColorCriterion c = getInput();
+				if(c != null) c.setColor(SwtUtils.rgb2color(rgb));
+				changeColorLabel(rgb);
+			}
+		}
+		
+		void changeColorLabel(RGB rgb) {
+			if(rgb != null) {
+				color = SwtUtils.changeColor(color, rgb, colorLabel.getDisplay());
+				colorLabel.setBackground(color);
+			}
+		}
+		
+				void createContents() {
+			setLayout(new GridLayout());
+			
+			Composite superComp = super.createNameComposite(this);
+			superComp.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+			
+			Composite colorComp = createColorComp(this);
+			colorComp.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+					    
+		    critComp = new CriterionComposite(this, null);
+		    critComp.setLayoutData(new GridData(GridData.FILL_BOTH));
+		    critComp.fetchSymbolsFromGex();
+		}
+		
+		Composite createColorComp(Composite parent) {
+			Composite colorComp = new Composite(parent, SWT.NULL);
+			colorComp.setLayout(new GridLayout(3, false));
+			
+			final GridData colorLabelGrid = new GridData(GridData.HORIZONTAL_ALIGN_BEGINNING);
+			colorLabelGrid.widthHint = colorLabelGrid.heightHint = colorLabelSize;
+			
+			Label label = new Label(colorComp, SWT.CENTER);
+			label.setText("Color:");
+
+			colorLabel = new CLabel(colorComp, SWT.SHADOW_IN);
+			colorLabel.setLayoutData(colorLabelGrid);
+			colorLabel.setBackground(getDisplay().getSystemColor(SWT.COLOR_BLACK));
+
+			Button colorButton = new Button(colorComp, SWT.PUSH);
+			colorButton.addListener(SWT.Selection | SWT.Dispose, new Listener() {
+				public void handleEvent(Event e) {
+					switch(e.type) {
+					case SWT.Selection:
+						RGB rgb = askColor();
+						changeColor(rgb);
+					break;
+					case SWT.Dispose:
+						color.dispose();
+					break;
+					}
+				}
+			});
+			
+			colorButton.setLayoutData(colorLabelGrid);
+			colorButton.setText("...");
+			
+			return colorComp;
+		}
+	}
+}

Property changes on: trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorCriterion.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorSetComposite.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorSetComposite.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorSetComposite.java	(revision 957)
@@ -0,0 +1,627 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.colorset;
+
+import java.util.HashMap;
+
+import org.eclipse.jface.dialogs.Dialog;
+import org.eclipse.jface.viewers.ILabelProviderListener;
+import org.eclipse.jface.viewers.ISelectionChangedListener;
+import org.eclipse.jface.viewers.IStructuredContentProvider;
+import org.eclipse.jface.viewers.IStructuredSelection;
+import org.eclipse.jface.viewers.ITableLabelProvider;
+import org.eclipse.jface.viewers.SelectionChangedEvent;
+import org.eclipse.jface.viewers.StructuredSelection;
+import org.eclipse.jface.viewers.TableViewer;
+import org.eclipse.jface.viewers.Viewer;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.CLabel;
+import org.eclipse.swt.custom.StackLayout;
+import org.eclipse.swt.dnd.DND;
+import org.eclipse.swt.dnd.DragSource;
+import org.eclipse.swt.dnd.DragSourceAdapter;
+import org.eclipse.swt.dnd.DragSourceEvent;
+import org.eclipse.swt.dnd.DropTarget;
+import org.eclipse.swt.dnd.DropTargetAdapter;
+import org.eclipse.swt.dnd.DropTargetEvent;
+import org.eclipse.swt.dnd.TextTransfer;
+import org.eclipse.swt.dnd.Transfer;
+import org.eclipse.swt.events.ModifyEvent;
+import org.eclipse.swt.events.ModifyListener;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.events.SelectionListener;
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.graphics.ImageData;
+import org.eclipse.swt.graphics.PaletteData;
+import org.eclipse.swt.graphics.RGB;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.layout.RowLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.ColorDialog;
+import org.eclipse.swt.widgets.Combo;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Group;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Table;
+import org.eclipse.swt.widgets.TableColumn;
+import org.eclipse.swt.widgets.TableItem;
+import org.eclipse.swt.widgets.Text;
+import org.pathvisio.util.SwtUtils;
+import org.pathvisio.util.TableColumnResizer;
+import org.pathvisio.util.Utils;
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+import org.pathvisio.visualization.VisualizationManager.VisualizationListener;
+import org.pathvisio.visualization.colorset.ColorCriterion.ColorCriterionComposite;
+import org.pathvisio.visualization.colorset.ColorGradient.ColorGradientComposite;
+
+public class ColorSetComposite extends Composite implements VisualizationListener {
+	final int colorLabelSize = 15;
+	ColorSet colorSet;
+	
+	TableViewer objectsTable;
+	
+	Composite colorButtons;
+	Group objectsGroup;
+	ObjectSettingsComposite objectSettings;
+	Color colorNCM, colorNGF, colorNDF;
+	CLabel labelColorNCM, labelColorNGF, labelColorNDF;
+	Combo colorSetCombo;
+	Text nameText;
+	
+	public ColorSetComposite(Composite parent, int style) {
+		super(parent, style);
+		createContents();
+		VisualizationManager.addListener(this);
+	}
+	
+	public void dispose() {
+		colorNCM.dispose();
+		colorNGF.dispose();
+		colorNDF.dispose();
+		super.dispose();
+	}
+	
+	public void setInput(ColorSet cs) {
+		colorSet = cs;
+		if(colorSet == null) {
+			setObjectsGroupEnabled(false);
+		} else {
+			setObjectsGroupEnabled(true);
+			initColorLabels();
+			initName();
+			objectsTable.setInput(colorSet);
+			objectsTable.getTable().select(0);
+		}
+	}
+		
+	void setObjectsGroupEnabled(boolean enable) {
+		SwtUtils.setCompositeAndChildrenEnabled(objectsGroup, enable);
+	}
+		
+	void initName() {
+		nameText.setText(colorSet.getName());
+	}
+	
+	void initColorLabels() {
+		changeColorLabel(labelColorNCM, SwtUtils.color2rgb(colorSet.getColor(ColorSet.ID_COLOR_NO_CRITERIA_MET)));
+		changeColorLabel(labelColorNGF, SwtUtils.color2rgb(colorSet.getColor(ColorSet.ID_COLOR_NO_GENE_FOUND)));
+		changeColorLabel(labelColorNDF, SwtUtils.color2rgb(colorSet.getColor(ColorSet.ID_COLOR_NO_DATA_FOUND)));
+	}
+		
+	public void refreshCombo() {
+		colorSetCombo.setItems(ColorSetManager.getColorSetNames());
+		colorSetCombo.layout();
+		colorSetCombo.select(0);
+	}
+
+	void createContents() {
+		setLayout(new GridLayout());
+		Composite colorSetComp = createColorSetComposite(this);
+		colorSetComp.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+		
+		objectsGroup = new Group(this, SWT.NULL);
+		objectsGroup.setText("Criteria");
+		objectsGroup.setLayoutData(new GridData(GridData.FILL_BOTH));
+		objectsGroup.setLayout(new GridLayout(2, false));
+		
+		Composite listComp = createObjectList(objectsGroup);
+		listComp.setLayoutData(new GridData(GridData.FILL_VERTICAL));
+		
+		objectSettings = new ObjectSettingsComposite(objectsGroup, SWT.NONE);
+		objectSettings.setLayoutData(new GridData(GridData.FILL_BOTH));
+
+		refreshCombo();
+		
+		colorSetCombo.select(0);
+	}
+
+	Composite createObjectList(Composite parent) {
+		Composite listComp = new Composite(parent, SWT.NULL);
+		listComp.setLayout(new GridLayout());
+		
+		Composite tableComp = new Composite(listComp, SWT.NULL);
+		tableComp.setLayoutData(new GridData(GridData.FILL_BOTH));
+		tableComp.setLayout(new FillLayout());
+		Table table = new Table(tableComp, SWT.BORDER | SWT.SINGLE);
+		TableColumn coCol = new TableColumn(table, SWT.LEFT);
+		coCol.setText("Name");
+		table.addControlListener(new TableColumnResizer(table, listComp));
+		
+		objectsTable = new TableViewer(table);
+		objectsTable.setContentProvider(new IStructuredContentProvider() {
+			public Object[] getElements(Object inputElement) {
+				return ((ColorSet)inputElement).getObjects().toArray();
+			}
+			
+			public void dispose() { }
+			public void inputChanged(Viewer viewer, Object oldInput, Object newInput) { }
+		});
+		objectsTable.setLabelProvider(new ITableLabelProvider() {			
+			private HashMap<Object, Image> images = new HashMap<Object, Image>();
+											
+			public void dispose() {
+				for(Image img : images.values()) disposeImage(img);
+			}
+			
+			void disposeImage(Image img) { if(img != null && !img.isDisposed()) img.dispose(); }
+			
+			public Image getColumnImage(Object element, int columnIndex) {
+				Image img = images.get(element);
+				if(element instanceof ColorGradient) {
+					disposeImage(img);
+					img = new Image(null, createGradientImage((ColorGradient)element));
+					images.put(element, img);
+					return img;
+				}
+				if(element instanceof ColorCriterion) {
+					disposeImage(img);
+					img = new Image(null, createColorImage(
+							SwtUtils.color2rgb(((ColorCriterion)element).getColor())));
+					images.put(element, img);
+					return img;
+				}
+				return null;
+			}
+			
+			public String getColumnText(Object element, int columnIndex) {
+				if(element instanceof ColorSetObject)
+					return ((ColorSetObject)element).getName();
+				return "";
+			}
+			
+			public boolean isLabelProperty(Object element, String property) {
+				return false;
+			}
+			public void removeListener(ILabelProviderListener listener) {}
+			public void addListener(ILabelProviderListener listener) {}
+		});
+		
+		objectsTable.addSelectionChangedListener(new ISelectionChangedListener() {
+			boolean ignore;
+			ColorSetObject previous = null;
+			public void selectionChanged(SelectionChangedEvent event) {
+				if(ignore) {
+					ignore = false;
+					return;
+				}
+				boolean save = true;
+				if(previous != null && colorSet.getObjects().contains(previous))
+					save = objectSettings.save();
+				if(save) {
+					previous = getSelectedObject();
+					objectSettings.setInput(previous);
+				} else {
+					ignore = true;
+					objectsTable.setSelection(new StructuredSelection(previous));
+				}
+			}
+		});
+		
+		//Drag & Drop support
+		DragSource ds = new DragSource(objectsTable.getTable(), DND.DROP_MOVE);
+		ds.addDragListener(new ColorSetObjectDragAdapter());
+		ds.setTransfer(new Transfer[] { TextTransfer.getInstance() });
+		DropTarget dt = new DropTarget(objectsTable.getTable(), DND.DROP_MOVE);
+		dt.addDropListener(new ColorSetObjectDropAdapter());
+		dt.setTransfer(new Transfer[] { TextTransfer.getInstance() });
+		
+		Composite buttons = new Composite(listComp, SWT.NULL);
+		buttons.setLayout(new RowLayout(SWT.HORIZONTAL));
+		final Button add = new Button(buttons, SWT.PUSH);
+		add.setText("Add");
+		final Button remove = new Button(buttons, SWT.PUSH);
+		remove.setText("Remove");
+		
+		SelectionListener buttonAdapter = new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				if(e.widget == add) addColorSetObject();
+				else removeColorSetObject();
+			}
+		};
+		
+		add.addSelectionListener(buttonAdapter);
+		remove.addSelectionListener(buttonAdapter);
+		
+		return  listComp;
+	}
+		
+	RGB askColor(RGB current) {
+		ColorDialog cd = new ColorDialog(getShell());
+		cd.setRGB(current);
+		return cd.open();
+	}
+	
+	void changeColor(CLabel label) {
+		ColorDialog cd = new ColorDialog(getShell());
+		cd.setRGB(label.getBackground().getRGB());
+		changeColor(label, cd.open());
+	}
+	
+	void changeColor(CLabel label, RGB rgb) {
+		int id = -1;
+		if(label == labelColorNCM)
+			id = ColorSet.ID_COLOR_NO_CRITERIA_MET;
+		else if	(label == labelColorNDF)
+			id = ColorSet.ID_COLOR_NO_DATA_FOUND;
+		else if (label == labelColorNGF)
+			id = ColorSet.ID_COLOR_NO_GENE_FOUND;
+
+		if(id >= 0) {
+			if(rgb != null) {
+				colorSet.setColor(id, SwtUtils.rgb2color(rgb));
+				changeColorLabel(label, rgb);
+			}
+		}
+	}
+	
+	void changeColorLabel(CLabel label, RGB rgb) {
+		Color c = null;
+		if(label == labelColorNCM)
+			c = colorNCM = SwtUtils.changeColor(colorNCM, rgb, getDisplay());
+		else if	(label == labelColorNDF)
+			c = colorNDF = SwtUtils.changeColor(colorNDF, rgb, getDisplay());
+		else if (label == labelColorNGF)
+			c = colorNGF = SwtUtils.changeColor(colorNGF, rgb, getDisplay());
+		
+		if(c != null) label.setBackground(c);
+	}
+	
+	void addColorSet() {
+		ColorSetManager.newColorSet(null);
+		refreshCombo();
+		colorSetCombo.select(ColorSetManager.getColorSets().size() - 1);
+	}
+	
+	void removeColorSet() {
+		ColorSetManager.removeColorSet(colorSetCombo.getSelectionIndex());
+		refreshCombo();
+	}
+	
+	void addColorSetObject() {
+		final int NEW_GRADIENT = 10;
+		final int NEW_EXPRESSION = 11;
+		Dialog dialog = new Dialog(getShell()) {
+			int newObject = NEW_GRADIENT;
+			public int open() {
+				int open = super.open();
+				return open == CANCEL ? CANCEL : newObject;
+			}
+			protected Control createDialogArea(Composite parent) {
+				setBlockOnOpen(true);
+				Composite contents = new Composite(parent, SWT.NULL);
+				contents.setLayout(new RowLayout(SWT.VERTICAL));
+				final Button gradient = new Button(contents, SWT.RADIO);
+				gradient.setText("Color by gradient");
+				final Button expression = new Button(contents, SWT.RADIO);
+				expression.setText("Color by boolean expression");
+				
+				SelectionListener lst = new SelectionAdapter() {
+					public void widgetSelected(SelectionEvent e) {
+						if(e.widget == gradient) newObject =  NEW_GRADIENT;
+						else newObject = NEW_EXPRESSION;
+					}
+				};
+				
+				gradient.addSelectionListener(lst);
+				expression.addSelectionListener(lst);
+				gradient.setSelection(true);
+				return contents;
+			}
+		};
+		
+		int type = dialog.open();
+		if(type == Dialog.CANCEL) return;
+		ColorSetObject newCso = null;
+		switch(type) {
+		case NEW_GRADIENT:
+			newCso = new ColorGradient(colorSet, colorSet.getNewName("New gradient"));
+			break;
+		case NEW_EXPRESSION:
+			newCso = new ColorCriterion(colorSet, colorSet.getNewName("New expression"));
+			break;
+		}
+		if(newCso != null) {
+			colorSet.addObject(newCso);
+			objectsTable.refresh();
+			objectsTable.setSelection(new StructuredSelection(newCso));
+		}
+		
+	}
+	
+	void removeColorSetObject() {
+		colorSet.removeObject(getSelectedObject());
+		objectsTable.refresh();
+	}
+	
+	ColorSetObject getSelectedObject() {
+		return (ColorSetObject)
+			((IStructuredSelection)objectsTable.getSelection()).getFirstElement();
+	}
+	void modifyName(String newName) {
+		if(!newName.equals("")) colorSet.setName(newName);
+	}
+	
+	void colorSetSelected() {
+		int index = colorSetCombo.getSelectionIndex();
+		if(index == -1)
+			setInput(null);
+		else
+			setInput(ColorSetManager.getColorSets().get(index));
+	}
+	
+	Composite createColorSetComposite(Composite parent) {
+		Composite csComp = new Composite(parent, SWT.NULL);
+		csComp.setLayout(new GridLayout(2, false));
+		
+		//Combo + buttons
+		Composite comboComp = new Composite(csComp, SWT.NULL);
+		comboComp.setLayout(new GridLayout());
+		
+		Label comboLabel = new Label(comboComp, SWT.NULL);
+		comboLabel.setText("Color set:");
+		colorSetCombo = new Combo(comboComp, SWT.SINGLE | SWT.READ_ONLY);
+		colorSetCombo.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+		colorSetCombo.addModifyListener(new ModifyListener() {
+			public void modifyText(ModifyEvent e) {
+				colorSetSelected();
+				enableSettings(colorSet != null);
+			}
+			
+			void enableSettings(boolean enable) {
+				nameText.setEnabled(enable);
+				SwtUtils.setCompositeAndChildrenEnabled(colorButtons, enable);
+			}
+		});
+		
+		Composite buttons = new Composite(comboComp, SWT.NULL);
+		buttons.setLayout(new RowLayout(SWT.HORIZONTAL));
+		final Button add = new Button(buttons, SWT.PUSH);
+		add.setText("Add");
+		final Button remove = new Button(buttons, SWT.PUSH);
+		remove.setText("Remove");
+		
+		SelectionListener buttonAdapter = new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				if(e.widget == add) addColorSet();
+				else removeColorSet();
+			}
+		};
+		
+		add.addSelectionListener(buttonAdapter);
+		remove.addSelectionListener(buttonAdapter);
+		
+		//Name + colors
+		Composite csSettings = new Composite(csComp, SWT.NULL);
+		csSettings.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+		csSettings.setLayout(new GridLayout(2, false));
+		
+		Label nameLabel = new Label(csSettings, SWT.NULL);
+		nameLabel.setText("Name: ");
+		
+		nameText = new Text(csSettings, SWT.SINGLE | SWT.BORDER);
+		nameText.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+		nameText.addModifyListener(new ModifyListener() {
+			public void modifyText(ModifyEvent e) {
+				modifyName(nameText.getText());
+			}
+		});
+		
+				
+		colorButtons = createFixedColors(csSettings);
+		GridData span2cols = new GridData(GridData.FILL_HORIZONTAL);
+		span2cols.horizontalSpan = 2;
+		colorButtons.setLayoutData(span2cols);
+		
+		nameText.setEnabled(false);
+		SwtUtils.setCompositeAndChildrenEnabled(colorButtons, false);
+		return csComp;
+	}
+	
+	Composite createFixedColors(Composite parent) {		
+		Group buttonGroup = new Group(parent, SWT.NULL);
+		buttonGroup.setLayout(new GridLayout(3, false));
+		buttonGroup.setText("Colors");
+		
+		CLabel[] colorLabels = new CLabel[3];
+		String[] names = new String[] {
+				"No criteria met", "Gene not found", "No data found"
+		};
+		for(int i = 0; i < colorLabels.length; i++) {
+			Composite comp = new Composite(buttonGroup, SWT.NULL);
+			comp.setLayout(new GridLayout(3, false));
+			final CLabel clabel = new CLabel(comp, SWT.SHADOW_IN);
+			clabel.setLayoutData(SwtUtils.getColorLabelGrid());
+			Button b = new Button(comp, SWT.PUSH);
+			b.setLayoutData(SwtUtils.getColorLabelGrid());
+			b.setText("...");
+			b.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) { 
+					changeColor(clabel);
+				}
+			});
+			Label label = new Label(comp, SWT.NULL);
+			label.setText(names[i]);
+			colorLabels[i] = clabel;
+		}
+		labelColorNCM = colorLabels[0];
+		labelColorNGF = colorLabels[1];
+		labelColorNDF = colorLabels[2];
+				
+		return buttonGroup;
+	}
+	
+	class ObjectSettingsComposite extends Composite {
+		StackLayout stack;
+		ColorSetObject input;
+		ColorGradientComposite gradientComp;
+		ColorCriterionComposite criterionComp;
+		Composite nothing;
+		
+		public ObjectSettingsComposite(Composite parent, int style) {
+			super(parent, style);
+			createContents();
+		}
+		
+		public void setInput(ColorSetObject cso) {
+			input = cso;
+			refresh();
+		}
+		
+		public boolean save() {
+			if(input instanceof ColorGradient) return gradientComp.save();
+			else if (input instanceof ColorCriterion) return criterionComp.save();
+			else return true;
+		}
+		
+		public void refresh() {
+			if(input == null) stack.topControl = nothing;
+			else {
+				if(input instanceof ColorGradient) {
+					stack.topControl = gradientComp;
+					gradientComp.setInput(getSelectedObject());
+				} else {
+					stack.topControl = criterionComp;
+					criterionComp.setInput(getSelectedObject());
+				}
+			}
+			layout();
+		}
+		
+		void createContents() {
+			stack = new StackLayout();
+			setLayout(stack);
+						
+			//Gradient
+			gradientComp = new ColorGradientComposite(this, SWT.NULL);
+			//Criterion
+			criterionComp = new ColorCriterionComposite(this, SWT.NULL);
+			//Nothing
+			new Composite(this, SWT.NULL);
+		}		
+	}
+	
+	/**
+	 * creates an 16x16 image filled with the given color
+	 * @param rgb the color to fill the image with
+	 * @return imagedata of a 16x16 image filled with the given color
+	 */
+	static ImageData createColorImage(RGB rgb) {
+		PaletteData colors = new PaletteData(new RGB[] { rgb, new RGB(0,0,0) });
+		ImageData data = new ImageData(16, 16, 1, colors);
+		for(int i = 0; i < 16; i++)
+		{
+			for(int j = 0; j < 16; j++)
+			{
+				if(j == 0 || j == 15 || i == 0 || i == 15) //Black border
+					data.setPixel(i, j, 1);
+				else
+					data.setPixel(i, j, 0);
+			}
+		}
+		return data;
+	}
+	
+	/**
+	 * creates a 16x16 image representing the given {@link GmmlColorGradient}
+	 * @param cg the gradient to create the image from
+	 * @return imagedata representing the gradient
+	 */
+	static ImageData createGradientImage(ColorGradient cg)
+	{
+		PaletteData colors = new PaletteData(0xFF0000, 0x00FF00, 0x0000FF);
+		ImageData data = new ImageData(16, 16, 24, colors);
+		double[] minmax = cg.getMinMax();
+		for(int i = 0; i < 16; i++)
+		{
+			RGB rgb = SwtUtils.color2rgb(cg.getColor(minmax[0] + (i * (minmax[1]- minmax[0])) / 16 ));
+			if(rgb == null)
+				rgb = new RGB(255,255,255);
+			for(int j = 0; j < 16; j++)
+			{
+				if(j == 0 || j == 15 || i == 0 || i == 15) //Black border
+					data.setPixel(i, j, colors.getPixel(new RGB(0,0,0)));
+				else
+					data.setPixel(i, j, colors.getPixel(rgb));
+			}
+		}
+		return data;
+	}
+
+
+	public void visualizationEvent(VisualizationEvent e) {
+		switch(e.type) {
+		case(VisualizationEvent.COLORSET_MODIFIED):
+			if(objectsTable != null && !objectsTable.getTable().isDisposed())
+				objectsTable.refresh();
+		}
+		
+	}
+	
+    private class ColorSetObjectDragAdapter extends DragSourceAdapter {
+    	public void dragStart(DragSourceEvent e) {
+    		e.doit = getSelectedObject() == null ? false : true;
+    	}
+    	
+    	public void dragSetData(DragSourceEvent e) {
+    		ColorSetObject selected = getSelectedObject();
+    		int csoIndex = colorSet.colorSetObjects.indexOf(selected);
+    		e.data = Integer.toString(csoIndex);
+    	}
+    }
+    
+    private class ColorSetObjectDropAdapter extends DropTargetAdapter {
+    	public void drop(DropTargetEvent e) {
+    		TableItem item = (TableItem)e.item;
+    		if(item != null)
+    		{
+    			Object selected = item.getData();
+    			int index = Integer.parseInt((String)e.data);
+    			if(index >= 0) {
+    				ColorSetObject cso = colorSet.getObjects().get(index);
+    				Utils.moveElement(colorSet.getObjects(), cso, colorSet.getObjects().indexOf(selected));
+    				objectsTable.refresh();
+    			}
+    		}
+    	}
+    }
+}

Property changes on: trunk/src/g2d_swt/org/pathvisio/visualization/colorset/ColorSetComposite.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/visualization/colorset/Criterion.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/visualization/colorset/Criterion.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/visualization/colorset/Criterion.java	(revision 957)
@@ -0,0 +1,574 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.colorset;
+
+import java.util.HashMap;
+
+import org.eclipse.swt.widgets.Composite;
+import org.pathvisio.Engine;
+import org.pathvisio.data.Gex;
+import org.pathvisio.data.Gex.Sample;
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+
+public class Criterion {
+	static final String displaySample = "|Displayed sample|";
+	public static final String[] tokens = {"AND", "OR", "=", "<", ">", "<=", ">="};
+	private HashMap<String, Double> symTab;
+
+	private String expression;
+		
+	private Exception parseException;
+	
+	CriterionComposite configComp;
+		
+	public String getExpression() {  
+		return expression == null ? "" : expression; 
+	}
+	
+	public boolean setExpression(String expression) {
+		this.expression = expression;
+		fireModifiedEvent();
+		return testExpression(expression);
+	}
+	
+	public boolean setExpression(String expression, String[] symbols) {
+		//Evaluate with dummy data:
+		this.expression = expression;
+		fireModifiedEvent();
+		return testExpression(expression, symbols);
+	}
+	
+	public boolean testExpression(String expression) {
+		try {
+			evaluate(expression);
+			parseException = null;
+			return true;
+		} catch(Exception e) { 
+			parseException = e;
+			return false;
+		}
+	}
+	
+	public boolean testExpression(String expression, String[] symbols) {
+		for(String s : symbols) {
+			addSymbol(s, 1.0);
+		}
+		return testExpression(expression);
+	}
+	
+	public Exception getParseException() { 
+		return parseException;
+	}
+
+	void setSampleData(HashMap<Integer, Object> data) {
+		// Add current sample values to symTab if they are of type Double
+		HashMap<Integer, Sample> samples = Gex.getSamples();
+		clearSymbols();
+		for(Sample s : samples.values()) {
+			Object value = data.get(s.getId());
+			if(value instanceof Double) addSymbol(s.getName(), (Double)value);
+		}
+	}
+	
+	public boolean evaluate(HashMap<Integer, Object> data, int displaySampleId) throws Exception {
+		setSampleData(data);
+		Object value = data.get(displaySampleId);
+		if(value instanceof Double) addSymbol(displaySample, (Double)value);
+
+		return evaluate(expression);
+	}
+	
+	public boolean evaluate(HashMap<Integer, Object> data) throws Exception {
+		setSampleData(data);
+		return evaluate(expression);
+	}
+	
+	public boolean evaluate(String[] symbols, double[] values) throws Exception {
+		clearSymbols();
+		for(int i = 0; i < symbols.length; i++) {
+			symTab.put(symbols[i], values[i]);
+		}
+		return evaluate(expression);
+	}
+
+	public void addSymbol(String sym, Double val)
+	{
+		if(symTab == null) symTab = new HashMap<String, Double>();
+		symTab.put(sym, val);
+	}
+
+	void clearSymbols()
+	{
+		if(symTab == null) return;
+		symTab.clear();
+	}
+		
+	public CriterionComposite getConfigComposite() {
+		return configComp;
+	}
+	
+	public CriterionComposite createConfigComposite(Composite parent) {
+		if(configComp != null && !configComp.isDisposed()) return configComp;
+		configComp = new CriterionComposite(parent, this);
+		return configComp;
+	}
+	
+	void fireModifiedEvent() {
+		VisualizationManager.fireVisualizationEvent(
+				new VisualizationEvent(this, VisualizationEvent.COLORSET_MODIFIED));
+	}
+	//Boolean expression parser by Martijn
+	String input;
+	int charNr;
+	boolean evaluate (String expr) throws Exception
+	{
+		Token e = parse(expr);
+		return e.evaluateAsBool();
+	}
+
+	Token parse(String expr) throws Exception {
+		charNr = 0;
+		input = expr;
+
+		Token e = expression();
+		Token t = getToken();
+		if (t.type != Token.TOKEN_END)
+		{
+			nextToken = null;
+			throw new Exception("Multiple expressions found, second expression " +
+					"starts at position " + charNr);
+		}
+		return e;
+	}
+	
+	char eatChar()
+	{
+		if (input.length() == 0)
+		{
+			return '\0';
+		}
+		else
+		{
+			charNr++;
+			char result = input.charAt(0);
+			input = input.substring(1);
+			return result;
+		}
+	}
+
+	void putBack(char ch)
+	{
+		if (input.length() == 0 && ch == '\0')
+		{
+		}
+		else
+		{
+			input = ch + input;
+		}
+	}
+
+	Token nextToken = null;
+
+	Token getLookAhead() throws Exception
+	{
+		nextToken = getToken();
+		return nextToken;
+	}
+
+	// note: token is taken away from input!
+	Token getToken() throws Exception
+	{      
+		Token token = null;
+		if (nextToken != null)
+		{
+			token = nextToken;
+			nextToken = null;
+			return token;
+		}
+
+		// eat whitespace
+		char ch = eatChar();
+
+		while (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r')
+		{
+			ch = eatChar();
+		}
+
+		// read token
+		switch (ch)
+		{
+		case '-':
+		case '0': case '1': case '2': case '3': case '4':
+		case '5': case '6': case '7': case '8': case '9':
+		case '.': {
+			String value = "" + ch;
+			ch = eatChar();
+			while ((ch >= '0' && ch <= '9') || ch == '.')
+			{
+				value += ch;
+				ch = eatChar();
+			}
+			putBack (ch);									
+			token = new Token(Token.TOKEN_NUMBER, Double.parseDouble(value)); }                            
+		break;
+		case '<':
+			ch = eatChar();
+			if (ch == '=')
+				token = new Token(Token.TOKEN_LE);	
+			else
+			{
+				token = new Token(Token.TOKEN_LT);
+				putBack (ch);
+			}
+			break;
+		case '>':
+			ch = eatChar();
+			if (ch == '=')
+				token = new Token(Token.TOKEN_GE);	
+			else
+			{
+				token = new Token(Token.TOKEN_GT);
+				putBack (ch);
+			}
+			break;
+		case '=': 
+			token = new Token(Token.TOKEN_EQ);
+			break;
+		case '(': 
+			token = new Token(Token.TOKEN_LPAREN);
+			break;
+		case ')': 
+			token = new Token(Token.TOKEN_RPAREN);
+			break;
+		case '[': {
+			ch = eatChar();
+			String value = "";
+			while (ch != ']' && ch != '\0')
+			{
+				value += ch;
+				ch = eatChar();
+			}
+			token = new Token(Token.TOKEN_ID, value);                 
+		} break;
+		case 'A':	
+
+			if (eatChar() == 'N' && eatChar() == 'D')
+			{
+				token = new Token (Token.TOKEN_AND);
+			}
+			else
+			{
+				throw new Exception("Invalid character 'A' at position " + (charNr - 2) + 
+				"\n- Expected start of 'AND'");
+			}
+			break;
+		case 'O':
+			ch = eatChar();
+			if (ch == 'R')
+			{
+				token = new Token (Token.TOKEN_OR);
+			}
+			else
+			{
+				throw new Exception("Invalid character 'O' at position " + (charNr - 1) + 
+				"\n- Expected start of 'OR'");
+			}
+			break;
+		case '\0':
+			token = new Token (Token.TOKEN_END);
+			break;
+		default:
+			throw new Exception("Unexpected end of expression at position " + charNr);
+		}
+		//~ System.out.print (token.type + ", ");
+		return token;
+	}
+
+	/*
+		eats a factor
+			forms:
+			- number
+			- identifier
+			- "(" expression ")"
+	 */
+	Token factor() throws Exception
+	{
+		Token result;
+		Token t = getLookAhead();
+		if (t.type == Token.TOKEN_NUMBER)
+		{
+			getToken();
+			result = t;
+		}
+		else if (t.type == Token.TOKEN_ID)
+		{
+			getToken();
+			result = t;
+		}
+		else if (t.type == Token.TOKEN_LPAREN)
+		{
+			getToken();
+			result = expression();
+			t = getToken();			
+			if (t.type != Token.TOKEN_RPAREN)
+			{
+				nextToken = null;
+				throw new Exception("Number of opening and closing brackets does not match");
+			}			
+		}
+		else
+		{
+			nextToken = null;
+			throw new Exception("Wrong token at position " + charNr);
+		}
+		return result;
+	}
+
+
+	/*
+		eats a subterm
+			forms:
+			subterm -> factor morefactors
+			morefactors -> "<=|=|>=|>|<" factor morefactors
+						| empty
+	 */
+	Token subterm() throws Exception
+	{
+		Token result;
+		result = factor();
+		while (true)
+		{
+			Token t = getLookAhead();
+			if (t.type == Token.TOKEN_EQ || t.type == Token.TOKEN_GE ||
+					t.type == Token.TOKEN_LE || t.type == Token.TOKEN_GT ||
+					t.type == Token.TOKEN_LT)
+			{
+				getToken();
+				t.left = result;
+				t.right = subterm();
+				result = t;
+			}
+			else
+			{
+				return result;
+			}
+		}		
+	}
+
+	/*
+		eats a term
+			forms:
+			term -> subterm moresubterms
+			moresubterms -> "AND" subterm moresubterms
+						| empty
+	 */
+	Token term() throws Exception
+	{
+		Token result;
+		result = subterm();
+		while (true)
+		{
+			Token t = getLookAhead();
+			if (t.type == Token.TOKEN_AND)
+			{
+				getToken();
+				t.left = result;
+				t.right = term();
+				result = t;
+			}
+			else
+			{
+				return result;
+			}
+		}
+	}
+
+
+	/* eats an expression
+			forms:
+			expression -> term moreterms
+			moreterms -> "OR" term moreterms
+				| empty
+	 */
+	Token expression() throws Exception
+	{
+		Token result;
+		result = term();
+		while (true)
+		{
+			Token t = getLookAhead();
+			if (t.type == Token.TOKEN_OR)
+			{
+				getToken();
+				t.left = result;			
+				t.right = expression();
+				result = t;
+			}
+			else
+			{
+				return result;
+			}				
+		}
+	}
+
+	/**
+	 * This class represents a single token of an expression
+	 */
+	class Token {
+		public int type;
+		public static final int TOKEN_NONE = -2;
+		public static final int TOKEN_END = -1;
+		public static final int TOKEN_NUMBER = 0;
+		public static final int TOKEN_ID = 1;
+		public static final int TOKEN_EQ = 2;
+		public static final int TOKEN_GT = 3;
+		public static final int TOKEN_LT = 4;
+		public static final int TOKEN_GE = 5;
+		public static final int TOKEN_LE = 6;
+		public static final int TOKEN_AND = 7;
+		public static final int TOKEN_OR = 8;
+		public static final int TOKEN_LPAREN = 9;
+		public static final int TOKEN_RPAREN = 10;
+
+		public double numberValue; // in case it is a number...
+		public String symbolValue; // in case it is a symbol
+
+		Token left = null;
+		Token right = null;
+
+		void printMe (int level)
+		{
+			for (int i = 0; i < level; ++i)
+			{
+				Engine.log.trace ("--- ");
+			}
+			switch (type)
+			{
+			case Token.TOKEN_AND:
+				Engine.log.trace("AND");
+				left.printMe(level + 1);
+				right.printMe(level + 1);
+				break;
+			case Token.TOKEN_OR:
+				Engine.log.trace("OR");
+				left.printMe(level + 1);
+				right.printMe(level + 1);
+				break;
+			case Token.TOKEN_LE:
+				Engine.log.trace("<=");
+				left.printMe(level + 1);
+				right.printMe(level + 1);
+				break;
+			case Token.TOKEN_LT:
+				Engine.log.trace("<");
+				left.printMe(level + 1);
+				right.printMe(level + 1);
+				break;
+			case Token.TOKEN_GT:
+				Engine.log.trace(">");
+				left.printMe(level + 1);
+				right.printMe(level + 1);
+				break;
+			case Token.TOKEN_GE:
+				Engine.log.trace(">=");
+				left.printMe(level + 1);
+				right.printMe(level + 1);
+				break;
+			case Token.TOKEN_EQ:
+				Engine.log.trace("=");
+				left.printMe(level + 1);
+				right.printMe(level + 1);
+				break;
+			case Token.TOKEN_ID:
+				Engine.log.trace("ID: " + symbolValue);
+				break;
+			case Token.TOKEN_NUMBER:
+				Engine.log.trace("NUMBER: " + numberValue);
+				break;
+			}
+		}
+
+		boolean evaluateAsBool() throws Exception
+		{
+			switch (type)
+			{
+			case Token.TOKEN_AND:
+				if (left.evaluateAsBool() && right.evaluateAsBool())
+					return true;
+				else
+					return false;
+			case Token.TOKEN_OR:
+				if (left.evaluateAsBool() || right.evaluateAsBool())
+					return true;
+				else
+					return false;
+			case Token.TOKEN_EQ:
+				if (left.evaluateAsDouble() == right.evaluateAsDouble())
+					return true;
+				else
+					return false;
+			case Token.TOKEN_GE:
+				if (left.evaluateAsDouble() >= right.evaluateAsDouble())
+					return true;
+				else
+					return false;
+			case Token.TOKEN_LE:
+				if (left.evaluateAsDouble() <= right.evaluateAsDouble())
+					return true;
+				else
+					return false;
+			case Token.TOKEN_GT:
+				if (left.evaluateAsDouble() > right.evaluateAsDouble())
+					return true;
+				else
+					return false;
+			case Token.TOKEN_LT:
+				if (left.evaluateAsDouble() < right.evaluateAsDouble())
+					return true;
+				else
+					return false;
+			}
+			throw new Exception("Can't evaluate this expression as boolean");
+		}
+
+		double evaluateAsDouble() throws Exception
+		{
+			String error = "";
+			switch (type)
+			{
+			case Token.TOKEN_ID:
+				if(!symTab.containsKey(symbolValue)) {//symbol has no value
+					error = "Sample '[" + symbolValue + "]' has no value";
+					break;
+				}
+				return (Double)symTab.get(symbolValue);
+			case Token.TOKEN_NUMBER:
+				return numberValue;
+			default:
+				error = "Can't evaluate this expression as numeric";
+			}
+			throw new Exception(error);
+		}
+
+		Token (int _type) { type = _type; numberValue = 0; symbolValue = ""; }
+		Token (int _type, double _numberValue) { type = _type; numberValue = _numberValue; symbolValue = ""; }
+		Token (int _type, String _symbolValue) { type = _type; numberValue = 0; symbolValue = _symbolValue; }
+	}
+}
+
+

Property changes on: trunk/src/g2d_swt/org/pathvisio/visualization/colorset/Criterion.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/visualization/VisualizationManager.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/visualization/VisualizationManager.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/visualization/VisualizationManager.java	(revision 957)
@@ -0,0 +1,429 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.EventObject;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.eclipse.jface.action.ContributionItem;
+import org.eclipse.jface.action.ControlContribution;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.ScrolledComposite;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Combo;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Label;
+import org.jdom.Document;
+import org.jdom.Element;
+import org.jdom.input.SAXBuilder;
+import org.jdom.output.Format;
+import org.jdom.output.XMLOutputter;
+import org.pathvisio.Engine;
+import org.pathvisio.Engine.ApplicationEvent;
+import org.pathvisio.Engine.ApplicationEventListener;
+import org.pathvisio.data.Gex;
+import org.pathvisio.data.Gex.ExpressionDataEvent;
+import org.pathvisio.data.Gex.ExpressionDataListener;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.view.Graphics;
+import org.pathvisio.view.SelectionBox;
+import org.pathvisio.view.SelectionBox.SelectionListener;
+
+/**
+ * Manages visualizations
+ * @author thomas
+ *
+ */
+public class VisualizationManager implements ApplicationEventListener, ExpressionDataListener {	
+	static {
+		VisualizationManager vm = new VisualizationManager();
+		Engine.addApplicationEventListener(vm);
+		Gex.addListener(vm);
+	}
+	
+	public static final String XML_ELEMENT = "visualizations";
+		
+	static final String FILENAME_GENERIC = "visualizations.xml";
+	
+	static final int CURRENT_NONE = -1;
+	
+	static List<Visualization> visualizations = new ArrayList<Visualization>();
+	static int current = -1;
+		
+	public static Visualization getCurrent() {
+		if(current < 0 || current >= visualizations.size()) return null;
+		return visualizations.get(current);
+	}
+	
+	public static void setCurrent(int index) {
+		current = index;
+		fireVisualizationEvent(
+				new VisualizationEvent(null, VisualizationEvent.VISUALIZATION_SELECTED));
+	}
+	
+	public static void setCurrent(Visualization v) {
+		int index = getVisualizations().indexOf(v);
+		if(index > -1) setCurrent(index);
+	}
+	
+	public static List<Visualization> getVisualizations() {
+		return visualizations;
+	}
+	
+	public static List<Visualization> getGeneric() {
+		List<Visualization> generic = new ArrayList<Visualization>();
+		for(Visualization v : visualizations) if(v.isGeneric()) generic.add(v);
+		return generic;
+	}
+	
+	public static List<Visualization> getNonGeneric() {
+		List<Visualization> nongeneric = new ArrayList<Visualization>();
+		for(Visualization v : visualizations) if(!v.isGeneric()) nongeneric.add(v);
+		return nongeneric;
+	}
+	
+	public static String[] getNames() {
+		String[] names = new String[visualizations.size()];
+		for(int i = 0; i < names.length; i++) 
+			names[i] = visualizations.get(i).getName();
+		return names;
+	}
+	
+	public static void addVisualization(Visualization v) {
+		visualizations.add(v);
+		fireVisualizationEvent(
+				new VisualizationEvent(null, VisualizationEvent.VISUALIZATION_ADDED));
+	}
+	
+	public static void removeVisualization(int index) {
+		if(index < 0 || index >= visualizations.size()) return; //Ignore wrong index
+		visualizations.remove(index);
+		fireVisualizationEvent(
+				new VisualizationEvent(null, VisualizationEvent.VISUALIZATION_REMOVED));
+	}
+	
+	public static void removeVisualization(Visualization v) {
+		removeVisualization(visualizations.indexOf(v));
+	}
+	
+	public static String getNewName() {
+		String prefix = "visualization";
+		int i = 1;
+		String name = prefix;
+		while(nameExists(name)) name = prefix + "-" + i++;
+		return name;
+	}
+	
+	public static boolean nameExists(String name) {
+		for(Visualization v : visualizations) 
+			if(v.getName().equalsIgnoreCase(name)) return true;
+		return false;
+	}
+	
+	public void saveGeneric() {
+		Document xmlDoc = new Document();
+		Element root = new Element(XML_ELEMENT);
+
+		for(Visualization v : visualizations) {
+			if(v.isGeneric()) root.addContent(v.toXML());
+		}
+		xmlDoc.addContent(root);
+		
+		XMLOutputter out = new XMLOutputter(Format.getPrettyFormat());
+		try {
+			FileWriter fw = new FileWriter(getGenericFile());
+			out.output(xmlDoc, fw);
+			fw.close();
+		} catch(IOException e) {
+			Engine.log.error("Unable to save visualization settings", e);
+		}
+	}
+	
+	public static void loadGeneric() {
+		if(!getGenericFile().exists()) return; //No generic visualizations saved yet
+		SAXBuilder parser = new SAXBuilder();
+		try {
+			Document doc = parser.build(getGenericFile());
+			Element root = doc.getRootElement();
+			for(Object o : root.getChildren(Visualization.XML_ELEMENT)) {
+				visualizations.add(Visualization.fromXML((Element) o));				
+			}
+		} catch(Exception e) {
+			Engine.log.error("Unable to load visualization settinsg", e);
+		}
+	}
+	
+	public static Element getNonGenericXML() {
+		Element xml = new Element(XML_ELEMENT);
+		
+		for(Visualization v : getNonGeneric()) xml.addContent(v.toXML());
+		
+		return xml;
+	}
+	
+	public static void loadNonGenericXML(Element xml) {		
+		if(xml == null) return;
+		
+		for(Object o : xml.getChildren(Visualization.XML_ELEMENT)) {
+			Visualization vis = Visualization.fromXML((Element) o);
+			if(!visualizations.contains(vis)) addVisualization(vis);				
+		}
+	}
+	
+	static void removeNonGeneric() {
+		List<Visualization> toRemove = new ArrayList<Visualization>();
+		for(Visualization v : getVisualizations()) {
+			if(!v.isGeneric()) toRemove.add(v);
+		}
+		for(Visualization v : toRemove) removeVisualization(v);
+	}
+	
+	static File getGenericFile() {
+		return new File(SwtEngine.getApplicationDir(), FILENAME_GENERIC);
+	}
+	
+	static VisComboItem visComboItem = new VisComboItem("VisualizationCombo");
+	public static ContributionItem getComboItem() {
+		return visComboItem;
+	}
+	
+	static VisualizationPanel sidePanel;
+		
+	public static Composite getSidePanel() {
+		return sidePanel;
+	}
+	public static Composite createSidePanel(Composite parent) {
+		if(sidePanel != null && !sidePanel.isDisposed()) sidePanel.dispose();
+		sidePanel = new VisualizationPanel(parent, SWT.NULL);
+		return sidePanel;
+	}
+	
+	static class VisComboItem extends ControlContribution implements VisualizationListener {
+		final String NONE = "no visualization";
+		Combo visCombo;
+		
+		public VisComboItem(String id) {
+			super(id);
+			addListener(this);
+		}
+
+		protected Control createControl(Composite parent) {
+			Composite control = new Composite(parent, SWT.NULL);
+			GridLayout layout = new GridLayout(2, false);
+			layout.marginHeight = layout.marginWidth = 1;
+			control.setLayout(layout);
+			
+			Label label = new Label(control, SWT.CENTER);
+			label.setText("Visualization: ");
+			visCombo = new Combo(control, SWT.DROP_DOWN | SWT.READ_ONLY);
+			visCombo.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+			visCombo.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					setCurrent(visCombo.getSelectionIndex() - 1);
+				}
+			});
+			visCombo.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					setCurrent(visCombo.getSelectionIndex() - 1);
+				}
+			});
+			update();
+			return control;
+		}
+		
+		public void update() {
+			if(visCombo == null) return;
+			
+			String[] visnames = getNames();
+			String[] items = new String[visnames.length + 1];
+			items[0] = NONE;
+			for(int i = 1; i < items.length; i++) items[i] = visnames[i-1];
+			visCombo.setItems(items);
+			visCombo.select(current + 1);
+		}
+
+		public void visualizationEvent(VisualizationEvent e) {
+			switch(e.type) {
+			case(VisualizationEvent.VISUALIZATION_ADDED):
+			case(VisualizationEvent.VISUALIZATION_REMOVED):
+			case(VisualizationEvent.VISUALIZATION_MODIFIED):
+				visCombo.getDisplay().syncExec(new Runnable() {
+					public void run() {
+						update();
+					}
+				});
+			}
+			
+		}
+	}
+	
+	static class VisualizationPanel extends ScrolledComposite implements SelectionListener, VisualizationListener {
+		Visualization vis;
+		Composite contents;
+		Set<Graphics> input;
+		
+		public VisualizationPanel(Composite parent, int style) {
+			super(parent, style);
+			createContents();
+			SelectionBox.addListener(this);
+			VisualizationManager.addListener(this);
+			input = new LinkedHashSet<Graphics>();
+		}
+		
+		void createContents() {
+			contents = new Composite(this, SWT.NULL);
+			contents.setBackground(getDisplay().getSystemColor(SWT.COLOR_WHITE));
+			setContent(contents);
+			setExpandHorizontal(true);
+			setExpandVertical(true);
+			contents.setLayout(new FillLayout());
+			setMinSize(contents.computeSize(SWT.DEFAULT, SWT.DEFAULT));
+		}
+		
+		void fillContents() {
+			if(vis != null) {
+				vis.disposeSidePanel();
+				vis.createSideSidePanel(contents);
+			}
+		}
+		
+		public void setVisualization(Visualization v) {
+			if(vis != null) vis.disposeSidePanel();
+			vis = v;
+			fillContents();
+		}
+		
+		void addInput(Graphics g) {
+			input.add(g);
+			refresh();
+		}
+		
+		void removeInput(Graphics g) {
+			input.remove(g);
+			refresh();
+		}
+		
+		void clearInput() {
+			input.clear();
+			refresh();
+		}
+		
+		void refresh() {
+			if(vis != null) vis.visualizeSidePanel(input);
+			layout(true, true);
+		}
+
+		public void drawingEvent(SelectionBox.SelectionEvent e) {
+			switch(e.type) {
+			case SelectionBox.SelectionEvent.OBJECT_ADDED:
+				if(e.affectedObject instanceof Graphics) 
+					addInput((Graphics)e.affectedObject);
+				break;
+			case SelectionBox.SelectionEvent.OBJECT_REMOVED:
+				if(e.affectedObject instanceof Graphics) 
+					removeInput((Graphics)e.affectedObject);
+				break;
+			case SelectionBox.SelectionEvent.SELECTION_CLEARED:
+				clearInput();
+			}
+		}
+
+		public void visualizationEvent(VisualizationEvent e) {
+			switch(e.type) {
+			case VisualizationEvent.VISUALIZATION_SELECTED:
+				setVisualization(getCurrent());
+			case VisualizationEvent.PLUGIN_SIDEPANEL_ACTIVATED:
+				fillContents();
+			}
+			
+		}		
+	}
+	
+	public void applicationEvent(ApplicationEvent e) {
+		if(e.type == ApplicationEvent.APPLICATION_CLOSE) {
+			saveGeneric();
+		}		
+	}
+	
+	static List<VisualizationListener> listeners;
+
+	/**
+	 * Add a {@link ExpressionDataListener}, that will be notified if an
+	 * event related to visualizations occurs
+	 * @param l The {@link ExpressionDataListener} to add
+	 */
+	public static void addListener(VisualizationListener l) {
+		if(listeners == null)
+			listeners = new ArrayList<VisualizationListener>();
+		listeners.add(l);
+	}
+
+	/**
+	 * Fire a {@link VisualizationEvent} to notify all {@link VisualizationListener}s registered
+	 * to this class
+	 * @param e
+	 */
+	public static void fireVisualizationEvent(VisualizationEvent e) {
+		for(VisualizationListener l : listeners) {
+			l.visualizationEvent(e);
+		}
+	}
+
+	public interface VisualizationListener {
+		public void visualizationEvent(VisualizationEvent e);
+	}
+
+	public static class VisualizationEvent extends EventObject {
+		private static final long serialVersionUID = 1L;
+		public static final int COLORSET_ADDED = 0;
+		public static final int COLORSET_REMOVED = 1;
+		public static final int COLORSET_MODIFIED = 2;
+		public static final int VISUALIZATION_ADDED = 3;
+		public static final int VISUALIZATION_REMOVED = 4;
+		public static final int VISUALIZATION_MODIFIED = 5;
+		public static final int VISUALIZATION_SELECTED = 6;
+		public static final int PLUGIN_MODIFIED = 7;
+		public static final int PLUGIN_ADDED = 8;
+		public static final int PLUGIN_SIDEPANEL_ACTIVATED = 9;
+
+		public Object source;
+		public int type;
+
+		public VisualizationEvent(Object source, int type) {
+			super(source == null ? VisualizationManager.class : source);
+			this.source = source;
+			this.type = type;
+		}
+	}
+
+	public void expressionDataEvent(ExpressionDataEvent e) {
+		if(e.type == ExpressionDataEvent.CONNECTION_CLOSED) {
+			removeNonGeneric();
+		}
+	}
+}

Property changes on: trunk/src/g2d_swt/org/pathvisio/visualization/VisualizationManager.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/visualization/LegendPanel.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/visualization/LegendPanel.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/visualization/LegendPanel.java	(revision 957)
@@ -0,0 +1,788 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization;
+
+import static org.pathvisio.visualization.LegendPanel.FONT;
+
+import java.util.ArrayList;
+import java.util.EventObject;
+import java.util.List;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.CLabel;
+import org.eclipse.swt.custom.ScrolledComposite;
+import org.eclipse.swt.custom.StackLayout;
+import org.eclipse.swt.events.MouseAdapter;
+import org.eclipse.swt.events.MouseEvent;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.events.PaintListener;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.Font;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.RGB;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Canvas;
+import org.eclipse.swt.widgets.Combo;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Group;
+import org.eclipse.swt.widgets.Label;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.util.SwtUtils;
+import org.pathvisio.visualization.LegendPanel.CollapseGroup.CollapseListener;
+import org.pathvisio.visualization.Visualization.PluginSet;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+import org.pathvisio.visualization.VisualizationManager.VisualizationListener;
+import org.pathvisio.visualization.colorset.ColorCriterion;
+import org.pathvisio.visualization.colorset.ColorGradient;
+import org.pathvisio.visualization.colorset.ColorSet;
+import org.pathvisio.visualization.colorset.ColorSetManager;
+import org.pathvisio.visualization.colorset.ColorSetObject;
+import org.pathvisio.visualization.colorset.ColorGradient.ColorValuePair;
+import org.pathvisio.visualization.plugins.VisualizationPlugin;
+
+/**
+ * This class shows a legend for the currently loaded visualization and color-sets.
+ * @author Thomas
+ *
+ */
+public class LegendPanel extends ScrolledComposite implements VisualizationListener {
+	static final String FONT = "arial narrow";
+	static final int FONTSIZE = 8;
+
+	Button combine; //Checkbutton to show all colorsets or not
+	Boolean doCombine = true;	//true: all colorsets are shown, false: only colorSetCombo selection
+	
+	ColorSet colorSet; //Currently selected color-set
+
+	ColorSetComposite colorSets;
+	PluginComposite plugins;
+	
+	CollapseGroup colorSetGroup;
+	CollapseGroup pluginGroup;
+
+	Combo colorSetCombo;
+
+	public LegendPanel(Composite parent, int style)
+	{
+		super(parent, style);
+
+		createContents();
+		rebuildContent();
+		VisualizationManager.addListener(this);
+	}
+
+	/**
+	 * Set the color-set to show in the legend (ignored if doCombine)
+	 * @param input The color-set to show in the legend
+	 */
+	public void setInput(ColorSet input) {
+		colorSet = input;
+		refreshContent();
+	}
+
+	/**
+	 * Rebuild the contents of the legend (refresh the names
+	 * in colorSetCombo and refresh the content)
+	 */
+	public void rebuildContent() {
+		combine.setSelection(true);
+		
+		String[] names = ColorSetManager.getColorSetNames();
+		colorSetCombo.setItems(names);
+		if(names.length == 0) {
+			colorSetCombo.setEnabled(false);
+		}
+		else {
+			colorSetCombo.setEnabled(!doCombine);
+			colorSetCombo.select(0);
+		}
+		
+		refreshContent();
+	}
+	
+	/**
+	 * Set whether the legend has to show all color-sets or only the one
+	 * selected in colorSetCombo
+	 * @param comb if true all color-sets are shown, if false only the one selected
+	 * in colorSetCombo is shown
+	 */
+	void setCombine(boolean comb) {
+		doCombine = comb;
+		colorSetCombo.setEnabled(!doCombine);
+		setInput(ColorSetManager.getColorSets().get(colorSetCombo.getSelectionIndex()));
+	}
+	
+	/**
+	 * Refresh the content of the legend
+	 */
+	void refreshContent() {		
+		if(!isDisposed()) {
+			colorSets.refresh();
+			plugins.refresh();
+			rearrange();
+		}
+	}
+
+	/**
+	 * Rearrange the elements of the legend:
+	 * re-layout the elements and compute the minimum size
+	 * for the scrollbars
+	 */
+	void rearrange() {
+		layout();
+		colorSetGroup.rearrange();
+		pluginGroup.rearrange();
+		setMinSize(getContent().computeSize(SWT.DEFAULT, SWT.DEFAULT));
+	}
+	
+	/**
+	 * Create the contents of the legend
+	 */
+	void createContents() {	
+		Composite contents = new Composite(this, SWT.NULL);
+		setContent(contents);
+		setExpandHorizontal(true);
+		setExpandVertical(true);
+		contents.setLayout(new GridLayout());
+
+		Composite comboComp = createColorSetCombo(contents);
+		comboComp.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+
+		Composite legendComp = createLegendComp(contents);
+		legendComp.setLayoutData(new GridData(GridData.FILL_BOTH));
+
+		setChildrenBackground(contents);
+	}
+
+	/**
+	 * Set the background of the given {@link Composite} and all its children
+	 * to background color of the legend (SWT.COLOR_WHITE).
+	 * @param comp the {@link Composite} for which the background has to be set
+	 */
+	void setChildrenBackground(Composite comp) {
+		comp.setBackground(getDisplay().getSystemColor(SWT.COLOR_WHITE));
+		for(Control c : comp.getChildren()) {
+			c.setBackground(getDisplay().getSystemColor(SWT.COLOR_WHITE));
+			if(c instanceof Composite) setChildrenBackground((Composite) c);
+		}
+	}
+
+	/**
+	 * Creates the composite that holds the color-set combo to select
+	 *  the color-set to display
+	 * @param parent The parent composite
+	 * @return The {@link Composite} that displays the color-set combo
+	 */
+	Composite createColorSetCombo(Composite parent) {
+		Composite comboComp = new Composite(parent, SWT.NULL);
+		comboComp.setLayout(new GridLayout(2, false));
+		combine = new Button(parent, SWT.CHECK);
+		GridData span = new GridData(GridData.FILL_HORIZONTAL);
+		span.horizontalSpan = 2;
+		combine.setLayoutData(span);
+		combine.setText("Show all color-sets");
+		combine.addSelectionListener(new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				setCombine(combine.getSelection());
+			}
+		});
+		Label label = new Label(comboComp, SWT.NULL);
+		label.setText("Show color-set:");
+		colorSetCombo = new Combo(comboComp, SWT.READ_ONLY);
+		colorSetCombo.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+		colorSetCombo.addSelectionListener(new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				setInput(ColorSetManager.getColorSets().get(colorSetCombo.getSelectionIndex()));
+			}
+		});
+		return comboComp;
+	}
+
+	/**
+	 * Create the {@link Composite} that holds the legend contents
+	 * @param parent The parent {@link Composite}
+	 * @return The {@link Composite} that holds the legend contents
+	 */
+	Composite createLegendComp(Composite parent) {
+		Composite legendComp = new Composite(parent, SWT.NULL);
+		GridLayout legendGrid = new GridLayout();
+		legendGrid.marginWidth = legendGrid.marginLeft = legendGrid.marginRight = 0;
+		legendComp.setLayout(legendGrid);
+
+		colorSetGroup = new CollapseGroup(legendComp, SWT.NULL);
+		pluginGroup = new CollapseGroup(legendComp, SWT.NULL);
+
+		colorSets = new ColorSetComposite(colorSetGroup.getGroup(), SWT.NONE);
+		plugins = new PluginComposite(pluginGroup.getGroup(), SWT.NONE);
+
+		colorSetGroup.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+		pluginGroup.setLayoutData(new GridData(GridData.FILL_BOTH));
+		
+		colorSetGroup.setText("Color-sets");
+		pluginGroup.setText("Plug-ins");
+
+		colorSetGroup.getGroup().setLayout(new FillLayout());
+		pluginGroup.getGroup().setLayout(new FillLayout());
+		
+		CollapseListener cl = new CollapseListener() {
+			public void stateChanged(LegendPanel.CollapseGroup.CollapseEvent e) {
+				rearrange();
+			}
+		};
+		
+		colorSetGroup.addCollapseListener(cl);
+		pluginGroup.addCollapseListener(cl);
+
+		return legendComp;
+	}
+
+	/**
+	 * This class displays a legend for every {@link VisualizaitonPlugin} that is activated
+	 * on the drawing for the currently selected {@link Visualization} 
+	 * and implements the method {@link VisualizationPlugin#createLegendComposite(Composite)}
+	 * @author Thomas
+	 *
+	 */
+	private class PluginComposite extends Composite
+	{
+		public PluginComposite(Composite parent, int style) {
+			super(parent, style);
+			setLayout(new GridLayout());
+			setChildrenBackground(this);
+		}
+		
+		/**
+		 * Refresh the contents. That is, reload the plug-in information
+		 * for the currently selected visualization and re-create their
+		 * legend-composites.
+		 */
+		public void refresh() {
+			for(Control c : getChildren()) c.dispose();
+			
+			Visualization v = VisualizationManager.getCurrent();
+			if(v == null) return;
+			
+			for(PluginSet ps : v.getPluginSetsDrawingOrder()) {
+				if(ps.isDrawing()) {
+					Group g = new Group(this, SWT.NULL);
+					g.setBackground(getBackground());
+					g.setLayoutData(new GridData(GridData.FILL_BOTH));
+					g.setLayout(new FillLayout());
+					g.setText(ps.getInstance().getName());
+					Composite c = ps.getDrawingPlugin().createLegendComposite(g);
+					if(c == null) g.dispose();
+				}
+			}
+			layout();
+		}
+	}
+	
+	/**
+	 * This class displays the legend for the color-sets.
+	 * @author Thomas
+	 */
+	private class ColorSetComposite extends Composite
+	{
+			public ColorSetComposite(Composite parent, int style) {
+				super(parent, style);
+				setLayout(new GridLayout());
+				setChildrenBackground(this);
+			}
+			
+			/**
+			 * Refresh the contents. That is, reload the color-set
+			 * information and re-create the {@link ColorSetGroup}s.
+			 */
+			public void refresh() {
+				for(Control c : getChildren()) c.dispose();
+				
+				if(doCombine) {
+					for(ColorSet cs : ColorSetManager.getColorSets()) {
+						drawColorSet(this, cs);
+					}
+				} else {
+					if(colorSet == null) return;
+					drawColorSet(this, colorSet);
+				}
+				
+				layout();
+			}
+			
+			/**
+			 * Create a {@link ColorSetGroup} for the given colorset
+			 * @param parent The parent {@link Composite} to create the {@link ColorSetGroup} on
+			 * @param cs The color-set to create the {@link ColorSetGroup} for
+			 */
+			void drawColorSet(Composite parent, ColorSet cs) {
+				ColorSetGroup csg = new ColorSetGroup(parent, SWT.NULL);
+				csg.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+				csg.setInput(cs);
+			}
+	}
+
+	/**
+	 * This class displays the legend for a single {@link ColorSet}
+	 * @author Thomas
+	 */
+	private class ColorSetGroup extends Composite
+	{
+		CriteriaComposite criteria;
+		GradientCanvas gradients;
+		Group group;
+		
+		ColorSet colorSet;
+		
+		public ColorSetGroup(Composite parent, int style) {
+			super(parent, style);
+			createContents();
+		}
+		
+		/**
+		 * Set the color-set of which the legend will be displayed
+		 * @param cs The color-set to display the legend of
+		 */
+		void setInput(ColorSet cs) {
+			colorSet = cs;
+			criteria.setInput(cs);
+			gradients.setInput(cs);
+			refresh();
+		}
+
+		void createContents() {
+			setLayout(new FillLayout());
+			group = new Group(this, SWT.NULL);
+			group.setLayout(new GridLayout());
+			criteria = new CriteriaComposite(group, SWT.NULL);
+			criteria.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+			gradients = new GradientCanvas(group, SWT.NULL);
+			gradients.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+			setChildrenBackground(this);
+		}
+		
+		public void refresh() {
+			if(colorSet != null) group.setText(colorSet.getName());
+			criteria.refresh();
+			gradients.refresh();
+		}
+		
+	}
+	
+	/**
+	 * This class shows the legend for all {@link ColorCriterion} in a color-set as well as
+	 * the 'special colors' ({@link ColorSet#COLOR_NO_GENE_FOUND}, {@link COLORSET#COLOR_NO_DATA_FOUND},
+	 * {@link ColorSet#COLOR_NO_CRITERIA_MET})
+	 * @author Thomas
+	 */
+	private class CriteriaComposite extends Composite
+	{
+		ColorSet colorSet; //The currently displayed color-set
+		
+		public CriteriaComposite(Composite parent, int style)
+		{
+			super(parent, style);
+			setChildrenBackground(this);
+		}
+
+		/**
+		 * Set the color-set to display the criteria legend for
+		 * @param cs
+		 */
+		void setInput(ColorSet cs) {
+			colorSet = cs;
+			refresh();
+		}
+		
+		final static int CLABEL_SIZE = 10; //Size of the colored labels
+		
+		public void refresh()
+		{
+			for(Control c : getChildren()) c.dispose();
+
+			if(colorSet == null) return;
+			drawColorSet(this, colorSet);
+		}
+		
+		/**
+		 * Create a {@Composite} that displays the criteria legend
+		 * @param parent The parent Composite
+		 * @param colorSet The color-set to display the legend for
+		 */
+		void drawColorSet(Composite parent, ColorSet colorSet) {			
+			Color c = null;
+			
+			parent.setLayout(new GridLayout(2, false));
+			
+			//Draw label for special criteria ('no gene found', 'no criteria met')
+			String[] specialLabels = {"No criteria met", "Gene not found", "No data found"};
+			RGB[] specialColors = {
+					SwtUtils.color2rgb(colorSet.getColor(ColorSet.ID_COLOR_NO_CRITERIA_MET)), 
+					SwtUtils.color2rgb(colorSet.getColor(ColorSet.ID_COLOR_NO_GENE_FOUND)),
+					SwtUtils.color2rgb(colorSet.getColor(ColorSet.ID_COLOR_NO_DATA_FOUND)) };
+
+			for(int i = 0; i < specialColors.length; i++)
+			{
+				c = SwtUtils.changeColor(c, specialColors[i], getDisplay());
+				createCriterionLabel(parent, specialLabels[i], c);
+			}
+
+			//Draw CLabel for every criterion
+			for(ColorSetObject co : colorSet.getObjects())
+			{
+				if(!(co instanceof ColorCriterion)) continue; //skip objects other than criretia
+				ColorCriterion cc = (ColorCriterion)co;
+				c = SwtUtils.changeColor(c, cc.getColor(), getDisplay());
+				createCriterionLabel(parent, cc.getName() + "\n(" + cc.getCriterion().getExpression() + ")", c);
+			}
+			
+			if(c != null) c.dispose();
+		}
+		
+		private void createCriterionLabel(Composite parent, String text, Color c)
+		{
+			GridData clabelGrid = new GridData(GridData.HORIZONTAL_ALIGN_BEGINNING);
+			clabelGrid.widthHint = CLABEL_SIZE;
+			clabelGrid.heightHint = CLABEL_SIZE;
+
+			CLabel cLabel = new CLabel(parent, SWT.SHADOW_IN);
+			Label label = new Label(parent, SWT.LEFT);
+
+			label.setBackground(getBackground());
+			label.setText(text);
+
+			cLabel.setBackground(c);
+			cLabel.setLayoutData(clabelGrid);
+		}
+	}
+
+	/**
+	 * This class displays the legend information for all {@link ColorGradient}s in
+	 * the given color-set
+	 * @author Thomas
+	 */
+	private class GradientCanvas extends Canvas implements PaintListener
+	{	
+		ColorSet colorSet; //The color-set to display the gradient information for
+		
+		public GradientCanvas(Composite parent, int style)
+		{
+			super(parent, style);
+			addPaintListener(this);
+		}
+
+		/**
+		 * Set the color-set to display the gradient legend for
+		 * @param input
+		 */
+		public void setInput(ColorSet input) {
+			colorSet = input;
+			refresh();
+		}
+		
+		public void refresh() {
+			layout();
+			redraw();
+		}
+
+		int getNrGradients() {
+			int n = 0;
+			for(ColorSetObject co : colorSet.getObjects()) {
+				if(co instanceof ColorGradient) n++;
+			}
+			return n;
+		}
+
+		public void paintControl (PaintEvent e)
+		{
+			if(colorSet == null) return;
+			
+			//Divide canvas in nr-gradients rows
+			Rectangle cla = getClientArea();
+			Point size = new Point(cla.width, cla.height);
+			int n = getNrGradients();
+			int i = 0;
+			for(ColorSetObject co : colorSet.getObjects()) {
+				if(co instanceof ColorGradient) {
+					ColorGradient cg = (ColorGradient)co;
+					Rectangle area = new Rectangle(
+							0, i++ * size.y / n,
+							size.x, size.y / n++);
+					drawColorGradient(e, cg, area);
+				}
+			}
+		}
+
+		public Point computeSize(int wHint, int hHint) {
+			if(colorSet == null) return new Point(0,0);
+						
+			int charw = SwtUtils.getAverageCharWidth(getDisplay());
+			int x = 0;
+			int nr = 0;
+			for(ColorSetObject co : colorSet.getObjects()) {
+				if(co instanceof ColorGradient) {
+					x = Math.max(x, co.getName().length() * charw);
+					nr++;
+				}
+			}
+			int y = nr * (MAX_BAR_HEIGHT + MARGIN_VERTICAL + LABEL_WIDTH);
+			return new Point(x, y);
+		}
+		
+		public Point computeSize(int wHint, int hHint, boolean changed) {
+			return computeSize(wHint, hHint);
+		}
+		
+		final static int LABEL_WIDTH = 20;
+		final static int MAX_BAR_HEIGHT = 10;
+		final static int MARGIN_VERTICAL = 20;
+		final static int MARGIN_HORIZONTAL = 15;
+		final static int MARKER_LENGTH = 4;
+		void drawColorGradient(PaintEvent e, ColorGradient cg, Rectangle r)
+		{
+			Color c = null;
+			RGB oldBackground = getBackground().getRGB();
+
+			double[] minmax = cg.getMinMax();
+			double min = minmax[0];
+			double max = minmax[1];
+
+			if((float)max == (float)min) {
+				return;
+			}
+
+			// Get region to draw
+			int yStart = r.y + MARGIN_VERTICAL;
+			int barHeight = MAX_BAR_HEIGHT;
+			int start = r.x + MARGIN_HORIZONTAL;
+			int end = r.width - MARGIN_HORIZONTAL;
+
+			int n = end - start;
+
+			// Fill squares with color cg.getColor()
+			for(int i = start; i < end; i++) {
+				double colorValue = min + (i-start) * (max - min) / n;
+				RGB rgb = SwtUtils.color2rgb(cg.getColor(colorValue));
+				if(rgb != null) {
+					c = SwtUtils.changeColor(c, rgb, e.display);
+					e.gc.setBackground(c);
+					e.gc.fillRectangle(i, yStart, 1, barHeight);
+				}
+			}
+
+			Font f = new Font(e.display, FONT, FONTSIZE, SWT.NONE);
+			e.gc.setFont(f);
+
+			int markerCenter = yStart + barHeight;
+			c = SwtUtils.changeColor(c, oldBackground, e.display);
+			e.gc.setBackground(c);
+			for(ColorValuePair cvp : cg.getColorValuePairs())
+			{
+				int x = (int)(start + (cvp.getValue() - min) / (max - min) * (end - start));
+				e.gc.drawLine(x, markerCenter - MARKER_LENGTH, x, markerCenter + MARKER_LENGTH);
+				Point labelSize = e.gc.textExtent(Double.toString(cvp.getValue()));
+				e.gc.drawString(Double.toString(cvp.getValue()), x - labelSize.x / 2, 
+						markerCenter + labelSize.y / 2, true);
+			}
+			
+			String label = cg.getName();
+			Point labelSize = e.gc.textExtent(label);
+			e.gc.drawString(label, (end - start) / 2 - labelSize.x / 2, 
+					yStart - barHeight - labelSize.y / 2, true);	
+
+			c.dispose();
+			f.dispose();
+		}
+	}
+
+	public void visualizationEvent(final VisualizationEvent e) {
+		getDisplay().asyncExec(new Runnable() {
+			public void run() {
+				switch(e.type) {
+				case VisualizationEvent.COLORSET_ADDED:
+				case VisualizationEvent.COLORSET_REMOVED:
+					rebuildContent();
+					break;
+				default:
+					refreshContent();
+				}
+			}
+		});
+	}
+
+	/**
+	 * This class contains an {@link Group} that can be collapsed and expanded.
+	 * Contents can to the {@link Group} by using {@link #getGroup()}
+	 * @author Thomas
+	 */
+	static class CollapseGroup extends Composite {
+		static final int SWITCH_SIZE = 9; //Size of the switch label
+		Group group;
+		Composite stackComp;
+		StackLayout stackLayout;
+		Label groupLabel;
+		Label switchLabel;
+		
+		boolean expanded = true;
+		
+		public CollapseGroup(Composite parent, int style) {
+			super(parent, style);
+			GridLayout grid = new GridLayout(2, false);
+			grid.horizontalSpacing = 3;
+			grid.marginBottom = grid.marginHeight = 0;
+			grid.marginLeft = grid.marginRight = grid.marginBottom = grid.marginTop = 0;
+			setLayout(grid);
+			createContents();
+		}
+		
+		void createContents() {
+			switchLabel = new Label(this, SWT.NULL);
+			GridData labelGrid = new GridData(	GridData.HORIZONTAL_ALIGN_BEGINNING | 
+												GridData.VERTICAL_ALIGN_BEGINNING);
+			labelGrid.widthHint = labelGrid.heightHint = SWITCH_SIZE;
+			switchLabel.setLayoutData(labelGrid);
+			switchLabel.addMouseListener(new MouseAdapter() {
+				public void mouseUp(MouseEvent e) {
+					if(expanded) collapse();
+					else expand();
+				}
+			});
+			stackComp = new Composite(this, SWT.NULL);
+			stackComp.setLayoutData(new GridData(GridData.FILL_BOTH));
+			stackLayout = new StackLayout();
+			stackComp.setLayout(stackLayout);
+					
+			groupLabel = new Label(stackComp, SWT.NULL);
+			group = new Group(stackComp, SWT.NULL);
+			
+			expand();
+		}
+		
+		/**
+		 * Get the collapsable group (e.g. to add contents or set layout)
+		 * @return The collapsable group
+		 */
+		public Group getGroup() {
+			return group;
+		}
+		
+		/**
+		 * Set the text of the collapsable {@link Group}
+		 * @param text The text to set
+		 */
+		public void setText(String text) {
+			groupLabel.setText(text);
+			group.setText(text);
+		}
+		
+		void collapse() {
+			setExpanded(false);
+		}
+		
+		void expand() {
+			setExpanded(true);
+		}
+
+		public void layout(boolean changed, boolean all) {
+			super.layout(changed, all);
+			getParent().layout(changed, all);
+		}
+		
+		public Point computeSize(int wHint, int hHint, boolean changed) {
+			int x = super.computeSize(wHint, hHint, changed).x;
+			int y = expanded ?
+					group.computeSize(wHint, hHint, changed).y :
+					groupLabel.computeSize(SWT.DEFAULT, SWT.DEFAULT).y;
+			return new Point(x, y);
+		}
+		
+		/**
+		 * Rearrange the contents. That is, reset the size of the group
+		 * and layout
+		 */
+		void rearrange() {
+			stackLayout.topControl = expanded ? group : groupLabel;
+			stackComp.layout();
+			Object ld = getLayoutData();
+			if(ld instanceof GridData) {
+				GridData gd = (GridData) ld;
+				gd.heightHint = computeSize(SWT.DEFAULT, SWT.DEFAULT).y;
+			}
+			layout();
+			switchLabel.setImage(SwtEngine.getImageRegistry().get(
+					expanded ? "tree.expanded" : "tree.collapsed"));
+		}
+		
+		void setExpanded(boolean exp) {
+			expanded = exp;
+			
+			rearrange();
+			
+			for(CollapseListener l : listeners) 
+				l.stateChanged(new CollapseEvent(this, expanded ? CollapseEvent.EXPANDED : CollapseEvent.COLLAPSED));
+		}
+		
+		List<CollapseListener> listeners = new ArrayList<CollapseListener>();
+		
+		/**
+		 * Add a collapse listener that is triggered when the group is collapsed or expanded
+		 * @param l The listener to add
+		 */
+		public void addCollapseListener(CollapseListener l) {
+			listeners.add(l);
+		}
+				
+		/**
+		 * This event is fired when a {@link CollapseGroup} is collapsed or expanded
+		 * @author Thomas
+		 */
+		public static class CollapseEvent extends EventObject {
+			private static final long serialVersionUID = 1L;
+			public static final int COLLAPSED = 0;
+			public static final int EXPANDED = 1;
+			int type;
+			
+			/**
+			 * Constructor for this class
+			 * @param source The source object that is collapsed or expanded
+			 * @param type one of {@link #COLLAPSED} or {@link #EXPANDED}
+			 */
+			public CollapseEvent(Object source, int type) {
+				super(source);
+				this.type = type;
+			}		
+		}
+		
+		/**
+		 * Implement this interface to listen for {@link CollapseEvent}s
+		 * @author Thomas
+		 */
+		public static interface CollapseListener {
+			/**
+			 * This method is triggered when the collapse state of a {@link CollapseGroup} 
+			 * is changed (collapsed or expanded)
+			 * @param e The collapse event contains information of the state change
+			 */
+			public void stateChanged(CollapseEvent e);
+		}
+	}
+}
\ No newline at end of file

Property changes on: trunk/src/g2d_swt/org/pathvisio/visualization/LegendPanel.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/AboutDlg.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/AboutDlg.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/AboutDlg.java	(revision 957)
@@ -0,0 +1,96 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Dialog;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Listener;
+import org.eclipse.swt.widgets.Shell;
+import org.pathvisio.Globals;
+import org.pathvisio.Revision;
+
+/**
+ * 
+ * A simple dialog box that shows about information
+ */
+public class AboutDlg extends Dialog
+{
+	private static final long serialVersionUID = 1L;
+
+	public AboutDlg(Shell parent) 
+	{
+		super (parent);
+	}
+
+	public AboutDlg(Shell parent, int style) 
+	{
+		super (parent, style);
+	}
+	
+	public void open()
+	{
+		Shell parent = getParent();
+		final Shell shell = new Shell (parent, SWT.TITLE | SWT.BORDER | SWT.APPLICATION_MODAL);
+
+		shell.setText ("About " + Globals.APPLICATION_VERSION_NAME);		
+		GridLayout ly = new GridLayout();
+		ly.numColumns = 2;
+		shell.setLayout (ly);
+		
+		Label lbl = new Label (shell, SWT.NULL);
+		lbl.setText (Globals.APPLICATION_VERSION_NAME + "\nRevision: " + Revision.REVISION);
+		GridData gd = new GridData (GridData.HORIZONTAL_ALIGN_CENTER);
+		gd.horizontalSpan = 2;		
+		lbl.setLayoutData (gd);
+		
+		lbl = new Label (shell, SWT.NULL);
+		lbl.setImage (SwtEngine.getImageRegistry().get("about.logo"));
+
+		lbl = new Label (shell, SWT.NULL);
+		lbl.setText ("R.M.H. Besseling\nS.P.M.Crijns\nI.Kaashoek\nM.M.Palm\n" +
+				"E.D Pelgrim\nT.A.J. Kelder\nM.P. van Iersel\n\nBiGCaT");
+		
+		final Button btnOk = new Button (shell, SWT.PUSH);
+		btnOk.setText ("OK");
+		gd = new GridData (GridData.HORIZONTAL_ALIGN_CENTER);
+		gd.horizontalSpan = 2;
+		gd.widthHint = 60;
+		btnOk.setLayoutData (gd);
+		
+		btnOk.addListener(SWT.Selection, new Listener() {
+			public void handleEvent (Event event) {
+					shell.dispose();
+			}
+		});
+			
+		shell.pack();
+		shell.open();
+		
+		Display display = parent.getDisplay();
+		while (!shell.isDisposed())
+		{
+			if (!display.readAndDispatch())
+				display.sleep();			
+		}
+	}
+}

Property changes on: trunk/src/g2d_swt/org/pathvisio/gui/swt/AboutDlg.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/NewElementAction.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/NewElementAction.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/NewElementAction.java	(revision 957)
@@ -0,0 +1,225 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+
+package org.pathvisio.gui.swt;
+
+import java.net.URL;
+import java.util.Vector;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.action.ActionContributionItem;
+import org.eclipse.jface.action.IMenuCreator;
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Menu;
+import org.pathvisio.Engine;
+import org.pathvisio.view.VPathway;
+
+/**
+ * {@link Action} to add a new element to the gpml pathway
+ */
+public class NewElementAction extends Action
+{
+	MainWindow window;
+	int element;
+		
+	/**
+	 * Constructor for this class
+	 * @param e	type of element this action adds; a {@link VPathway} field constant
+	 */
+	public NewElementAction (int e)
+	{
+		// TODO: this should be moved to CommonActions, since it is both in v1 and v2
+		element = e;
+		
+		String toolTipText;
+		URL imageURL = null;
+		toolTipText = null;
+		switch(element) {
+		case VPathway.NEWLINE: 
+			toolTipText = "Draw new line";
+			imageURL = Engine.getResourceURL("icons/newline.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLINEARROW:
+			toolTipText = "Draw new arrow";
+			imageURL = Engine.getResourceURL("icons/newarrow.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLINEDASHED:
+			toolTipText = "Draw new dashed line";
+			imageURL = Engine.getResourceURL("icons/newdashedline.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLINEDASHEDARROW:
+			toolTipText = "Draw new dashed arrow";
+			imageURL = Engine.getResourceURL("icons/newdashedarrow.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLABEL:
+			toolTipText = "Draw new label";
+			imageURL = Engine.getResourceURL("icons/newlabel.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWARC:
+			toolTipText = "Draw new arc";
+			imageURL = Engine.getResourceURL("icons/newarc.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWBRACE:
+			toolTipText = "Draw new brace";
+			imageURL = Engine.getResourceURL("icons/newbrace.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWGENEPRODUCT:
+			toolTipText = "Draw new geneproduct";
+			imageURL = Engine.getResourceURL("icons/newgeneproduct.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWRECTANGLE:
+			imageURL = Engine.getResourceURL("icons/newrectangle.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWOVAL:
+			toolTipText = "Draw new oval";
+			imageURL = Engine.getResourceURL("icons/newoval.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWTBAR:
+			toolTipText = "Draw new TBar";
+			imageURL = Engine.getResourceURL("icons/newtbar.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWRECEPTORROUND:
+			toolTipText = "Draw new round receptor";
+			imageURL = Engine.getResourceURL("icons/newreceptorround.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWRECEPTORSQUARE:
+			toolTipText = "Draw new square receptor";
+			imageURL = Engine.getResourceURL("icons/newreceptorsquare.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLIGANDROUND:
+			toolTipText = "Draw new round ligand";
+			imageURL = Engine.getResourceURL("icons/newligandround.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLIGANDSQUARE:
+			toolTipText = "Draw new square ligand";
+			imageURL = Engine.getResourceURL("icons/newligandsquare.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLINEMENU:
+			setMenuCreator(new NewItemMenuCreator(VPathway.NEWLINEMENU));
+			imageURL = Engine.getResourceURL("icons/newlinemenu.gif");
+			toolTipText = "Draw new line or arrow";
+			break;
+		case VPathway.NEWLINESHAPEMENU:
+			setMenuCreator(new NewItemMenuCreator(VPathway.NEWLINESHAPEMENU));
+			imageURL = Engine.getResourceURL("icons/newlineshapemenu.gif");
+			toolTipText = "Draw new ligand or receptor";
+			break;
+		}
+		setToolTipText(toolTipText);
+		setId("newItemAction");
+		if(imageURL != null) setImageDescriptor(ImageDescriptor.createFromURL(imageURL));
+	}
+				
+	public void run () {
+		if(isChecked())
+		{
+			SwtEngine.getWindow().deselectNewItemActions();
+			setChecked(true);
+			Engine.getActiveVPathway().setNewGraphics(element);
+		}
+		else
+		{	
+			Engine.getActiveVPathway().setNewGraphics(VPathway.NEWNONE);
+		}
+	}
+
+	/**
+	 * {@link IMenuCreator} that creates the drop down menus for 
+	 * adding new line-type and -shape elements
+	 */
+	private class NewItemMenuCreator implements IMenuCreator
+	{
+		private Menu menu;
+		int element;
+		
+		/**
+		 * Constructor for this class
+		 * @param e	type of menu to create; one of {@link VPathway}.NEWLINEMENU
+		 * , {@link VPathway}.NEWLINESHAPEMENU
+		 */
+		public NewItemMenuCreator(int e) 
+		{
+			element = e;
+		}
+		
+		public Menu getMenu(Menu parent)
+		{
+			return null;
+		}
+
+		public Menu getMenu(Control parent)
+		{
+			if (menu != null)
+				menu.dispose();
+			
+			menu = new Menu(parent);
+			Vector<Action> actions = new Vector<Action>();
+			switch(element)
+			{
+			case VPathway.NEWLINEMENU:
+				actions.add(new NewElementAction(VPathway.NEWLINE));
+				actions.add(new NewElementAction(VPathway.NEWLINEARROW));
+				actions.add(new NewElementAction(VPathway.NEWLINEDASHED));
+				actions.add(new NewElementAction(VPathway.NEWLINEDASHEDARROW));
+				break;
+			case VPathway.NEWLINESHAPEMENU:
+				actions.add(new NewElementAction(VPathway.NEWLIGANDROUND));
+				actions.add(new NewElementAction(VPathway.NEWRECEPTORROUND));
+				actions.add(new NewElementAction(VPathway.NEWLIGANDSQUARE));
+				actions.add(new NewElementAction(VPathway.NEWRECEPTORSQUARE));
+			}
+			
+			for (Action act : actions)
+			{			
+				addActionToMenu(menu, act);
+			}
+
+			return menu;
+		}
+		
+		protected void addActionToMenu(Menu parent, Action a)
+		{
+			ActionContributionItem item = new ActionContributionItem(a);
+			item.fill(parent, -1);
+		}
+		
+		public void dispose() 
+		{
+			if (menu != null)  {
+				menu.dispose();
+				menu = null;
+			}
+		}
+	}
+
+}

Property changes on: trunk/src/g2d_swt/org/pathvisio/gui/swt/NewElementAction.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/ButtonCellEditor.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/ButtonCellEditor.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/ButtonCellEditor.java	(revision 957)
@@ -0,0 +1,36 @@
+package org.pathvisio.gui.swt;
+
+import org.eclipse.jface.viewers.CellEditor;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+
+public abstract class ButtonCellEditor extends CellEditor {
+	public static int buttonStyle = SWT.PUSH;
+	private Button button;
+		
+	public ButtonCellEditor(Composite parent, String label) {
+		super(parent);
+		button.setText(label);
+	}
+		
+	protected Control createControl(Composite parent) {
+		//Composite comp = new Composite(parent, SWT.NULL);
+		//comp.setLayout(new FillLayout());
+		button = new Button(parent, buttonStyle);
+		setSelectionListeners(button);
+		return button;
+	}
+	
+	protected Button getButton() {
+		return button;
+	}
+	
+	protected abstract void setSelectionListeners(Button b);
+	
+	protected void doSetFocus() {
+		if(button != null && !button.isDisposed()) 
+			button.setFocus();
+	}
+}
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/GdbCellEditor.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/GdbCellEditor.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/GdbCellEditor.java	(revision 957)
@@ -0,0 +1,262 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Statement;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.FocusAdapter;
+import org.eclipse.swt.events.FocusEvent;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Layout;
+import org.pathvisio.Engine;
+import org.pathvisio.data.DataSources;
+import org.pathvisio.data.Gdb;
+import org.pathvisio.gui.swt.PropertyPanel.AutoFillData;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.PropertyType;
+import org.pathvisio.util.SuggestCellEditor;
+import org.pathvisio.util.SuggestCombo;
+import org.pathvisio.util.SuggestCombo.SuggestionListener;
+import org.pathvisio.util.SuggestCombo.SuggestionProvider;
+
+public class GdbCellEditor extends SuggestCellEditor implements SuggestionProvider, SuggestionListener {
+	public static final int TYPE_IDENTIFIER = 0;
+	public static final int TYPE_SYMBOL = 1;
+	int type;
+	
+	public static final int NO_LIMIT = 0;
+	public static final int NO_TIMEOUT = 0;
+	public static int query_timeout = 5; //seconds
+	
+	HashMap<String, PropertyPanel.AutoFillData> suggested;
+	
+	Button button;
+	
+	GdbCellEditor(Composite parent, int type) {
+		super();
+		this.type = type;
+		create(parent); //Set type before creating contol
+		suggestCombo.addSuggetsionListener(this);
+		suggested = new HashMap<String, PropertyPanel.AutoFillData>();
+	}
+		
+	protected Control createControl(Composite parent) {
+		if(type == TYPE_IDENTIFIER) {
+			Composite comp = new Composite(parent, SWT.NULL);
+			super.createControl(comp);
+			button = new Button(comp, SWT.PUSH);
+			button.setText("Set Label");
+			button.setToolTipText("Set the Label property by looking up the gene symbol in the synonym database");
+			button.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					Object value = doGetValue();
+					if(value instanceof AutoFillData) {
+						AutoFillData afd = (AutoFillData) value;
+						afd.setDoGuessData(true);
+						fireApplyEditorValue();
+						afd.setDoGuessData(false);
+					}
+				}
+			});
+			comp.setLayout(new CellLayout());
+			return comp;
+		} else {
+			return super.createControl(parent);
+		}
+	}
+	
+	protected void setFocusListeners() {
+        suggestCombo.getControl().addFocusListener(new FocusAdapter() {
+            public void focusLost(FocusEvent e) {
+            	if(!suggestCombo.isSuggestFocus() &&
+            		(button != null && !button.isFocusControl())) { //Also check focus on button
+            		GdbCellEditor.this.focusLost();
+            	}
+            }
+        });
+	}
+	
+    private class CellLayout extends Layout {
+    	//Adapted from DialogCellEditor
+        public void layout(Composite editor, boolean force) {
+            Rectangle bounds = editor.getClientArea();
+            Point size = button.computeSize(SWT.DEFAULT, SWT.DEFAULT, force);
+			suggestCombo.setBounds(0, 0, bounds.width - size.x, bounds.height);
+            button.setBounds(bounds.width - size.x, 0, size.x, bounds.height);
+        }
+
+        public Point computeSize(Composite editor, int wHint, int hHint,
+                boolean force) {
+            if (wHint != SWT.DEFAULT && hHint != SWT.DEFAULT) {
+				return new Point(wHint, hHint);
+			}
+            Point contentsSize = suggestCombo.computeSize(SWT.DEFAULT, SWT.DEFAULT,
+                    force);
+            Point buttonSize = button.computeSize(SWT.DEFAULT, SWT.DEFAULT,
+            		force);
+            Point result = new Point(buttonSize.x, Math.max(contentsSize.y,
+            		buttonSize.y));
+            return result;
+        }
+    }
+
+    public String getLabel(AutoFillData adf) {
+    	String iddb = adf.getProperty(PropertyType.GENEID) + " (" +
+    	adf.getProperty(PropertyType.SYSTEMCODE) + ")";
+    	switch(type) {
+    	case TYPE_IDENTIFIER:
+    		return 	iddb;
+    	case TYPE_SYMBOL:
+    	default:
+    		return adf.getProperty(PropertyType.TEXTLABEL) + ": " + iddb;
+    	}
+				
+	}
+	
+	public SuggestionProvider getSuggestionProvider() {
+		return this;
+	}
+
+	public void suggestionSelected(String suggestion) {
+		suggestCombo.setText(suggestion);
+		fireApplyEditorValue();
+	}
+	
+	protected Object doGetValue() {
+		String text = suggestCombo.getText();
+		AutoFillData suggestion = suggested.get(text);
+		if(suggestion == null) {
+			suggested.put(text, suggestion = new GdbAutoFillData(getMainPropertyType(), text));
+		}
+		return suggestion;
+	}
+	
+	protected PropertyType getMainPropertyType() {
+		switch(type) {
+		case TYPE_IDENTIFIER:
+			return PropertyType.GENEID;
+		case TYPE_SYMBOL:
+		default:
+			return PropertyType.TEXTLABEL;
+		}
+	}
+	
+	public String[] getSuggestions(String text, SuggestCombo suggestCombo) {
+		int limit = getLimit();
+		
+		List<String> sugg = new ArrayList<String>();
+		try {
+			Statement s = Gdb.getCon().createStatement();
+			
+			s.setQueryTimeout(query_timeout);
+			if(limit > NO_LIMIT) s.setMaxRows(limit);
+			
+			String query = "";
+			switch(type) {
+			case TYPE_IDENTIFIER:
+				query =
+						"SELECT id, code FROM gene WHERE " +
+						"id LIKE '" + text + "%'";
+				break;
+			case TYPE_SYMBOL:
+			default:
+				query =
+						"SELECT id, code, backpageText FROM gene WHERE " +
+						"backpageText LIKE '%<TH>Gene Name:<TH>" + text + "%'";
+			}
+			
+			ResultSet r = s.executeQuery(query);
+	
+			while(r.next()) {
+				String sysCode = r.getString("code");
+				String sysName = DataSources.sysCode2Name.get(sysCode);
+				
+				AutoFillData adf = null;
+				switch(type) {
+				case TYPE_IDENTIFIER:
+					adf = new GdbAutoFillData(PropertyType.GENEID, r.getString("id"));
+					adf.setProperty(PropertyType.SYSTEMCODE, sysName);
+					break;
+				case TYPE_SYMBOL:
+				default:
+					String symbol = Gdb.parseGeneSymbol(r.getString("backpageText"));
+					adf = new GdbAutoFillData(PropertyType.TEXTLABEL, symbol);
+					adf.setProperty(PropertyType.SYSTEMCODE, sysName);
+					adf.setProperty(PropertyType.GENEID, r.getString("id"));
+					
+				}
+				
+				String label = getLabel(adf);
+				suggested.put(label, adf);
+				sugg.add(label);
+			}
+		} catch (SQLException e) {
+			Engine.log.error("Unable to query suggestions", e);
+		}
+		if(limit > NO_LIMIT && sugg.size() == limit) sugg.add("...results limited to " + limit);
+		return sugg.toArray(new String[sugg.size()]);
+	}
+
+	int getLimit() {
+		switch(type) {
+		case TYPE_IDENTIFIER:
+			return 100;
+		case TYPE_SYMBOL:
+		default:
+			return 100;
+		}
+	}
+
+	class GdbAutoFillData extends AutoFillData {
+		public GdbAutoFillData(PropertyType mainProperty, String mainValue) {
+			super(mainProperty, mainValue);
+		}
+		
+		protected void guessData(PathwayElement o) {
+			//Fetch info from self
+			String id = getProperty(PropertyType.GENEID);
+			String sysName = getProperty(PropertyType.SYSTEMCODE);
+			
+			//If null, fetch from dataobject
+			if(id == null) id = (String)o.getProperty(PropertyType.GENEID);
+			if(sysName == null) sysName = (String)o.getProperty(PropertyType.SYSTEMCODE);
+			
+			String code = sysName == null ? null : DataSources.sysName2Code.get(sysName);
+			
+			//Guess symbol
+			if(id != null && code != null) {
+				String symbol = Gdb.getGeneSymbol(id, code);
+				if(symbol != null) {
+					setProperty(PropertyType.TEXTLABEL, symbol);
+				}
+			}
+		}
+	}
+
+}
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/SwtEngine.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/SwtEngine.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/SwtEngine.java	(revision 957)
@@ -0,0 +1,411 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.io.File;
+import java.lang.reflect.InvocationTargetException;
+
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.jface.dialogs.IDialogConstants;
+import org.eclipse.jface.dialogs.MessageDialog;
+import org.eclipse.jface.dialogs.ProgressMonitorDialog;
+import org.eclipse.jface.resource.ImageRegistry;
+import org.eclipse.jface.window.ApplicationWindow;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.graphics.DeviceData;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.FileDialog;
+import org.eclipse.swt.widgets.Shell;
+import org.pathvisio.Engine;
+import org.pathvisio.Globals;
+import org.pathvisio.debug.Sleak;
+import org.pathvisio.model.ConverterException;
+import org.pathvisio.model.Pathway;
+import org.pathvisio.preferences.PreferenceCollection;
+import org.pathvisio.preferences.swt.SwtPreferences;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.util.SwtUtils.SimpleRunnableWithProgress;
+import org.pathvisio.view.VPathway;
+import org.pathvisio.view.VPathwayWrapper;
+import org.pathvisio.view.swt.VPathwaySwtAwt;
+
+import edu.stanford.ejalbert.BrowserLauncher;
+import edu.stanford.ejalbert.exception.BrowserLaunchingExecutionException;
+import edu.stanford.ejalbert.exception.BrowserLaunchingInitializingException;
+import edu.stanford.ejalbert.exception.UnsupportedOperatingSystemException;
+
+/**
+ * This class contains the essential parts of the program: the window, drawing and gpml data
+ */
+public class SwtEngine {
+	/**
+	 * {@link Pathway} object containing JDOM representation of the gpml pathway 
+	 * and handle gpml related actions
+	 */
+	
+	private static MainWindow window;
+	
+	private static ImageRegistry imageRegistry;
+	private static PreferenceCollection preferences;
+	
+	private static File DIR_APPLICATION;
+	private static File DIR_DATA;
+	static boolean USE_R;
+		
+	/**
+	 * Get the {@link ApplicationWindow}, the UI of the program
+	 */
+	public static MainWindow getWindow() {
+		if(window == null) window = new MainWindow();
+		return window;
+	}
+	
+	/**
+	   Updates the title of the main window.
+	   Call at initialization of the program,
+	   whenever the filename of the current document has changed,
+	   or the change status has changed.
+	*/
+	public static void updateTitle()
+	{
+		if (Engine.getActivePathway() == null)
+		{
+			window.getShell().setText(Globals.APPLICATION_VERSION_NAME);
+		}
+		else
+		{
+			// get filename, or (New Pathway) if current pathway hasn't been opened yet
+			String fname = (Engine.getActivePathway().getSourceFile() == null) ? "(New Pathway)" :
+				Engine.getActivePathway().getSourceFile().getName();
+			window.getShell().setText(
+				"*" + fname + " - " +
+				Globals.APPLICATION_VERSION_NAME
+				);
+		}
+	}
+	
+	/**
+	 * Initiates an instance of {@link MainWindow} that is monitored by Sleak.java,
+	 * to monitor what handles (to OS device context) are in use. For debug purposes only 
+	 * (to check for undisposed widgets)
+	 * @return The {@link MainWindow} monitored by Sleak.java
+	 */
+	public static MainWindow getSleakWindow() {
+		//<DEBUG to find undisposed system resources>
+		DeviceData data = new DeviceData();
+		data.tracking = true;
+		Display display = new Display(data);
+		Sleak sleak = new Sleak();
+		sleak.open();
+		
+		Shell shell = new Shell(display);
+		window = new MainWindow(shell);
+		return window;
+		//</DEBUG>
+	}
+	
+	private static VPathwayWrapper createWrapper() {
+		if(window != null) {
+//			return new VPathwaySwtAwt(window.sc, SWT.NO_BACKGROUND);
+			return new VPathwaySwtAwt(window.swingPathwayComposite.getScrollPane(), window.getShell().getDisplay());
+		}
+		return null;
+	}
+		
+	public static void newPathway() {
+		if(canDiscardPathway()) {
+			VPathwayWrapper w = createWrapper();
+			Engine.newPathway(w);
+			updateTitle();
+		}
+	}
+	
+	/**
+	   Opens a file dialog and lets user select a file.
+	   Then the pathways is saved to that file.
+	   returns false if the action was cancelled by the user
+	 */
+	public static boolean savePathwayAs()
+	{
+		Pathway pathway = Engine.getActivePathway();
+		VPathway vPathway = Engine.getActiveVPathway();
+		
+		// Check if a gpml pathway is loaded
+		if (pathway != null)
+		{
+			FileDialog fd = new FileDialog(window.getShell(), SWT.SAVE);
+			fd.setText("Save");
+			fd.setFilterExtensions(new String[] {"*." + Engine.PATHWAY_FILE_EXTENSION, "*.*"});
+			fd.setFilterNames(new String[] {Engine.PATHWAY_FILTER_NAME, "All files (*.*)"});
+			
+			File xmlFile = pathway.getSourceFile();
+			if(xmlFile != null) {
+				fd.setFileName(xmlFile.getName());
+				fd.setFilterPath(xmlFile.getPath());
+			} else {
+					fd.setFilterPath(SwtPreference.SWT_DIR_PWFILES.getValue());
+			}
+			String fileName = fd.open();
+			// Only proceed if user selected a file
+			
+			if(fileName == null) return false;
+			
+			// Append .gpml extension if not already present
+			if(!fileName.endsWith("." + Engine.PATHWAY_FILE_EXTENSION)) 
+				fileName += "." + Engine.PATHWAY_FILE_EXTENSION;
+			
+			File checkFile = new File(fileName);
+			boolean confirmed = true;
+			// If file exists, ask overwrite permission
+			if(checkFile.exists())
+			{
+				confirmed = MessageDialog.openQuestion(window.getShell(),"",
+													   "File already exists, overwrite?");
+			}
+			if(confirmed)
+			{
+				double usedZoom = vPathway.getPctZoom();
+				// Set zoom to 100%
+				vPathway.setPctZoom(100);					
+				// Overwrite the existing xml file
+				try
+				{
+					Engine.savePathway(checkFile);
+					updateTitle();
+					// Set zoom back
+					vPathway.setPctZoom(usedZoom);
+				}
+				catch (ConverterException e)
+				{
+					String msg = "While writing xml to " 
+						+ checkFile.getAbsolutePath();					
+					MessageDialog.openError (window.getShell(), "Error", 
+											 "Error: " + msg + "\n\n" + 
+											 "See the error log for details.");
+					Engine.log.error(msg, e);
+				}
+			}
+		}
+		else
+		{
+			MessageDialog.openError (window.getShell(), "Error", 
+									 "No gpml file loaded! Open or create a new gpml file first");
+		}			
+		return true;
+	}
+
+	/**
+	   Checks if the current pathway has changes, and if so, pops up a dialog
+	   offering to save.
+	   This should always be called before you change pathway
+
+	   @return returns false if the user pressed cancel. 
+	   
+	   TODO: Currently always asks, even if there were no changes since last save.
+	 */
+	static public boolean canDiscardPathway()
+	{
+		Pathway pathway = Engine.getActivePathway();
+		// checking not necessary if there is no pathway.
+		if (pathway == null) return true;
+		String[] opts =
+		{
+			IDialogConstants.YES_LABEL,
+			IDialogConstants.NO_LABEL,
+			IDialogConstants.CANCEL_LABEL
+		};
+		MessageDialog msgDlg = new MessageDialog (
+			window.getShell(),
+			"Save changes?",
+			null,
+			"Your pathway may have changed. Do you want to save?",
+			MessageDialog.QUESTION,
+			opts,
+			0);
+		int result = msgDlg.open();
+		if (result == 2) // cancel
+		{
+			return false;
+		}
+		else if (result == 0) // yes
+		{
+			// return false if save is cancelled.
+			return (savePathway());
+		}
+		// no
+		return true;
+	}
+	
+
+	/**
+	   Opens a URL in the default webbrowser.  Uses a progress dialog
+	   if it takes a long time.  Shows an error message and returns
+	   false if it somehow failed to open the web page.
+	*/
+	public static boolean openWebPage(String url, String progressMsg, String errMsg) {
+		Shell shell = getWindow().getShell();
+		if(shell == null || shell.isDisposed()) return false;
+		
+		SimpleRunnableWithProgress rwp = new SimpleRunnableWithProgress(
+				Engine.class, "doOpenWebPage", new Class[] { String.class }, new Object[] { url }, null);
+		SimpleRunnableWithProgress.setMonitorInfo(progressMsg, IProgressMonitor.UNKNOWN);
+		ProgressMonitorDialog dialog = new ProgressMonitorDialog(shell);
+		try {
+			dialog.run(true, true, rwp);
+			return true;
+		} catch (InvocationTargetException e) {
+			Throwable cause = e.getCause();
+			String msg = cause == null ? null : cause.getMessage();
+			MessageDialog.openError(shell, "Error",
+			"Unable to open web browser" +
+			(msg == null ? "" : ": " + msg) +
+			"\n" + errMsg);
+			return false;
+		} catch (InterruptedException ignore) { return false; }
+	}
+	
+	public static void doOpenWebPage(String url) throws BrowserLaunchingInitializingException, BrowserLaunchingExecutionException, UnsupportedOperatingSystemException {
+		BrowserLauncher bl = new BrowserLauncher(null);
+		bl.openURLinBrowser(url);
+	}
+	
+	/**
+	 Open a pathway from a gpml file
+	 Asks the user if the old pathway should be discarded, if necessary
+	 */
+	public static void openPathway(String pwf)
+	{
+		if (canDiscardPathway())
+		{
+			try { 
+				VPathwayWrapper w = createWrapper();
+				Engine.openPathway(pwf, w);
+				updateTitle();
+			} catch(ConverterException e) {		
+				if (e.getMessage().contains("Cannot find the declaration of element 'Pathway'"))
+				{
+					MessageDialog.openError(getWindow().getShell(), 
+						"Unable to open Gpml file", 
+						"Unable to open Gpml file.\n\n" +
+						"The most likely cause for this error is that you are trying to open an old Gpml file. " +
+						"Please note that the Gpml format has changed as of March 2007. " +
+						"The standard pathway set can be re-downloaded from http://pathvisio.org " +
+						"Non-standard pathways need to be recreated or upgraded. " +
+						"Please contact the authors at martijn.vaniersel@bigcat.unimaas.nl if you need help with this.\n" +
+						"\nSee error log for details");
+					Engine.log.error("Unable to open Gpml file", e);
+				}
+				else
+				{
+					MessageDialog.openError(getWindow().getShell(), 
+											"Unable to open Gpml file", e.getClass() + e.getMessage());
+					Engine.log.error("Unable to open Gpml file", e);
+				}
+			}
+		}
+	}
+	
+	/**
+	 * Get the {@link SwtPreferences} containing the user preferences
+	 */
+	public static PreferenceCollection getPreferences() { 
+		if(preferences == null) preferences = new SwtPreferences();
+		return preferences; 
+	}
+	
+	/**
+	 * Get the {@link ImageRegistry} containing commonly used images
+	 */
+	public static ImageRegistry getImageRegistry() { 
+		if(imageRegistry == null) imageRegistry = new ImageRegistry();
+		return imageRegistry; 
+	}
+	
+	/**
+	 * Set the {@link ImageRegistry} containing commonly used images
+	 */
+	public static void setImageRegistry(ImageRegistry _imageRegistry) {
+		imageRegistry = _imageRegistry;
+	}
+			
+	/**
+	 * Get the working directory of this application
+	 */
+	public static File getApplicationDir() {
+		if(DIR_APPLICATION == null) {
+			DIR_APPLICATION = new File(System.getProperty("user.home"), "." + Globals.APPLICATION_NAME);
+			if(!DIR_APPLICATION.exists()) DIR_APPLICATION.mkdir();
+		}
+		return DIR_APPLICATION;
+	}
+		
+	public static File getDataDir() {
+		if(DIR_DATA == null) {
+			DIR_DATA = new File(System.getProperty("user.home"), Globals.APPLICATION_NAME + "-Data");
+			if(!DIR_DATA.exists()) DIR_DATA.mkdir();
+		}
+		return DIR_DATA;
+	}
+			
+	public static boolean isUseR() { return USE_R; }
+	
+	/**
+	   save the current pathway
+	   returns false if the action was cancelled by the user
+	   
+	   Calls savePathwayAs if the filename of the current pathway is unknown,
+	   so that the user can set a location for this pathway
+	*/
+		public static boolean savePathway()
+		{
+			Pathway pathway = Engine.getActivePathway();
+			VPathway vPathway = Engine.getActiveVPathway();
+			
+			boolean result = true;
+			
+			double usedZoom = vPathway.getPctZoom();
+			// Set zoom to 100%
+			vPathway.setPctZoom(100);			
+			
+	        // Overwrite the existing xml file.
+			// If the target file is read-only, let the user select a new pathway
+			if (pathway.getSourceFile() != null && pathway.getSourceFile().canWrite())
+			{
+				try
+				{
+					Engine.savePathway();
+				}
+				catch (ConverterException e)
+				{
+					String msg = "While writing xml to " 
+						+ pathway.getSourceFile().getAbsolutePath();					
+					MessageDialog.openError (window.getShell(), "Error", 
+											 "Error: " + msg + "\n\n" + 
+											 "See the error log for details.");
+					Engine.log.error(msg, e);
+				}
+			}
+			else
+			{
+				result = savePathwayAs();
+			}
+			// Set zoom back
+			vPathway.setPctZoom(usedZoom);
+
+			return result;
+		}
+}
\ No newline at end of file

Property changes on: trunk/src/g2d_swt/org/pathvisio/gui/swt/SwtEngine.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/PropertyPanel.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/PropertyPanel.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/PropertyPanel.java	(revision 957)
@@ -0,0 +1,657 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.awt.Color;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Set;
+
+import org.eclipse.jface.viewers.ArrayContentProvider;
+import org.eclipse.jface.viewers.CellEditor;
+import org.eclipse.jface.viewers.ColorCellEditor;
+import org.eclipse.jface.viewers.ComboBoxCellEditor;
+import org.eclipse.jface.viewers.ICellModifier;
+import org.eclipse.jface.viewers.ILabelProviderListener;
+import org.eclipse.jface.viewers.IStructuredContentProvider;
+import org.eclipse.jface.viewers.ITableLabelProvider;
+import org.eclipse.jface.viewers.TableViewer;
+import org.eclipse.jface.viewers.TextCellEditor;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.graphics.RGB;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Table;
+import org.eclipse.swt.widgets.TableColumn;
+import org.eclipse.swt.widgets.TableItem;
+import org.pathvisio.Engine;
+import org.pathvisio.biopax.gui.BiopaxCellEditor;
+import org.pathvisio.data.DataSources;
+import org.pathvisio.model.DataNodeType;
+import org.pathvisio.model.LineStyle;
+import org.pathvisio.model.LineType;
+import org.pathvisio.model.MappFormat;
+import org.pathvisio.model.ObjectType;
+import org.pathvisio.model.OrientationType;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.PathwayEvent;
+import org.pathvisio.model.PathwayListener;
+import org.pathvisio.model.PropertyClass;
+import org.pathvisio.model.PropertyType;
+import org.pathvisio.model.ShapeType;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.util.ColorConverter;
+import org.pathvisio.util.SuggestCellEditor;
+import org.pathvisio.util.TableColumnResizer;
+import org.pathvisio.view.Graphics;
+import org.pathvisio.view.SelectionBox;
+import org.pathvisio.view.SelectionBox.SelectionEvent;
+import org.pathvisio.view.SelectionBox.SelectionListener;
+
+/**
+ * This class implements the sidepanel where you can edit graphical properties
+ * of each object on the pathway.
+ */
+public class PropertyPanel extends Composite implements PathwayListener, SelectionListener {
+	public TableViewer tableViewer;
+	CellEditor[] cellEditors = new CellEditor[2];
+	TextCellEditor textEditor;
+	ColorCellEditor colorEditor;
+	ComboBoxCellEditor comboBoxEditor;
+	SuggestCellEditor identifierSuggestEditor;
+	SuggestCellEditor symbolSuggestEditor;
+	BiopaxCellEditor biopaxEditor;
+	
+	private List<PathwayElement> dataObjects;
+	
+	private List<PropertyType> attributes;
+	
+	final static int TYPES_DIFF = ObjectType.MIN_VALID -1;
+	final static Object VALUE_DIFF = new Object() {
+		public boolean equals(Object o) { return false; }
+		public String toString() { return "different values"; }
+	};
+
+	/**
+	 * Add a {@link PathwayElement} to the list of objects of which 
+	 * the properties are displayed
+	 * @param o
+	 */
+	public void addGmmlDataObject(PathwayElement o) {
+		if(!dataObjects.contains(o)) {
+			if(dataObjects.add(o)) {
+				o.addListener(this);
+				refresh();
+			}
+		}
+	}
+	
+	/**
+	 * Remove a {@link PathwayElement} from the list of objects of which 
+	 * the properties are displayed
+	 * @param o
+	 */
+	public void removeGmmlDataObject(PathwayElement o) {
+		if(dataObjects.remove(o)) {
+			o.removeListener(this);
+			refresh();
+		}
+	}
+	
+	/**
+	 * Clear the list of objects of which the properties are displayed
+	 */
+	public void clearGmmlDataObjects() {
+		for(PathwayElement o : dataObjects) o.removeListener(this);
+		dataObjects.clear();
+		refresh();
+	}
+	
+	/**
+	 * Refresh the table and attributes to display
+	 */
+	void refresh() {
+		setAttributes();
+		tableViewer.refresh();
+	}
+	
+	int getAggregateType() {
+		int type = TYPES_DIFF;
+		for(int i = 0; i < dataObjects.size(); i++) {
+			PathwayElement g = dataObjects.get(i);
+			
+			if(i != 0 && type != g.getObjectType()) return TYPES_DIFF;
+			
+			type = g.getObjectType();
+		}
+		return type;
+	}
+	
+	Object getAggregateValue(PropertyType key) {
+		Object value = VALUE_DIFF;
+		for(int i = 0; i < dataObjects.size(); i++) {
+			PathwayElement g = dataObjects.get(i);
+			Object o = g.getProperty(key);
+			if(i != 0 && (o == null || !o.equals(value))) return VALUE_DIFF;
+
+			value = o;
+		}
+		return value;
+	}
+		
+	/**
+	 * Sets the attributes for the selected objects
+	 * Only attributes that are present in all objects in the selection will be
+	 * added to the attributes list and shown in the property table
+	 */
+	public void setAttributes ()
+	{
+		HashMap<PropertyType, Integer> master = new HashMap<PropertyType, Integer>();
+		for (PathwayElement o : dataObjects)
+		{
+			// get attributes. Only get advanced attributes if the preferences say so.
+			for (PropertyType attr : o.getAttributes(
+					 GlobalPreference.getValueBoolean(SwtPreference.SWT_SHOW_ADVANCED_ATTR)))
+			{
+				if (master.containsKey(attr))
+				{
+					// increment
+					master.put(attr, master.get(attr) + 1);
+				}
+				else
+				{
+					// set to 1
+					master.put(attr, 1);
+				}
+			}
+		}
+		attributes.clear();
+		for (PropertyType attr : master.keySet())
+		{
+			if (master.get(attr) == dataObjects.size())
+			{
+				attributes.add(attr);
+			}
+		}
+		// sortAttributes();
+		Collections.sort (attributes);		
+	}
+	
+//	void sortAttributes() {
+//		Collections.sort(attributes, new Comparator() {
+//			public int compare(Object o1, Object o2) {
+//				return o1.ordinal() - o2.ordinal();
+//			}
+//		});
+//	}
+
+	final static String[] colNames = new String[] {"Property", "Value"};
+				
+	PropertyPanel(Composite parent, int style)
+	{
+		super(parent, style);
+		setLayout(new FillLayout());
+		Table t = new Table(this, style);
+		TableColumn tcName = new TableColumn(t, SWT.LEFT);
+		TableColumn tcValue = new TableColumn(t, SWT.LEFT);
+		tcName.setText(colNames[0]);
+		tcValue.setText(colNames[1]);
+		tcName.setWidth(80);
+		tcValue.setWidth(70);
+		tableViewer = new TableViewer(t);
+		tableViewer.getTable().setLinesVisible(true);
+		tableViewer.getTable().setHeaderVisible(true);
+		tableViewer.setContentProvider(tableContentProvider);
+		tableViewer.setLabelProvider(tableLabelProvider);
+		
+		cellEditors[1] = cellEditors[0] = textEditor = new TextCellEditor(tableViewer.getTable());
+		colorEditor = new ColorCellEditor(tableViewer.getTable());
+		comboBoxEditor = new ComboBoxCellEditor(tableViewer.getTable(), new String[] {""});
+		identifierSuggestEditor = new GdbCellEditor(tableViewer.getTable(), GdbCellEditor.TYPE_IDENTIFIER);
+		symbolSuggestEditor = new GdbCellEditor(tableViewer.getTable(), GdbCellEditor.TYPE_SYMBOL);
+		biopaxEditor = new BiopaxCellEditor(tableViewer.getTable(), "...");
+		
+		tableViewer.setCellEditors(cellEditors);
+		tableViewer.setColumnProperties(colNames);
+		tableViewer.setCellModifier(cellModifier);
+		
+		t.addControlListener(new TableColumnResizer(t, t.getParent()));
+		
+		dataObjects = new ArrayList<PathwayElement>();
+		attributes = new ArrayList<PropertyType>();
+		tableViewer.setInput(attributes);
+		
+		SelectionBox.addListener(this);
+	}
+	
+	/**
+	 * return the right cell editor for a certain object. Will return
+	 * one of existing editors. In the case of a list of possible values, 
+	 * a comboboxeditor will be set up with the proper values for
+	 * the drop down list.
+	 */
+	final static String[] orientation_names = OrientationType.getNames();
+	final static String[] linestyle_names = LineStyle.getNames();
+	final static String[] boolean_names = {"false", "true"};
+	final static String[] shape_names = ShapeType.getNames();
+	final static String[] linetype_names = LineType.getNames(); 
+	final static String[] genetype_names = DataNodeType.getNames();
+	
+	private CellEditor getCellEditor(Object element)
+	{
+		PropertyType key = (PropertyType)element;
+		PropertyClass type = key.type();
+		switch(type)
+		{
+			case FONT:				
+			case STRING:
+			case DOUBLE:
+			case ANGLE:
+			case INTEGER: 	return textEditor;
+			case COLOR: 	return colorEditor;
+			case LINETYPE:
+				comboBoxEditor.setItems(linetype_names);
+				return comboBoxEditor;
+			case SHAPETYPE:
+				comboBoxEditor.setItems(shape_names);
+				return comboBoxEditor;
+			case DATASOURCE:			
+				comboBoxEditor.setItems(DataSources.dataSources);
+				return comboBoxEditor;
+			case ORIENTATION:
+				comboBoxEditor.setItems(orientation_names);
+				return comboBoxEditor;
+			case LINESTYLE:
+				comboBoxEditor.setItems(linestyle_names);
+				return comboBoxEditor;
+			case BOOLEAN:
+				comboBoxEditor.setItems(boolean_names);
+				return comboBoxEditor;
+			case ORGANISM:
+				comboBoxEditor.setItems(MappFormat.organism_latin_name);
+				return comboBoxEditor;
+			case GENETYPE:
+				comboBoxEditor.setItems(genetype_names);
+				return comboBoxEditor;
+			case DB_ID:
+				return identifierSuggestEditor;
+			case DB_SYMBOL:
+				return textEditor;
+			case BIOPAXREF:
+				return biopaxEditor;
+				
+		}
+		return textEditor;
+	}
+	
+	private ICellModifier cellModifier = new ICellModifier()
+	{
+		public boolean canModify(Object element, String property) {
+			if (!colNames[1].equals(property))
+			{
+				return false;
+			}
+			
+			cellEditors[1] = getCellEditor(element);
+			return true;
+		}
+
+		/**
+		 * Getvalue is the value that is passed to the Cell Editor when it is 
+		 * activated.
+		 * It should return an Integer object for ComboboxCellEditors.
+		 */
+		public Object getValue(Object element, String property) 
+		{
+			PropertyType key = (PropertyType)element;
+			Object value = getAggregateValue(key);
+			if(value == VALUE_DIFF) {
+				return VALUE_DIFF.toString();
+			}
+			switch(key.type())
+			{
+				case ANGLE:
+				{
+					Double x = Math.round((Double)(value) * 1800.0 / Math.PI) / 10.0;
+					return x.toString();
+				}
+				case DOUBLE:
+				{
+					Double x = Math.round((Double)(value) * 100.0) / 100.0;
+					return x.toString();
+				}
+				case INTEGER: 
+					return value.toString();
+				case ORGANISM:
+					return Arrays.asList(MappFormat.organism_latin_name).indexOf((String)value);
+				case GENETYPE:
+					return Arrays.asList(genetype_names).indexOf((String)value);
+				case STRING:
+				case FONT:
+					return value == null ? "" : (String)value;
+				case DATASOURCE:
+					return DataSources.lDataSources.indexOf((String)value);				
+				// for all combobox types:
+				case BOOLEAN:
+					return ((Boolean)value) ? 1 : 0;
+				case SHAPETYPE:
+					return (((ShapeType)value).ordinal());
+				case LINETYPE:
+					return (((LineType)value).ordinal());
+				case COLOR:
+					if(value instanceof Color)
+						value = ColorConverter.toRGB((Color)value);
+					return (RGB)value;
+				case ORIENTATION:
+				case LINESTYLE:
+				{
+//					try 
+//					{
+						return (Integer)value;
+//					}
+//					catch (ClassCastException e)
+//					{
+//						MessageDialog.openWarning(getShell(), "warning", "Can't cast " + value + " to Integer!");
+//					}
+				}
+				case DB_ID:
+				case DB_SYMBOL:
+					if(value instanceof String) return (String)value;
+					if(value instanceof PropertyPanel.AutoFillData) 
+						return ((PropertyPanel.AutoFillData)value).getMainValue();
+				case BIOPAXREF:
+					return value;
+					
+			}
+			return null;
+		}
+		
+		public void modify(Object element, String property, Object value) {
+			PropertyType key = (PropertyType)((TableItem)element).getData();
+			
+			if(value == VALUE_DIFF || value == VALUE_DIFF.toString()) {
+				return;
+			}
+			/*
+			 * Here, we transform the output of the cell editor
+			 * to a value understood by PathwayElement.SetProperty().
+			 * 
+			 * The output of a comboboxCellEditor is Integer.
+			 * The output of a textCellEditor is String.
+			 * 
+			 * For linetype and shapetype we go from Integer to Integer. easy
+			 * For boolean, we go from Integer to Boolean
+			 * For Double / Integer, we go from String to Double
+			 * For Datasource, we go from Integer to String.
+			 */
+			switch(key.type())
+			{
+			case ANGLE: 	
+				try 
+				{ 
+					// convert degrees (property editor) to radians (model)
+					value = Double.parseDouble((String)value) * Math.PI / 180;					
+					break;
+				} 
+				catch(Exception e) 
+				{
+					// invalid input, ignore
+					return; 
+				}
+			case DOUBLE: 	
+				try 
+				{ 
+					value = Double.parseDouble((String)value); 
+					break; 
+				} 
+				catch(Exception e) 
+				{
+					// invalid input, ignore
+					return; 
+				}
+			case INTEGER: 	
+				try 
+				{ 
+					value = Integer.parseInt((String)value); 
+					break; 
+				}
+				catch(Exception e) 
+				{ 
+					// invalid input, ignore 
+					return; 
+				}
+			case DATASOURCE:
+				if((Integer)value == -1) return; //Nothing selected
+				value = DataSources.lDataSources.get((Integer)value);
+				break;
+			case BOOLEAN:
+				if ((Integer)value == 0)
+				{
+					value = new Boolean (false);
+				}
+				else
+				{
+					value = new Boolean (true);
+				}
+				break;
+			case ORGANISM:
+				if((Integer)value == -1) return; //Nothing selected
+				value = MappFormat.organism_latin_name[(Integer)value];
+				break;
+			case GENETYPE:
+				if((Integer)value == -1) return; //Nothing selected
+				value = genetype_names[(Integer)value];
+				break;
+			case COLOR:
+				value = ColorConverter.fromRGB((RGB)value);
+			case DB_SYMBOL:
+			case DB_ID:
+				if(value instanceof PropertyPanel.AutoFillData) {
+					PropertyPanel.AutoFillData adf = (PropertyPanel.AutoFillData)value;
+					for(PathwayElement o : dataObjects) {
+						if(o.getObjectType() == ObjectType.DATANODE) {
+							adf.fillData(o);
+						}
+					}
+					value = adf.getMainValue();
+				}
+				break;
+			}
+			for(PathwayElement o : dataObjects) {
+				o.setProperty(key, value);
+			}
+			tableViewer.refresh();
+			Engine.getActiveVPathway().redrawDirtyRect();
+		}
+	};
+	
+	private IStructuredContentProvider tableContentProvider = new ArrayContentProvider();
+	
+	private ITableLabelProvider tableLabelProvider = new ITableLabelProvider() {
+		public Image getColumnImage(Object element, int columnIndex) {
+			return null;
+		}
+		public String getColumnText(Object element, int columnIndex) {
+			PropertyType key = (PropertyType)element;
+			switch(columnIndex) {
+				case 0:
+					return key.desc();					
+				case 1:
+					//TODO: prettier labels for different value types
+					if(attributes.contains(key))
+					{
+						Object value = getAggregateValue(key);
+						if (value == null)
+						{
+							return null;
+						}
+						else 
+						{
+							switch (key.type())
+							{
+								case ANGLE:
+								{
+									if (value instanceof Double)
+									{
+										Double x = Math.round((Double)(value) * 1800.0 / Math.PI) / 10.0;
+										return x.toString();
+									}
+									else
+										return value.toString();
+								}
+								case DOUBLE:								
+									if (value instanceof Double)
+									{
+										Double x = Math.round((Double)(value) * 10.0) / 10.0;
+										return x.toString();
+									}
+									else
+										return value.toString();
+										
+								case BOOLEAN:
+								{
+									if (value instanceof Boolean)
+									{
+										return (Boolean)(value) ? "true" : "false";
+									}
+									else
+										return value.toString();
+								}
+								case LINETYPE:
+								{
+									if (value instanceof Integer)
+										return linetype_names[(Integer)(value)];
+									else
+										return value.toString();
+								}
+								case LINESTYLE:
+								{
+									if (value instanceof Integer)
+										return linestyle_names[(Integer)(value)];
+									else
+										return value.toString();
+								}
+								case ORIENTATION:
+								{
+									if (value instanceof Integer)
+										return orientation_names[(Integer)(value)];
+									else
+										return value.toString();									
+								}
+								case SHAPETYPE:
+								{
+									if (value instanceof Integer)
+										return shape_names[(Integer)(value)];
+									else
+										return value.toString();
+								}
+								case COLOR:
+									if(value instanceof Color) {
+										return ColorConverter.toRGB((Color)value).toString();
+									}
+								default:
+									return value.toString();
+							}
+						}
+					}
+			}
+			return null;
+			}
+		
+		public void addListener(ILabelProviderListener listener) { }
+		public void dispose() {}
+		public boolean isLabelProperty(Object element, String property) {
+			return false;
+		}
+		public void removeListener(ILabelProviderListener listener) { }
+	};
+
+	public void gmmlObjectModified(PathwayEvent e) {
+		tableViewer.refresh();
+	}
+
+	//TODO: implement all attribute types as subclasses of MyType.
+//	class MyType {
+//		abstract String getColumnText(Object value);
+//		abstract Object adjustedValue(Object value);
+//		abstract CellEditor getCellEditor()
+//	}
+	
+	public void drawingEvent(SelectionEvent e) {
+		switch(e.type) {
+		case SelectionEvent.OBJECT_ADDED:
+			if(e.affectedObject instanceof Graphics)
+				addGmmlDataObject(((Graphics)e.affectedObject).getGmmlData());
+			break;
+		case SelectionEvent.OBJECT_REMOVED:
+			if(e.affectedObject instanceof Graphics)
+				removeGmmlDataObject(((Graphics)e.affectedObject).getGmmlData());
+			break;
+		case SelectionEvent.SELECTION_CLEARED:
+			 clearGmmlDataObjects();
+			break;
+		}
+		
+	}
+
+	static class AutoFillData {
+		PropertyType mProp;
+		Object mValue;
+		HashMap<PropertyType, String> values;
+		
+		private boolean doGuess = false;
+		
+		public AutoFillData(PropertyType mainProperty, String mainValue) {
+			values = new HashMap<PropertyType, String>();
+			mProp = mainProperty;
+			mValue = mainValue;
+			setProperty(mainProperty, mainValue);
+		}
+		
+		public void setProperty(PropertyType property, String value) {
+			values.put(property, value);
+		}
+		
+		public PropertyType getMainProperty() { return mProp; }
+		public Object getMainValue() { return mValue; }
+		
+		public String getProperty(PropertyType property) { return values.get(property); }
+		
+		public Set<PropertyType> getProperties() { return values.keySet(); }
+		
+		public void fillData(PathwayElement o) {
+			if(doGuess) guessData(o);
+			for(PropertyType p : getProperties()) {
+				Object vNew = getProperty(p);
+				o.setProperty(p, vNew);
+			}
+		}
+		
+		public void setDoGuessData(boolean doGuessData) {
+			doGuess = doGuessData;
+		}
+		
+		protected void guessData(PathwayElement o) {
+		}
+	}
+}
+

Property changes on: trunk/src/g2d_swt/org/pathvisio/gui/swt/PropertyPanel.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/SidePanel.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/SidePanel.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/SidePanel.java	(revision 957)
@@ -0,0 +1,212 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.SashForm;
+import org.eclipse.swt.custom.StackLayout;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Sash;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+
+/**
+ * This class can be extended to create a sidepanel with minimize button
+ * for use as component of a {@link SashForm}
+ */
+public class SidePanel extends Composite {
+	private SashForm parentSash;
+	private Composite contentComposite;
+	
+	/**
+	 * Constructor for this class
+	 * @param parent	The parent composite (needs to be an {@link SashForm} for the
+	 * minimize button to work
+	 * @param style
+	 */
+	public SidePanel(Composite parent, int style) {
+		super(parent, style);
+		if(parent instanceof SashForm) //Minimize button only works if parent is sashform
+			parentSash = (SashForm)parent;
+		createControls();
+	}
+
+	public Composite getContentComposite() { return contentComposite; }
+	
+	Composite buttonBar;
+	Composite stackComposite;
+	Composite emptyComposite;
+	StackLayout stackLayout;
+	Button minButton;
+	/**
+	 * Creates the button controls to minimize the sidepanel and a {@link Composite} for the contents
+	 */
+	public void createControls() {
+		GridLayout topLayout = new GridLayout();
+		topLayout.verticalSpacing = topLayout.marginTop = topLayout.marginWidth = 0;
+		setLayout(topLayout);
+		
+		if(parentSash != null) {
+			//Create minimize control on top of content
+			buttonBar = new Composite(this, SWT.NULL);
+			GridLayout barLayout = new GridLayout(2, true);
+			barLayout.marginBottom = barLayout.marginHeight = barLayout.marginWidth = 1;
+			buttonBar.setLayout(barLayout);
+						
+			minButton = new Button(buttonBar, SWT.TOGGLE);
+			minButton.setToolTipText("Minimize this sidepanel");
+			minButton.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					if(minButton.getSelection()) {
+						minimize();
+						minButton.setToolTipText("Restore this sidepanel");
+					}
+					else {
+						restore();
+						minButton.setToolTipText("Minimize this sidepanel");
+					}
+				}
+			});
+			minButton.setImage(SwtEngine.getImageRegistry().get("sidepanel.minimize"));
+			final Button hideButton = new Button(buttonBar, SWT.PUSH);
+			hideButton.setToolTipText("Close this sidepanel (use view menu to open again)");
+			hideButton.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					hide();
+					SwtEngine.getWindow().showRightPanelAction.setChecked(false);
+				}
+			});
+			hideButton.setImage(SwtEngine.getImageRegistry().get("sidepanel.hide"));
+			
+			GridData buttonGrid = new GridData();
+			buttonGrid.widthHint = 12;
+			buttonGrid.heightHint =  12;
+			hideButton.setLayoutData(buttonGrid);
+			minButton.setLayoutData(buttonGrid);
+			
+			buttonBar.pack();
+		}
+		stackComposite = new Composite(this, SWT.NULL);
+		stackComposite.setLayoutData(new GridData(GridData.FILL_BOTH));
+		stackLayout = new StackLayout();
+		stackComposite.setLayout(stackLayout);
+		emptyComposite = new Composite(stackComposite, SWT.NULL);
+		emptyComposite.setLayout(new FillLayout());
+		contentComposite = new Composite(stackComposite, SWT.NULL);
+		contentComposite.setLayout(new FillLayout());
+		
+		stackLayout.topControl = contentComposite;
+	}
+	
+	/**
+	 * Minimizes this panel, while the minimize button will still be visible
+	 */
+	public void minimize() {
+		parentSash.setWeights(calculateWeights(WEIGHTS_MINIMIZE));
+		stackLayout.topControl = emptyComposite;
+		stackComposite.layout();
+	}
+	
+	/**
+	 * Hides this panel, the minimize button will not be visible anymore
+	 */
+	public void hide() {
+		parentSash.setWeights(calculateWeights(WEIGHTS_HIDE));
+	}
+	
+	public void show() {
+		int sidePanelSize = GlobalPreference.getValueInt(SwtPreference.SWT_SIDEPANEL_SIZE);
+		if(sidePanelSize == 0) sidePanelSize = 10; //Force show if initial size = 0
+		parentSash.setWeights(calculateWeights(sidePanelSize));
+	}
+	
+	/**
+	 * Restores the size of the panel to its previous size
+	 */
+	public void restore() {
+		if(oldWeights == null) return;
+		parentSash.setWeights(oldWeights);
+		stackLayout.topControl = contentComposite;
+		stackComposite.layout();
+	}
+	
+	private int[] oldWeights;
+	private static final int WEIGHTS_HIDE = -1;
+	private static final int WEIGHTS_MINIMIZE = -2;
+	/**
+	 * Calculates weights that have to be passed to the parent {@link SashForm#setWeights(int[])}
+	 * to resize, minimize or hide this panel
+	 * @param percent percentage of total size for this panel or 
+	 * one of WEIGHTS_HIDE or WEIGHTS_MINIMIZE, in the first case the panel is hidden,
+	 * so its weight is set to zero, in the second case the panel is miminized in a way the minimize 
+	 * button is still visible
+	 * @return
+	 */
+	private int[] calculateWeights(int percent) {
+		Control[] controls = parentSash.getChildren();
+		int[] weights = parentSash.getWeights();
+		oldWeights = weights.clone();
+		//Get the index of this control in the sashform
+		int thisIndex = 0;
+		for(int i = 0; i < controls.length; i++) {
+			if(controls[i] == this) break;
+			if(!(controls[i] instanceof Sash)) thisIndex++; //Don't count sash controls
+		}
+		
+		int thisWeight = weights[thisIndex];
+		
+		//Get the index of the neighbouring composite
+		int neighbourIndex = -1;
+		if(thisIndex == weights.length - 1) neighbourIndex = thisIndex - 1;
+		else neighbourIndex = thisIndex + 1;
+		
+		//Calculate widths needed to calculate new weight 
+		int newWidth;
+		switch(percent) {
+		case WEIGHTS_MINIMIZE: newWidth = minButton.getSize().x; break;
+		case WEIGHTS_HIDE: newWidth = 0; break;
+		default:
+			//Calculate new weights
+			int percentLeft = 100 - percent;
+			int sum = 0;
+			for(int i = 0; i < weights.length; i++) {
+				sum += weights[i];
+				if(i == thisIndex) continue;
+				weights[i] = (int)(((double)weights[i] / 100) * percentLeft);
+			}
+			weights[thisIndex] = (int)(((double)percent / 100) * sum);
+			return weights;
+			}
+		
+		int thisWidth = getSize().x;
+		
+		//Calculate new weights
+		int newWeight = (int)(((double)newWidth / thisWidth) * thisWeight);
+		//Adjust the weight of this and the next control
+		weights[thisIndex] = newWeight;
+		weights[neighbourIndex] += thisWeight - newWeight;
+		return weights;
+	}
+
+}

Property changes on: trunk/src/g2d_swt/org/pathvisio/gui/swt/SidePanel.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/TabbedSidePanel.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/TabbedSidePanel.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/TabbedSidePanel.java	(revision 957)
@@ -0,0 +1,175 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.util.HashMap;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.CTabFolder;
+import org.eclipse.swt.custom.CTabItem;
+import org.eclipse.swt.custom.SashForm;
+import org.eclipse.swt.events.DisposeEvent;
+import org.eclipse.swt.events.DisposeListener;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.TabFolder;
+import org.eclipse.swt.widgets.TabItem;
+
+/**
+ * This class represents a side panel with contents placed in different
+ * tabitems. Components to add needs to be children of the {@link TabFolder}
+ * returned by {@link #getTabFolder()}
+ */
+public class TabbedSidePanel extends SidePanel {
+	private CTabFolder tabFolder;
+	HashMap<String, Control> controls;
+	HashMap<String, CTabItem> tabItems;
+	
+	/**
+	 * Returns the {@link TabFolder} containing the different
+	 * tabItems of this sidepanel
+	 */
+	public CTabFolder getTabFolder() { return tabFolder; }
+	
+	public HashMap<String, CTabItem> getTabItemHash() { return tabItems; }
+	
+	/**
+	 * Constructor for this class
+	 * @param parent	The parent composite (needs to be an {@link SashForm} for the
+	 * minimize button to work
+	 * @param style		
+	 */
+	public TabbedSidePanel(Composite parent, int style) {
+		super(parent, style);
+		controls = new HashMap<String, Control>();
+		tabItems = new HashMap<String, CTabItem>();
+		
+		tabFolder = new CTabFolder(getContentComposite(), SWT.BORDER);
+		tabFolder.setSimple(false);
+	}
+	
+	/**
+	 * Add a TabItem containing the given Control.
+	 * @param content	{@link Control} that needs to be a child of the
+	 * TabFolder returned by {@link #getTabFolder()}
+	 * @param title		The title for the TabItem
+	 */
+	public void addTab(Control content, String title)
+	{		
+		createTabItem(content, title, false);
+		controls.put(title, content);
+	}
+	
+	public void addTab(Control content, String title, boolean close)
+	{		
+		createTabItem(content, title, close);
+		controls.put(title, content);
+	}
+	
+	/**
+	 * Creates an {@link TabItem} with the given control and title
+	 * @param content
+	 * @param title
+	 * @param close
+	 * @returns
+	 */
+	private CTabItem createTabItem(Control content, String title, boolean close)
+	{
+		return createTabItem(content, title, tabFolder.getItemCount(), close);
+	}
+	
+	/**
+	 * Creates an {@link TabItem} with the given control and title at the given index.
+	 * If the index is lower than the number of tabitems, the new tabitem is placed before the first,
+	 * otherwise it is placed after the last.
+	 * @param content
+	 * @param title
+	 * @returns
+	 * @param index
+	 * @return
+	 */
+	private CTabItem createTabItem(Control content, String title, int index, boolean close) {
+		int nrTabs = tabFolder.getItemCount();
+		
+		if(index > nrTabs) index = nrTabs; //If index is invalid, choose first or last tab
+		else if(index < 0) index = 0;
+		
+		final CTabItem ti = new CTabItem(tabFolder, close ? SWT.CLOSE : SWT.NULL, index);
+		ti.setText(title);
+		ti.setControl(content);
+		ti.addDisposeListener(new DisposeListener() {
+			public void widgetDisposed(DisposeEvent e) {
+				tabItems.remove(ti.getText());
+			}
+		});
+		tabItems.put(title, ti);
+		return ti;
+	}
+	
+	/**
+	 * Hides a tab (without disposing the containing {@link Control})
+	 * @param title The title of the tab
+	 */
+	public void hideTab(String title) {
+		if(!tabItems.containsKey(title)) return;
+		tabItems.get(title).dispose();
+		tabItems.remove(title);
+	}
+	
+	/**
+	 * Shows a tab if a control with the given title exists
+	 * @param title	The title of the tabitem, also serves to find the {@link Control} for the tabItem
+	 * @return true if the tab is added, false if not ({@link Control} not found)
+	 */
+	public boolean unhideTab(String title) {
+		return unhideTab(title, tabFolder.getItemCount());
+	}
+	
+	/**
+	 * Shows a tab if a control with the given title exists
+	 * @param title	The title of the tabitem, also serves to find the {@link Control} for the tabItem
+	 * @param position The index of the position to add the tab
+	 * @return true if the tab is added, false if not ({@link Control} not found)
+	 */
+	public boolean unhideTab(String title, int position) {
+		if(controls.containsKey(title)) {
+			createTabItem(controls.get(title), title, position, false);
+			return true;
+		}
+		return false;
+	}
+	
+	public void selectTab(String title) {
+		if(tabItems.containsKey(title)) 
+			tabFolder.setSelection(tabItems.get(title));
+	}
+	
+	/**
+	 * Checks whether a tabitem is visible
+	 */
+	public boolean isVisible(String title) {
+		return tabItems.containsKey(title) && controls.containsKey(title);
+	}
+	
+	/**
+	 * Check whether a tabitem with the given title exists
+	 * @param title
+	 */
+	public boolean hasTab(String title) {
+		return tabItems.containsKey(title);
+	}
+}

Property changes on: trunk/src/g2d_swt/org/pathvisio/gui/swt/TabbedSidePanel.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/MainWindowBase.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/MainWindowBase.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/MainWindowBase.java	(revision 957)
@@ -0,0 +1,431 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.action.ActionContributionItem;
+import org.eclipse.jface.action.ControlContribution;
+import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.action.IContributionItem;
+import org.eclipse.jface.action.MenuManager;
+import org.eclipse.jface.action.ToolBarContributionItem;
+import org.eclipse.jface.action.ToolBarManager;
+import org.eclipse.jface.dialogs.MessageDialog;
+import org.eclipse.jface.dialogs.ProgressMonitorDialog;
+import org.eclipse.jface.window.ApplicationWindow;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.SashForm;
+import org.eclipse.swt.custom.ScrolledComposite;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.widgets.Combo;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Shell;
+import org.pathvisio.Engine;
+import org.pathvisio.Engine.ApplicationEvent;
+import org.pathvisio.Engine.ApplicationEventListener;
+import org.pathvisio.data.DBConnector;
+import org.pathvisio.data.Gdb;
+import org.pathvisio.data.Gex;
+import org.pathvisio.data.Gex.ExpressionDataEvent;
+import org.pathvisio.data.Gex.ExpressionDataListener;
+import org.pathvisio.gui.swt.awt.VPathwaySwingComposite;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.search.PathwaySearchComposite;
+import org.pathvisio.view.GeneProduct;
+import org.pathvisio.view.VPathway;
+import org.pathvisio.view.VPathwayEvent;
+import org.pathvisio.view.VPathwayListener;
+import org.pathvisio.visualization.LegendPanel;
+
+/**
+ * MainWindowBase is an abstract and incomplete Main Window that contains some
+ * core functionality. This way we can create different flavours of the main window
+ * without having too much duplicate code. Descendants should at least provide
+ * a constructor, and override createCoolBarManager and createMenuManager.
+ */
+public abstract class MainWindowBase extends ApplicationWindow implements 
+	ApplicationEventListener, ExpressionDataListener, VPathwayListener
+{
+	private static final long serialVersionUID = 1L;
+	static int ZOOM_TO_FIT = -1;
+		
+	protected CommonActions.UndoAction undoAction = new CommonActions.UndoAction(this);	
+	protected CommonActions.NewAction newAction = new CommonActions.NewAction (this);
+	protected CommonActions.OpenAction openAction = new CommonActions.OpenAction (this);	
+	protected CommonActions.ImportAction importAction = new CommonActions.ImportAction (this);	
+	protected CommonActions.SaveAction saveAction = new CommonActions.SaveAction(this);	
+	protected CommonActions.SaveAsAction saveAsAction = new CommonActions.SaveAsAction (this);
+	protected CommonActions.ExportAction exportAction = new CommonActions.ExportAction (this);
+	protected CommonActions.ExitAction exitAction = new CommonActions.ExitAction(this);
+	protected CommonActions.PreferencesAction preferencesAction = new CommonActions.PreferencesAction(this);
+	protected CommonActions.AboutAction aboutAction = new CommonActions.AboutAction(this);
+	protected CommonActions.CopyAction copyAction = new CommonActions.CopyAction(this);
+	protected CommonActions.HelpAction helpAction = new CommonActions.HelpAction(this);	
+	protected CommonActions.PasteAction pasteAction = new CommonActions.PasteAction(this);
+	protected CommonActions.SwitchEditModeAction switchEditModeAction = new CommonActions.SwitchEditModeAction(this);
+	public ShowRightPanelAction showRightPanelAction = new ShowRightPanelAction(this);
+	protected SelectGdbAction selectGdbAction = new SelectGdbAction(this);
+	protected AlignActions.AlignCenterXAction alignCenterXAction = new AlignActions.AlignCenterXAction(this);
+	protected AlignActions.AlignCenterYAction alignCenterYAction = new AlignActions.AlignCenterYAction(this);
+	protected AlignActions.AlignLeftAction alignLeftAction = new AlignActions.AlignLeftAction(this);
+	protected AlignActions.AlignRightAction alignRightAction = new AlignActions.AlignRightAction(this);
+	protected AlignActions.AlignTopAction alignTopAction = new AlignActions.AlignTopAction(this);
+	protected AlignActions.AlignBottomAction alignBottomAction = new AlignActions.AlignBottomAction(this);
+	protected AlignActions.SetCommonWidthAction setCommonWidthAction = new AlignActions.SetCommonWidthAction(this);
+	protected AlignActions.SetCommonHeightAction setCommonHeightAction = new AlignActions.SetCommonHeightAction(this);
+
+	/**
+	 * {@link Action} to select a Gene Database
+	 */
+	private class SelectGdbAction extends Action
+	{
+		MainWindowBase window;
+		public SelectGdbAction(MainWindowBase w)
+		{
+			window = w;
+			setText("Select &Gene Database");
+			setToolTipText("Select Gene Database");
+		}
+		
+		public void run () {			
+			try {
+				DBConnector dbcon = Gdb.getDBConnector();
+				String dbName = dbcon.openChooseDbDialog(getShell());
+				
+				if(dbName == null) return;
+				
+				Gdb.connect(dbName);
+				setStatus("Using Gene Database: '" + SwtPreference.SWT_CURR_GDB + "'");
+				cacheExpressionData();
+			} catch(Exception e) {
+				String msg = "Failed to open Gene Database; " + e.getMessage();
+				MessageDialog.openError (window.getShell(), "Error", 
+						"Error: " + msg + "\n\n" + 
+						"See the error log for details.");
+				Engine.log.error(msg, e);
+			}
+		}
+	}
+
+	/**
+	 * deselect all buttons in the alignActionsCI coolbar
+	 */
+	public void deselectAlignItemActions()
+	{
+		IContributionItem[] items = alignActionsCI.getToolBarManager().getItems();
+		for(int i = 0; i < items.length; i++)
+		{
+			if(items[i] instanceof ActionContributionItem)
+			{
+				((ActionContributionItem)items[i]).getAction().setChecked(false);
+			}
+		}
+		Engine.getActiveVPathway().setNewGraphics(VPathway.NEWNONE);
+	}
+	
+	/**
+	 * {@link Action} to show or hide the right sidepanel
+	 */
+	public class ShowRightPanelAction extends Action
+	{
+		MainWindowBase window;
+		public ShowRightPanelAction (MainWindowBase w)
+		{
+			super("Show &information panel", IAction.AS_CHECK_BOX);
+			window = w;
+			setChecked(true);
+		}
+		
+		public void run() {
+			if(isChecked()) rightPanel.show();
+			else rightPanel.hide();
+		}
+	}
+
+	/**
+	 * Loads expression data for all {@link GeneProduct}s in the loaded pathway
+	 */
+	private void cacheExpressionData()
+	{
+		if(Engine.isDrawingOpen())
+		{
+			VPathway drawing = Engine.getActiveVPathway();
+			//Check for neccesary connections
+			if(Gex.isConnected() && Gdb.isConnected())
+			{
+				ProgressMonitorDialog dialog = new ProgressMonitorDialog(getShell());
+				try {
+					dialog.run(true, true, Gex.createCacheRunnable(drawing.getMappIds(), drawing.getSystemCodes()));
+					drawing.redraw();
+				} catch(Exception e) {
+					String msg = "while caching expression data: " + e.getMessage();					
+					MessageDialog.openError (getShell(), "Error", 
+							"Error: " + msg + "\n\n" + 
+							"See the error log for details.");
+					Engine.log.error(msg, e);
+				}
+			}
+		}
+	}
+
+	/**
+	 * Deselects all {@link NewElementAction}s on the toolbar and sets 
+	 * {@link VPathway}.newGraphics to {@link VPathway}.NEWNONE
+	 */
+	public void deselectNewItemActions()
+	{
+		IContributionItem[] items = editActionsCI.getToolBarManager().getItems();
+		for(int i = 0; i < items.length; i++)
+		{
+			if(items[i] instanceof ActionContributionItem)
+			{
+				((ActionContributionItem)items[i]).getAction().setChecked(false);
+			}
+		}
+		Engine.getActiveVPathway().setNewGraphics(VPathway.NEWNONE);
+	}
+
+	// Elements of the coolbar
+	ToolBarContributionItem commonActionsCI;
+	ToolBarContributionItem editActionsCI;
+	ToolBarContributionItem alignActionsCI;
+	ToolBarContributionItem viewActionsCI;
+	
+	/**
+	 * Creates element of the coolbar containing common actions as new, save etc.
+	 */
+	protected void createCommonActionsCI()
+	{
+		ToolBarManager toolBarManager = new ToolBarManager(SWT.FLAT);
+		toolBarManager.add(newAction);
+		toolBarManager.add(openAction);
+		toolBarManager.add(saveAction);
+		commonActionsCI = new ToolBarContributionItem(toolBarManager, "CommonActions");
+	}
+
+	/**
+	 * Creates element of the coolbar only shown in edit mode (new element actions)
+	 */
+	protected void createEditActionsCI()
+	{
+		ToolBarManager toolBarManager = new ToolBarManager(SWT.FLAT);		
+		toolBarManager.add(new NewElementAction(VPathway.NEWGENEPRODUCT));
+		toolBarManager.add(new NewElementAction(VPathway.NEWLABEL));
+		toolBarManager.add(new NewElementAction(VPathway.NEWLINEMENU));
+		toolBarManager.add(new NewElementAction(VPathway.NEWRECTANGLE));
+		toolBarManager.add(new NewElementAction(VPathway.NEWOVAL));
+		toolBarManager.add(new NewElementAction(VPathway.NEWARC));
+		toolBarManager.add(new NewElementAction(VPathway.NEWBRACE));
+		toolBarManager.add(new NewElementAction(VPathway.NEWTBAR));
+		toolBarManager.add(new NewElementAction(VPathway.NEWLINESHAPEMENU));
+
+		editActionsCI = new ToolBarContributionItem(toolBarManager, "EditModeActions");
+	}
+	
+	/**
+	 * Creates element of the coolbar containing controls related to viewing a pathway
+	 */
+	protected void createViewActionsCI()
+	{
+		final MainWindowBase window = this;
+		ToolBarManager toolBarManager = new ToolBarManager(SWT.FLAT);
+		//Add zoomCombo
+		toolBarManager.add(new ControlContribution("ZoomCombo") {
+			protected Control createControl(Composite parent) {
+				final Combo zoomCombo = new Combo(parent, SWT.DROP_DOWN);
+				zoomCombo.setItems(new String[] { "200%", "100%", "75%", "50%", "Zoom to fit" });
+				zoomCombo.setText("100%");
+				zoomCombo.addSelectionListener(new SelectionAdapter() {
+					public void widgetSelected(SelectionEvent e) {
+						int pctZoom = 100;
+						String zoomText = zoomCombo.getText().replace("%", "");
+						try {
+							pctZoom = Integer.parseInt(zoomText);
+						} catch (Exception ex) { 
+							if(zoomText.equals("Zoom to fit"))
+									{ pctZoom = ZOOM_TO_FIT; } else { return; }
+						}
+						new CommonActions.ZoomAction(window, pctZoom).run();
+					}
+					public void widgetDefaultSelected(SelectionEvent e) { widgetSelected(e); }
+				});
+				return zoomCombo;
+			}
+		});
+		//Add swich to editmode
+		toolBarManager.add(switchEditModeAction);
+		
+		viewActionsCI =  new ToolBarContributionItem(toolBarManager, "SwitchActions");
+	}
+		
+	/**
+	 * Shows or hides the editActionsCI
+	 * @param show	true/false for either show or hide
+	 */
+	public void showEditActionsCI(boolean show)
+	{
+		if(show) {
+			getCoolBarManager().insertAfter(viewActionsCI.getId(), editActionsCI);
+		}
+		else {
+			getCoolBarManager().remove(editActionsCI);
+		}
+//		showVisualizationCI(!show); //Visualizations can show up in edit mode...
+		getCoolBarManager().update(true);
+	}
+
+	/**
+	   Shows or hides the alignActionsCI.
+	   @param show	true/false for either show or hide
+	*/
+	public void showAlignActionsCI(boolean show)
+	{
+		if(show) {
+			getCoolBarManager().insertAfter(editActionsCI.getId(), alignActionsCI);
+		}
+		else {
+			getCoolBarManager().remove(alignActionsCI);
+		}
+//		showVisualizationCI(!show); //Visualizations can show up in edit mode...
+		getCoolBarManager().update(true);
+	}
+	
+	//	KH 20070514 begin
+	/**
+	 * set up the alignActions coolbar
+	 */
+	protected void createAlignActionsCI()
+	{
+		ToolBarManager toolBarManager = new ToolBarManager(SWT.FLAT);
+		toolBarManager.add(alignCenterXAction);
+		toolBarManager.add(alignCenterYAction);
+		toolBarManager.add(alignLeftAction);
+		toolBarManager.add(alignRightAction);
+		toolBarManager.add(alignTopAction);
+		toolBarManager.add(alignBottomAction);
+		toolBarManager.add(setCommonWidthAction);
+		toolBarManager.add(setCommonHeightAction);
+	
+		alignActionsCI = new ToolBarContributionItem(toolBarManager, "AlignActions");
+	}
+	
+//	KH end
+	/**
+	   Invoked when user tries to close window.
+	   We'll ask the user if he wants to save the pathway
+	*/
+	protected boolean canHandleShellCloseEvent()
+	{
+		return SwtEngine.canDiscardPathway();
+	}
+	
+	protected MenuManager menuManager = null;
+	/**
+	 * can be accessed by plugins etc. 
+	 * to add menu items and even complete menus.
+	 * 
+	 * (plugin API)
+	 */
+	public MenuManager getMenuManager()
+	{
+		return menuManager;
+	}
+		
+	public boolean close() {
+		Engine.fireApplicationEvent(
+				new ApplicationEvent(this, ApplicationEvent.APPLICATION_CLOSE));
+		return super.close();
+	}
+	
+	public ScrolledComposite sc;
+	public BackpagePanel bpBrowser; //Browser for showing backpage information
+	public PropertyPanel propertyTable;	//Table showing properties of Graphics objects
+	SashForm sashForm; //SashForm containing the drawing area and sidebar
+	TabbedSidePanel rightPanel; //side panel containing backbage browser and property editor
+	PathwaySearchComposite pwSearchComposite; //Composite that handles pathway searches and displays results
+	LegendPanel legend; //Legend to display colorset information
+	VPathwaySwingComposite swingPathwayComposite;
+	
+	public TabbedSidePanel getSidePanel() { return rightPanel; }
+	
+	public LegendPanel getLegend() { return legend; }
+	
+	public void showLegend(boolean show) {	
+		if(show && Gex.isConnected()) {
+			if(rightPanel.isVisible("Legend")) return; //Legend already visible, only refresh
+			rightPanel.unhideTab("Legend", 0);
+			rightPanel.selectTab("Legend");
+		}
+		
+		else rightPanel.hideTab("Legend");
+	}
+				
+	public void applicationEvent(ApplicationEvent e) {
+		switch(e.type) {
+		case ApplicationEvent.PATHWAY_OPENED:
+			if(Gex.isConnected()) cacheExpressionData();
+			break;
+		}
+		switch(e.type) {
+		case ApplicationEvent.PATHWAY_NEW:
+		case ApplicationEvent.PATHWAY_OPENED:
+			Engine.getActiveVPathway().addVPathwayListener(this);
+		}
+	}
+
+	public void expressionDataEvent(ExpressionDataEvent e) {
+		switch(e.type) {
+		case ExpressionDataEvent.CONNECTION_CLOSED:
+			getShell().getDisplay().syncExec(new Runnable() {
+				public void run() {
+					showLegend(false);
+				}
+			});
+			break;
+		case ExpressionDataEvent.CONNECTION_OPENED:
+			getShell().getDisplay().syncExec(new Runnable() {
+				public void run() {
+					cacheExpressionData();
+					showLegend(true);
+				}
+			});
+			break;
+		}
+	}
+	
+	public void vPathwayEvent(VPathwayEvent e) {
+		switch(e.getType()) {
+		case VPathwayEvent.EDIT_MODE_OFF:
+			showLegend(true);
+			break;
+		case VPathwayEvent.EDIT_MODE_ON:
+			showLegend(false);
+			break;
+		case VPathwayEvent.NEW_ELEMENT_ADDED:
+			deselectNewItemActions();
+			break;
+		}
+	}
+	
+	public MainWindowBase(Shell shell)
+	{
+		super(shell);
+	}
+
+}

Property changes on: trunk/src/g2d_swt/org/pathvisio/gui/swt/MainWindowBase.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/CommonActions.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/CommonActions.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/CommonActions.java	(revision 957)
@@ -0,0 +1,625 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.dialogs.MessageDialog;
+import org.eclipse.jface.preference.PreferenceDialog;
+import org.eclipse.jface.preference.PreferenceManager;
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.widgets.FileDialog;
+import org.pathvisio.Engine;
+import org.pathvisio.Globals;
+import org.pathvisio.Engine.ApplicationEvent;
+import org.pathvisio.Engine.ApplicationEventListener;
+import org.pathvisio.biopax.gui.BiopaxDialog;
+import org.pathvisio.model.ConverterException;
+import org.pathvisio.model.Pathway;
+import org.pathvisio.model.PathwayExporter;
+import org.pathvisio.preferences.swt.PreferenceDlg;
+import org.pathvisio.preferences.swt.SwtPreferences;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.view.VPathway;
+
+/**
+   This class contains a large number of JFace Actions that are both in V1 and V2.
+*/   
+public class CommonActions
+{
+	static class UndoAction extends Action
+	{
+		MainWindowBase window;
+		public UndoAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Undo@Ctrl+Z");
+			setToolTipText ("Undo last action");
+		}
+		public void run() 
+		{
+			if (Engine.getActivePathway() != null)
+			{
+				Engine.getActivePathway().undo();
+			}
+		}
+	}
+	
+	/**
+	 * {@link Action} to create a new gpml pathway
+	 */
+	static class NewAction extends Action 
+	{
+		MainWindowBase window;
+		public NewAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&New pathway@Ctrl+N");
+			setToolTipText ("Create new pathway");
+			setImageDescriptor(ImageDescriptor.createFromURL(
+					Engine.getResourceURL("icons/new.gif")));
+		}
+		public void run ()
+		{			
+			SwtEngine.newPathway();
+		}	
+	}
+	
+	/**
+	 * {@link Action} to create a new gpml pathway
+	 */
+	static class SvgExportAction extends Action 
+	{
+		MainWindowBase window;
+		public SvgExportAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("Export to SVG");
+			setToolTipText ("Export to Scalable Vector Graphics (SVG) " +
+					"for publication-quality images");
+		}
+		public void run () 
+		{
+			//TODO: move to engine, merge with "save"
+			VPathway drawing = Engine.getActiveVPathway();
+			Pathway gmmlData = Engine.getActivePathway();
+			// Check if a gpml pathway is loaded
+			if (drawing != null)
+			{
+				FileDialog fd = new FileDialog(window.getShell(), SWT.SAVE);
+				fd.setText("Save");
+				fd.setFilterExtensions(new String[] {"*." + Engine.SVG_FILE_EXTENSION, "*.*"});
+				fd.setFilterNames(new String[] {Engine.SVG_FILTER_NAME, "All files (*.*)"});
+				
+				File xmlFile = gmmlData.getSourceFile();
+				if(xmlFile != null) {
+					String name = xmlFile.getName();
+					if (name.endsWith("." + Engine.PATHWAY_FILE_EXTENSION))
+					{
+						name = name.substring(0, name.length() - 
+							Engine.PATHWAY_FILE_EXTENSION.length()) +
+							Engine.SVG_FILE_EXTENSION;
+					}
+					fd.setFileName(name);
+					fd.setFilterPath(xmlFile.getPath());
+				} else {
+					fd.setFileName(SwtPreference.SWT_DIR_PWFILES.getValue());
+				}
+				String fileName = fd.open();
+				// Only proceed if user selected a file
+				
+				if(fileName == null) return;
+				
+				// Append .svg extension if not already present
+				if(!fileName.endsWith("." + Engine.SVG_FILE_EXTENSION)) 
+					fileName += "." + Engine.SVG_FILE_EXTENSION;
+				
+				File checkFile = new File(fileName);
+				boolean confirmed = true;
+				// If file exists, ask overwrite permission
+				if(checkFile.exists())
+				{
+					confirmed = MessageDialog.openQuestion(window.getShell(),"",
+					"File already exists, overwrite?");
+				}
+				if(confirmed)
+				{
+					try
+					{
+						gmmlData.writeToSvg(checkFile);
+					}
+					catch (ConverterException e)
+					{
+						String msg = "While writing svg to " 
+							+ checkFile.getAbsolutePath();					
+						MessageDialog.openError (window.getShell(), "Error", 
+								"Error: " + msg + "\n\n" + 
+								"See the error log for details.");
+						Engine.log.error(msg, e);
+					}
+				}
+			}
+			else
+			{
+				MessageDialog.openError (window.getShell(), "Error", 
+					"No pathway to save! Open or create a new pathway first");
+			}			
+		}
+	}
+
+	/**
+	 * {@link Action} to open an gpml pathway
+	 */
+	static class OpenAction extends Action 
+	{
+		MainWindowBase window;
+		public OpenAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Open pathway@Ctrl+O");
+			setToolTipText ("Open pathway");
+			setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/open.gif")));
+		}
+		public void run () 
+		{
+			FileDialog fd = new FileDialog(window.getShell(), SWT.OPEN);
+			fd.setText("Open");
+			String pwpath = SwtPreference.SWT_DIR_PWFILES.getValue();
+			fd.setFilterPath(pwpath);
+			fd.setFilterExtensions(new String[] {"*." + Engine.PATHWAY_FILE_EXTENSION, "*.*"});
+			fd.setFilterNames(new String[] {Engine.PATHWAY_FILTER_NAME, "All files (*.*)"});
+	        String fnMapp = fd.open();
+	        // Only open pathway if user selected a file
+	        
+	        if(fnMapp != null) { 
+	        	SwtEngine.openPathway(fnMapp); 
+	        }
+		}
+	}
+
+	/**
+	 * {@link Action} to open an gpml pathway
+	 */
+	static class ImportAction extends Action 
+	{
+		MainWindowBase window;
+		public ImportAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Import");
+			setToolTipText ("Import Pathway in GenMAPP format");
+		}
+		public void run () 
+		{
+			if(SwtEngine.canDiscardPathway())
+			{
+				FileDialog fd = new FileDialog(window.getShell(), SWT.OPEN);
+				fd.setText("Open");
+				fd.setFilterPath(SwtPreference.SWT_DIR_PWFILES.getValue());
+				fd.setFilterExtensions(new String[] {"*." + Engine.GENMAPP_FILE_EXTENSION, "*.*"});
+				fd.setFilterNames(new String[] {Engine.GENMAPP_FILTER_NAME, "All files (*.*)"});
+	        	String fnMapp = fd.open();
+	        	// Only open pathway if user selected a file
+	        	
+	        	if(fnMapp != null) { 
+	        		SwtEngine.openPathway(fnMapp); 
+	        	}
+	        }
+		}
+	}
+
+	/**
+	 * {@link Action} to save a gpml pathway to a file specified by the user
+	 */
+	static class SaveAsAction extends Action 
+	{
+		MainWindowBase window;
+		public SaveAsAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("Save pathway &As");
+			setToolTipText ("Save pathway with new file name");
+		}
+		
+		public void run () 
+		{
+			SwtEngine.savePathwayAs();
+		}
+	}
+
+	
+	/**
+	 * {@link Action} to save a gpml pathway to a file specified by the user
+	 */
+	static class ExportAction extends Action 
+	{
+		MainWindowBase window;
+		public ExportAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Export");
+			setToolTipText ("Export Pathway to GenMAPP format");
+		}
+		public void run () {
+			//TODO: move to engine, merge with "save" or "saveAs"
+			VPathway drawing = Engine.getActiveVPathway();
+			Pathway gmmlData = Engine.getActivePathway();
+			// Check if a gpml pathway is loaded
+			if (drawing != null)
+			{
+				FileDialog fd = new FileDialog(window.getShell(), SWT.SAVE);
+				fd.setText("Export");
+				
+				class FileType implements Comparable<FileType> {
+					final String name;
+					final String ext;
+					public FileType(String n, String e) { name = n; ext = e; }
+					public int compareTo(FileType o) {
+						return name.compareTo(o.name);
+					}
+				}
+				
+				ArrayList<FileType> fts = new ArrayList<FileType>();
+				HashMap<String, PathwayExporter> exporters = Engine.getPathwayExporters();
+								
+				for(String ext : exporters.keySet()) {
+					fts.add(new FileType(
+								exporters.get(ext).getName() + " (*." + ext + ")",
+								"*." + ext));
+				}
+				Collections.sort(fts);
+				String[] exts = new String[fts.size()];
+				String[] nms = new String[fts.size()];
+				for(int i = 0; i < fts.size(); i++) {
+					FileType ft = fts.get(i);
+					exts[i] = ft.ext;
+					nms[i] = ft.name;
+				}
+				fd.setFilterExtensions(exts);
+				fd.setFilterNames(nms);
+								
+				File xmlFile = gmmlData.getSourceFile();
+				if(xmlFile != null) {
+					String name = xmlFile.getName();
+					if (name.endsWith("." + Engine.PATHWAY_FILE_EXTENSION))
+					{
+						name = name.substring(0, name.length() - 
+							Engine.PATHWAY_FILE_EXTENSION.length() - 1);
+					}
+					fd.setFileName(name);
+					fd.setFilterPath(xmlFile.getPath());
+				} else {
+					fd.setFileName(SwtPreference.SWT_DIR_PWFILES.getValue());
+				}
+				String fileName = fd.open();
+				// Only proceed if user selected a file
+				if(fileName == null) return;
+				
+				int dot = fileName.lastIndexOf('.');
+				String ext = Engine.GENMAPP_FILE_EXTENSION;
+				if(dot >= 0) {
+					ext = fileName.substring(dot + 1, fileName.length());
+				}
+				PathwayExporter exporter = Engine.getPathwayExporter(ext);
+				
+				if(exporter == null) 
+					MessageDialog.openError (window.getShell(), "Error", 
+					"No exporter for '" + ext +  "' files");
+								
+				File checkFile = new File(fileName);
+				boolean confirmed = true;
+				// If file exists, ask overwrite permission
+				if(checkFile.exists())
+				{
+					confirmed = MessageDialog.openQuestion(window.getShell(),"",
+					"File already exists, overwrite?");
+				}
+				if(confirmed)
+				{
+					try
+					{
+						//gmmlData.writeToMapp(checkFile);
+						exporter.doExport(checkFile, gmmlData);
+					}
+					catch (ConverterException e)
+					{
+						String msg = "While exporting to " 
+							+ checkFile.getAbsolutePath();					
+						MessageDialog.openError (window.getShell(), "Error", 
+								"Error: " + msg + "\n\n" + 
+								"See the error log for details.");
+						Engine.log.error(msg, e);
+					}
+				}
+			}
+			else
+			{
+				MessageDialog.openError (window.getShell(), "Error", 
+					"No pathway to save! Open or create a new pathway first");
+			}			
+		}
+	}
+
+	/**
+	 * {@link Action} to exit the application
+	 */
+	static class ExitAction extends Action 
+	{
+		MainWindowBase window;
+		public ExitAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("E&xit@Ctrl+X");
+			setToolTipText ("Exit Application");
+		}
+		public void run () 
+		{
+			if (SwtEngine.canDiscardPathway())
+			{
+				window.close();
+			}
+		}
+	}
+	
+	static class PreferencesAction extends Action
+	{
+		MainWindowBase window;
+		public PreferencesAction (MainWindowBase w)
+		{
+			window = w;
+			setText("&Preferences");
+			setToolTipText("Edit preferences");
+		}
+		public void run () {
+			PreferenceManager pg = new PreferenceDlg();
+			PreferenceDialog pd = new PreferenceDialog(window.getShell(), pg);
+			pd.setPreferenceStore((SwtPreferences)SwtEngine.getPreferences());
+			pd.open();
+		}
+	}
+
+	/**
+	 * {@link Action} that zooms a mapp to the specified zoomfactor
+	 */
+	static class ZoomAction extends Action 
+	{
+		MainWindowBase window;
+		int pctZoomFactor;
+		
+		/**
+		 * Constructor for this class
+		 * @param w {@link MainWindow} window this action belongs to
+		 * @param newPctZoomFactor the zoom factor as percentage of original
+		 */
+		public ZoomAction (MainWindowBase w, int newPctZoomFactor)
+		{
+			window = w;
+			pctZoomFactor = newPctZoomFactor;
+			if(pctZoomFactor == MainWindowBase.ZOOM_TO_FIT) 
+			{
+				setText ("Zoom to fit");
+				setToolTipText("Zoom mapp to fit window");
+			}
+			else
+			{
+				setText (pctZoomFactor + " %");
+				setToolTipText ("Zoom mapp to " + pctZoomFactor + " %");
+			}
+		}
+		public void run () {
+			VPathway drawing = Engine.getActiveVPathway();
+			if (drawing != null)
+			{
+				drawing.setPctZoom(pctZoomFactor);
+			}
+			else
+			{
+				MessageDialog.openError (window.getShell(), "Error", 
+					"No gpml file loaded! Open or create a new gpml file first");
+			}
+		}
+	}
+
+	/**
+	 * {@link Action} to open a {@link AboutDlg} window
+	 */
+	static class AboutAction extends Action 
+	{
+		MainWindowBase window;
+		public AboutAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&About");
+			setToolTipText ("About " + Globals.APPLICATION_VERSION_NAME);
+		}
+		public void run () {
+			AboutDlg gmmlAboutBox = new AboutDlg(window.getShell(), SWT.NONE);
+			gmmlAboutBox.open();
+		}
+	}
+	
+	/**
+	 * {@link Action} to open a Help window
+	 */
+	static class HelpAction extends Action 
+	{
+		MainWindowBase window;
+		public HelpAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Help@F1");
+			setToolTipText ("Opens " + Globals.APPLICATION_VERSION_NAME + " help in your web browser");
+		}
+		public void run ()
+		{
+			SwtEngine.openWebPage(Globals.HELP_URL, "Opening help page in broswer",
+						"Unable to open web browser" +
+						"\nYou can open the help page manually:\n" +
+						Globals.HELP_URL);
+		}
+	}
+
+	static class CopyAction extends Action
+	{
+		MainWindowBase window;
+		public CopyAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("Copy@Ctrl+C");
+			setToolTipText ("Copy selected objects to clipboard");
+		}
+		public void run()
+		{
+			Engine.getActiveVPathway().copyToClipboard();
+		}
+	}
+
+	static class PasteAction extends Action
+	{
+		MainWindowBase window;
+		public PasteAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("Paste@Ctrl+V");
+			setToolTipText ("Paste contents of clipboard");
+		}
+		public void run()
+		{
+			Engine.getActiveVPathway().pasteFromClipboad();
+		}
+	}
+	
+	/**
+	 * {@link Action} to save a gpml pathway
+	 */
+	static class SaveAction extends Action 
+	{
+		MainWindowBase window;
+		public SaveAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Save pathway@Ctrl+S");
+			setToolTipText ("Save pathway");
+			setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/save.gif")));
+		}
+		
+		public void run ()
+		{
+			SwtEngine.savePathway();
+		}
+	}
+	
+	static class BiopaxAction extends Action 
+	{
+		MainWindowBase window;
+		public BiopaxAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("Edit &BioPAX code");
+			setToolTipText ("Edit BioPAX code");
+		}
+		
+		public void run () {
+			BiopaxDialog d = new BiopaxDialog(window.getShell());
+			d.setPathway(Engine.getActivePathway());
+			d.open();
+		}
+	}
+	
+	/**
+	 * {@link Action} to switch between edit and view mode
+	 */
+	static class SwitchEditModeAction extends Action implements ApplicationEventListener
+	{
+		final String ttChecked = "Exit edit mode";
+		final String ttUnChecked = "Switch to edit mode to edit the pathway content";
+		MainWindowBase window;
+		public SwitchEditModeAction (MainWindowBase w)
+		{
+			super("&Edit mode", IAction.AS_CHECK_BOX);
+			setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/edit.gif")));
+			setToolTipText(ttUnChecked);
+			window = w;
+			
+			Engine.addApplicationEventListener(this);
+		}
+
+		public void run ()
+		{
+			if(Engine.isDrawingOpen())
+			{
+				VPathway drawing = Engine.getActiveVPathway();
+				Pathway pathway = Engine.getActivePathway();
+				if(isChecked())
+				{
+					// give a warning that this can't be edited.
+					if (pathway.getSourceFile() != null && !pathway.getSourceFile().canWrite())
+					{
+						MessageDialog.openWarning(
+								window.getShell(), "Read-only Warning",
+								"You're trying to edit a Read-only file.\n" +
+						"When you want to save your changes, you have to save to a different file.");
+					}
+					//Switch to edit mode: show edit toolbar, show property table in sidebar
+					drawing.setEditMode(true);
+					window.showEditActionsCI(true);
+					window.showAlignActionsCI(true);
+					window.rightPanel.getTabFolder().setSelection(1);
+				}
+				else
+				{
+					//Switch to view mode: hide edit toolbar, show backpage browser in sidebar
+					drawing.setEditMode(false);
+					window.showEditActionsCI(false);
+					window.showAlignActionsCI(false);
+					window.rightPanel.getTabFolder().setSelection(0);
+				}
+			}
+			else //No gpml pathway loaded, deselect action and do nothing
+			{
+				setChecked(false);
+			}
+			window.getCoolBarManager().update(true);
+		}
+		
+		public void setChecked(boolean check) {
+			super.setChecked(check);
+			setToolTipText(check ? ttChecked : ttUnChecked);
+		}
+
+		public void switchEditMode(boolean edit) {
+			setChecked(edit);
+			run();
+
+		}
+
+		public void applicationEvent(ApplicationEvent e) {
+			if(e.type == ApplicationEvent.PATHWAY_OPENED) {
+				Engine.getActiveVPathway().setEditMode(isChecked());
+			}
+			else if(e.type == ApplicationEvent.PATHWAY_NEW) {
+				switchEditMode(true);
+			}
+		}
+	}
+}

Property changes on: trunk/src/g2d_swt/org/pathvisio/gui/swt/CommonActions.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/GuiMain.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/GuiMain.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/GuiMain.java	(revision 957)
@@ -0,0 +1,206 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.io.File;
+import java.io.PrintStream;
+
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.eclipse.jface.resource.ImageRegistry;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.graphics.ImageData;
+import org.eclipse.swt.widgets.Display;
+import org.pathvisio.Engine;
+import org.pathvisio.data.Gdb;
+import org.pathvisio.data.Gex;
+import org.pathvisio.model.ImageExporter;
+import org.pathvisio.model.MappFormat;
+import org.pathvisio.model.Pathway;
+import org.pathvisio.model.SvgFormat;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.Preference;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.util.SwtUtils;
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.plugins.PluginManager;
+
+/**
+ * This class contains the main method and is responsible for initiating 
+ * the application by setting up the user interface and creating all necessary objects
+ */
+public class GuiMain {
+	
+	/**
+	 * Main method which will be carried out when running the program
+	 */
+	public static void main(String[] args)
+	{
+		boolean debugHandles = false;
+		for(String a : args) {
+			if(		a.equalsIgnoreCase("--MonitorHandles") ||
+					a.equalsIgnoreCase("-mh")) {
+				debugHandles = true;
+			}
+			else if(a.equalsIgnoreCase("--UseR") ||
+					a.equalsIgnoreCase("-ur")) {
+				SwtEngine.USE_R = true;
+			}
+		}
+		
+		//Setup the application window
+		MainWindow window = null;
+		if(debugHandles)	window = SwtEngine.getSleakWindow();
+		else				window = SwtEngine.getWindow();
+		
+		initiate();
+		
+		window.setBlockOnOpen(true);
+		window.open();
+		
+		//Perform exit operations
+		//TODO: implement PropertyChangeListener and fire exit property when closing
+		// make classes themself responsible for closing when exit property is changed
+		Gex.close();
+		Gdb.close();
+		//Close log stream
+		Engine.log.getStream().close();
+		
+		Display.getCurrent().dispose();
+	}
+	
+	/**
+	 * Initiates some objects used by the program
+	 */
+	public static void initiate() {
+		//initiate logger
+		try { 
+			GlobalPreference.FILE_LOG.setDefault(new File(SwtEngine.getApplicationDir(), ".PathVisioLog").toString());
+			Engine.log.setStream(new PrintStream(GlobalPreference.FILE_LOG.getValue())); 
+		} catch(Exception e) {}
+		Engine.log.setLogLevel(true, true, true, true, true, true);//Modify this to adjust log level
+		Pathway.setLogger(Engine.log);
+		
+		//load the preferences
+		loadPreferences();
+		
+		//initiate Gene database (to load previously used gdb)
+		Gdb.init();
+		
+		//load visualizations and plugins
+		loadVisualizations();
+		
+		//create data directories if they don't exist yet
+		createDataDirectories();
+		
+		//register listeners for static classes
+		registerListeners();
+				
+		registerExporters();
+		
+		//NOTE: ImageRegistry will be initiated in "createContents" of MainWindow,
+		//since the window has to be opened first (need an active Display)
+	}
+	
+	/**
+	 * Creates data directories stored in preferences (if not exist)
+	 */
+	static void createDataDirectories() {
+		Preference[] dirPrefs = new Preference[] {
+				SwtPreference.SWT_DIR_EXPR,
+				SwtPreference.SWT_DIR_GDB,
+				SwtPreference.SWT_DIR_PWFILES,
+				SwtPreference.SWT_DIR_RDATA,
+		};
+		for(Preference p : dirPrefs) {
+			File dir = new File(p.getValue());
+			if(!dir.exists()) dir.mkdir();
+		}
+	}
+	
+			
+	static void registerListeners() {
+		VisualizationManager vmgr = new VisualizationManager();
+		Gex gex = new Gex();
+		
+		Engine.addApplicationEventListener(vmgr);
+		Engine.addApplicationEventListener(gex);
+	}
+	
+	static void registerExporters() {
+		Engine.addPathwayExporter(new MappFormat());
+		Engine.addPathwayExporter(new SvgFormat());
+		Engine.addPathwayExporter(new ImageExporter(ImageExporter.TYPE_PNG));
+		Engine.addPathwayExporter(new ImageExporter(ImageExporter.TYPE_TIFF));
+		Engine.addPathwayExporter(new ImageExporter(ImageExporter.TYPE_PDF));
+	}
+	
+	static void loadVisualizations() {
+		//load visualization plugins
+		try {
+			PluginManager.loadPlugins();
+		} catch (Throwable e) {
+			Engine.log.error("When loading visualization plugins", e);
+		}
+		
+		VisualizationManager.loadGeneric();
+	}
+	
+	static void loadPreferences() {
+		SwtEngine.getPreferences();
+	}
+	
+	/**
+	 * Loads images used throughout the applications into an {@link ImageRegistry}
+	 */
+	static void loadImages(Display display)
+	{
+		ClassLoader cl = GuiMain.class.getClassLoader();
+	
+		ImageRegistry imageRegistry = new ImageRegistry(display);
+		
+		// Labels for color by expressiondata (mRNA and Protein)
+		ImageData img = new ImageData(cl.getResourceAsStream("images/mRNA.bmp"));
+		img.transparentPixel = img.palette.getPixel(SwtUtils.color2rgb(Engine.TRANSPARENT_COLOR));
+		imageRegistry.put("data.mRNA",
+				new Image(display, img));
+		img = new ImageData(cl.getResourceAsStream("images/protein.bmp"));
+		img.transparentPixel = img.palette.getPixel(SwtUtils.color2rgb(Engine.TRANSPARENT_COLOR));
+		imageRegistry.put("data.protein",
+				new Image(display, img));
+		imageRegistry.put("sidepanel.minimize",
+				ImageDescriptor.createFromURL(cl.getResource("icons/minimize.gif")));
+		imageRegistry.put("sidepanel.hide",
+				ImageDescriptor.createFromURL(cl.getResource("icons/close.gif")));
+		imageRegistry.put("shell.icon", 
+				ImageDescriptor.createFromURL(cl.getResource("images/bigcateye.gif")));
+		imageRegistry.put("about.logo",
+				ImageDescriptor.createFromURL(cl.getResource("images/logo.jpg")));
+						imageRegistry.put("checkbox.unchecked",
+				ImageDescriptor.createFromURL(cl.getResource("icons/unchecked.gif")));
+		imageRegistry.put("checkbox.unavailable",
+				ImageDescriptor.createFromURL(cl.getResource("icons/unchecked_unavailable.gif")));
+		imageRegistry.put("checkbox.checked",
+				ImageDescriptor.createFromURL(cl.getResource("icons/checked.gif")));
+		imageRegistry.put("tree.collapsed",
+				ImageDescriptor.createFromURL(cl.getResource("icons/tree_collapsed.gif")));
+		imageRegistry.put("tree.expanded",
+				ImageDescriptor.createFromURL(cl.getResource("icons/tree_expanded.gif")));
+		SwtEngine.setImageRegistry(imageRegistry);
+	}
+	
+}
+

Property changes on: trunk/src/g2d_swt/org/pathvisio/gui/swt/GuiMain.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/AlignActions.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/AlignActions.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/AlignActions.java	(revision 957)
@@ -0,0 +1,177 @@
+//	 PathVisio,
+//	 a tool for data visualization and analysis using Biological Pathways
+//	 Copyright 2006-2007 BiGCaT Bioinformatics
+	//
+//	 Licensed under the Apache License, Version 2.0 (the "License"); 
+//	 you may not use this file except in compliance with the License. 
+//	 You may obtain a copy of the License at 
+//	 
+//	 http://www.apache.org/licenses/LICENSE-2.0 
+//	  
+//	 Unless required by applicable law or agreed to in writing, software 
+//	 distributed under the License is distributed on an "AS IS" BASIS, 
+//	 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+//	 See the License for the specific language governing permissions and 
+//	 limitations under the License.
+	//
+
+package org.pathvisio.gui.swt;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.pathvisio.Engine;
+public class AlignActions {
+
+		
+	public static final char CENTERX = 'x';
+	public static final char CENTERY = 'y';
+	public static final char LEFT = 'l';
+	public static final char RIGHT = 'r';
+	public static final char TOP = 't';
+	public static final char BOTTOM = 'b';
+	public static final char WIDTH = 'w';
+	public static final char HEIGHT = 'h';
+	
+	
+		static class AlignCenterXAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignCenterXAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align horizontal centers");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/aligncenterx.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(CENTERX);
+				
+			}
+		}
+		
+		static class AlignCenterYAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignCenterYAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align vertical centers");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/aligncentery.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(CENTERY);
+				
+			}
+		}
+		static class AlignLeftAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignLeftAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align left edges");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/alignleft.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(LEFT);
+				
+			}
+		}
+		static class AlignRightAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignRightAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align right edges");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/alignright.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(RIGHT);
+				
+			}
+		}
+		static class AlignTopAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignTopAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align top edges");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/aligntop.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(TOP);
+				
+			}
+		}
+		static class AlignBottomAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignBottomAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align bottom edges");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/alignbottom.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(BOTTOM);
+				
+			}
+		}
+		static class SetCommonHeightAction extends Action 
+		{
+			MainWindowBase window;
+			public SetCommonHeightAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Set common height");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/sizeheight.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().scaleSelected(HEIGHT);
+				
+			}
+		}
+		static class SetCommonWidthAction extends Action 
+		{
+			MainWindowBase window;
+			public SetCommonWidthAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Set common width");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/sizewidth.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().scaleSelected(WIDTH);
+				
+			}
+		}
+
+
+	}
+
+
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/SwtInputBlocker.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/SwtInputBlocker.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/SwtInputBlocker.java	(revision 957)
@@ -0,0 +1,111 @@
+/*******************************************************************************
+ * Copyright (c) 2007 SAS Institute.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     SAS Institute - initial API and implementation
+ *******************************************************************************/
+package org.pathvisio.gui.swt.awt;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.FocusAdapter;
+import org.eclipse.swt.events.FocusEvent;
+import org.eclipse.swt.widgets.Dialog;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Shell;
+
+
+
+class SwtInputBlocker extends Dialog {
+    static private SwtInputBlocker instance = null;
+    static private int blockCount = 0;
+    private Shell shell;
+
+    private SwtInputBlocker(Shell parent) {
+        super(parent, SWT.NONE); 
+    }
+    
+    private Object open() {
+        assert Display.getCurrent() != null;     // On SWT event thread
+        
+        final Shell parent = getParent();
+        shell = new Shell(parent, SWT.APPLICATION_MODAL);
+        shell.setSize(0, 0);
+        shell.addFocusListener(new FocusAdapter() {
+            public void focusGained(FocusEvent e) {
+                // On some platforms (e.g. Linux/GTK), the 0x0 shell still appears as a dot 
+                // on the screen, so make it invisible by moving it below other windows. This
+                // is unnecessary under Windows and causes a flash, so only make the call when necessary. 
+                if (Platform.isGtk()) {
+                    shell.moveBelow(null);
+                }
+                AwtEnvironment.getInstance(shell.getDisplay()).requestAwtDialogFocus();
+            }
+        });
+        shell.open();
+        
+        Display display = parent.getDisplay();
+        while (!shell.isDisposed()) {
+            if (!display.readAndDispatch()) {
+                display.sleep();
+            }
+        }
+        return null;
+    }
+
+    private void close() {
+        assert shell != null;
+        
+        shell.dispose();
+    }
+
+    static void unblock() {
+        assert blockCount >= 0;
+        assert Display.getCurrent() != null;  // On SWT event thread
+
+        
+        // System.out.println("Deleting SWT blocker");
+        if (blockCount == 0) {
+            return;
+        }
+        if ((blockCount == 1) && (instance != null)) {
+            instance.close();
+            instance = null;
+        }
+        blockCount--;
+    }
+    
+    static void block() {
+        assert blockCount >= 0;
+        
+        // System.out.println("Creating SWT blocker");
+        final Display display = Display.getCurrent();
+        assert display != null;  // On SWT event thread
+        
+        blockCount++;
+        if (blockCount == 1) {
+            assert instance == null;  // should be no existing blocker
+            
+            // get a shell to parent the blocking dialog
+            Shell shell = AwtEnvironment.getInstance(display).getShell();
+
+            // If there is a shell to block, block input now. If there are no shells, 
+            // then there is no input to block. In the case of no shells, we are not
+            // protecting against a shell that might get created later. This is a rare
+            // enough case to skip, at least for now. In the future, a listener could be 
+            // added to cover it. 
+            // TODO: if (shell==null) add listener to block shells created later?
+            //
+            // Block is implemented with a hidden modal dialog. Using setEnabled(false) is another option, but 
+            // on some platforms that will grey the disabled controls.
+            if (shell != null) {
+                instance = new SwtInputBlocker(shell);
+                instance.open();
+            }
+        }
+    }
+
+}
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/AwtEnvironment.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/AwtEnvironment.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/AwtEnvironment.java	(revision 957)
@@ -0,0 +1,337 @@
+/*******************************************************************************
+ * Copyright (c) 2007 SAS Institute.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     SAS Institute - initial API and implementation
+ *******************************************************************************/
+package org.pathvisio.gui.swt.awt;
+
+import java.awt.EventQueue;
+import java.awt.Frame;
+import java.lang.reflect.InvocationTargetException;
+
+import javax.swing.UIManager;
+import javax.swing.UnsupportedLookAndFeelException;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.SWTException;
+import org.eclipse.swt.awt.SWT_AWT;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Shell;
+
+
+
+/**
+ * An environment to enable the proper display of AWT/Swing windows within a SWT or RCP 
+ * application. This class extends the base {@link org.eclipse.swt.awt.SWT_AWT Eclipse SWT/AWT integration}
+ * support by
+ * <ul>
+ * <li>Using the platform-specific system Look and Feel. 
+ * <li>Ensuring AWT modal dialogs are modal across the SWT application.
+ * <li>Working around various AWT/Swing bugs  
+ * </ul>
+ * <p>
+ * This class is most helpful to applications which create new AWT/Swing windows (e.g. dialogs) rather
+ * than those which embed AWT/Swing components in SWT windows. For support specific to embedding
+ * AWT/Swing components see {@link EmbeddedSwingComposite}.
+ * <p>
+ * There is at most one instance of this class per SWT
+ * {@link org.eclipse.swt.widgets.Display Display}. In almost all applications
+ * this means that there is exactly one instance for the entire application. In fact, the
+ * current implementation always limits the number of instances to exactly one.
+ * <p>
+ * An instance of this class can be obtained with the static
+ * {@link #getInstance(Display)} method.
+*/
+public final class AwtEnvironment {
+    // TODO: add pop-up dismissal and font synchronization support to this level?
+    
+    private static final String GTK_LOOK_AND_FEEL_NAME = "com.sun.java.swing.plaf.gtk.GTKLookAndFeel"; //$NON-NLS-1$
+
+    private static AwtEnvironment instance = null;
+    private static boolean isLookAndFeelInitialized = false;
+
+    private final Display display;
+    private final AwtDialogListener dialogListener;
+
+    /**
+     * Returns the single instance of AwtEnvironment for the given display. On
+     * the first call to this method, the necessary initialization to allow
+     * AWT/Swing code to run properly within an Eclipse application is done.
+     * This initialization includes setting the approprite look and feel and
+     * registering the necessary listeners to ensure proper behavior of modal
+     * dialogs.
+     * <p>
+     * The first call to this method must occur before any AWT/Swing APIs are
+     * called. 
+     * <p>
+     * The current implementation limits the number of instances of
+     * AwtEnvironment to one. If this method is called with a display different
+     * to one used on a previous call, {@link UnsupportedOperationException} is
+     * thrown.
+     * 
+     * @param display
+     *            the non-null SWT display
+     * @return the AWT environment
+     * @exception IllegalArgumentException
+     *                <ul>
+     *                <li>ERROR_NULL_ARGUMENT - if the display is null</li>
+     *                </ul>
+     * @exception UnsupportedOperationException -
+     *                on attempt to use multiple displays.
+     */
+    public static AwtEnvironment getInstance(Display display) {
+        // For now assume a single display. If necessary, this implementation
+        // can be changed to create multiple environments for multiple display
+        // applications.
+        // TODO: add multiple display support
+        if (display == null) {
+            SWT.error(SWT.ERROR_NULL_ARGUMENT);
+        }
+        if ((instance != null) && !display.equals(instance.display)) {
+            throw new UnsupportedOperationException("Multiple displays not supported");
+        }
+        synchronized (AwtEnvironment.class) {
+            if (instance == null) {
+                instance = new AwtEnvironment(display);
+            }
+        }
+        return instance;
+    }
+
+    // Private constructor - clients use getInstance() to obtain instances
+    private AwtEnvironment(Display display) {
+        assert display != null;
+
+        /*
+         * This property removes a large amount of flicker from embedded swing
+         * components. Ideally it would not be set until EmbeddedSwingComposite
+         * is used, but since its value is read once and cached by AWT, it needs
+         * to be set before any AWT/Swing APIs are called.
+         */       
+        // TODO: this is effective only on Windows.
+        System.setProperty("sun.awt.noerasebackground", "true"); //$NON-NLS-1$//$NON-NLS-2$
+
+        /*
+         * RCP apps always want the standard platform look and feel It's
+         * important to wait for the L&F to be set so that any subsequent calls
+         * to createFrame() will be return a frame with the proper L&F (note
+         * that createFrame() happens on the SWT thread).
+         * 
+         * The call to invokeAndWait is safe because
+         * the first call AwtEnvironment.getInstance should happen
+         * before any (potential deadlocking) activity occurs on the 
+         * AWT thread.
+         */
+        try {
+            EventQueue.invokeAndWait(new Runnable() {
+                public void run() {
+                    setSystemLookAndFeel();
+                }
+            });
+        } catch (InterruptedException e) {
+            SWT.error(SWT.ERROR_FAILED_EXEC, e);
+        } catch (InvocationTargetException e) {
+            SWT.error(SWT.ERROR_FAILED_EXEC, e);
+        }
+
+        this.display = display;
+
+        // Listen for AWT modal dialogs to make them modal application-wide
+        dialogListener = new AwtDialogListener(display);
+    }
+
+    /**
+     * Invokes the given runnable in the AWT event thread while blocking user
+     * input on the SWT event thread. The SWT event thread will remain blocked
+     * until the runnable task completes, at which point this method will
+     * return.
+     * <p>
+     * This method is useful for displayng modal AWT/Swing dialogs from the SWT
+     * event thread. The modal AWT/Swing dialog will always block input across
+     * the whole application, but not until it appears. By calling this method,
+     * it is guaranteed that SWT input is blocked immediately, even before the
+     * AWT/Swing dialog appears.
+     * <p>
+     * To avoid unnecessary flicker, AWT/Swing dialogs should have their parent
+     * set to a frame returned by {@link #createDialogParentFrame()}.
+     * <p>
+     * This method must be called from the SWT event thread.
+     * 
+     * @param runnable
+     *            the code to schedule on the AWT event thread
+     * @exception IllegalArgumentException
+     *                <ul>
+     *                <li>ERROR_NULL_ARGUMENT - if the runnable is null</li>
+     *                </ul>
+     * @exception SWTException
+     *                <ul>
+     *                <li>ERROR_THREAD_INVALID_ACCESS - if not called from the
+     *                SWT event thread
+     *                </ul>
+     */
+    public void invokeAndBlockSwt(final Runnable runnable) {
+        assert display != null;
+
+        /*
+         * This code snippet is based on the following thread on
+         * news.eclipse.platform.swt:
+         * http://dev.eclipse.org/newslists/news.eclipse.platform.swt/msg24234.html
+         */
+        if (runnable == null) {
+            SWT.error(SWT.ERROR_NULL_ARGUMENT);
+        }
+        if (display != Display.getCurrent()) {
+            SWT.error(SWT.ERROR_THREAD_INVALID_ACCESS);
+        }
+
+        // Switch to the AWT thread...
+        EventQueue.invokeLater(new Runnable() {
+            public void run() {
+                try {
+                    // do swing work...
+                    runnable.run();
+                } finally {
+                    display.asyncExec(new Runnable() {
+                        public void run() {
+                            // Unblock SWT
+                            SwtInputBlocker.unblock();
+                        }
+                    });
+                }
+            }
+        });
+
+        // Prevent user input on SWT components
+        SwtInputBlocker.block();
+    }
+
+    /**
+     * Creates an AWT frame suitable as a parent for AWT/Swing dialogs. 
+     * <p>
+     * This method must be called from the SWT event thread. There must be an active
+     * shell associated with the environment's display.  
+     * <p>
+     * The created frame is a non-visible child of the active shell and will be disposed when that shell
+     * is disposed.
+     * <p>
+     * See {@link #createDialogParentFrame(Shell)} for more details. 
+     * 
+     * @return a {@link java.awt.Frame} to be used for parenting dialogs
+     * @exception SWTException
+     *                <ul>
+     *                <li>ERROR_THREAD_INVALID_ACCESS - if not called from the
+     *                SWT event thread
+     *                </ul>
+     * @exception IllegalStateException
+     *                if the current display has no shells
+     */
+    public Frame createDialogParentFrame() {
+        if (display != Display.getCurrent()) {
+            SWT.error(SWT.ERROR_THREAD_INVALID_ACCESS);
+        }
+        Shell parent = display.getActiveShell();
+        if (parent == null) {
+            throw new IllegalStateException("No Active Shell");
+        }
+        return createDialogParentFrame(parent);
+    }
+    
+    /**
+     * Creates an AWT frame suitable as a parent for AWT/Swing dialogs. 
+     * <p>
+     * This method must be called from the SWT event thread. There must be an active
+     * shell associated with the environment's display.
+     * <p>
+     * The created frame is a non-visible child of the given shell and will be disposed when that shell
+     * is disposed.
+     * <p>
+     * This method is useful for creating a frame to parent any AWT/Swing
+     * dialogs created for use inside a SWT application. A modal AWT/Swing
+     * dialogs will flicker less if its parent is set to the returned frame
+     * rather than to null or to an independently created {@link java.awt.Frame}.  
+     * 
+     * @return a {@link java.awt.Frame} to be used for parenting dialogs
+     * @exception SWTException
+     *                <ul>
+     *                <li>ERROR_THREAD_INVALID_ACCESS - if not called from the
+     *                SWT event thread
+     *                </ul>
+     * @exception IllegalStateException
+     *                if the current display has no shells
+     */
+    public Frame createDialogParentFrame(Shell parent) {
+        if (parent == null) {
+            SWT.error(SWT.ERROR_NULL_ARGUMENT);
+        }
+        if (display != Display.getCurrent()) {
+            SWT.error(SWT.ERROR_THREAD_INVALID_ACCESS);
+        }
+        Shell shell = new Shell(parent);
+        shell.setVisible(false);
+        Composite composite = new Composite(shell, SWT.EMBEDDED);
+        return SWT_AWT.new_Frame(composite);
+    }
+
+    // Find a shell to use, giving preference to the active shell.
+    Shell getShell() {
+        Shell shell = display.getActiveShell();
+        if (shell == null) {
+            Shell[] allShells = display.getShells();
+            if (allShells.length > 0) {
+                shell = allShells[0];
+            }
+        }
+        return shell;
+    }
+
+    void requestAwtDialogFocus() {
+        assert dialogListener != null;
+
+        dialogListener.requestFocus();
+    }
+
+    private void setSystemLookAndFeel() {
+        assert EventQueue.isDispatchThread(); // On AWT event thread
+
+        if (!isLookAndFeelInitialized) {
+            isLookAndFeelInitialized = true;
+            try {
+                String systemLaf = UIManager.getSystemLookAndFeelClassName();
+                String xplatLaf = UIManager.getCrossPlatformLookAndFeelClassName();
+
+                // Java makes metal the system look and feel if running under a
+                // non-gnome Linux desktop. Fix that here, if the RCP itself is
+                // running
+                // with the GTK windowing system set.
+                if (xplatLaf.equals(systemLaf) && Platform.isGtk()) {
+                    systemLaf = GTK_LOOK_AND_FEEL_NAME;
+                }
+                UIManager.setLookAndFeel(systemLaf);
+            } catch (ClassNotFoundException e) {
+                // TODO Auto-generated catch block
+                e.printStackTrace();
+            } catch (InstantiationException e) {
+                // TODO Auto-generated catch block
+                e.printStackTrace();
+            } catch (IllegalAccessException e) {
+                // TODO Auto-generated catch block
+                e.printStackTrace();
+            } catch (UnsupportedLookAndFeelException e) {
+                // TODO Auto-generated catch block
+                e.printStackTrace();
+            }
+        }
+    }
+    
+    // This method is called by unit tests
+    static void reset() {
+        instance = null;
+    }
+
+}
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/RecursiveContainerListener.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/RecursiveContainerListener.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/RecursiveContainerListener.java	(revision 957)
@@ -0,0 +1,101 @@
+/*******************************************************************************
+ * Copyright (c) 2007 SAS Institute.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     SAS Institute - initial API and implementation
+ *******************************************************************************/
+package org.pathvisio.gui.swt.awt;
+
+import java.awt.Component;
+import java.awt.Container;
+import java.awt.EventQueue;
+import java.awt.event.ContainerEvent;
+import java.awt.event.ContainerListener;
+
+class RecursiveContainerListener implements ContainerListener {
+    private final ContainerListener listener;
+    
+    RecursiveContainerListener(ContainerListener listener) {
+        assert listener != null;
+        
+        this.listener = listener;
+    }
+
+    private void handleAdd(Container source, Component c) {
+        assert source != null;
+        assert c != null;
+        assert listener != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // System.out.println("Listening to: " + c);
+        listener.componentAdded(new ContainerEvent(source, ContainerEvent.COMPONENT_ADDED, c));
+        if (c instanceof Container) {
+            ((Container)c).addContainerListener(this);
+        }
+    }
+    
+    private void handleRemove(Container source, Component c) {
+        assert source != null;
+        assert c != null;
+        assert listener != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+
+        // System.out.println("Stopped Listening to: " + c);
+        listener.componentRemoved(new ContainerEvent(source, ContainerEvent.COMPONENT_REMOVED, c));
+        if (c instanceof Container) {
+            ((Container)c).removeContainerListener(this);
+        }
+    }
+    
+    private void handleAllAdds(Container source, Component child) {
+        assert source != null;
+        assert child != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+
+        if (child instanceof Container) {
+            Container container = (Container)child;
+            Component[] children = container.getComponents();
+            for (int i = 0; i < children.length; i++) {
+                handleAllAdds(container, children[i]);
+            }
+        }
+        handleAdd(source, child);
+    }
+    
+    private void handleAllRemoves(Container source, Component child) {
+        assert source != null;
+        assert child != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+
+        if (child instanceof Container) {
+            Container container = (Container)child;
+            Component[] children = container.getComponents();
+            for (int i = 0; i < children.length; i++) {
+                handleAllRemoves(container, children[i]);
+            }
+        }
+        handleRemove(source, child);
+
+    }
+
+    public void componentAdded(ContainerEvent e) {
+        assert e != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        Container source = (Container)e.getSource();
+        handleAllAdds(source, e.getChild());
+    }
+    
+    public void componentRemoved(ContainerEvent e) {
+        assert e != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        Container source = (Container)e.getSource();
+        handleAllRemoves(source, e.getChild());
+    }
+}
+
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/AwtDialogListener.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/AwtDialogListener.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/AwtDialogListener.java	(revision 957)
@@ -0,0 +1,224 @@
+/*******************************************************************************
+ * Copyright (c) 2007 SAS Institute.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     SAS Institute - initial API and implementation
+ *******************************************************************************/
+package org.pathvisio.gui.swt.awt;
+
+import java.awt.AWTEvent;
+import java.awt.Dialog;
+import java.awt.EventQueue;
+import java.awt.Toolkit;
+import java.awt.Window;
+import java.awt.event.AWTEventListener;
+import java.awt.event.ComponentEvent;
+import java.awt.event.ComponentListener;
+import java.awt.event.WindowEvent;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.eclipse.swt.widgets.Display;
+
+/**
+ * A listener that insures the proper modal behavior of Swing dialogs when running
+ * within a SWT environment. When initialized, it blocks and unblocks SWT input
+ * as modal Swing dialogs are shown and hidden. 
+ */
+class AwtDialogListener implements AWTEventListener, ComponentListener {
+    
+    // modalDialogs should be accessed only from the AWT thread, so no
+    // synchronization is needed. 
+    private final List modalDialogs = new ArrayList();
+    private final Display display;
+    
+    /**
+     * Registers this object as an AWT event listener so that Swing dialogs have the 
+     * proper modal behavior in the containing SWT environment. This is called automatically
+     * when you construct a {@link EmbeddedSwingComposite}, and it
+     * need not be called separately in that case.  
+     * @param shell 
+     */
+    AwtDialogListener(Display display) {
+        assert display != null;
+        
+        this.display = display;
+        Toolkit.getDefaultToolkit().addAWTEventListener(this, AWTEvent.WINDOW_EVENT_MASK);
+    }
+    
+    private void handleRemovedDialog(Dialog awtDialog, boolean removeListener) {
+        assert awtDialog != null;
+        assert modalDialogs != null;
+        assert display != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // System.out.println("Remove dialog: " + awtDialog);
+        if (removeListener) {
+            awtDialog.removeComponentListener(this);
+        }
+        // Note: there is no isModal() check here because the dialog might 
+        // have been changed from modal to non-modal after it was opened. In this case
+        // the currently visible dialog would still act modal and we'd need to unblock
+        // SWT here when it goes away.
+        if (modalDialogs.remove(awtDialog)) {
+            display.asyncExec(new Runnable() {
+                public void run() {
+                    SwtInputBlocker.unblock();
+                }
+            });            
+        }
+    }
+
+    private void handleAddedDialog(final Dialog awtDialog) {
+        assert awtDialog != null;
+        assert modalDialogs != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // System.out.println("Add dialog: " + awtDialog);
+        if (modalDialogs.contains(awtDialog) || !awtDialog.isModal() || !awtDialog.isVisible()) {
+            return;
+        }
+        modalDialogs.add(awtDialog);
+        awtDialog.addComponentListener(this);
+        display.asyncExec(new Runnable() {
+            public void run() {
+                SwtInputBlocker.block();
+            }
+        });        
+    }
+    
+    void requestFocus() {
+        // TODO: this does not always bring the dialog to the top 
+        // under some Linux desktops/window managers (e.g. metacity under GNOME).
+        EventQueue.invokeLater(new Runnable() {
+            public void run() {
+                assert modalDialogs != null;
+                
+                int size = modalDialogs.size();
+                if (size > 0) {
+                    final Dialog awtDialog = (Dialog)modalDialogs.get(size - 1);
+
+                    // In one case, a call to requestFocus() alone does not 
+                    // bring the AWT dialog to the top. This happens if the 
+                    // dialog is given a null parent frame. When opened, the dialog
+                    // can be hidden by the SWT window even when it obtains focus.
+                    // Calling toFront() solves the problem, but...
+                    //
+                    // There are still problems if the Metal look and feel is in use.
+                    // The SWT window will hide the dialog the first time it is 
+                    // selected. Once the dialog is brought back to the front by 
+                    // the user, there is no further problem. 
+                    //
+                    // Why? It looks like SWT is not being notified of lost focus when 
+                    // the Metal dialog first opens; subsequently, when focus is regained, the 
+                    // focus gain event is not posted to the SwtInputBlocker.  
+                    //
+                    // The workaround is to use Windows look and feel, rather than Metal.
+                    // System.out.println("Bringing to front");
+
+                    awtDialog.requestFocus();
+                    awtDialog.toFront();
+                }
+            }
+        });
+    }
+
+    private void handleOpenedWindow(WindowEvent event) {
+        assert event != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        Window window = event.getWindow();
+        if (window instanceof Dialog) {
+            handleAddedDialog((Dialog)window);
+        }
+    }
+    
+    private void handleClosedWindow(WindowEvent event) {
+        assert event != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // Dispose-based close
+        Window window = event.getWindow();
+        if (window instanceof Dialog) {
+            // Remove dialog and component listener
+            handleRemovedDialog((Dialog)window, true);
+        }
+    }
+
+    private void handleClosingWindow(WindowEvent event) {
+        assert event != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // System-based close 
+        Window window = event.getWindow();
+        if (window instanceof Dialog) {
+            final Dialog dialog = (Dialog) window;
+            // Defer until later. Bad things happen if 
+            // handleRemovedDialog() is called directly from 
+            // this event handler. The Swing dialog does not close
+            // properly and its modality remains in effect.
+            EventQueue.invokeLater(new Runnable() {
+                public void run() {
+                    // Remove dialog and component listener
+                    handleRemovedDialog(dialog, true);
+                }
+            });
+        }
+    }
+    
+    public void eventDispatched(AWTEvent event) {
+        assert event != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        switch (event.getID()) {
+        case WindowEvent.WINDOW_OPENED:
+            handleOpenedWindow((WindowEvent)event);
+            break;
+            
+        case WindowEvent.WINDOW_CLOSED:
+            handleClosedWindow((WindowEvent)event);
+            break;
+
+        case WindowEvent.WINDOW_CLOSING:
+            handleClosingWindow((WindowEvent)event);
+            break;
+
+        default:
+            break;
+        }
+    }
+
+    public void componentHidden(ComponentEvent e) {
+        assert e != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // System.out.println("Component hidden");
+        Object obj = e.getSource();
+        if (obj instanceof Dialog) {
+            // Remove dialog but keep listener in place so that we know if/when it is set visible
+            handleRemovedDialog((Dialog)obj, false);
+        }
+    }
+
+    public void componentShown(ComponentEvent e) {
+        assert e != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // System.out.println("Component shown");
+        Object obj = e.getSource();
+        if (obj instanceof Dialog) {
+            handleAddedDialog((Dialog)obj);
+        }
+    }
+
+    public void componentResized(ComponentEvent e) {
+    }
+
+    public void componentMoved(ComponentEvent e) {
+    }
+        
+}
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/EmbeddedChildFocusTraversalPolicy.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/EmbeddedChildFocusTraversalPolicy.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/EmbeddedChildFocusTraversalPolicy.java	(revision 957)
@@ -0,0 +1,93 @@
+/*******************************************************************************
+ * Copyright (c) 2007 SAS Institute.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     SAS Institute - initial API and implementation
+ *******************************************************************************/
+package org.pathvisio.gui.swt.awt;
+
+
+import java.awt.Component;
+import java.awt.Container;
+import java.awt.EventQueue;
+
+import javax.swing.LayoutFocusTraversalPolicy;
+
+class EmbeddedChildFocusTraversalPolicy extends LayoutFocusTraversalPolicy {
+
+    private static final long serialVersionUID = -7708166698501335927L;
+    private final AwtFocusHandler awtHandler;
+
+     EmbeddedChildFocusTraversalPolicy(AwtFocusHandler handler) {
+         assert handler != null;
+         awtHandler = handler;
+    }
+
+    public Component getComponentAfter(Container container, Component component) {
+        assert container != null;
+        assert component != null;
+        assert awtHandler != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        if (component.equals(getLastComponent(container))) {
+            // Instead of cycling around to the first component, transfer to the next SWT component
+            awtHandler.transferFocusNext();
+            return null;
+        } else {
+            return super.getComponentAfter(container, component);
+        }
+    }
+
+    public Component getComponentBefore(Container container, Component component) {
+        assert container != null;
+        assert component != null;
+        assert awtHandler != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        if (component.equals(getFirstComponent(container))) {
+            // Instead of cycling around to the last component, transfer to the previous SWT component
+            awtHandler.transferFocusPrevious();
+            return null;
+        } else {
+            return super.getComponentBefore(container, component);
+        }
+    }
+    
+    public Component getDefaultComponent(Container container) {
+        assert container != null;
+        assert awtHandler != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // This is a hack which depends on knowledge of current JDK implementation to 
+        // work. The implementation above of getComponentBefore/After
+        // properly returns null when transferring to SWT. However, the calling AWT container
+        // will then immediately try this method to find the next recipient of
+        // focus. But we don't want *any* AWT component to receive focus... it's just
+        // been transferred to SWT. So, this method must return null when AWT does 
+        // not own the focus. When AWT *does* own the focus, behave normally.  
+        if (awtHandler.awtHasFocus()) {
+            // System.out.println("getDefault: super");
+            return super.getDefaultComponent(container);
+        } else {
+            // System.out.println("getDefault: null");
+            return null;
+        }
+    }
+
+    public Component getCurrentComponent(Container container) {
+        assert container != null;
+        assert awtHandler != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        Component currentAwtComponent = awtHandler.getCurrentComponent();
+        if ((currentAwtComponent != null) && container.isAncestorOf(currentAwtComponent)){
+            return currentAwtComponent;
+        } else {
+            return getDefaultComponent(container);
+        }
+    }
+}
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/EmbeddedSwingComposite.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/EmbeddedSwingComposite.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/EmbeddedSwingComposite.java	(revision 957)
@@ -0,0 +1,480 @@
+/*******************************************************************************
+ * Copyright (c) 2007 SAS Institute.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     SAS Institute - initial API and implementation
+ *******************************************************************************/
+package org.pathvisio.gui.swt.awt;
+
+import java.awt.Container;
+import java.awt.EventQueue;
+import java.awt.Frame;
+import java.awt.Toolkit;
+
+import javax.swing.JApplet;
+import javax.swing.JComponent;
+import javax.swing.RootPaneContainer;
+import javax.swing.SwingUtilities;
+import javax.swing.UIManager;
+import javax.swing.plaf.FontUIResource;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.SWTException;
+import org.eclipse.swt.awt.SWT_AWT;
+import org.eclipse.swt.graphics.Font;
+import org.eclipse.swt.graphics.FontData;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.Listener;
+import org.eclipse.swt.widgets.Widget;
+
+/**
+ * A SWT composite widget for embedding Swing components in a SWT composite within an RCP or standalone-SWT application. The Eclipse platform 
+ * provides limited support for embedding Swing components through {@link org.eclipse.swt.awt.SWT_AWT}. 
+ * This class extends that support by 
+ * <ul>
+ * <li>Using the platform-specific system Look and Feel. 
+ * <li>Ensuring AWT modal dialogs are modal across the SWT application.
+ * <li>Reducing flicker, especially on window resizes
+ * <li>Allowing Tab Traversal to and from the Embedded Frame
+ * <li>Dismissing most Pop-Up Menus when focus leaves the AWT frame.  
+ * <li>Synchronizing Font Changes from system settings
+ * <li>Working around various AWT/Swing bugs  
+ * </ul>
+ * <P>
+ * If, rather than embedding Swing components, you are integrating with Swing by opening 
+ * Swing dialogs, see the {@link AwtEnvironment} class. 
+ * <p>
+ * This is an abstract that is normally used by extending it and implementing the {@link #createSwingComponent()} method. For example,  
+ * <pre>
+ *        embeddedComposite = new EmbeddedSwingComposite(parent, SWT.NONE) {
+ *            protected JComponent createSwingComponent() {
+ *                scrollPane = new JScrollPane();
+ *                table = new JTable();
+ *                scrollPane.setViewportView(table);
+ *                return scrollPane;
+ *            }
+ *        }; 
+ *        embeddedComposite.populate();
+ * </pre>
+ * <p>
+ * The Swing component is created inside a standard Swing containment hierarchy, rooted in 
+ * a {@link javax.swing.RootPaneContainer}. The root pane container is placed inside an AWT frame, as
+ * returned by {@link org.eclipse.swt.awt.SWT_AWT#new_Frame(Composite)} 
+ * <p>
+ * <b>Note:</b> When you mix components from Swing/AWT and SWT toolkits, there will be two UI event threads,
+ * one for AWT, one for SWT. Most SWT APIs require that you call them from the SWT thread. Swing 
+ * has similar restrictions though it does not enforce them as much as SWT.
+ * <p>
+ * Applications need to be aware of the current thread, and, where necessary, schedule tasks to run 
+ * on another thread. This has always been required in the pure Swing or SWT environments, but when 
+ * mixing Swing and SWT, more of this scheduling will be necessary.
+ * <p>
+ * To schedule work on the AWT event 
+ * thread, you can use:
+ * <ul>
+ * <li>{@link javax.swing.SwingUtilities#invokeLater(Runnable)}
+ * <li>{@link javax.swing.SwingUtilities#invokeAndWait(Runnable)} 
+ * </ul>
+ * <p>
+ * (or similar methods in {@link java.awt.EventQueue})
+ * <p>
+ * To schedule work on the SWT event thread, use:
+ * <ul>
+ * <li>{@link org.eclipse.swt.widgets.Display#asyncExec(Runnable)}
+ * <li>{@link org.eclipse.swt.widgets.Display#syncExec(Runnable)}
+ * </ul>
+ * 
+ * Of course, as in single-toolkit environments, long-running tasks should be offloaded from either UI 
+ * thread to a background thread. The Eclipse jobs API can be used for this purpose.
+ */
+public abstract class EmbeddedSwingComposite extends Composite {
+    private static class AwtContext {
+        private Frame frame;
+        private JComponent swingComponent;
+        
+        AwtContext(Frame frame) {
+            assert frame != null;
+            this.frame = frame;
+        }
+
+        Frame getFrame() {
+            return frame;
+        }
+
+        void setSwingComponent(JComponent swingComponent) {
+            this.swingComponent = swingComponent;
+        }
+
+        JComponent getSwingComponent() {
+            return swingComponent;
+        }
+        
+    }
+    private Font currentSystemFont;
+    private AwtContext awtContext;
+    private AwtFocusHandler awtHandler;
+
+    private Listener settingsListener = new Listener() {
+        public void handleEvent(Event event) {
+            handleSettingsChange();
+        }
+    };
+    
+    // This listener helps ensure that Swing popup menus are properly dismissed when
+    // a menu item off the SWT main menu bar is shown.
+    private final Listener menuListener = new Listener() {
+        public void handleEvent(Event event) {
+            assert awtHandler != null;
+            
+            awtHandler.postHidePopups();
+        }
+    };
+    
+    /**
+     * Constructs a new instance of this class given its parent
+     * and a style value describing its behavior and appearance.
+     * <p>
+     * This method must be called from the SWT event thread. 
+     * <p>
+     * The style value is either one of the style constants defined in
+     * class <code>SWT</code> which is applicable to instances of this
+     * class, or must be built by <em>bitwise OR</em>'ing together 
+     * (that is, using the <code>int</code> "|" operator) two or more
+     * of those <code>SWT</code> style constants. The class description
+     * lists the style constants that are applicable to the class.
+     * Style bits are also inherited from superclasses.
+     * </p>
+     * <p>
+     * The styles SWT.EMBEDDED and SWT.NO_BACKGROUND will be added
+     * to the specified style. Usually, no other style bits are needed.
+     *
+     * @param parent a widget which will be the parent of the new instance (cannot be null)
+     * @param style the style of widget to construct
+     *
+     * @exception IllegalArgumentException <ul>
+     *    <li>ERROR_NULL_ARGUMENT - if the parent is null</li>
+     * </ul>
+     * @exception SWTException <ul>
+     *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the SWT event thread
+     * </ul>
+     *
+     * @see Widget#getStyle
+     */
+    public EmbeddedSwingComposite(Composite parent, int style) {
+        super(parent, style | SWT.EMBEDDED | SWT.NO_BACKGROUND);
+        getDisplay().addListener(SWT.Settings, settingsListener);
+        setLayout(new FillLayout());
+        currentSystemFont = getFont();
+    }
+
+    /**
+     * Populates the embedded composite with the Swing component.
+     * <p> 
+     * This method must be called from the
+     * SWT event thread.  
+     * <p>
+     * The Swing component will be created by calling {@link #createSwingComponent()}. The creation is
+     * scheduled asynchronously on the AWT event thread. This method does not wait for completion of this
+     * asynchronous task, so it may return before createSwingComponent() is complete.   
+     * <p>
+     * The Swing component is created inside a standard Swing containment hierarchy, rooted in 
+     * a {@link javax.swing.RootPaneContainer}. Clients can override {@link #addRootPaneContainer(Frame)}
+     * to provide their own root pane container implementation.
+     * <p>
+     * This method can be called multiple times for a single instance. If an embedded frame exists from 
+     * a previous call, it is disposed.
+     *  
+     * @exception SWTException <ul>
+     *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
+     *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the SWT event thread
+     * </ul>
+     */
+    public void populate() {
+        checkWidget();
+        createFrame();
+        scheduleComponentCreation();
+    }
+
+    /**
+     * Creates the embedded Swing component. This method is called from the AWT event thread. 
+     * <p> 
+     * Implement this method to provide the Swing component that will be shown inside this composite.
+     * The returned component will be added to the Swing content pane. At least one component must
+     * be created by this method; null is not a valid return value.   
+     *   
+     * @return a non-null Swing component
+     */
+    protected abstract JComponent createSwingComponent();
+    
+    /**
+     * Adds a root pane container to the embedded AWT frame. Override this to provide your own 
+     * {@link javax.swing.RootPaneContainer} implementation. In most cases, it is not necessary
+     * to override this method.    
+     * <p>
+     * This method is called from the AWT event thread. 
+     * <p> 
+     * If you are defining your own root pane container, make sure that there is at least one
+     * heavyweight (AWT) component in the frame's containment hierarchy; otherwise, event 
+     * processing will not work correctly. See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4982522
+     * for more information.  
+     *   
+     * @param frame the frame to which the root pane container is added 
+     * @return a non-null Swing component
+     */
+    protected RootPaneContainer addRootPaneContainer(Frame frame) {
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        assert frame != null;
+        
+        // It is important to set up the proper top level components in the frame:
+        // 1) For Swing to work properly, Sun documents that there must be an implementor of 
+        // javax.swing.RootPaneContainer at the top of the component hierarchy. 
+        // 2) For proper event handling there must be a heavyweight 
+        // an AWT frame must contain a heavyweight component (see 
+        // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4982522)
+        // 3) The Swing implementation further narrows the options by expecting that the 
+        // top of the hierarchy be a JFrame, JDialog, JWindow, or JApplet. See javax.swing.PopupFactory.
+        // All this drives the choice of JApplet for the top level Swing component. It is the 
+        // only single component that satisfies all the above. This does not imply that 
+        // we have a true applet; in particular, there is no notion of an applet lifecycle in this
+        // context. 
+        JApplet applet = new JApplet();
+        
+        // In JRE 1.4, the JApplet makes itself a focus cycle root. This
+        // interferes with the focus handling installed on the parent frame, so
+        // change it back to a non-root here. 
+        // TODO: consider moving the focus policy from the Frame down to the JApplet
+        applet.setFocusCycleRoot(false);
+
+        frame.add(applet);
+        
+        return applet;
+    }
+
+    /**
+     * Performs custom updates to newly set fonts. This method is called whenever a change
+     * to the system font through the system settings (i.e. control panel) is detected.
+     * <p>
+     * This method is called from the AWT event thread.  
+     * <p>
+     * In most cases it is not necessary to override this method.  Normally, the implementation
+     * of this class will automatically propogate font changes to the embedded Swing components 
+     * through Swing's Look and Feel support. However, if additional 
+     * special processing is necessary, it can be done inside this method. 
+     *    
+     * @param newFont New AWT font
+     */
+    protected void updateAwtFont(java.awt.Font newFont) {
+    }
+
+    /**
+     * Returns the embedded AWT frame. The returned frame is the root of the AWT containment
+     * hierarchy for the embedded Swing component. This method can be called from 
+     * any thread. 
+     *    
+     * @return the embedded frame
+     */
+    public Frame getFrame() {
+        // Intentionally leaving out checkWidget() call. This may need to be called from within user's 
+        // createSwingComponent() method. Accessing from a non-SWT thread is OK, but we still check
+        // for disposal
+        if (getDisplay() == null || isDisposed()) {
+            SWT.error(SWT.ERROR_WIDGET_DISPOSED);            
+        }
+        
+        return (awtContext != null) ? awtContext.getFrame() : null;
+    }
+
+    private void createFrame() {
+        assert Display.getCurrent() != null;     // On SWT event thread
+        
+        // Make sure Awt environment is initialized. 
+        AwtEnvironment.getInstance(getDisplay());
+        
+        if (awtContext != null) {
+            final Frame oldFrame = awtContext.getFrame();
+            // Schedule disposal of old frame on AWT thread so that there are no problems with
+            // already-scheduled operations that have not completed.
+            // Note: the implementation of Frame.dispose() would schedule the use of the AWT 
+            // thread even if it was not done here, but it uses invokeAndWait() which is 
+            // prone to deadlock (and not necessary for this case). 
+            EventQueue.invokeLater(new Runnable() {
+                public void run() {
+                    oldFrame.dispose();
+                }
+            });
+        }
+        Frame frame = SWT_AWT.new_Frame(this);
+        awtContext = new AwtContext(frame);
+
+        // Glue the two frameworks together. Do this before anything is added to the frame
+        // so that all necessary listeners are in place.
+        createFocusHandlers();
+        
+        // This listener clears garbage during resizing, making it looker much cleaner 
+        addControlListener(new CleanResizeListener());
+    }
+
+    private void createFocusHandlers() {
+        assert awtContext != null;
+        assert Display.getCurrent() != null;     // On SWT event thread
+        
+        Frame frame = awtContext.getFrame();
+        awtHandler = new AwtFocusHandler(frame);   
+        SwtFocusHandler swtHandler = new SwtFocusHandler(this);
+        awtHandler.setSwtHandler(swtHandler);
+        swtHandler.setAwtHandler(awtHandler);
+        
+        // Ensure that AWT popups are dimissed whenever a SWT menu is shown
+        getDisplay().addFilter(SWT.Show, menuListener);
+        
+        EmbeddedChildFocusTraversalPolicy policy = new EmbeddedChildFocusTraversalPolicy(awtHandler);
+        frame.setFocusTraversalPolicy(policy);
+    }
+    
+    private void scheduleComponentCreation() {
+        assert awtContext != null;
+        
+        // Create AWT/Swing components on the AWT thread. This is 
+        // especially necessary to avoid an AWT leak bug (6411042).
+        final AwtContext currentContext = awtContext;
+        EventQueue.invokeLater(new Runnable() {
+            public void run() {
+                
+                RootPaneContainer container = addRootPaneContainer(currentContext.getFrame());
+                JComponent swingComponent = createSwingComponent();
+                currentContext.setSwingComponent(swingComponent);
+                container.getRootPane().getContentPane().add(swingComponent);
+                setComponentFont();
+            }
+        });
+    }
+
+    private void setComponentFont() {
+        assert currentSystemFont != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        JComponent swingComponent = (awtContext != null) ? awtContext.getSwingComponent() : null;
+        if ((swingComponent != null) && !currentSystemFont.getDevice().isDisposed()) {
+            FontData fontData = currentSystemFont.getFontData()[0];
+            
+            // AWT font sizes assume a 72 dpi resolution, always. The true screen resolution must be 
+            // used to convert the platform font size into an AWT point size that matches when displayed. 
+            int resolution = Toolkit.getDefaultToolkit().getScreenResolution();
+            int awtFontSize = (int)Math.round((double)fontData.getHeight() * resolution / 72.0);
+            
+            // The style constants for SWT and AWT map exactly, and since they are int constants, they should
+            // never change. So, the SWT style is passed through as the AWT style. 
+            java.awt.Font awtFont = new java.awt.Font(fontData.getName(), fontData.getStyle(), awtFontSize);
+
+            // Update the look and feel defaults to use new font.
+            updateLookAndFeel(awtFont);
+
+            // Allow subclasses to react to font change if necessary. 
+            updateAwtFont(awtFont);
+
+            // Allow components to update their UI based on new font 
+            // TODO: should the update method be called on the root pane instead?
+            Container contentPane = swingComponent.getRootPane().getContentPane();
+            SwingUtilities.updateComponentTreeUI(contentPane);
+        }
+    }
+    
+    private void updateLookAndFeel(java.awt.Font awtFont) {
+        assert awtFont != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // The FontUIResource class marks the font as replaceable by the look and feel 
+        // implementation if font settings are later changed. 
+        FontUIResource fontResource = new FontUIResource(awtFont);
+
+        // Assign the new font to the relevant L&F font properties. These are 
+        // the properties that are initially assigned to the system font
+        // under the Windows look and feel. 
+        // TODO: It's possible that other platforms will need other assignments.
+        // TODO: This does not handle fonts other than the "system" font. 
+        // Other fonts may change, and the Swing L&F may not be adjusting.
+        
+        UIManager.put("Button.font", fontResource); //$NON-NLS-1$
+        UIManager.put("CheckBox.font", fontResource); //$NON-NLS-1$
+        UIManager.put("ComboBox.font", fontResource); //$NON-NLS-1$
+        UIManager.put("EditorPane.font", fontResource); //$NON-NLS-1$
+        UIManager.put("Label.font", fontResource); //$NON-NLS-1$
+        UIManager.put("List.font", fontResource); //$NON-NLS-1$
+        UIManager.put("Panel.font", fontResource); //$NON-NLS-1$
+        UIManager.put("ProgressBar.font", fontResource); //$NON-NLS-1$
+        UIManager.put("RadioButton.font", fontResource); //$NON-NLS-1$
+        UIManager.put("ScrollPane.font", fontResource); //$NON-NLS-1$
+        UIManager.put("TabbedPane.font", fontResource); //$NON-NLS-1$
+        UIManager.put("Table.font", fontResource); //$NON-NLS-1$
+        UIManager.put("TableHeader.font", fontResource); //$NON-NLS-1$
+        UIManager.put("TextField.font", fontResource); //$NON-NLS-1$
+        UIManager.put("TextPane.font", fontResource); //$NON-NLS-1$
+        UIManager.put("TitledBorder.font", fontResource); //$NON-NLS-1$
+        UIManager.put("ToggleButton.font", fontResource); //$NON-NLS-1$
+        UIManager.put("TreeFont.font", fontResource); //$NON-NLS-1$
+        UIManager.put("ViewportFont.font", fontResource); //$NON-NLS-1$
+    }
+
+    private void handleSettingsChange() {
+        Font newFont = getDisplay().getSystemFont();
+        if (!newFont.equals(currentSystemFont)) { 
+            currentSystemFont = newFont;
+            EventQueue.invokeLater(new Runnable() {
+                public void run() {
+                    setComponentFont();
+                }
+            });            
+        }
+    }
+
+    private boolean isFocusable() {
+        if (awtContext == null) {
+            return false;
+        }
+        JComponent swingComponent = awtContext.getSwingComponent();
+        return (swingComponent != null) && swingComponent.isFocusable(); 
+    }
+
+    /* (non-Javadoc)
+     * @see org.eclipse.swt.widgets.Control#setFocus()
+     */
+    public boolean setFocus() {
+        checkWidget();
+        
+        if (!isFocusable()) {
+            return false;
+        }
+        return super.setFocus();
+    }
+
+    /* (non-Javadoc)
+     * @see org.eclipse.swt.widgets.Control#forceFocus()
+     */
+    public boolean forceFocus() {
+        checkWidget();
+        
+        if (!isFocusable()) {
+            return false;
+        }
+        return super.forceFocus();
+    }
+
+    /* (non-Javadoc)
+     * @see org.eclipse.swt.widgets.Widget#dispose()
+     */
+    public void dispose() {
+        if (!isDisposed()) {
+            getDisplay().removeListener(SWT.Settings, settingsListener);
+            getDisplay().removeFilter(SWT.Show, menuListener);
+            super.dispose();
+        }
+    }
+    
+}
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/Platform.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/Platform.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/Platform.java	(revision 957)
@@ -0,0 +1,30 @@
+/*******************************************************************************
+ * Copyright (c) 2007 SAS Institute.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     SAS Institute - initial API and implementation
+ *******************************************************************************/
+package org.pathvisio.gui.swt.awt;
+
+import org.eclipse.swt.SWT;
+
+class Platform {
+    private static String platformString = SWT.getPlatform();
+
+    // prevent instantiation
+    private Platform() {
+    }
+    
+    public static boolean isWin32() {
+        return "win32".equals(platformString); //$NON-NLS-1$
+    }
+    
+    public static boolean isGtk() {
+        return "gtk".equals(platformString); //$NON-NLS-1$
+    }
+    
+}
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/AwtFocusHandler.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/AwtFocusHandler.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/AwtFocusHandler.java	(revision 957)
@@ -0,0 +1,254 @@
+/*******************************************************************************
+ * Copyright (c) 2007 SAS Institute.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     SAS Institute - initial API and implementation
+ *******************************************************************************/
+package org.pathvisio.gui.swt.awt;
+
+import java.awt.Component;
+import java.awt.Container;
+import java.awt.EventQueue;
+import java.awt.FocusTraversalPolicy;
+import java.awt.Frame;
+import java.awt.Window;
+import java.awt.event.ContainerEvent;
+import java.awt.event.ContainerListener;
+import java.awt.event.FocusEvent;
+import java.awt.event.FocusListener;
+import java.awt.event.WindowEvent;
+import java.awt.event.WindowFocusListener;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import javax.swing.JPopupMenu;
+import javax.swing.text.Caret;
+import javax.swing.text.JTextComponent;
+
+class AwtFocusHandler implements FocusListener, ContainerListener, 
+                                      WindowFocusListener {
+
+    private final Frame frame;
+    private SwtFocusHandler swtHandler;
+    private boolean awtHasFocus = false;
+    private Component currentComponent = null;
+    
+    AwtFocusHandler(Frame frame) {
+        assert frame != null;
+        
+        this.frame = frame;
+        frame.addContainerListener(new RecursiveContainerListener(this));
+        frame.addWindowFocusListener(this);
+    }
+
+    void setSwtHandler(SwtFocusHandler handler) {
+        assert handler != null;
+        assert swtHandler == null;  // this method is meant to be called once
+        
+        swtHandler = handler;
+    }
+
+    void gainFocus() {
+        assert frame != null;
+        // assert !awtHasFocus;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        FocusTraversalPolicy policy = frame.getFocusTraversalPolicy();
+        Component component;
+        if (policy instanceof EmbeddedChildFocusTraversalPolicy) {
+            EmbeddedChildFocusTraversalPolicy embeddedPolicy = (EmbeddedChildFocusTraversalPolicy) policy; 
+            component = embeddedPolicy.getCurrentComponent(frame);
+        } else {
+            // TODO: direction based?
+            component = policy.getDefaultComponent(frame);
+        }
+        if (component != null) {
+            // System.out.println("Requesting focus for component: " + component);
+            component.requestFocus();
+            // TODO: else case error? If not, consider moving flag setting below into this if
+        }
+        awtHasFocus = true;
+    }
+    
+    /**
+     * Moves focus back to the next SWT component
+     */
+    void transferFocusNext() {
+        assert swtHandler != null;
+        assert awtHasFocus;
+        
+        awtHasFocus = false;
+        swtHandler.gainFocusNext();
+    }
+    
+    /**
+     * Moves focus back to the previous SWT component
+     */
+    void transferFocusPrevious() {
+        assert swtHandler != null;
+        assert awtHasFocus;
+        
+        awtHasFocus = false;
+        swtHandler.gainFocusPrevious();
+    }
+    
+    boolean awtHasFocus() {
+        return awtHasFocus;
+    }
+
+    Component getCurrentComponent() {
+        return currentComponent;
+    }
+    
+    // ..................... Listener implementations
+
+    public void focusGained(FocusEvent e) {
+        assert e != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // System.out.println("gained (awt). component = " + e.getComponent() + ", opposite = " + e.getOppositeComponent());
+        currentComponent  = e.getComponent();
+    }
+
+    public void focusLost(FocusEvent e) {
+        // System.out.println("component focus lost (awt). opposite = " + e.getOppositeComponent());
+        
+        // Intentionally leaving currentComponent set. When window focus is lost, 
+        // it will be needed. 
+    }
+
+    public void componentAdded(ContainerEvent e) {
+        assert e != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        e.getChild().addFocusListener(this);
+    }
+
+    public void componentRemoved(ContainerEvent e) {
+        assert e != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        e.getChild().removeFocusListener(this);
+    }
+    
+    public void windowGainedFocus(WindowEvent e) {
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        // System.out.println("WindowFocusListener.windowGainedFocus");
+        awtHasFocus = true;
+    }
+
+    public void windowLostFocus(WindowEvent e) {
+        assert e != null;
+        assert swtHandler != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // System.out.println("WindowFocusListener.windowLostFocus");
+        
+        // Dismiss any popup menus that are
+        // open when losing focus. This prevents situations where
+        // multiple popup menus are visible at the same time. In JDK 1.4 and earlier, 
+        // the dismissal is not done automatically. In JDK 1.5, this code is 
+        // unnecessary, but it doesn't seem to hurt anything. 
+        // TODO: verify this is OK on other windowing systems
+        // TODO: disable in post-1.4 environments
+        /* boolean popupShown = */hidePopups();
+        
+        // If focus is being lost to the parent SWT composite, then
+        // grab it back for AWT and return. Normally the parent SWT composite will
+        // do this for us, but it will not see a focus gained event when focus 
+        // is transferred to it from its AWT frame child. 
+        // This happens, for example, if an AWT control has focus and the 
+        // tab of a containing (already active) view is clicked.
+        //
+        // However, don't grab back focus if a popup was hidden above. The popup
+        // area will not be properly redrawn (the popup, or part of it, will 
+        // appear to be still there. 
+        //if (!popupShown && swtHandler.hasFocus()) {
+            // System.out.println("**** Taking back focus: " + e);
+            // This seems to have side effects, so it's commented out for now. 
+            // (Sometimes, it forces the workbench window to the foreground when another
+            // program's window is selected.)
+            // TODO: find an alternate approach to reassert focus
+            // gainFocus();
+            // return;
+        //}
+        
+        // On a normal change of focus, Swing will turn off any selection
+        // in a text field to help indicate focus is lost. This won't happen
+        // automatically when transferring to SWT, so turn off the selection
+        // manually.
+        if (currentComponent instanceof JTextComponent) {
+            Caret caret = ((JTextComponent)currentComponent).getCaret();
+            if (caret != null) {
+                caret.setSelectionVisible(false);
+            }
+        }
+        awtHasFocus = false;
+    }
+
+    // Returns true if any popup has been hidden
+    private boolean hidePopups() {
+        boolean result = false;
+        List popups = new ArrayList();
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // Look for popups inside the frame's component hierarchy. 
+        // Lightweight popups will be found here. 
+        findContainedPopups(frame, popups);
+        
+        // Also look for popups in the frame's window hierachy. 
+        // Heavyweight popups will be found here.
+        findOwnedPopups(frame, popups);
+        
+        // System.out.println("Hiding popups, count=" + popups.size());
+        for (Iterator iter = popups.iterator(); iter.hasNext();) {
+            Component popup = (Component)iter.next();
+            if (popup.isVisible()) {
+                result = true;
+                popup.setVisible(false);
+            }
+        }
+        return result;
+    }
+
+    private void findOwnedPopups(Window window, List popups) {
+        assert window != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        Window[] ownedWindows = window.getOwnedWindows();
+        for (int i = 0; i < ownedWindows.length; i++) {
+            findContainedPopups(ownedWindows[i], popups);
+            findOwnedPopups(ownedWindows[i], popups);
+        }
+    }
+
+    private void findContainedPopups(Container container, List popups) {
+        assert container != null;
+        assert popups != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        Component[] components = container.getComponents();
+        for (int i = 0; i < components.length; i++) {
+            Component c = components[i];
+            // JPopupMenu is a container, so check for it first
+            if (c instanceof JPopupMenu) {
+                popups.add(c);
+            } else if (c instanceof Container) {
+                findContainedPopups((Container)c, popups);
+            }
+        }
+    }
+
+    void postHidePopups() {
+        EventQueue.invokeLater(new Runnable() {
+            public void run() {
+                hidePopups();
+            }
+        });
+    }
+}
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/CleanResizeListener.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/CleanResizeListener.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/CleanResizeListener.java	(revision 957)
@@ -0,0 +1,47 @@
+/*******************************************************************************
+ * Copyright (c) 2007 SAS Institute.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     SAS Institute - initial API and implementation
+ *******************************************************************************/
+package org.pathvisio.gui.swt.awt;
+
+import org.eclipse.swt.events.ControlAdapter;
+import org.eclipse.swt.events.ControlEvent;
+import org.eclipse.swt.graphics.GC;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Display;
+
+class CleanResizeListener extends ControlAdapter {
+    private Rectangle oldRect = null;
+    public void controlResized(ControlEvent e) {
+        assert e != null;
+        assert Display.getCurrent() != null;     // On SWT event thread
+        
+        // Prevent garbage from Swing lags during resize. Fill exposed areas 
+        // with background color. 
+        Composite composite = (Composite)e.widget;
+        //Rectangle newRect = composite.getBounds();
+        //newRect = composite.getDisplay().map(composite.getParent(), composite, newRect);
+        Rectangle newRect = composite.getClientArea();
+        if (oldRect != null) {
+            int heightDelta = newRect.height - oldRect.height;
+            int widthDelta = newRect.width - oldRect.width;
+            if ((heightDelta > 0) || (widthDelta > 0)) {
+                GC gc = new GC(composite);
+                try {
+                    gc.fillRectangle(newRect.x, oldRect.height, newRect.width, heightDelta);
+                    gc.fillRectangle(oldRect.width, newRect.y, widthDelta, newRect.height);
+                } finally {
+                    gc.dispose();
+                }
+            }
+        }
+        oldRect = newRect;
+    }
+}
\ No newline at end of file
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/SwtFocusHandler.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/SwtFocusHandler.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/SwtFocusHandler.java	(revision 957)
@@ -0,0 +1,153 @@
+/*******************************************************************************
+ * Copyright (c) 2007 SAS Institute.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     SAS Institute - initial API and implementation
+ *******************************************************************************/
+package org.pathvisio.gui.swt.awt;
+
+import java.awt.EventQueue;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.ControlAdapter;
+import org.eclipse.swt.events.ControlEvent;
+import org.eclipse.swt.events.DisposeEvent;
+import org.eclipse.swt.events.DisposeListener;
+import org.eclipse.swt.events.FocusEvent;
+import org.eclipse.swt.events.FocusListener;
+import org.eclipse.swt.events.KeyEvent;
+import org.eclipse.swt.events.KeyListener;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Shell;
+
+class SwtFocusHandler implements FocusListener, KeyListener {
+
+    private final Composite composite;
+    private final Display display;
+    private AwtFocusHandler awtHandler;
+    
+    SwtFocusHandler(Composite composite) {
+        assert composite != null;
+        assert Display.getCurrent() != null;     // On SWT event thread
+        
+        this.composite = composite;
+        display = composite.getDisplay();
+        composite.addFocusListener(this);
+        composite.addKeyListener(this);
+    }
+
+    void setAwtHandler(AwtFocusHandler handler) {
+        assert handler != null;
+        assert awtHandler == null;  // this method is meant to be called once
+        assert composite != null;
+        assert Display.getCurrent() != null;     // On SWT event thread        
+        
+        awtHandler = handler;
+        
+        // Dismiss Swing popups when the main window is moved. (It would be 
+        // better to dismiss popups whenever the titlebar is clicked, but 
+        // there does not seem to be a way.)
+        final ControlAdapter controlAdapter = new ControlAdapter() {
+            public void controlMoved(ControlEvent e) {
+                assert awtHandler != null;
+                awtHandler.postHidePopups();
+            }
+        };
+        final Shell shell = composite.getShell();
+        shell.addControlListener(controlAdapter);
+        
+        // Cleanup listeners on dispose
+        composite.addDisposeListener(new DisposeListener() {
+            public void widgetDisposed(DisposeEvent e) {
+                shell.removeControlListener(controlAdapter);
+            }
+        });
+    }
+    
+    void gainFocusNext() {
+        traverse(SWT.TRAVERSE_TAB_NEXT);
+    }
+    
+    void gainFocusPrevious() {
+        traverse(SWT.TRAVERSE_TAB_PREVIOUS);
+    }
+    
+    private void traverse(final int traversal) {
+        assert composite != null;
+        
+        // Tab from the containing SWT component while 
+        // running on the SWT thread
+        Runnable r = new Runnable() {
+            public void run() {
+                composite.traverse(traversal);
+            }
+        };
+        display.asyncExec(r);
+    }
+
+//    boolean hasFocus() {
+//        assert composite != null;
+//        
+//        // This will return true if the composite has focus, or if any
+//        // foreign (e.g. AWT) child of the composite has focus.
+//        if (display.isDisposed()) {
+//            return false;
+//        }
+//        final boolean[] result = new boolean[1];
+//        display.syncExec(new Runnable() {
+//            public void run() {
+//                result[0] = (!composite.isDisposed() &&
+//                             (display.getFocusControl() == composite));
+//            }
+//        });
+//        return result[0];
+//    }
+
+    // ..................... Listener implementations
+    
+    public void focusGained(FocusEvent e) {
+        assert awtHandler != null;
+        assert Display.getCurrent() != null;     // On SWT event thread
+        
+        // System.out.println("Gained: " + e.toString() + " (" + e.widget.getClass().getName() + ")");
+        EventQueue.invokeLater(new Runnable() {
+            public void run() {
+                awtHandler.gainFocus();
+            }
+        });        
+    }
+    
+    public void focusLost(FocusEvent e) {
+        // System.out.println("Lost: " + e.toString() + " (" + e.widget.getClass().getName() + ")");
+    }
+
+    public void keyPressed(KeyEvent e) {
+        assert Display.getCurrent() != null;     // On SWT event thread
+
+        // If the embedded swing root pane has no components to receive focus, 
+        // then there will be cases where the parent SWT composite will keep 
+        // focus. (For example, when tabbing into the root pane container). 
+        // By default, in these cases, the focus is swallowed by the Composite
+        // and never escapes. This code allows tab and back-tab to do the 
+        // proper traversal to other SWT components from the composite.
+        // TODO: other keys?
+        if (e.keyCode == SWT.TAB) {
+            // TODO: In some cases, this gobbles up all the tabs, even from AWT children. Find a more selective way. 
+            /*if (e.stateMask == SWT.NONE) {
+                traverse(SWT.TRAVERSE_TAB_NEXT);
+            } else if (e.stateMask == SWT.SHIFT) {
+                traverse(SWT.TRAVERSE_TAB_PREVIOUS);
+            }*/
+        }
+    }
+
+    public void keyReleased(KeyEvent e) {
+    }
+
+
+}
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/VPathwaySwingComposite.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/VPathwaySwingComposite.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/awt/VPathwaySwingComposite.java	(revision 957)
@@ -0,0 +1,24 @@
+package org.pathvisio.gui.swt.awt;
+
+import javax.swing.JComponent;
+import javax.swing.JScrollPane;
+
+import org.eclipse.swt.widgets.Composite;
+
+public class VPathwaySwingComposite extends EmbeddedSwingComposite {
+	JScrollPane scrollPane;
+	
+	public VPathwaySwingComposite(Composite parent, int style) {
+		super(parent, style);
+		populate();
+	}
+	
+	protected JComponent createSwingComponent() {
+		scrollPane = new JScrollPane();
+		return scrollPane;
+	}
+	
+	public JScrollPane getScrollPane() {
+		return scrollPane;
+	}
+}
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/BackpagePanel.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/BackpagePanel.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/BackpagePanel.java	(revision 957)
@@ -0,0 +1,296 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.util.List;
+
+import org.eclipse.swt.browser.Browser;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.pathvisio.Engine;
+import org.pathvisio.data.DataSources;
+import org.pathvisio.data.Gdb;
+import org.pathvisio.data.Gex;
+import org.pathvisio.data.Gdb.IdCodePair;
+import org.pathvisio.util.Utils;
+import org.pathvisio.view.GeneProduct;
+import org.pathvisio.view.SelectionBox;
+import org.pathvisio.view.VPathwayElement;
+import org.pathvisio.view.SelectionBox.SelectionEvent;
+import org.pathvisio.view.SelectionBox.SelectionListener;
+
+/**
+ * Backpage browser - side panel that shows the backpage information when a GeneProduct is double-clicked
+ */
+public class BackpagePanel extends Composite implements SelectionListener {
+	/**
+	 * Directory containing HTML files needed to display the backpage information
+	 */
+	final static String BPDIR = "backpage";
+	/**
+	 * Header file, containing style information
+	 */
+	final static String HEADERFILE = "header.html";
+	
+	/**
+	 * Header for the gene information in HTML format
+	 */
+	final static String bpHeader = "<H1>Gene information</H1><P>";
+	/**
+	 * Header for the expression information in HTML format
+	 */
+	final static String gexHeader = "<H1>Expression data</H1><P>";
+	
+	private String bpText;
+	private String gexText;
+	private String header;
+	
+	private Browser bpBrowser;
+	
+	private GeneProduct geneProduct;
+	
+	/**
+	 * Constructor for this class
+	 * @param parent	Parent {@link Composite} for the Browser widget
+	 * @param style		Style for the Browser widget
+	 */
+	public BackpagePanel(Composite parent, int style) {
+		super(parent, style);
+		
+		initializeHeader(); //Load the header including style information
+		setLayout(new FillLayout());
+		bpBrowser = new Browser(this, style); //Set the Browser widget
+		setGeneText(null);
+		setGexText(null);
+		
+		SelectionBox.addListener(this);
+	}
+	
+	public void setGeneProduct(final GeneProduct gp) 
+	{ 
+		if(geneProduct == gp) return;
+		
+		Thread fetchThread = new Thread() {
+			public void run() {
+				geneProduct = gp;
+				if(gp == null) {
+					setGeneText(null);
+					setGexText(null);
+					return;
+				}
+				// Get the backpage text
+				String geneHeader = geneProduct.getGmmlData().getBackpageHead();
+				if (geneHeader == null) geneHeader = "";
+				String geneId = geneProduct.getGmmlData().getGeneID();
+				String systemCode = geneProduct.getGmmlData().getSystemCode();
+				String bpText = geneHeader.equals("") ? geneHeader : "<H2>" + geneHeader + "</H2><P>";
+				String bpInfo = Gdb.getBpInfo(geneId, systemCode);
+				bpText += bpInfo == null ? "<I>No gene information found</I>" : bpInfo;
+				String crossRefText = getCrossRefText(geneId, systemCode);
+				String gexText = Gex.getDataString(new IdCodePair(geneId, systemCode));
+				if (bpText != null) 	setGeneText(bpText);
+				if (gexText != null)	setGexText(gexText + crossRefText);
+				else 					setGexText("<I>No expression data found</I>");
+			}
+		};
+		
+		//Run in seperate thread so that this method can return
+		fetchThread.start();
+	}
+		
+	public String getCrossRefText(String id, String code) {
+		List<IdCodePair> crfs = Gdb.getCrossRefs(id, code);
+		if(crfs.size() == 0) return "";
+		StringBuilder crt = new StringBuilder("<H1>Cross references</H1><P>");
+		for(IdCodePair cr : crfs) {
+			String idtxt = cr.getId();
+			String url = getCrossRefLink(cr);
+			if(url != null) {
+				int os = Utils.getOS();
+				if(os == Utils.OS_WINDOWS) {
+					//In windows: open in new browser window
+					idtxt = "<a href='" + url + "' target='_blank'>" + idtxt + "</a>";
+				} else {
+					//This doesn't work under ubuntu, so no new windoe there
+					idtxt = "<a href='" + url + "'>" + idtxt + "</a>";
+				}
+				
+			}
+			String dbName = DataSources.sysCode2Name.get(cr.getCode());
+			crt.append( idtxt + ", " + (dbName != null ? dbName : cr.getCode()) + "<br>");
+		}
+		return crt.toString();
+	}
+	
+	String getCrossRefLink(IdCodePair idc) {
+		String c = idc.getCode();
+		String id = idc.getId();
+		if(c.equalsIgnoreCase("En"))
+			return "http://www.ensembl.org/Homo_sapiens/searchview?species=all&idx=Gene&q=" + id;
+		if(c.equalsIgnoreCase("P"))
+			return "http://www.expasy.org/uniprot/" + id;
+		if(c.equalsIgnoreCase("Q")) {
+			String pre = "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?";
+			if(id.startsWith("NM")) {
+				return pre + "db=Nucleotide&cmd=Search&term=" + id;
+			} else {
+				return pre + "db=Protein&cmd=search&term=" + id;
+			}
+		}
+		if(c.equalsIgnoreCase("T"))
+			return "http://godatabase.org/cgi-bin/go.cgi?view=details&search_constraint=terms&depth=0&query=" + id;
+		if(c.equalsIgnoreCase("I"))
+			return "http://www.ebi.ac.uk/interpro/IEntry?ac=" + id;
+		if(c.equalsIgnoreCase("Pd"))
+			return "http://bip.weizmann.ac.il/oca-bin/ocashort?id=" + id;
+		if(c.equalsIgnoreCase("X"))
+			return "http://www.ensembl.org/Homo_sapiens/featureview?type=OligoProbe;id=" + id;
+		if(c.equalsIgnoreCase("Em"))
+			return "http://www.ebi.ac.uk/cgi-bin/emblfetch?style=html&id=" + id;
+		if(c.equalsIgnoreCase("L"))
+			return "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=gene&cmd=Retrieve&dopt=full_report&list_uids=" + id;
+		if(c.equalsIgnoreCase("H"))
+			return "http://www.gene.ucl.ac.uk/cgi-bin/nomenclature/get_data.pl?hgnc_id=" + id;
+		if(c.equalsIgnoreCase("I"))
+			return "http://www.ebi.ac.uk/interpro/IEntry?ac=" + id;
+		if(c.equalsIgnoreCase("M"))
+			return "http://www.informatics.jax.org/searches/accession_report.cgi?id=" + id;
+		if(c.equalsIgnoreCase("Om"))
+			return "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=OMIM&cmd=Search&doptcmdl=Detailed&term=?" + id;
+		if(c.equalsIgnoreCase("Pf"))
+			return "http://www.sanger.ac.uk//cgi-bin/Pfam/getacc?" + id;
+		if(c.equalsIgnoreCase("R"))
+			return "http://rgd.mcw.edu/generalSearch/RgdSearch.jsp?quickSearch=1&searchKeyword=" + id;
+		if(c.equalsIgnoreCase("D"))
+			return "http://db.yeastgenome.org/cgi-bin/locus.pl?locus=" + id;
+		if(c.equalsIgnoreCase("S"))
+			return "http://www.expasy.org/uniprot/" + id;
+		if(c.equalsIgnoreCase("U")) {
+			String [] org_nr = id.split("\\.");
+			if(org_nr.length == 2) {
+				return "http://www.ncbi.nlm.nih.gov/UniGene/clust.cgi?ORG=" + 
+				org_nr[0] + "&CID=" + org_nr[1];
+			}
+			else {
+				return null;
+			}
+		}
+		if (c.equalsIgnoreCase("Nw"))
+		{
+			return "http://nugowiki.org/index.php/" + id;
+		}
+		if (c.equalsIgnoreCase("Ca"))
+		{
+			return "http://chem.sis.nlm.nih.gov/chemidplus/direct.jsp?regno=" + id;
+		}
+		if (c.equalsIgnoreCase("Cp"))
+		{
+			return "http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi?cid=" + id;
+		}
+		if (c.equalsIgnoreCase("Ce"))
+		{
+			return "http://www.ebi.ac.uk/chebi/searchId=CHEBI:" + id;
+		}
+		if (c.equalsIgnoreCase("Ch"))
+		{
+			return "http://www.hmdb.ca/scripts/show_card.cgi?METABOCARD=" + id + ".txt";
+		}
+		if (c.equalsIgnoreCase("Ck"))
+		{
+			return "http://www.genome.jp/dbget-bin/www_bget?cpd:" + id;
+		}
+		return null;
+	}
+	
+	/**
+	 * Sets the text for the Gene information part of the browser. Will be prepended by a paragraph
+	 * header as defined in bpHeader
+	 * @param bpText	Text to display in HTML format
+	 */
+	public void setGeneText(String bpText) {
+		if(bpText == null) { //In case no information has to be displayed
+			this.bpText = bpHeader + "<I>No gene selected</I>";
+		} else {
+			this.bpText = bpHeader + bpText;
+		}
+		refresh();
+	}
+	
+	/**
+	 * Sets the text for the expression part of the browser. Will be prepended by a paragraph
+	 * header as defined in gexHeader
+	 * @param gexText	Text to display in HTML format
+	 */
+	public void setGexText(String gexText) {
+		if(gexText != null) { //In case no information has to be displayed
+			this.gexText = gexHeader + gexText;
+		} else {
+			this.gexText = "";
+		}
+		refresh();
+	}
+	
+	/**
+	 * Refreshes the text displayed in the browser
+	 */
+	public void refresh() {
+		getDisplay().asyncExec(new Runnable() {
+			public void run() {
+				bpBrowser.setText(header + bpText + gexText);	
+			}
+		});
+	}
+	
+	/**
+	 * Reads the header of the HTML content displayed in the browser. This header is displayed in the
+	 * file specified in the {@link HEADERFILE} field
+	 */
+	private void initializeHeader() {
+		try {
+			BufferedReader input = new BufferedReader(new InputStreamReader(
+						Engine.getResourceURL(BPDIR + "/" + HEADERFILE).openStream()));
+			String line;
+			header = "";
+			while((line = input.readLine()) != null) {
+				header += line.trim();
+			}
+		} catch (Exception e) {
+			Engine.log.error("Unable to read header file for backpage browser: " + e.getMessage(), e);
+		}
+	}
+
+	public void drawingEvent(SelectionEvent e) {
+		switch(e.type) {
+		case SelectionEvent.OBJECT_ADDED:
+			//Just take the first GeneProduct in the selection
+			for(VPathwayElement o : e.selection) {
+				if(o instanceof GeneProduct) {
+					if(geneProduct != o) setGeneProduct((GeneProduct)o);
+					break; //Selects the first, TODO: use setGmmlDataObjects
+				}
+			}
+			break;
+		case SelectionEvent.OBJECT_REMOVED:
+			if(e.selection.size() != 0) break;
+		case SelectionEvent.SELECTION_CLEARED:
+			setGeneProduct(null);
+			break;
+		}
+	}
+}

Property changes on: trunk/src/g2d_swt/org/pathvisio/gui/swt/BackpagePanel.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_swt/org/pathvisio/view/swt/VPathwaySWT.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/view/swt/VPathwaySWT.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/view/swt/VPathwaySWT.java	(revision 957)
@@ -0,0 +1,166 @@
+package org.pathvisio.view.swt;
+
+import java.awt.Dimension;
+import java.awt.Graphics2D;
+import java.awt.Rectangle;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.KeyEvent;
+import org.eclipse.swt.events.KeyListener;
+import org.eclipse.swt.events.MouseEvent;
+import org.eclipse.swt.events.MouseListener;
+import org.eclipse.swt.events.MouseMoveListener;
+import org.eclipse.swt.events.MouseTrackListener;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.events.PaintListener;
+import org.eclipse.swt.graphics.GC;
+import org.eclipse.swt.widgets.Canvas;
+import org.eclipse.swt.widgets.Composite;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.view.InputEvent;
+import org.pathvisio.view.VPathway;
+import org.pathvisio.view.VPathwayWrapper;
+
+public class VPathwaySWT extends Canvas implements VPathwayWrapper, PaintListener, 
+				MouseListener, KeyListener, MouseMoveListener, MouseTrackListener {
+	final SWTGraphics2DRenderer renderer = new SWTGraphics2DRenderer();
+	
+	private VPathway child;
+	
+	public VPathwaySWT(Composite parent, int style) {
+		super(parent, style);
+	}
+
+	public VPathway createVPathway() {
+		setChild(new VPathway(this));
+		return child;
+	}
+	
+	protected void setChild(VPathway c) {
+		child = c;
+		addPaintListener(this);
+		addMouseListener(this);
+		addMouseMoveListener(this);
+		addMouseTrackListener(this);
+		addKeyListener(this);
+	}
+	
+	public void redraw(Rectangle r) {
+		redraw(r.x, r.y, r.width, r.height, false);
+	}
+
+	public void setVSize(Dimension size) {
+		setVSize(size.width, size.height);
+	}
+
+	public void setVSize(int w, int h) {
+		setSize(w, h);
+	}
+	
+	public Dimension getVSize() {
+		org.eclipse.swt.graphics.Point p = getSize();
+		return new Dimension(p.x, p.y);
+	}
+	
+	public Rectangle getVBounds() {
+		org.eclipse.swt.graphics.Rectangle b = getBounds();
+		return new Rectangle(b.x, b.y, b.width, b.height);
+	}
+	
+	public Dimension getViewportSize() {
+		org.eclipse.swt.graphics.Point scs = SwtEngine.getWindow().sc.getSize();
+		return new Dimension(scs.x, scs.y);
+	}
+	
+	//Method 1: transfer from BufferedImage
+	public void paintControl(PaintEvent e) {
+		GC gc = e.gc; // gets the SWT graphics context from the event
+
+		gc.setClipping(e.x, e.y, e.width, e.height);
+		
+		renderer.prepareRendering(gc); // prepares the Graphics2D renderer
+
+		Graphics2D g2d = renderer.getGraphics2D();
+			
+		child.draw(g2d, new Rectangle(e.x, e.y, e.width, e.height));
+		
+		renderer.render(gc);
+	}
+
+	//Method 2: use Graphics2D extension
+//	public void paintControl(PaintEvent e) {
+//		GC gc = e.gc; // gets the SWT graphics context from the event
+//		
+//		Graphics2D g2d = new SWTGraphics2D(gc, gc.getDevice());
+//		child.draw(g2d, new Rectangle(e.x, e.y, e.width, e.height));
+//		
+//	}
+	
+	public static int convertStateMask(int swtMask) {
+		int newMask = 0;
+		newMask = addModifier(swtMask, SWT.CTRL, newMask, InputEvent.M_CTRL);
+		newMask = addModifier(swtMask, SWT.ALT, newMask, InputEvent.M_ALT);
+		//newMask = addModifier(stateMask, SWT.)//TODO: find SWT mapping for M_META
+		newMask = addModifier(swtMask, SWT.SHIFT, newMask, InputEvent.M_SHIFT);
+		return newMask;
+	}
+
+	private static int addModifier(int swtMask, int swtModifier, int pvMask, int pvModifier) {
+		if((swtMask & swtModifier) != 0) {
+			pvMask |= pvModifier;
+		}
+		return pvMask;
+	}
+	
+	public void mouseDoubleClick(MouseEvent e) {
+		SwtMouseEvent pve = new SwtMouseEvent(
+				e, org.pathvisio.view.MouseEvent.MOUSE_CLICK, 2);
+		child.mouseDoubleClick(pve);
+	}
+
+	public void mouseDown(MouseEvent e) {
+		SwtMouseEvent pve = new SwtMouseEvent(
+				e, org.pathvisio.view.MouseEvent.MOUSE_DOWN, 0);
+		child.mouseDown(pve);
+	}
+
+	public void mouseUp(MouseEvent e) {
+		SwtMouseEvent pve = new SwtMouseEvent(
+				e, org.pathvisio.view.MouseEvent.MOUSE_UP, 0);
+		child.mouseUp(pve);
+	}
+
+	public void keyPressed(KeyEvent e) {
+		SwtKeyEvent pve = new SwtKeyEvent(e, org.pathvisio.view.KeyEvent.KEY_PRESSED);
+		child.keyPressed(pve);
+	}
+
+	public void keyReleased(KeyEvent e) {
+		SwtKeyEvent pve = new SwtKeyEvent(e, org.pathvisio.view.KeyEvent.KEY_RELEASED);
+		child.keyReleased(pve);
+	}
+
+	public void mouseMove(MouseEvent e) {
+		SwtMouseEvent pve = new SwtMouseEvent(
+				e, org.pathvisio.view.MouseEvent.MOUSE_MOVE, 0);
+		child.mouseMove(pve);
+	}
+
+	public void mouseEnter(MouseEvent e) {
+		SwtMouseEvent pve = new SwtMouseEvent(
+				e, org.pathvisio.view.MouseEvent.MOUSE_ENTER, 0);
+		child.mouseEnter(pve);
+	}
+
+	public void mouseExit(MouseEvent e) {
+		SwtMouseEvent pve = new SwtMouseEvent(
+				e, org.pathvisio.view.MouseEvent.MOUSE_ENTER, 0);
+		child.mouseExit(pve);
+	}
+
+	public void mouseHover(MouseEvent e) {
+		SwtMouseEvent pve = new SwtMouseEvent(
+				e, org.pathvisio.view.MouseEvent.MOUSE_HOVER, 0);
+		child.mouseHover(pve);	
+	}
+}
\ No newline at end of file
Index: trunk/src/g2d_swt/org/pathvisio/view/swt/SWTGraphics2D.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/view/swt/SWTGraphics2D.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/view/swt/SWTGraphics2D.java	(revision 957)
@@ -0,0 +1,942 @@
+package org.pathvisio.view.swt;
+
+import java.awt.Color;
+import java.awt.Composite;
+import java.awt.Font;
+import java.awt.FontMetrics;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.GraphicsConfiguration;
+import java.awt.Image;
+import java.awt.Paint;
+import java.awt.Point;
+import java.awt.Rectangle;
+import java.awt.RenderingHints;
+import java.awt.Shape;
+import java.awt.Stroke;
+import java.awt.RenderingHints.Key;
+import java.awt.font.FontRenderContext;
+import java.awt.font.GlyphVector;
+import java.awt.geom.AffineTransform;
+import java.awt.geom.Arc2D;
+import java.awt.geom.Ellipse2D;
+import java.awt.geom.Rectangle2D;
+import java.awt.geom.RoundRectangle2D;
+import java.awt.image.BufferedImage;
+import java.awt.image.BufferedImageOp;
+import java.awt.image.ImageObserver;
+import java.awt.image.RenderedImage;
+import java.awt.image.renderable.RenderableImage;
+import java.text.AttributedCharacterIterator;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.graphics.Device;
+import org.eclipse.swt.graphics.FontData;
+import org.eclipse.swt.graphics.GC;
+
+/**
+ * An extension to Graphics2D to support an SWT Piccolo Canvas with little modification to the current Piccolo architecture
+ * 
+ * There is an outstanding SWT bug request #33319 for more efficient polyline/polygon rendering methods.  It also appears that
+ * most of the code below could be made obselete by bug fix #6490
+ * 
+ * A lot of this may also be duplicated in GEF - the eclipse Graphical Editor Framework
+ * 
+ * @author Lance Good
+ */
+public class SWTGraphics2D extends Graphics2D {
+
+	protected static int CACHE_COUNT = 0;
+	protected static HashMap FONT_CACHE = new HashMap();
+	protected static HashMap COLOR_CACHE = new HashMap();
+	protected static HashMap SHAPE_CACHE = new HashMap();
+	protected static BufferedImage BUFFER = new BufferedImage(1,1,BufferedImage.TYPE_INT_ARGB);
+
+	static Point PT = new Point();	
+	static Rectangle2D RECT = new Rectangle2D.Double();
+	static Rectangle2D LINE_RECT = new Rectangle2D.Double();
+	static org.eclipse.swt.graphics.Rectangle SWT_RECT = new org.eclipse.swt.graphics.Rectangle(0,0,0,0);
+
+	protected GC gc;
+	protected Device device;
+	protected AffineTransform transform = new AffineTransform();
+	protected org.eclipse.swt.graphics.Font curFont;
+	protected double lineWidth = 1.0;
+
+	/**
+	 * Constructor for SWTGraphics2D.
+	 */
+	public SWTGraphics2D(GC gc, Device device) {
+		super();
+		
+		this.gc = gc;		
+		this.device = device;
+	}
+
+	////////////////////
+	// GET CLIP
+	////////////////////
+
+	/**
+	 * @see java.awt.Graphics#getClipBounds()
+	 */
+	public Rectangle getClipBounds() {
+		org.eclipse.swt.graphics.Rectangle rect = gc.getClipping();
+		Rectangle aRect = new Rectangle(rect.x,rect.y,rect.width,rect.height);
+		try {
+			SWTShapeManager.transform(aRect,transform.createInverse());
+		} catch (Exception e) {e.printStackTrace();}
+		return aRect;
+	}
+
+	public void clipRect(int x, int y, int width, int height) {
+		RECT.setRect(x,y,width,height);
+		SWTShapeManager.transform(RECT,transform);
+		SWTShapeManager.awtToSWT(RECT,SWT_RECT);
+		
+		org.eclipse.swt.graphics.Rectangle clip = gc.getClipping();
+		clip = clip.intersection(SWT_RECT);
+		
+		gc.setClipping(clip);
+	}
+
+	public void setClip(int x, int y, int width, int height) {
+		RECT.setRect(x,y,width,height);
+		SWTShapeManager.transform(RECT,transform);
+		SWTShapeManager.awtToSWT(RECT,SWT_RECT);
+				
+		gc.setClipping(SWT_RECT);		
+	}
+
+	/**
+	 * This method isn't really supported by SWT - so will use the shape bounds
+	 */
+	public void clip(Shape s) {
+		Rectangle2D clipBds = s.getBounds2D();
+		SWTShapeManager.transform(clipBds,transform);
+		SWTShapeManager.awtToSWT(clipBds,SWT_RECT);
+
+		org.eclipse.swt.graphics.Rectangle clip = gc.getClipping();
+		clip = clip.intersection(SWT_RECT);
+				
+		gc.setClipping(SWT_RECT);
+	}
+
+	/**
+	 * This method isn't really supported by SWT - so will use the shape bounds
+	 */
+	public void setClip(Shape clip) {
+		if (clip == null) {
+			gc.setClipping((org.eclipse.swt.graphics.Rectangle)null);	
+		}
+		else {
+			Rectangle2D clipBds = clip.getBounds2D();
+			SWTShapeManager.transform(clipBds,transform);
+			SWTShapeManager.awtToSWT(clipBds,SWT_RECT);
+	
+			gc.setClipping(SWT_RECT);
+		}
+	}
+	
+	public Shape getClip() {
+		org.eclipse.swt.graphics.Rectangle rect = gc.getClipping();
+		Rectangle2D aRect = new Rectangle2D.Double(rect.x,rect.y,rect.width,rect.height);
+		try {
+			SWTShapeManager.transform(aRect,transform.createInverse());
+		} catch (Exception e) {e.printStackTrace();}
+		return aRect;
+	}
+
+	/////////////////////
+	// DEVICE SPECIFIC
+	/////////////////////
+	
+
+	public GraphicsConfiguration getDeviceConfiguration() {
+		return ((Graphics2D)BUFFER.getGraphics()).getDeviceConfiguration();
+	}
+
+
+	////////////////
+	// COLOR METHODS
+	////////////////
+
+	public Paint getPaint() {
+		return getColor();
+	}
+
+	public void setPaint(Paint paint) {
+		if (paint instanceof Color) {
+			setColor((Color)paint);
+		}
+	}
+
+	public Color getColor() {
+		org.eclipse.swt.graphics.Color color = gc.getForeground();
+		Color awtColor = new Color(color.getRed(),color.getGreen(),color.getBlue());
+		return awtColor;
+	}
+
+	public void setColor(Color c) {
+		org.eclipse.swt.graphics.Color cachedColor = (org.eclipse.swt.graphics.Color)COLOR_CACHE.get(c);
+		if (cachedColor == null) {
+			cachedColor = new org.eclipse.swt.graphics.Color(device,c.getRed(),c.getGreen(),c.getBlue());	
+			COLOR_CACHE.put(c,cachedColor);
+		}
+		gc.setForeground(cachedColor);
+	}
+
+	public void setColor(org.eclipse.swt.graphics.Color c) {
+		gc.setForeground(c);	
+	}
+
+	public void setBackground(Color c) {
+		org.eclipse.swt.graphics.Color cachedColor = (org.eclipse.swt.graphics.Color)COLOR_CACHE.get(c);
+		if (cachedColor == null) {
+			cachedColor = new org.eclipse.swt.graphics.Color(device,c.getRed(),c.getGreen(),c.getBlue());	
+			COLOR_CACHE.put(c,cachedColor);
+		}
+		gc.setBackground(cachedColor);
+	}
+
+	public void setBackground(org.eclipse.swt.graphics.Color c) {
+		gc.setBackground(c);	
+	}
+
+	public Color getBackground() {
+		org.eclipse.swt.graphics.Color color = gc.getBackground();
+		Color awtColor = new Color(color.getRed(),color.getGreen(),color.getBlue());
+		return awtColor;
+	}
+
+	////////////////
+	// FONT METHODS
+	////////////////
+
+	public org.eclipse.swt.graphics.Font getSWTFont() {
+		return curFont;	
+	}
+	
+	public org.eclipse.swt.graphics.FontMetrics getSWTFontMetrics() {
+		gc.setFont(curFont);
+		return gc.getFontMetrics();
+	}
+
+	public Font getFont() {
+		if (curFont != null) {
+			int style = Font.PLAIN;
+			
+			FontData[] fd = curFont.getFontData();
+			if (fd.length > 0) {
+				if ((fd[0].getStyle() & SWT.BOLD) != 0) {
+					style = style | Font.BOLD;	
+				}
+				if ((fd[0].getStyle() & SWT.ITALIC) != 0) {
+					style = style | SWT.ITALIC;	
+				}
+				
+				return new Font(fd[0].getName(),style,fd[0].height);
+			}
+			return null;			
+		}
+		else {
+			return null;
+		}
+	}
+
+	public void setFont(Font font) {
+		String fontString = "name="+font.getFamily()+";bold="+font.isBold()+";italic="+font.isItalic()+";size="+font.getSize();
+		
+		curFont = getFont(fontString);
+	}
+
+	public void setFont(org.eclipse.swt.graphics.Font font) {
+		curFont = font;	
+	}
+
+	public org.eclipse.swt.graphics.Font getFont(String fontString) {
+		org.eclipse.swt.graphics.Font cachedFont = (org.eclipse.swt.graphics.Font)FONT_CACHE.get(fontString);
+		if (cachedFont == null) {
+			int style = 0;
+			if (fontString.indexOf("bold=true") != -1) {
+				style = style | SWT.BOLD;	
+			}
+			if (fontString.indexOf("italic=true") != -1) {
+				style = style | SWT.ITALIC;	
+			}
+			
+			String name = fontString.substring(0,fontString.indexOf(";"));
+			String size = fontString.substring(fontString.lastIndexOf(";")+1,fontString.length());
+			int sizeInt = 12;
+			try {
+				sizeInt = Integer.parseInt(size.substring(size.indexOf("=")+1,size.length()));
+			}
+			catch (Exception e) {e.printStackTrace();}
+			
+			cachedFont = new org.eclipse.swt.graphics.Font(device,name.substring(name.indexOf("=")+1,name.length()),sizeInt,style);
+			FONT_CACHE.put(fontString,cachedFont);
+		}
+		return cachedFont;		
+	}
+
+	protected org.eclipse.swt.graphics.Font getTransformedFont() {
+		if (curFont != null) {
+			FontData fontData = curFont.getFontData()[0];
+			int height = fontData.getHeight();
+			RECT.setRect(0,0,height,height);
+			SWTShapeManager.transform(RECT,transform);
+			height = (int)(RECT.getHeight()+0.5);
+			
+			String fontString = "name="+fontData.getName()+";bold="+((fontData.getStyle() & SWT.BOLD) != 0)+";italic="+((fontData.getStyle() & SWT.ITALIC) != 0)+";size="+height;
+			return getFont(fontString);
+		}
+		return null;
+	}
+
+	///////////////////////////
+	// AFFINE TRANSFORM METHODS
+	///////////////////////////	
+
+	public void translate(int x, int y) {
+		transform.translate(x,y);
+	}
+
+	public void translate(double tx, double ty) {
+		transform.translate(tx,ty);
+	}
+
+	public void rotate(double theta) {
+		transform.rotate(theta);
+	}
+
+	public void rotate(double theta, double x, double y) {
+		transform.rotate(theta,x,y);
+	}
+
+	public void scale(double sx, double sy) {
+		transform.scale(sx,sy);
+	}
+
+	public void shear(double shx, double shy) {
+		transform.shear(shx,shy);
+	}
+
+	public void transform(AffineTransform Tx) {
+		transform.concatenate(Tx);
+	}
+
+	public void setTransform(AffineTransform Tx) {
+		transform = (AffineTransform)Tx.clone();
+	}
+
+	public AffineTransform getTransform() {
+		return (AffineTransform)transform.clone();
+	}
+
+	///////////////////////////////
+	// DRAWING AND FILLING METHODS
+	///////////////////////////////
+	
+	public void clearRect(int x, int y, int width, int height) {
+		fillRect(x,y,width,height);	
+	}
+	
+	public void draw(Shape s) {
+		if (s instanceof Rectangle2D) {
+			Rectangle2D r2 = (Rectangle2D)s;
+			drawRect(r2.getX(),r2.getY(),r2.getWidth(),r2.getHeight());
+		}
+		else if (s instanceof Ellipse2D) {
+			Ellipse2D e2 = (Ellipse2D)s;
+			drawOval(e2.getX(),e2.getY(),e2.getWidth(),e2.getHeight());
+		}
+		else if (s instanceof RoundRectangle2D) {
+			RoundRectangle2D r2 = (RoundRectangle2D)s;
+			drawRoundRect(r2.getX(),r2.getY(),r2.getWidth(),r2.getHeight(),r2.getArcWidth(),r2.getArcHeight());	
+		}
+		else if (s instanceof Arc2D) {
+			Arc2D a2 = (Arc2D)s;
+			drawArc(a2.getX(),a2.getY(),a2.getWidth(),a2.getHeight(),a2.getAngleStart(),a2.getAngleExtent());
+		}
+		else {
+			double[] pts = (double[])SHAPE_CACHE.get(s);
+			
+			if (pts == null) {
+				pts = SWTShapeManager.shapeToPolyline(s);
+				SHAPE_CACHE.put(s,pts);	
+			}
+			
+			drawPolyline(pts);
+		}
+	}
+
+	public void fill(Shape s) {
+		if (s instanceof Rectangle2D) {
+			Rectangle2D r2 = (Rectangle2D)s;
+			fillRect(r2.getX(),r2.getY(),r2.getWidth(),r2.getHeight());
+		}
+		else if (s instanceof Ellipse2D) {
+			Ellipse2D e2 = (Ellipse2D)s;
+			fillOval(e2.getX(),e2.getY(),e2.getWidth(),e2.getHeight());
+		}
+		else if (s instanceof RoundRectangle2D) {
+			RoundRectangle2D r2 = (RoundRectangle2D)s;
+			fillRoundRect(r2.getX(),r2.getY(),r2.getWidth(),r2.getHeight(),r2.getArcWidth(),r2.getArcHeight());	
+		}
+		else if (s instanceof Arc2D) {
+			Arc2D a2 = (Arc2D)s;
+			fillArc(a2.getX(),a2.getY(),a2.getWidth(),a2.getHeight(),a2.getAngleStart(),a2.getAngleExtent());
+		}
+		else {
+			double[] pts = (double[])SHAPE_CACHE.get(s);
+			
+			if (pts == null) {
+				pts = SWTShapeManager.shapeToPolyline(s);
+				SHAPE_CACHE.put(s,pts);	
+			}
+			
+			fillPolygon(pts);
+		}
+	}
+
+	public void drawPolyline(int[] xPoints, int[] yPoints, int nPoints) {
+		int[] ptArray = new int[2*nPoints];
+		for(int i=0; i<nPoints; i++) {
+			PT.setLocation(xPoints[i],yPoints[i]);
+			transform.transform(PT,PT);
+			ptArray[2*i] = xPoints[i];
+			ptArray[2*i+1] = yPoints[i];
+		}
+		
+		gc.setLineWidth(getTransformedLineWidth());
+		gc.drawPolyline(ptArray);	
+	}
+
+	public void drawPolyline(double[] pts) {
+		int[] intPts = SWTShapeManager.transform(pts,transform);
+		gc.drawPolyline(intPts);			
+	}
+
+	public void drawPolygon(int[] xPoints, int[] yPoints, int nPoints) {
+		int[] ptArray = new int[2*nPoints];
+		for(int i=0; i<nPoints; i++) {
+			PT.setLocation(xPoints[i],yPoints[i]);
+			transform.transform(PT,PT);
+			ptArray[2*i] = xPoints[i];
+			ptArray[2*i+1] = yPoints[i];
+		}
+		
+		gc.drawPolygon(ptArray);
+	}
+
+	public void fillPolygon(double[] pts) {
+		int[] intPts = SWTShapeManager.transform(pts,transform);
+		gc.fillPolygon(intPts);
+	}
+
+	public void fillPolygon(int[] xPoints, int[] yPoints, int nPoints) {
+		int[] ptArray = new int[2*nPoints];
+		for(int i=0; i<nPoints; i++) {
+			PT.setLocation(xPoints[i],yPoints[i]);
+			transform.transform(PT,PT);
+			ptArray[2*i] = xPoints[i];
+			ptArray[2*i+1] = yPoints[i];
+		}
+		
+		gc.fillPolygon(ptArray);		
+	}
+
+	public void drawLine(int x1, int y1, int x2, int y2) {
+		drawLine((double)x1,(double)y1,(double)x2,(double)y2);
+	}
+
+	public void drawLine(double x1, double y1, double x2, double y2) {
+		PT.setLocation(x1,y1);
+		transform.transform(PT,PT);
+		x1 = (int)PT.getX();
+		y1 = (int)PT.getY();
+		PT.setLocation(x2,y2);
+		transform.transform(PT,PT);
+		x2 = (int)PT.getX();
+		y2 = (int)PT.getY();
+
+		gc.setLineWidth(getTransformedLineWidth());		
+		gc.drawLine((int)(x1+0.5),(int)(y1+0.5),(int)(x2+0.5),(int)(y2+0.5));
+	}
+
+	//***************************************************************************
+	// FOR NOW - ASSUME NO ROTATION ON THE TRANSFORM FOR THE FOLLOWING CALLS!
+	//***************************************************************************
+
+	public void copyArea(org.eclipse.swt.graphics.Image img, double x, double y) {
+		PT.setLocation(x,y);
+		transform.transform(PT,PT);
+		
+		gc.copyArea(img,(int)(PT.getX()+0.5),(int)(PT.getY()+0.5));
+	}
+
+	public void copyArea(int x, int y, int width, int height, int dx, int dy) {
+		RECT.setRect(x,y,width,height);
+		SWTShapeManager.transform(RECT,transform);
+
+		PT.setLocation(dx,dy);
+		transform.transform(PT,PT);
+		gc.copyArea((int)RECT.getX(),(int)RECT.getY(),(int)RECT.getWidth(),(int)RECT.getHeight(),(int)PT.getX(),(int)PT.getY());
+	}
+
+	public void drawString(String str, double x, double y) {
+		PT.setLocation(x,y);
+		transform.transform(PT,PT);
+		gc.setFont(getTransformedFont());
+		gc.drawString(str,(int)(PT.getX()+0.5),(int)(PT.getY()+0.5),true);
+	}
+	
+	public void drawString(String str, int x, int y) {
+		drawString(str,(double)x,(double)y);
+	}
+
+	public void drawString(String str, float x, float y) {
+		drawString(str,(double)x,(double)y);
+	}
+
+	public void drawText(String s, double x, double y) {
+		PT.setLocation(x,y);
+		transform.transform(PT,PT);
+		gc.setFont(getTransformedFont());
+		gc.drawText(s,(int)(PT.getX()+0.5),(int)(PT.getY()+0.5),true);	
+	}
+
+	public void drawText(String s, double x, double y, int flags) {
+		PT.setLocation(x,y);
+		transform.transform(PT,PT);
+		gc.setFont(getTransformedFont());
+		gc.drawText(s,(int)(PT.getX()+0.5),(int)(PT.getY()+0.5),flags);	
+	}
+
+	public void drawRect(int x, int y, int width, int height) {
+		drawRect((double)x,(double)y,(double)width,(double)height);	
+	}
+
+	public void drawRect(double x, double y, double width, double height) {
+		RECT.setRect(x,y,width,height);
+		SWTShapeManager.transform(RECT,transform);
+		SWTShapeManager.awtToSWT(RECT,SWT_RECT);
+		
+		gc.setLineWidth(getTransformedLineWidth());
+		gc.drawRectangle(SWT_RECT);
+	}
+
+	public void fillRect(int x, int y, int width, int height) {
+		fillRect((double)x,(double)y,(double)width,(double)height);	
+	}
+
+	public void fillRect(double x, double y, double width, double height) {
+		RECT.setRect(x,y,width,height);
+		SWTShapeManager.transform(RECT,transform);
+		SWTShapeManager.awtToSWT(RECT,SWT_RECT);
+		
+		gc.fillRectangle(SWT_RECT);
+	}
+
+	public void drawRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight) {
+		drawRoundRect((double)x,(double)y,(double)width,(double)height,(double)arcWidth,(double)arcHeight);
+	}
+
+	public void drawRoundRect(double x, double y, double width, double height, double arcWidth, double arcHeight) {
+		RECT.setRect(x,y,width,height);
+		SWTShapeManager.transform(RECT,transform);		
+		x = RECT.getX();
+		y = RECT.getY();
+		width = RECT.getWidth();
+		height = RECT.getHeight();
+
+		RECT.setRect(0,0,arcWidth,arcHeight);
+		SWTShapeManager.transform(RECT,transform);
+		arcWidth = RECT.getWidth();
+		arcHeight = RECT.getHeight();
+
+		gc.setLineWidth(getTransformedLineWidth());
+		gc.drawRoundRectangle((int)(x+0.5),(int)(y+0.5),(int)(width+0.5),(int)(height+0.5),(int)(arcWidth+0.5),(int)(arcHeight+0.5));		
+	}
+
+
+	public void fillRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight) {
+		fillRoundRect((double)x,(double)y,(double)width,(double)height,(double)arcWidth,(double)arcHeight);
+	}
+
+	public void fillRoundRect(double x, double y, double width, double height, double arcWidth, double arcHeight) {
+		RECT.setRect(x,y,width,height);
+		SWTShapeManager.transform(RECT,transform);		
+		x = RECT.getX();
+		y = RECT.getY();
+		width = RECT.getWidth();
+		height = RECT.getHeight();
+
+		RECT.setRect(0,0,arcWidth,arcHeight);
+		SWTShapeManager.transform(RECT,transform);
+		arcWidth = RECT.getWidth();
+		arcHeight = RECT.getHeight();
+
+		gc.setLineWidth(getTransformedLineWidth());
+		gc.fillRoundRectangle((int)(x+0.5),(int)(y+0.5),(int)(width+0.5),(int)(height+0.5),(int)(arcWidth+0.5),(int)(arcHeight+0.5));		
+	}
+
+	public void drawOval(int x, int y, int width, int height) {
+		drawOval((double)x,(double)y,(double)width,(double)height);
+	}
+	
+	public void drawOval(double x, double y, double width, double height) {
+		RECT.setRect(x,y,width,height);
+		SWTShapeManager.transform(RECT,transform);
+		
+		gc.setLineWidth(getTransformedLineWidth());
+		gc.drawOval((int)(RECT.getX()+0.5),(int)(RECT.getY()+0.5),(int)(RECT.getWidth()+0.5),(int)(RECT.getHeight()+0.5));
+	}
+
+	public void fillOval(int x, int y, int width, int height) {
+		fillOval((double)x,(double)y,(double)width,(double)height);
+	}
+
+	public void fillOval(double x, double y, double width, double height) {
+		RECT.setRect(x,y,width,height);
+		SWTShapeManager.transform(RECT,transform);
+		
+		gc.fillOval((int)(RECT.getX()+0.5),(int)(RECT.getY()+0.5),(int)(RECT.getWidth()+0.5),(int)(RECT.getHeight()+0.5));
+	}
+
+
+	public void drawArc(int x, int y, int width, int height, int startAngle, int extent) {
+		drawArc((double)x,(double)y,(double)width,(double)height,(double)startAngle,(double)extent);
+	}
+
+	public void drawArc(double x, double y, double width, double height, double startAngle, double extent) {
+		RECT.setRect(x,y,width,height);
+		SWTShapeManager.transform(RECT,transform);
+		
+		gc.setLineWidth(getTransformedLineWidth());
+		gc.drawArc((int)(RECT.getX()+0.5),(int)(RECT.getY()+0.5),(int)(RECT.getWidth()+0.5),(int)(RECT.getHeight()+0.5),(int)(startAngle+0.5),(int)(startAngle+extent+0.5));
+	}
+
+	public void fillArc(int x, int y, int width, int height, int startAngle, int extent) {
+		drawArc((double)x,(double)y,(double)width,(double)height,(double)startAngle,(double)extent);
+	}
+
+	public void fillArc(double x, double y, double width, double height, double startAngle, double extent) {
+		RECT.setRect(x,y,width,height);
+		SWTShapeManager.transform(RECT,transform);
+		
+		gc.drawArc((int)(RECT.getX()+0.5),(int)(RECT.getY()+0.5),(int)(RECT.getWidth()+0.5),(int)(RECT.getHeight()+0.5),(int)(startAngle+0.5),(int)(startAngle+extent+0.5));
+	}
+
+	//////////////////////////
+	// SWT IMAGE METHODS
+	//////////////////////////
+
+	public void drawImage(org.eclipse.swt.graphics.Image image, double x, double y) {
+		org.eclipse.swt.graphics.Rectangle bounds = image.getBounds();
+		RECT.setRect(x,y,bounds.width,bounds.height);
+		SWTShapeManager.transform(RECT,transform);
+		SWTShapeManager.awtToSWT(RECT,SWT_RECT);
+
+		gc.drawImage(image,0,0,bounds.width,bounds.height,SWT_RECT.x,SWT_RECT.y,SWT_RECT.width,SWT_RECT.height);
+	}
+
+	public void drawImage(org.eclipse.swt.graphics.Image image, int srcX, int srcY, int srcW, int srcH, double destX, double destY, double destW, double destH) {
+		RECT.setRect(destX,destY,destW,destH);
+		SWTShapeManager.transform(RECT,transform);
+		SWTShapeManager.awtToSWT(RECT,SWT_RECT);
+
+		gc.drawImage(image,srcX,srcY,srcW,srcH,SWT_RECT.x,SWT_RECT.y,SWT_RECT.width,SWT_RECT.height);
+	}
+
+	//////////////////////////////
+	// OTHER SWT SPECIFIC METHODS
+	//////////////////////////////
+
+	public void setLineWidth(double lineWidth) {
+		this.lineWidth = lineWidth;			
+	}
+
+	protected int getTransformedLineWidth() {
+		LINE_RECT.setRect(0,0,lineWidth,lineWidth);
+		SWTShapeManager.transform(LINE_RECT,transform);
+		
+		return (int)(Math.max(LINE_RECT.getWidth(),1)+0.5);
+	}
+	
+	public void fillGradientRectangle(double x, double y, double width, double height, boolean vertical) {
+		RECT.setRect(x,y,width,height);
+		SWTShapeManager.transform(RECT,transform);
+		SWTShapeManager.awtToSWT(RECT,SWT_RECT);
+		
+		gc.fillGradientRectangle(SWT_RECT.x,SWT_RECT.y,SWT_RECT.width,SWT_RECT.height,vertical);
+	}
+
+	public void setXORMode(boolean xOr) {
+		gc.setXORMode(xOr);	
+	}
+
+	public int getAdvanceWidth(char ch) {
+		org.eclipse.swt.graphics.Font scaledFont = gc.getFont();
+		gc.setFont(curFont);
+		int width = gc.getAdvanceWidth(ch);	
+		gc.setFont(scaledFont);
+		return width;
+	}
+
+	public int getCharWidth(char ch) {
+		org.eclipse.swt.graphics.Font scaledFont = gc.getFont();
+		gc.setFont(curFont);
+		int width = gc.getCharWidth(ch);
+		gc.setFont(scaledFont);
+		return width;
+	}
+
+	public org.eclipse.swt.graphics.Point stringExtent(String str) {
+		org.eclipse.swt.graphics.Font scaledFont = gc.getFont();
+		gc.setFont(curFont);		
+		org.eclipse.swt.graphics.Point extent = gc.stringExtent(str);	
+		gc.setFont(scaledFont);
+		return extent;
+	}
+
+	public org.eclipse.swt.graphics.Point textExtent(String str) {
+		org.eclipse.swt.graphics.Font scaledFont = gc.getFont();
+		gc.setFont(curFont);		
+		org.eclipse.swt.graphics.Point extent = gc.textExtent(str);	
+		gc.setFont(scaledFont);
+		return extent;
+	}
+
+	public org.eclipse.swt.graphics.Point textExtent(String str, int flags) {
+		org.eclipse.swt.graphics.Font scaledFont = gc.getFont();
+		gc.setFont(curFont);		
+		org.eclipse.swt.graphics.Point extent = gc.textExtent(str,flags);	
+		gc.setFont(scaledFont);
+		return extent;
+	}
+
+	/////////////////////////////////
+	// CURRENTLY UNSUPPORTED METHODS
+	/////////////////////////////////
+
+	/**
+	 * @see java.awt.Graphics#drawString(AttributedCharacterIterator, int, int)
+	 */
+	public void drawString(AttributedCharacterIterator iterator, int x, int y) {
+	}
+
+	/**
+	 * @see java.awt.Graphics2D#drawString(AttributedCharacterIterator, float, float)
+	 */
+	public void drawString(AttributedCharacterIterator iterator, float x, float y) {
+	}
+
+	/**
+	 * @see java.awt.Graphics2D#drawGlyphVector(GlyphVector, float, float)
+	 */
+	public void drawGlyphVector(GlyphVector g, float x, float y) {
+	}
+
+	/**
+	 * @see java.awt.Graphics2D#hit(Rectangle, Shape, boolean)
+	 */
+	public boolean hit(Rectangle rect, Shape s, boolean onStroke) {
+		return false;
+	}
+
+	/**
+	 * @see java.awt.Graphics2D#setComposite(Composite)
+	 */
+	public void setComposite(Composite comp) {
+	}
+
+	/**
+	 * @see java.awt.Graphics2D#setStroke(Stroke)
+	 */
+	public void setStroke(Stroke s) {
+	}
+
+	public void setRenderingHint(Key hintKey, Object hintValue) {
+	}
+
+	public Object getRenderingHint(Key hintKey) {
+		return null;
+	}
+
+	/**
+	 * @see java.awt.Graphics2D#setRenderingHints(Map)
+	 */
+	public void setRenderingHints(Map hints) {
+	}
+
+	/**
+	 * @see java.awt.Graphics2D#addRenderingHints(Map)
+	 */
+	public void addRenderingHints(Map hints) {
+	}
+
+	/**
+	 * @see java.awt.Graphics2D#getRenderingHints()
+	 */
+	public RenderingHints getRenderingHints() {
+		return null;
+	}
+
+	/**
+	 * @see java.awt.Graphics2D#getComposite()
+	 */
+	public Composite getComposite() {
+		return null;
+	}
+
+	/**
+	 * @see java.awt.Graphics2D#getStroke()
+	 */
+	public Stroke getStroke() {
+		return null;
+	}
+
+	/**
+	 * @see java.awt.Graphics2D#getFontRenderContext()
+	 */
+	public FontRenderContext getFontRenderContext() {
+		return null;
+	}
+
+	/**
+	 * @see java.awt.Graphics#create()
+	 */
+	public Graphics create() {
+		return null;
+	}
+
+	/**
+	 * @see java.awt.Graphics#setPaintMode()
+	 */
+	public void setPaintMode() {
+	}
+
+	/**
+	 * @see java.awt.Graphics#setXORMode(Color)
+	 */
+	public void setXORMode(Color c1) {
+	}
+
+	/**
+	 * @see java.awt.Graphics#getFontMetrics(Font)
+	 */
+	public FontMetrics getFontMetrics(Font f) {
+		return null;
+	}
+
+	/**
+	 * @see java.awt.Graphics2D#drawImage(Image, AffineTransform, ImageObserver)
+	 */
+	public boolean drawImage(Image img, AffineTransform xform, ImageObserver obs) {
+		return false;
+	}
+
+	/**
+	 * @see java.awt.Graphics2D#drawImage(BufferedImage, BufferedImageOp, int, int)
+	 */
+	public void drawImage(BufferedImage img, BufferedImageOp op, int x, int y) {
+	}
+
+	/**
+	 * @see java.awt.Graphics2D#drawRenderedImage(RenderedImage, AffineTransform)
+	 */
+	public void drawRenderedImage(RenderedImage img, AffineTransform xform) {
+	}
+
+	/**
+	 * @see java.awt.Graphics2D#drawRenderableImage(RenderableImage, AffineTransform)
+	 */
+	public void drawRenderableImage(RenderableImage img, AffineTransform xform) {
+	}
+
+	/**
+	 * @see java.awt.Graphics#drawImage(Image, int, int, ImageObserver)
+	 */
+	public boolean drawImage(Image img, int x, int y, ImageObserver observer) {
+		return false;
+	}
+
+	/**
+	 * @see java.awt.Graphics#drawImage(Image, int, int, int, int, ImageObserver)
+	 */
+	public boolean drawImage(Image img, int x, int y, int width, int height, ImageObserver observer) {
+		return false;
+	}
+
+	/**
+	 * @see java.awt.Graphics#drawImage(Image, int, int, Color, ImageObserver)
+	 */
+	public boolean drawImage(Image img, int x, int y, Color bgcolor, ImageObserver observer) {
+		return false;
+	}
+
+	/**
+	 * @see java.awt.Graphics#drawImage(Image, int, int, int, int, Color, ImageObserver)
+	 */
+	public boolean drawImage(Image img, int x, int y, int width, int height, Color bgcolor, ImageObserver observer) {
+		return false;
+	}
+
+	/**
+	 * @see java.awt.Graphics#drawImage(Image, int, int, int, int, int, int, int, int, ImageObserver)
+	 */
+	public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2, ImageObserver observer) {
+		return false;
+	}
+
+	/**
+	 * @see java.awt.Graphics#drawImage(Image, int, int, int, int, int, int, int, int, Color, ImageObserver)
+	 */
+	public boolean drawImage(
+		Image img,
+		int dx1,
+		int dy1,
+		int dx2,
+		int dy2,
+		int sx1,
+		int sy1,
+		int sx2,
+		int sy2,
+		Color bgcolor,
+		ImageObserver observer) {
+		return false;
+	}
+
+	/**
+	 * DO NOTHING - DISPOSED IN RENDERING CLASS
+	 */
+	public void dispose() {
+	}
+
+	/////////////////////////////////
+	// CLEAN-UP METHODS
+	/////////////////////////////////
+
+	public static void incrementGCCount() {
+		CACHE_COUNT++;		
+	}
+
+	public static void decrementGCCount() {
+		CACHE_COUNT--;
+
+		if (CACHE_COUNT == 0) {
+			for(Iterator i=FONT_CACHE.values().iterator(); i.hasNext();) {
+				org.eclipse.swt.graphics.Font font = (org.eclipse.swt.graphics.Font)i.next();
+				font.dispose();
+			}
+			for(Iterator i=COLOR_CACHE.values().iterator(); i.hasNext();) {
+				org.eclipse.swt.graphics.Color color = (org.eclipse.swt.graphics.Color)i.next();
+				color.dispose();
+			}
+		}
+	}
+}
Index: trunk/src/g2d_swt/org/pathvisio/view/swt/SwtKeyEvent.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/view/swt/SwtKeyEvent.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/view/swt/SwtKeyEvent.java	(revision 957)
@@ -0,0 +1,30 @@
+package org.pathvisio.view.swt;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.KeyEvent;
+
+public class SwtKeyEvent extends org.pathvisio.view.KeyEvent {
+	KeyEvent swtEvent;
+	
+	public SwtKeyEvent(KeyEvent swtEvent, int type) {
+		super(swtEvent.getSource(), convertKeyCode(swtEvent), type, VPathwaySWT.convertStateMask(swtEvent.stateMask));
+		this.swtEvent = swtEvent;
+	}
+
+	protected static int convertKeyCode(KeyEvent swtEvent) {
+		switch(swtEvent.keyCode) {
+		case SWT.CTRL:
+			return org.pathvisio.view.KeyEvent.CTRL;
+		case SWT.ALT:
+			return org.pathvisio.view.KeyEvent.ALT;
+		case SWT.DEL:
+			return org.pathvisio.view.KeyEvent.DEL;
+		case SWT.INSERT:
+			return org.pathvisio.view.KeyEvent.INSERT;
+		case SWT.SHIFT:
+			return org.pathvisio.view.KeyEvent.SHIFT;
+		default:
+			return swtEvent.keyCode;
+		}
+	}
+}
Index: trunk/src/g2d_swt/org/pathvisio/view/swt/SwtMouseEvent.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/view/swt/SwtMouseEvent.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/view/swt/SwtMouseEvent.java	(revision 957)
@@ -0,0 +1,29 @@
+package org.pathvisio.view.swt;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.MouseEvent;
+
+public class SwtMouseEvent extends org.pathvisio.view.MouseEvent {
+
+	private MouseEvent swtEvent;
+	
+	public SwtMouseEvent(MouseEvent swtEvent, int type, int clickCount) {
+		super(swtEvent.getSource(), type, convertButton(swtEvent), swtEvent.x, swtEvent.y, 
+				clickCount, VPathwaySWT.convertStateMask(swtEvent.stateMask));
+		
+		this.swtEvent = swtEvent;
+	}
+
+	protected static int convertButton(MouseEvent se) {
+		switch(se.button) {
+		case SWT.BUTTON1:
+			return org.pathvisio.view.MouseEvent.BUTTON1;
+		case SWT.BUTTON2:
+			return org.pathvisio.view.MouseEvent.BUTTON2;
+		case SWT.BUTTON3:
+			return org.pathvisio.view.MouseEvent.BUTTON3;
+		}
+		return org.pathvisio.view.MouseEvent.BUTTON_NONE;
+	}
+		
+}
Index: trunk/src/g2d_swt/org/pathvisio/view/swt/SWTShapeManager.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/view/swt/SWTShapeManager.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/view/swt/SWTShapeManager.java	(revision 957)
@@ -0,0 +1,112 @@
+package org.pathvisio.view.swt;
+
+import java.awt.Shape;
+import java.awt.geom.AffineTransform;
+import java.awt.geom.PathIterator;
+import java.awt.geom.Point2D;
+import java.awt.geom.Rectangle2D;
+import java.util.ArrayList;
+
+import org.eclipse.swt.graphics.Rectangle;
+
+/**
+ * @author Lance Good
+ */
+public class SWTShapeManager {
+
+	static AffineTransform IDENTITY_XFORM = new AffineTransform();
+	static Point2D aPoint = new Point2D.Double();
+	static ArrayList segList = new ArrayList();
+	static double[] pts = new double[8];
+
+
+    /**
+     * Apply the specified transform to the specified rectangle, modifying the rect.
+     * @param rect The rectangle to be transformed
+     * @param at The transform to use to transform the rectangle
+     */
+    public static void transform(Rectangle2D rect, AffineTransform at) {
+                                // First, transform all 4 corners of the rectangle
+        pts[0] = rect.getX();          // top left corner
+        pts[1] = rect.getY();
+        pts[2] = rect.getX() + rect.getWidth();  // top right corner
+        pts[3] = rect.getY();
+        pts[4] = rect.getX() + rect.getWidth();  // bottom right corner
+        pts[5] = rect.getY() + rect.getHeight();
+        pts[6] = rect.getX();          // bottom left corner
+        pts[7] = rect.getY() + rect.getHeight();
+        at.transform(pts, 0, pts, 0, 4);
+
+                                // Then, find the bounds of those 4 transformed points.
+        double minX = pts[0];
+        double minY = pts[1];
+        double maxX = pts[0];
+        double maxY = pts[1];
+        int i;
+        for (i=1; i<4; i++) {
+            if (pts[2*i] < minX) {
+                minX = pts[2*i];
+            }
+            if (pts[2*i+1] < minY) {
+                minY = pts[2*i+1];
+            }
+            if (pts[2*i] > maxX) {
+                maxX = pts[2*i];
+            }
+            if (pts[2*i+1] > maxY) {
+                maxY = pts[2*i+1];
+            }
+        }
+        rect.setRect(minX, minY, maxX - minX, maxY - minY);
+    }
+
+	public static void awtToSWT(Rectangle2D aRect, Rectangle sRect) {
+		sRect.x = (int)(aRect.getX()+0.5);
+		sRect.y = (int)(aRect.getY()+0.5);
+		sRect.width = (int)(aRect.getWidth()+0.5);
+		sRect.height = (int)(aRect.getHeight()+0.5);
+	}
+	
+	public static double[] shapeToPolyline(Shape s) {
+		segList.clear();
+		aPoint.setLocation(0,0);
+		
+		PathIterator pi = s.getPathIterator(IDENTITY_XFORM,0.000000001);
+		while (!pi.isDone()) {
+			int segType = pi.currentSegment(pts);
+			switch (segType) {
+				case PathIterator.SEG_MOVETO:
+					aPoint.setLocation(pts[0],pts[1]);
+					segList.add(new Point2D.Double(pts[0],pts[1]));
+					break;
+				case PathIterator.SEG_LINETO:
+					segList.add(new Point2D.Double(pts[0],pts[1]));					
+					break;
+				case PathIterator.SEG_CLOSE:
+					segList.add(new Point2D.Double(aPoint.getX(),aPoint.getY()));
+					break;
+			}
+			pi.next();
+		}
+		
+		double[] polyObj = new double[2*segList.size()];
+		for(int i=0; i<segList.size(); i++) {
+			Point2D p2 = (Point2D)segList.get(i);
+			polyObj[2*i] = (int)(p2.getX()+0.5);
+			polyObj[2*i+1] = (int)(p2.getY()+0.5);
+		}
+		
+		return polyObj;
+	}
+	
+	public static int[] transform(double[] pts, AffineTransform at) {
+		int[] intPts = new int[pts.length];
+		for(int i=0; i<pts.length/2; i++) {
+			aPoint.setLocation(pts[2*i],pts[2*i+1]);
+			at.transform(aPoint,aPoint);
+			intPts[2*i] = (int)(aPoint.getX()+0.5);
+			intPts[2*i+1] = (int)(aPoint.getY()+0.5);
+		}
+		return intPts;
+	}	
+}
Index: trunk/src/g2d_swt/org/pathvisio/view/swt/SWTGraphics2DRenderer.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/view/swt/SWTGraphics2DRenderer.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/view/swt/SWTGraphics2DRenderer.java	(revision 957)
@@ -0,0 +1,126 @@
+package org.pathvisio.view.swt;
+
+import java.awt.Graphics2D;
+import java.awt.image.BufferedImage;
+
+import org.eclipse.swt.graphics.GC;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.graphics.ImageData;
+import org.eclipse.swt.graphics.PaletteData;
+import org.eclipse.swt.widgets.Display;
+
+/**
+ * Helper class allowing the use of Java 2D on SWT or Draw2D graphical
+ * context.
+ * @author Yannick Saillet
+ */
+public class SWTGraphics2DRenderer {
+  private static final PaletteData PALETTE_DATA =
+    new PaletteData(0xFF0000, 0xFF00, 0xFF);
+
+  private BufferedImage awtImage;
+  private Image swtImage;
+  private ImageData swtImageData;
+  private int[] awtPixels;
+
+  /** RGB value to use as transparent color */
+  private static final int TRANSPARENT_COLOR = 0x123456;
+
+  /**
+   * Prepare to render on a SWT graphics context.
+   */
+  public void prepareRendering(GC gc) {
+    org.eclipse.swt.graphics.Rectangle clip = gc.getClipping();
+    prepareRendering(clip.x, clip.y, clip.width, clip.height);
+  }
+
+  /**
+   * Prepare the AWT offscreen image for the rendering of the rectangular
+   * region given as parameter.
+   */
+  public void prepareRendering(int clipX, int clipY, int clipW, int clipH) {
+    // check that the offscreen images are initialized and large enough
+    checkOffScreenImages(clipX, clipY, clipW, clipH);
+    // fill the region in the AWT image with the transparent color
+    java.awt.Graphics awtGraphics = awtImage.getGraphics();
+    awtGraphics.setColor(new java.awt.Color(TRANSPARENT_COLOR));
+    awtGraphics.fillRect(clipX, clipY, clipW, clipH);
+  }
+
+  /**
+   * Returns the Graphics2D context to use.
+   */
+  public Graphics2D getGraphics2D() {
+    if (awtImage == null) return null;
+    return (Graphics2D) awtImage.getGraphics();
+  }
+
+  /**
+   * Complete the rendering by flushing the 2D renderer on a SWT graphical
+   * context.
+   */
+  public void render(GC gc) {
+    if (awtImage == null) return;
+
+    org.eclipse.swt.graphics.Rectangle clip = gc.getClipping();
+    transferPixels(clip.x, clip.y, clip.width, clip.height);
+    gc.drawImage(swtImage, clip.x, clip.y, clip.width, clip.height,
+                 clip.x, clip.y, clip.width, clip.height);
+  }
+
+  /**
+   * Transfer a rectangular region from the AWT image to the SWT image.
+   */
+  private void transferPixels(int clipX, int clipY, int clipW, int clipH) {
+    int step = swtImageData.depth / 8;
+    byte[] data = swtImageData.data;
+    awtImage.getRGB(clipX, clipY, clipW, clipH, awtPixels, 0, clipW);
+    for (int i = 0; i < clipH; i++) {
+      int idx = (clipY + i) * swtImageData.bytesPerLine + clipX * step;
+      for (int j = 0; j < clipW; j++) {
+        int rgb = awtPixels[j + i * clipW];
+        for (int k = swtImageData.depth - 8; k >= 0; k -= 8) {
+          data[idx++] = (byte) ((rgb >> k) & 0xFF);
+        }
+      }
+    }
+    if (swtImage != null) swtImage.dispose();
+    swtImage = new Image(Display.getDefault(), swtImageData);
+  }
+
+  /**
+   * Dispose the resources attached to this 2D renderer.
+   */
+  public void dispose() {
+    if (awtImage != null) awtImage.flush();
+    if (swtImage != null) swtImage.dispose();
+    awtImage = null;
+    swtImageData = null;
+    awtPixels = null;
+  }
+
+  /**
+   * Ensure that the offscreen images are initialized and are at least
+   * as large as the size given as parameter.
+   */
+  private void checkOffScreenImages(int x, int y, int width, int height) {
+	System.out.println("width: " + width + "| height: " + height);
+    int currentImageWidth = 0;
+    int currentImageHeight = 0;
+    if (swtImage != null) {
+      currentImageWidth = swtImage.getImageData().width;
+      currentImageHeight = swtImage.getImageData().height;
+    }
+
+    // if the offscreen images are too small, recreate them
+    if ((x + width) > currentImageWidth || (y + height) > currentImageHeight) {
+      dispose();
+      width = Math.max(width, x + width);
+      height = Math.max(height, y + height);
+      awtImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
+      swtImageData = new ImageData(width, height, 24, PALETTE_DATA);
+      swtImageData.transparentPixel = TRANSPARENT_COLOR;
+      awtPixels = new int[width * height];
+    }
+  }
+}
\ No newline at end of file
Index: trunk/src/g2d_swt/org/pathvisio/view/swt/VPathwaySwtAwt.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/view/swt/VPathwaySwtAwt.java	(revision 0)
+++ trunk/src/g2d_swt/org/pathvisio/view/swt/VPathwaySwtAwt.java	(revision 957)
@@ -0,0 +1,97 @@
+package org.pathvisio.view.swt;
+
+import java.awt.event.KeyEvent;
+import java.awt.event.MouseEvent;
+
+import javax.swing.JScrollPane;
+
+import org.eclipse.swt.widgets.Display;
+import org.pathvisio.view.swing.VPathwaySwing;
+
+public class VPathwaySwtAwt extends VPathwaySwing {
+	Display display;
+	public VPathwaySwtAwt(JScrollPane parent, Display display) {
+		super(parent);
+		this.display = display;
+	}
+
+	public void mouseClicked(final MouseEvent e) {
+		display.syncExec(new Runnable() {
+			public void run() {
+				VPathwaySwtAwt.super.mouseClicked(e);
+			}
+		});
+	}
+
+	public void mouseEntered(final MouseEvent e) {
+		display.syncExec(new Runnable() {
+			public void run() {
+				VPathwaySwtAwt.super.mouseEntered(e);
+			}
+		});
+	}
+
+	public void mouseExited(final MouseEvent e) {
+		display.syncExec(new Runnable() {
+			public void run() {
+				VPathwaySwtAwt.super.mouseExited(e);
+			}
+		});
+	}
+
+	public void mousePressed(final MouseEvent e) {
+		display.syncExec(new Runnable() {
+			public void run() {
+				VPathwaySwtAwt.super.mousePressed(e);
+			}
+		});
+	}
+
+	public void mouseReleased(final MouseEvent e) {
+		display.syncExec(new Runnable() {
+			public void run() {
+				VPathwaySwtAwt.super.mouseReleased(e);
+			}
+		});
+	}
+
+	public void keyPressed(final KeyEvent e) {
+		display.syncExec(new Runnable() {
+			public void run() {
+				VPathwaySwtAwt.super.keyPressed(e);
+			}
+		});
+	}
+
+	public void keyReleased(final KeyEvent e) {
+		display.syncExec(new Runnable() {
+			public void run() {
+				VPathwaySwtAwt.super.keyReleased(e);
+			}
+		});
+	}
+
+	public void keyTyped(final KeyEvent e) {
+		display.syncExec(new Runnable() {
+			public void run() {
+				VPathwaySwtAwt.super.keyTyped(e);
+			}
+		});
+	}
+
+	public void mouseDragged(final MouseEvent e) {
+		display.syncExec(new Runnable() {
+			public void run() {
+				VPathwaySwtAwt.super.mouseDragged(e);
+			}
+		});
+	}
+
+	public void mouseMoved(final MouseEvent e) {
+		display.syncExec(new Runnable() {
+			public void run() {
+				VPathwaySwtAwt.super.mouseMoved(e);
+			}
+		});
+	}
+}
\ No newline at end of file
Index: trunk/src/g2d/org/pathvisio/preferences/GlobalPreference.java
===================================================================
--- trunk/src/g2d/org/pathvisio/preferences/GlobalPreference.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/preferences/GlobalPreference.java	(revision 957)
@@ -0,0 +1,86 @@
+package org.pathvisio.preferences;
+
+import java.awt.Color;
+
+import org.pathvisio.util.ColorConverter;
+
+public enum GlobalPreference implements Preference {
+	
+	FILE_LOG(""), //TODO
+	
+	COLOR_NO_CRIT_MET(new Color(200, 200, 200)),
+	COLOR_NO_GENE_FOUND(Color.WHITE),
+	COLOR_NO_DATA_FOUND(new Color(100, 100, 100)),
+	COLOR_SELECTED(Color.RED),
+	COLOR_HIGHLIGHTED(Color.GREEN);
+	
+	GlobalPreference(String defaultValue) {
+		this.defaultValue = defaultValue;
+	}
+	
+	GlobalPreference(Color defaultValue) {
+		this.defaultValue = color2String(defaultValue);
+	}
+	
+	private String defaultValue;
+	private String value;
+	
+	public String getDefault() {
+		return defaultValue;
+	}
+	
+	public void setDefault(String defValue) {
+		defaultValue = defValue;
+	}
+	
+	public void setValue(String newValue) {
+		value = newValue;
+	}
+	
+	public String getValue() {
+		if(value != null) {
+			return value;
+		} else {
+			return defaultValue;
+		}
+	}
+		
+	public static boolean isDefault(Preference p) {
+		return p.getValue().equals(p.getDefault());
+	}
+	public static void setValue(Preference p, Color newValue) {
+		p.setValue(color2String(newValue));
+	}
+	
+	public static void setValue(Preference p, int newValue) {
+		p.setValue(Integer.toString(newValue));
+	}
+	
+	public static void setValue(Preference p, double newValue) {
+		p.setValue(Double.toString(newValue));
+	}
+	
+	public static Color getValueColor(Preference p) {
+		return string2Color(p.getValue());
+	}
+	
+	public static int getValueInt(Preference p) {
+		return Integer.parseInt(p.getValue());
+	}
+	
+	public static double getValueDouble(Preference p) {
+		return Double.parseDouble(p.getValue());
+	}
+	
+	public static boolean getValueBoolean(Preference p) {
+		return Boolean.parseBoolean(p.getValue());
+	}
+	
+	private static Color string2Color(String s) {
+		return ColorConverter.parseColorString(s);
+	}
+	
+	private static String color2String(Color c) {
+		return ColorConverter.getRgbString(c);
+	}
+}
Index: trunk/src/g2d/org/pathvisio/preferences/PreferenceCollection.java
===================================================================
--- trunk/src/g2d/org/pathvisio/preferences/PreferenceCollection.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/preferences/PreferenceCollection.java	(revision 957)
@@ -0,0 +1,9 @@
+package org.pathvisio.preferences;
+
+import java.io.IOException;
+
+public interface PreferenceCollection {	
+	public Preference byName(String name);
+	
+	public void save() throws IOException;
+}

Property changes on: trunk/src/g2d/org/pathvisio/preferences/PreferenceCollection.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d/org/pathvisio/preferences/Preference.java
===================================================================
--- trunk/src/g2d/org/pathvisio/preferences/Preference.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/preferences/Preference.java	(revision 957)
@@ -0,0 +1,14 @@
+package org.pathvisio.preferences;
+
+
+public interface Preference {
+	public String name();
+	
+	public void setDefault(String defValue);
+	
+	public String getDefault();
+	
+	public void setValue(String newValue);
+
+	public String getValue();
+}
Index: trunk/src/g2d/org/pathvisio/Engine.java
===================================================================
--- trunk/src/g2d/org/pathvisio/Engine.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/Engine.java	(revision 957)
@@ -0,0 +1,284 @@
+package org.pathvisio;
+
+import java.awt.Color;
+import java.io.File;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.EventObject;
+import java.util.HashMap;
+import java.util.List;
+
+import org.pathvisio.data.DBConnector;
+import org.pathvisio.debug.Logger;
+import org.pathvisio.model.ConverterException;
+import org.pathvisio.model.Pathway;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.PathwayExporter;
+import org.pathvisio.model.PathwayImporter;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.util.Utils;
+import org.pathvisio.view.VPathway;
+import org.pathvisio.view.VPathwayWrapper;
+
+public class Engine {
+	private static Pathway pathway;
+	private static VPathway vPathway;
+		
+	public static final String SVG_FILE_EXTENSION = "svg";
+	public static final String SVG_FILTER_NAME = "Scalable Vector Graphics (*." + SVG_FILE_EXTENSION + ")";
+	public static final String PATHWAY_FILE_EXTENSION = "gpml";
+	public static final String PATHWAY_FILTER_NAME = "PathVisio Pathway (*." + PATHWAY_FILE_EXTENSION + ")";
+	public static final String GENMAPP_FILE_EXTENSION = "mapp";
+	public static final String GENMAPP_FILTER_NAME = "GenMAPP Pathway (*." + GENMAPP_FILE_EXTENSION + ")";
+	
+	/**
+	 * the transparent color used in the icons for visualization of protein/mrna data
+	 */
+	public static final Color TRANSPARENT_COLOR = new Color(255, 0, 255);
+	
+	public final static Logger log = new Logger();
+			
+	/**
+	 * Get the {@link URL} for the resource stored in a jar file in the classpath
+	 * @param name	the filename of the resource
+	 * @return the URL pointing to the resource
+	 */
+	public static URL getResourceURL(String name) {
+		URL url = Engine.class.getClassLoader().getResource(name);
+		if(url == null) log.error("Couldn't load resource '" + name + "'");
+		return url;
+	}
+	
+	/**
+	 * Gets the currently open drawing
+	 */
+	public static VPathway getActiveVPathway() {
+		return vPathway;
+	}
+
+	/**
+	 * Returns the currently open Pathway
+	 */
+	public static Pathway getActivePathway() {
+		return pathway;
+	}
+	
+	/**
+	 * application global clipboard.
+	 */
+	public static List<PathwayElement> clipboard = null;
+
+	public static void openPathway(String fileName) throws ConverterException {
+		openPathway(new File(fileName));
+	}
+	
+	public static void openPathway(File pathwayFile) throws ConverterException {
+		openPathway(pathwayFile, null);
+	}
+	
+	public static void importPathway(File file) throws ConverterException {
+		importPathway(file, null);
+	}
+	
+	public static void importPathway(File file, VPathwayWrapper wrapper) throws ConverterException {
+		String fileName = file.toString();
+		
+		int dot = fileName.lastIndexOf('.');
+		String ext = Engine.PATHWAY_FILE_EXTENSION; //
+		if(dot >= 0) {
+			ext = fileName.substring(dot + 1, fileName.length());
+		}
+		PathwayImporter importer = getPathwayImporter(ext);
+		
+		if(importer == null) throw new ConverterException( "No importer for '" + ext +  "' files" );
+		
+		Pathway _pathway = new Pathway();
+		importer.doImport(file, _pathway);
+		pathway = _pathway;
+		fireApplicationEvent(new ApplicationEvent(pathway, ApplicationEvent.PATHWAY_OPENED));
+		if(wrapper != null) {
+			createVPathway(pathway, wrapper);
+		}
+	}
+	
+	public static void openPathway(String fileName, VPathwayWrapper wrapper) throws ConverterException {
+		openPathway(new File(fileName), wrapper);
+	}
+	
+	/**
+	 * Open a pathway from a gpml file
+	 */
+	public static void openPathway(File pathwayFile, VPathwayWrapper wrapper) throws ConverterException
+	{
+		Pathway _pathway = null;		
+		String pwf = pathwayFile.toString();
+		
+		// initialize new JDOM gpml representation and read the file
+		_pathway = new Pathway();
+		if (pwf.endsWith(".mapp"))
+		{
+			_pathway.readFromMapp(new File(pwf));
+		}
+		else
+		{
+			_pathway.readFromXml(new File(pwf), true);
+		}
+		if(_pathway != null) //Only continue if the data is correctly loaded
+		{
+			pathway = _pathway;
+			if(wrapper != null) {
+				createVPathway(_pathway, wrapper);
+			}
+			fireApplicationEvent(new ApplicationEvent(pathway, ApplicationEvent.PATHWAY_OPENED));
+		}
+		
+	}
+	
+	public static void savePathway() throws ConverterException {
+		savePathway(pathway.getSourceFile());
+	}
+	
+	public static void savePathway(File toFile) throws ConverterException {
+		pathway.writeToXml(toFile, true);
+	}
+	
+	private static void createVPathway(Pathway p, VPathwayWrapper wrapper) {
+		vPathway = wrapper.createVPathway();
+		vPathway.fromGmmlData(pathway);
+		fireApplicationEvent(new ApplicationEvent(vPathway, ApplicationEvent.VPATHWAY_CREATED));
+	}
+	
+	/**
+	 * Create a new pathway
+	 */
+	public static void newPathway() {
+		newPathway(null);
+	}
+	
+	/**
+	 * Create a new pathway and view (Pathay and VPathway)
+	 */
+	public static void newPathway(VPathwayWrapper wrapper) {
+		pathway = new Pathway();
+		pathway.initMappInfo();
+		
+		if(wrapper != null) {
+			newVPathway(pathway, wrapper);
+		}
+		fireApplicationEvent(new ApplicationEvent(vPathway, ApplicationEvent.PATHWAY_NEW));
+	}
+	
+	public static void newVPathway(Pathway pathway, VPathwayWrapper wrapper) {
+		vPathway = wrapper.createVPathway();
+		vPathway.fromGmmlData(pathway);
+	}
+	
+	/**
+	 * Find out whether a drawing is currently open or not
+	 * @return true if a drawing is open, false if not
+	 */
+	public static boolean isDrawingOpen() { return vPathway != null; }
+
+
+	private static HashMap<String, PathwayExporter> exporters = new HashMap<String, PathwayExporter>();
+	private static HashMap<String, PathwayImporter> importers = new HashMap<String, PathwayImporter>();
+	/**
+	 * Add a {@link PathwayExporter} that handles export of GPML to another file format
+	 * @param export
+	 */
+	public static void addPathwayExporter(PathwayExporter export) {
+		for(String ext : export.getExtensions()) {
+			exporters.put(ext, export);
+		}
+	}
+
+	/**
+	 * Add a {@link PathwayImporter} that handles imoprt of GPML to another file format
+	 * @param export
+	 */
+	public static void addPathwayImporter(PathwayImporter importer) {
+		for(String ext : importer.getExtensions()) {
+			importers.put(ext, importer);
+		}
+	}
+	
+	public static PathwayExporter getPathwayExporter(String ext) {
+		return exporters.get(ext);
+	}
+
+	public static PathwayImporter getPathwayImporter(String ext) {
+		return importers.get(ext);
+	}
+	
+	public static HashMap<String, PathwayExporter> getPathwayExporters() {
+		return exporters;
+	}
+		
+	public static HashMap<String, PathwayImporter> getPathwayImporters() {
+		return importers;
+	}
+	
+	public static DBConnector getDbConnector(int type) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
+		DBConnector connector = null;
+		String className = null;
+		switch(type) {
+		case DBConnector.TYPE_GDB:
+			className = SwtPreference.SWT_DB_ENGINE_GDB.getValue();
+			break;
+		case DBConnector.TYPE_GEX:
+			className = SwtPreference.SWT_DB_ENGINE_GDB.getValue();
+			break;
+		}
+		if(className == null) return null;
+		
+		Class dbc = Class.forName(className);
+		
+		if(Utils.isSubClass(dbc, DBConnector.class)) {
+			connector = (DBConnector)dbc.newInstance();
+			connector.setDbType(type);
+		}
+	
+		return connector;
+	}
+		
+	private static List<ApplicationEventListener> applicationEventListeners  = new ArrayList<ApplicationEventListener>();
+	
+	/**
+	 * Add an {@link ApplicationEventListener}, that will be notified if a
+	 * property changes that has an effect throughout the program (e.g. opening a pathway)
+	 * @param l The {@link ApplicationEventListener} to add
+	 */
+	public static void addApplicationEventListener(ApplicationEventListener l) {
+		applicationEventListeners.add(l);
+	}
+	
+	/**
+	 * Fire a {@link ApplicationEvent} to notify all {@link ApplicationEventListener}s registered
+	 * to this class
+	 * @param e
+	 */
+	public static void fireApplicationEvent(ApplicationEvent e) {
+		for(ApplicationEventListener l : applicationEventListeners) l.applicationEvent(e);
+	}
+	
+	public interface ApplicationEventListener {
+		public void applicationEvent(ApplicationEvent e);
+	}
+	
+	public static class ApplicationEvent extends EventObject {
+		private static final long serialVersionUID = 1L;
+		public static final int PATHWAY_OPENED = 1;
+		public static final int PATHWAY_NEW = 2;
+		public static final int APPLICATION_CLOSE = 3;
+		public static final int VPATHWAY_CREATED = 4;
+
+		public Object source;
+		public int type;
+		
+		public ApplicationEvent(Object source, int type) {
+			super(source);
+			this.source = source;
+			this.type = type;
+		}
+	}
+}
\ No newline at end of file
Index: trunk/src/g2d/org/pathvisio/view/Shape.java
===================================================================
--- trunk/src/g2d/org/pathvisio/view/Shape.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/view/Shape.java	(revision 957)
@@ -0,0 +1,102 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import java.awt.Color;
+import java.awt.Graphics2D;
+
+import org.pathvisio.model.PathwayElement;
+
+/**
+ * This class represents a GMMLShape, which can be a 
+ * rectangle or ellips, depending of its type.
+ */
+public class Shape extends GraphicsShape
+{
+	private static final long serialVersionUID = 1L;
+			
+	/**
+	 * Constructor for this class
+	 * @param canvas - the VPathway this Shape will be part of
+	 */
+	public Shape(VPathway canvas, PathwayElement o)
+	{
+		super(canvas, o);
+		setHandleLocation();
+	}
+		
+	public int getDrawingOrder() {
+		switch(gdata.getShapeType()) {
+		case BRACE:
+			return VPathway.DRAW_ORDER_BRACE;
+		default:
+			return VPathway.DRAW_ORDER_SHAPE;
+		}
+	}
+	
+	public void doDraw(Graphics2D g)
+	{					
+		Color fillcolor = gdata.getFillColor();
+		Color linecolor = gdata.getColor();
+		if(isSelected()) {
+			linecolor = selectColor;
+		} else if (isHighlighted()) {
+			linecolor = highlightColor;
+		}
+		
+		int x = getVLeft();
+		int y = getVTop();
+		int w = getVWidth();
+		int h = getVHeight();
+		int cx = getVCenterX();
+		int cy = getVCenterY();
+						
+		g.rotate(gdata.getRotation(), cx, cy);
+		
+		switch(gdata.getShapeType()) {
+		case OVAL:
+			if(!gdata.isTransparent()) {
+				g.setColor(fillcolor);
+				g.fillOval(x, y, w, h);
+			}
+			g.setColor(linecolor);
+			g.drawOval(x, y, w, h);
+			break;
+		case ARC:
+			g.setColor(linecolor);
+			g.drawArc(x, y, w, h, 0, -180);
+			break;
+		case BRACE:
+			g.setColor(linecolor);
+			g.drawLine (cx + h/2, cy, cx + w/2 - h/2, cy); //line on the right
+			g.drawLine (cx - h/2, cy, cx - w/2 + h/2, cy); //line on the left
+			g.drawArc (cx - w/2, cy, h, h, -180, -90); //arc on the left
+			g.drawArc (cx - h, cy - h,	h, h, -90, 90); //left arc in the middle
+			g.drawArc (cx, cy - h, h, h, -90, -90); //right arc in the middle
+			g.drawArc (cx + w/2 - h, cy, h, h, 0, 90); //arc on the right
+			break;
+		default:
+			if(!gdata.isTransparent()) {
+				g.setColor(fillcolor);
+				g.fillRect(x, y, w, h);
+			}
+			g.setColor(linecolor);
+			g.drawRect(x, y, w, h);
+			break;
+		}
+	}	
+}
\ No newline at end of file

Property changes on: trunk/src/g2d/org/pathvisio/view/Shape.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d/org/pathvisio/view/Graphics.java
===================================================================
--- trunk/src/g2d/org/pathvisio/view/Graphics.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/view/Graphics.java	(revision 957)
@@ -0,0 +1,146 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import java.awt.Color;
+import java.awt.Font;
+import java.awt.geom.Area;
+
+import org.pathvisio.model.Pathway;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.PathwayEvent;
+import org.pathvisio.model.PathwayListener;
+import org.pathvisio.preferences.GlobalPreference;
+
+
+/**
+ * This class is a parent class for all graphics
+ * that can be added to a VPathway.
+ */
+public abstract class Graphics extends VPathwayElement implements PathwayListener
+{
+	public static Color selectColor = GlobalPreference.getValueColor(GlobalPreference.COLOR_SELECTED);
+	public static Color highlightColor = GlobalPreference.getValueColor(GlobalPreference.COLOR_HIGHLIGHTED);
+	
+	protected PathwayElement gdata = null;
+	
+	public Graphics(VPathway canvas, PathwayElement o) {
+		super(canvas);
+		o.addListener(this);
+		gdata = o;
+	}
+	
+	public void select()
+	{
+		super.select();
+		for (Handle h : getHandles())
+		{
+			h.show();
+		}
+	}
+	
+	public void deselect()
+	{
+		super.deselect();
+		for (Handle h : getHandles())
+		{
+			h.hide();
+		}
+	}
+	
+	public PathwayElement getGmmlData() {
+		return gdata;
+	}
+	
+//	public List getAttributes() { return gdata.getAttributes() ;}
+	boolean listen = true;
+	public void gmmlObjectModified(PathwayEvent e) {	
+		if(listen) markDirty(); // mark everything dirty
+	}
+	
+	public Area createVisualizationRegion() {
+		return new Area(getVBounds());
+	}
+	
+	
+	/**
+	 * Get the x-coordinate of the center point of this object
+	 * adjusted to the current zoom factor
+
+	 * @return the center x-coordinate as integer
+	 */
+	public int getVCenterX() { return (int)(vFromM(gdata.getMCenterX())); }
+	
+	/**
+	 * Get the y-coordinate of the center point of this object
+	 * adjusted to the current zoom factor
+	 * 
+	 * @return the center y-coordinate as integer
+	 */
+	public int getVCenterY() { return (int)(vFromM(gdata.getMCenterY())); }
+
+	public int getVLeft() { return (int)(vFromM(gdata.getMLeft())); }
+	public int getVWidth() { return (int)(vFromM(gdata.getMWidth()));  }
+	public int getVTop() { return (int)(vFromM(gdata.getMTop())); }
+	public int getVHeight() { return (int)(vFromM(gdata.getMHeight())); }
+	
+	/**
+	 * Get the x-coordinate of the center point of this object
+	 * adjusted to the current zoom factor
+
+	 * @return the center x-coordinate as double
+	 */
+	public double getVCenterXDouble() { return vFromM(gdata.getMCenterX()); }
+	
+	/**
+	 * Get the y-coordinate of the center point of this object
+	 * adjusted to the current zoom factor
+	 * 
+	 * @return the center y-coordinate as double
+	 */
+	public double getVCenterYDouble() { return vFromM(gdata.getMCenterY()); }
+
+	public double getVLeftDouble() { return vFromM(gdata.getMLeft()); }
+	public double getVWidthDouble() { return vFromM(gdata.getMWidth());  }
+	public double getVTopDouble() { return vFromM(gdata.getMTop()); }
+	public double getVHeightDouble() { return vFromM(gdata.getMHeight()); }
+	
+	/**
+	 * Returns the fontstyle to create a java.awt.Font
+	 * @return the fontstyle, or Font.PLAIN if no font is available
+	 */
+	public int getVFontStyle() {
+		int style = Font.PLAIN;
+		if(gdata.getFontName() != null) {
+			if(gdata.isBold()) {
+				style |= Font.BOLD;
+			}
+			if(gdata.isItalic()) {
+				style |= Font.ITALIC;
+			}
+		}
+		return style;
+	}
+	
+	protected void destroy() {
+		super.destroy();
+		gdata.removeListener(canvas);
+		Pathway parent = gdata.getParent();
+		if(parent != null) parent.remove(gdata);
+	}
+	
+}
\ No newline at end of file

Property changes on: trunk/src/g2d/org/pathvisio/view/Graphics.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d/org/pathvisio/view/InputEvent.java
===================================================================
--- trunk/src/g2d/org/pathvisio/view/InputEvent.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/view/InputEvent.java	(revision 957)
@@ -0,0 +1,21 @@
+package org.pathvisio.view;
+
+import java.util.EventObject;
+
+public class InputEvent extends EventObject {
+	public static final int M_SHIFT = java.awt.event.InputEvent.SHIFT_MASK;
+	public static final int M_CTRL = java.awt.event.InputEvent.CTRL_MASK;
+	public static final int M_ALT = java.awt.event.InputEvent.ALT_MASK;
+	public static final int M_META = java.awt.event.InputEvent.META_MASK;
+	
+	private int modifier;
+	
+	public InputEvent(Object source, int modifier) {
+		super(source);
+		this.modifier = modifier;
+	}
+	
+	public boolean isKeyDown(int key) {
+		return (modifier & key) != 0;
+	}
+}
Index: trunk/src/g2d/org/pathvisio/view/VPathway.java
===================================================================
--- trunk/src/g2d/org/pathvisio/view/VPathway.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/view/VPathway.java	(revision 957)
@@ -0,0 +1,1478 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import java.awt.Color;
+import java.awt.Dimension;
+import java.awt.Graphics2D;
+import java.awt.Point;
+import java.awt.Rectangle;
+import java.awt.RenderingHints;
+import java.awt.geom.Point2D;
+import java.awt.geom.Rectangle2D;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.pathvisio.Engine;
+import org.pathvisio.gui.swt.AlignActions;
+import org.pathvisio.model.GroupStyle;
+import org.pathvisio.model.LineStyle;
+import org.pathvisio.model.LineType;
+import org.pathvisio.model.ObjectType;
+import org.pathvisio.model.OrientationType;
+import org.pathvisio.model.Pathway;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.PathwayEvent;
+import org.pathvisio.model.PathwayListener;
+import org.pathvisio.model.ShapeType;
+import org.pathvisio.model.PathwayElement.MPoint;
+import org.pathvisio.visualization.Visualization;
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+import org.pathvisio.visualization.VisualizationManager.VisualizationListener;
+
+/**
+ * This class implements and handles a drawing.
+ * Graphics objects are stored in the drawing and can be 
+ * visualized. The class also provides methods for mouse  and key
+ * event handling.
+ */
+public class VPathway implements PathwayListener, VisualizationListener
+{	
+	private static final long serialVersionUID = 1L;
+	static final double M_PASTE_OFFSET = 10 * 15;
+	public static final double ZOOM_TO_FIT = -1;
+	
+	private VPathwayWrapper parent; // may be null
+	
+	/**
+	 * All objects that are visible on this mapp, including the handles
+	 * but excluding the legend, mappInfo and selectionBox objects
+	 */
+	private ArrayList<VPathwayElement> drawingObjects;
+	public ArrayList<VPathwayElement> getDrawingObjects() { 
+		return drawingObjects; 
+	}
+	
+	/**
+	 * The {@link VPathwayElement} that is pressed last mouseDown event}
+	 */
+	VPathwayElement pressedObject	= null;	
+	
+	/**
+	 * The {@link Graphics} that is directly selected since last mouseDown event
+	 */
+	public Graphics selectedGraphics = null;
+	
+	/**
+	 * {@link InfoBox} object that contains information about this pathway,
+	 * currently only used for information in {@link gmmlVision.PropertyPanel}
+	 * (TODO: has to be implemented to behave the same as any Graphics object
+	 * when displayed on the drawing)
+	 */
+	InfoBox infoBox;
+	private Pathway data;
+	
+	public Pathway getGmmlData()
+	{
+		return data;
+	}
+	
+	SelectionBox s; 
+		
+	private boolean editMode;
+	/**
+	 * Checks if this drawing is in edit mode
+	 * @return false if in edit mode, true if not
+	 */
+	public boolean isEditMode() { return editMode; }
+	
+	/**
+	 Constructor for this class.
+	 @param parent Optional gui-specific wrapper for this VPathway
+	 */	
+	public VPathway(VPathwayWrapper parent)
+	{
+		this.parent = parent;
+		
+		drawingObjects	= new ArrayList<VPathwayElement>();
+		
+		s = new SelectionBox(this);
+		
+		VisualizationManager.addListener(this);
+	}
+	
+	public void redraw()
+	{
+		if (parent != null) parent.redraw();
+	}
+	
+	public VPathwayWrapper getWrapper()
+	{
+		return parent;
+	}
+	
+	/**
+	 * Map the contents of a single data object to this VPathway
+	 */	
+	private Graphics fromGmmlDataObject (PathwayElement o)
+	{
+		Graphics result = null;
+		switch (o.getObjectType())
+		{
+			case ObjectType.DATANODE: result = new GeneProduct(this, o); break;
+			case ObjectType.SHAPE: result = new Shape(this, o); break;
+			case ObjectType.LINE: result = new Line(this, o); break;
+			case ObjectType.MAPPINFO: 
+				InfoBox mi = new InfoBox(this, o);
+				addObject(mi); 
+				setMappInfo(mi);
+				result = mi; 
+				break;				
+			case ObjectType.LABEL: result = new Label(this, o); break;					
+			case ObjectType.GROUP: result = new Group(this, o); break;					
+		}
+		return result;
+	}
+	
+	/**
+	 * Maps the contents of a pathway to this VPathway
+	 */	
+	public void fromGmmlData(Pathway _data)
+	{		
+		data = _data;
+			
+		for (PathwayElement o : data.getDataObjects())
+		{
+			fromGmmlDataObject (o);
+		}
+		int width = (int)vFromM(infoBox.getGmmlData().getMBoardWidth());
+		int height = (int)vFromM(infoBox.getGmmlData().getMBoardHeight());
+		if (parent != null)
+		{
+			parent.setVSize(width, height);
+		}
+		data.fireObjectModifiedEvent(new PathwayEvent(null, PathwayEvent.MODIFIED_GENERAL));
+		data.addListener(this);
+	}
+
+	private int newGraphics = NEWNONE;
+	/**
+	 * Method to set the new graphics type that has to be added next time the user clicks on the
+	 * drawing. 
+	 * @param type One of the NEWXX fields of this class, where XX stands for the type of graphics to draw
+	 */
+	public void setNewGraphics(int type) { newGraphics = type; }
+	
+	private Rectangle dirtyRect = null;
+	/**
+	 * Adds object boundaries to the 'dirty rectangle', which marks the area that needs to be redrawn
+	 */
+	public void addDirtyRect(Rectangle r)
+	{
+		if(r == null) { //In case r is null, add whole drawing
+			if (parent != null) { r = parent.getVBounds(); }
+		}
+		if(dirtyRect == null)
+			dirtyRect = r;
+		else
+			dirtyRect.add(r);	
+	}
+	
+	/**
+	 * Redraw parts marked dirty
+	 * reset dirty rect afterwards
+	 */
+	public void redrawDirtyRect()
+	{
+		if (dirtyRect != null && parent != null)
+			parent.redraw (dirtyRect);
+		dirtyRect = null;
+	}
+			
+	/**
+	 * Sets the MappInfo containing information on the pathway
+	 * @param mappInfo
+	 */
+	public void setMappInfo(InfoBox mappInfo)
+	{
+		this.infoBox = mappInfo;
+		infoBox.getGmmlData().addListener(this);
+	}
+
+	/**
+	 * Gets the MappInfo containing information on the pathway
+	 */
+	public InfoBox getMappInfo() { return infoBox; }
+		
+	/**
+	 * Adds an element to the drawing
+	 * @param o the element to add
+	 */
+	public void addObject(VPathwayElement o)
+	{
+		if(!drawingObjects.contains(o)) { //Don't add duplicates!
+			drawingObjects.add(o);
+		}
+		
+	}
+
+	HashMap<MPoint, VPoint> pointsMtoV = new HashMap<MPoint, VPoint>();
+	protected VPoint getPoint(MPoint mPoint) {
+		VPoint p = pointsMtoV.get(mPoint);
+		if(p == null) {
+			p = newPoint(mPoint);
+		}
+		return p;
+	}
+	
+	
+	private VPoint newPoint(MPoint mPoint) {
+		VPoint p = null;
+		for(MPoint ep : mPoint.getEqualPoints()) {
+			p = pointsMtoV.get(ep);
+			if(p != null) {
+				p.addMPoint(mPoint);
+				pointsMtoV.put(mPoint, p);
+				break;
+			}
+		}
+		if(p == null) p = new VPoint(this);
+		p.addMPoint(mPoint);
+		pointsMtoV.put(mPoint, p);
+		return p;
+	}
+	
+	/**
+	 * Get the gene identifiers of all genes in this pathway
+	 * @return	List containing an identifier for every gene on the mapp
+	 * @deprecated get this info from Pathway directly
+	 */
+	public ArrayList<String> getMappIds()
+	{
+		ArrayList<String> mappIds = new ArrayList<String>();
+		for(VPathwayElement o : drawingObjects)
+		{
+			if(o instanceof GeneProduct)
+			{
+				mappIds.add(((GeneProduct)o).getID());
+			}
+		}
+		return mappIds;
+	}
+	
+	/**
+	 * Get the systemcodes of all genes in this pathway
+	 * @return	List containing a systemcode for every gene on the mapp
+	 * 
+	 * @deprecated get this info from Pathway directly
+	 */
+	public ArrayList<String> getSystemCodes()
+	{
+		ArrayList<String> systemCodes = new ArrayList<String>();
+		for(VPathwayElement o : drawingObjects)
+		{
+			if(o instanceof GeneProduct)
+			{
+				systemCodes.add(((GeneProduct)o).getSystemCode());
+			}
+		}
+		return systemCodes;
+	}
+	
+	/**
+	 * Set this drawing to editmode
+	 * @param editMode	true if editmode has to be enabled, false if disabled (view mode)
+	 */
+	public void setEditMode(boolean editMode)
+	{
+		this.editMode = editMode;
+		if(!editMode)
+		{
+			clearSelection();
+		}
+
+		redraw();
+		int type = editMode ? VPathwayEvent.EDIT_MODE_ON : VPathwayEvent.EDIT_MODE_OFF;
+		fireVPathwayEvent(new VPathwayEvent(this, VPathwayEvent.EDIT_MODE_OFF));
+	}
+	
+	private double zoomFactor = 1.0/15.0;
+	/**
+	 * Get the current zoomfactor used. 
+	 * 1/15 means 100%, 15 gpml unit = 1 pixel
+	 * 2/15 means 200%, 7.5 gpml unit = 1 pixel
+	 * 
+	 * The 15/1 ratio is there because of 
+	 * the Visual Basic legacy of GenMAPP
+	 * 
+	 * To distinguish between model coordinates and view coordinates,
+	 * we prefix all coordinates with either v or m (or V or M). For example:
+	 * 
+	 * mTop = gdata.getMTop();
+	 * vTop = GeneProduct.getVTop();
+	 * 
+	 * Calculations done on M's and V's should always match.
+	 * The only way to convert is to use the functions
+	 * mFromV and vFromM.
+	 * 
+	 * Correct: mRight = mLeft + mWidth;
+	 * Wrong: mLeft += vDx; 
+	 * Fixed: mLeft += mFromV(vDx);
+	 * 
+	 * @return	the current zoomfactor
+	 */
+	public double getZoomFactor() { return zoomFactor; }
+
+	/**
+	 * same as getZoomFactor, but in %
+	 * @return
+	 */
+	public double getPctZoom() { return zoomFactor * 100 * 15.0; }
+
+	/**
+	 * Sets the drawings zoom in percent
+	 * @param pctZoomFactor zoomfactor in percent, or ZOOM_TO_FIT to fit the
+	 * zoomfactor to the drawing's viewport
+	 */
+	public void setPctZoom(double pctZoomFactor)
+	{
+		if(pctZoomFactor == ZOOM_TO_FIT) 
+		{
+			Dimension drawingSize = getWrapper().getVSize();
+			Dimension viewportSize = getWrapper().getViewportSize();
+			pctZoomFactor = (int)Math.min(
+					getPctZoom() * (double)viewportSize.width / drawingSize.width,
+					getPctZoom() * (double)viewportSize.height / drawingSize.height
+			);
+		}
+		zoomFactor = pctZoomFactor / 100.0 / 15.0;
+		int width = (int)vFromM(infoBox.getGmmlData().getMBoardWidth());
+		int height = (int)vFromM(infoBox.getGmmlData().getMBoardHeight());
+		if (parent != null)
+		{
+			parent.setVSize(width, height); 				
+			redraw();
+		}
+	}
+
+	public void setPressedObject(VPathwayElement o) {
+		pressedObject = o;
+	}
+	
+	int vPreviousX;
+	int vPreviousY;
+	boolean isDragging;
+	/**
+	 * handles mouse movement
+	 */
+	public void mouseMove(MouseEvent ve)
+	{
+		boolean altPressed = ve.isKeyDown(MouseEvent.M_ALT);
+		// If draggin, drag the pressed object
+		if (pressedObject != null && isDragging)
+		{
+			double vdx = ve.getX() - vPreviousX;
+			double vdy = ve.getY() - vPreviousY;
+			pressedObject.vMoveBy(vdx, vdy);
+				
+			vPreviousX = ve.getX();
+			vPreviousY = ve.getY();
+			
+			if (pressedObject instanceof Handle && altPressed && newGraphics == NEWNONE &&
+					((Handle)pressedObject).parent instanceof VPoint)
+			{
+				resetHighlight();
+				Point2D p2d = new Point2D.Double(ve.getX(), ve.getY());
+				List<VPathwayElement> objects = getObjectsAt (p2d);
+				Collections.sort(objects);
+				Handle g = (Handle)pressedObject;
+				VPoint p = (VPoint)g.parent;
+				VPathwayElement x = null;
+				for (VPathwayElement o : objects)
+				{
+					if (o instanceof VPoint && o != p) {
+						x = o;
+						p.link((VPoint)o);
+						break;
+					} else if(o instanceof Graphics && !(o instanceof Line)) {
+						x = o;
+						p.link((Graphics)o);
+						break;
+					} 
+				}
+				if(x != null) x.highlight();
+			}
+			redrawDirtyRect();
+		}
+	}
+	
+	public void selectObject(VPathwayElement o) {
+		clearSelection();
+		lastAdded.select();
+		s.addToSelection(lastAdded);
+	}
+	
+	/**
+	 * Handles mouse Pressed input
+	 */
+	public void mouseDown(MouseEvent e)
+	{		
+		//setFocus();
+		if (editMode)
+		{
+			if (newGraphics != NEWNONE)
+			{
+				newObject(new Point(e.getX(), e.getY()));
+				//SwtEngine.getWindow().deselectNewItemActions();
+			}
+			else
+			{
+				editObject(new Point(e.getX(), e.getY()), e);
+			}
+		}
+		else
+		{
+			mouseDownViewMode(e);
+		}
+
+	}
+		
+	/**
+	 * Handles mouse Released input
+	 */
+	public void mouseUp(MouseEvent e)
+	{
+		if(isDragging)
+		{
+			resetHighlight();
+			if(s.isSelecting()) { //If we were selecting, stop it
+				s.stopSelecting();
+			}
+			// check if we placed a new object by clicking or dragging
+			// if it was a click, give object the initial size.
+			else if (newObject != null && 
+					Math.abs(newObjectDragStart.x - e.getX()) <= MIN_DRAG_LENGTH &&
+					Math.abs(newObjectDragStart.y - e.getY()) <= MIN_DRAG_LENGTH)
+			{
+				newObject.setInitialSize();
+			}
+			newObject = null;
+			redrawDirtyRect();
+		}
+		isDragging = false;
+	}
+	
+	/**
+	 * Handles mouse entered input
+	 */
+	public void mouseDoubleClick(MouseEvent e) {	}
+
+	public void draw(Graphics2D g2d) {
+		draw(g2d, null);
+	}
+	
+	/**
+	 * Paints all components in the drawing.
+	 * This method is called automatically in the 
+	 * painting process
+	 */
+	public void draw (Graphics2D g2d, Rectangle area)
+	{		
+		if(area == null) {
+			area = g2d.getClipBounds();
+		}
+		
+		g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
+		g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
+		
+		g2d.setColor(java.awt.Color.WHITE);
+		g2d.fillRect(area.x, area.y, area.width, area.height);
+		g2d.setColor(java.awt.Color.BLACK);
+		Collections.sort(drawingObjects);
+		
+		Visualization v = VisualizationManager.getCurrent();
+		for(VPathwayElement o : drawingObjects)
+		{
+			if(o.vIntersects(area))
+			{
+				if(checkDrawAllowed(o)) {
+					o.draw (g2d);
+				}
+				
+				if(v != null && o instanceof Graphics) {
+						try {
+							v.visualizeDrawing((Graphics) o, g2d);
+						} catch(Exception ex) {
+							Engine.log.error(
+									"Unable to apply visualization " + v + " on " + o, ex);
+							ex.printStackTrace();
+						}
+				}
+			}
+		}
+	}
+
+	boolean checkDrawAllowed(VPathwayElement o) {
+		if(isEditMode()) return true;
+		else return !(	o instanceof Handle ||
+						(o == s && !isDragging)
+					);
+	}
+
+	/**
+	 * deselect all elements on the drawing
+	 */
+	private void clearSelection()
+	{
+		for(VPathwayElement o : drawingObjects) o.deselect(); //Deselect all objects
+		s.reset();
+	}
+
+	/**
+	 * Handles event when on mouseDown in case the drawing is in view mode
+	 * (does nothing yet)
+	 * @param e	the mouse event to handle
+	 */
+	private void mouseDownViewMode(MouseEvent e) 
+	{
+		Point2D p2d = new Point2D.Double(e.getX(), e.getY());
+
+		pressedObject = getObjectAt(p2d);
+		
+		if (pressedObject != null)
+			doClickSelect(p2d, e);
+		else
+			startSelecting(p2d);
+	}
+	
+	/**
+	 * Initializes selection, resetting the selectionbox
+	 * and then setting it to the position specified
+	 * @param vp - the point to start with the selection
+	 */
+	private void startSelecting(Point2D vp)
+	{
+		vPreviousX = (int)vp.getX();
+		vPreviousY = (int)vp.getY();
+		isDragging = true;
+		
+		clearSelection();
+		s.reset(vp.getX(), vp.getY());
+		s.startSelecting();
+		pressedObject = s.getCornerHandle();
+	}
+		
+	/**
+	 * Resets highlighting, unhighlights all GmmlDrawingObjects
+	 */
+	public void resetHighlight() 
+	{
+		for(VPathwayElement o : drawingObjects) o.unhighlight();
+		redraw();
+	}
+	
+	/**
+	 * Called by MouseDown, when we're in editting mode and we're not adding new objects
+	 * prepares for dragging the object
+	 */
+	private void editObject(Point p, MouseEvent e)
+	{
+		Point2D p2d = new Point2D.Double(p.x, p.y);
+		
+		pressedObject = getObjectAt(p2d);
+		
+		// if we clicked on an object
+		if (pressedObject != null)
+		{
+			// if our object is an handle, select also it's parent.
+			if(pressedObject instanceof Handle)
+			{
+				((Handle)pressedObject).parent.select();
+			} else {
+				doClickSelect(p2d, e);
+			}
+			
+			// start dragging
+			vPreviousX = p.x;
+			vPreviousY = p.y;
+			
+			isDragging = true;		
+		}
+		else
+		{
+			// start dragging selectionbox	
+			startSelecting(p2d);
+		}		
+	}
+
+	/**
+	 * Find the object at a particular location on the drawing
+	 * 
+	 * if you want to get more than one @see #getObjectsAt(Point2D)
+	 */
+	VPathwayElement getObjectAt(Point2D p2d) {
+		System.out.println(p2d);
+		Collections.sort(drawingObjects);
+		VPathwayElement probj = null;
+		for (VPathwayElement o : drawingObjects)
+		{
+			if (o.vContains(p2d))
+			{
+				// select this object, unless it is an invisible gmmlHandle
+				if (o instanceof Handle && !((Handle)o).isVisible()) 
+					;
+				else 
+					probj = o;
+			}
+		}
+		return probj;
+	}
+	
+	/**
+	 * Find all objects at a particular location on the drawing
+	 * 
+	 * if you only need the top object, @see #getObjectAt(Point2D)
+	 */
+	List<VPathwayElement> getObjectsAt(Point2D p2d) 
+	{
+		List<VPathwayElement> result = new ArrayList<VPathwayElement>();
+		for (VPathwayElement o : drawingObjects)
+		{
+			if (o.vContains(p2d))
+			{
+				// select this object, unless it is an invisible gmmlHandle
+				if (o instanceof Handle && !((Handle)o).isVisible()) 
+					;
+				else 
+					result.add(o);
+			}
+		}
+		return result;
+	}
+	
+	void doClickSelect(Point2D p2d, MouseEvent e) {
+		//Ctrl pressed, add/remove from selection
+		boolean ctrlPressed =  e.isKeyDown(MouseEvent.M_CTRL);
+		if(ctrlPressed) 
+		{
+			if(pressedObject instanceof SelectionBox) {
+				//Object inside selectionbox clicked, pass to selectionbox
+				s.objectClicked(p2d);
+			}
+			else if(pressedObject.isSelected()) { //Already in selection: remove
+				s.removeFromSelection(pressedObject);
+			} else {
+				s.addToSelection(pressedObject); //Not in selection: add
+			}
+			pressedObject = null; //Disable dragging
+		} 
+		else //Ctrl not pressed
+		{
+			//If pressedobject is not selectionbox:
+			//Clear current selection and select pressed object
+			if(!(pressedObject instanceof SelectionBox))
+			{
+				clearSelection();
+				s.addToSelection(pressedObject);
+			} else { //Check if clicked object inside selectionbox
+				if(s.getChild(p2d) == null) clearSelection();
+			}
+		}
+		redrawDirtyRect();
+	}
+	
+	public static final int NEWNONE = -1;
+	public static final int NEWLINE = 0;
+	public static final int NEWLABEL = 1;
+	public static final int NEWARC = 2;
+	public static final int NEWBRACE = 3;
+	public static final int NEWGENEPRODUCT = 4;
+	public static final int NEWLINEDASHED = 5;
+	public static final int NEWLINEARROW = 6;
+	public static final int NEWLINEDASHEDARROW = 7;
+	public static final int NEWRECTANGLE = 8;
+	public static final int NEWOVAL = 9;
+	public static final int NEWTBAR = 10;
+	public static final int NEWRECEPTORROUND = 11;
+	public static final int NEWLIGANDROUND = 12;
+	public static final int NEWRECEPTORSQUARE = 13;
+	public static final int NEWLIGANDSQUARE = 14;
+	public static final int NEWLINEMENU = 15;
+	public static final int NEWLINESHAPEMENU = 16;
+	public static final Color stdRGB = new Color(0, 0, 0);
+
+	/**
+	 * pathvisio distinguishes between placing objects with a click
+	 * or with a drag. If you don't move the cursor in between the mousedown
+	 * and mouseup event, the object is placed with a default initial size.
+	 * 
+	 * newObjectDragStart is used to determine the mousemovement during the click.
+	 */
+	private Point newObjectDragStart;
+	
+	/** newly placed object, is set to null again when mouse button is released */
+	private PathwayElement newObject = null;
+	/** minimum drag length for it to be considered a drag and not a click */
+	private static final int MIN_DRAG_LENGTH = 3;
+
+	/**
+	 * Add a new object to the drawing
+	 * {@see VPathway#setNewGraphics(int)}
+	 * @param p	The point where the user clicked on the drawing to add a new graphics
+	 */
+	private void newObject(Point ve)
+	{
+		newObjectDragStart = ve;
+		int mx = (int)mFromV((double)ve.x);
+		int my = (int)mFromV((double)ve.y); 
+		
+		PathwayElement gdata = null;
+		Handle h = null;
+		lastAdded = null; // reset lastAdded class member
+		switch(newGraphics) {
+		case NEWNONE:
+			return;
+		case NEWLINE:
+			gdata = new PathwayElement(ObjectType.LINE);
+			gdata.setMStartX(mx);
+			gdata.setMStartY(my);
+			gdata.setMEndX(mx);
+			gdata.setMEndY(my);	
+			gdata.setColor (stdRGB);
+			gdata.setLineStyle (LineStyle.SOLID);
+			gdata.setLineType (LineType.LINE);
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Line)lastAdded).getEnd().getHandle();
+			isDragging = true;
+			break;
+		case NEWLINEARROW:
+			gdata = new PathwayElement(ObjectType.LINE);
+			gdata.setMStartX(mx);
+			gdata.setMStartY(my);
+			gdata.setMEndX(mx);
+			gdata.setMEndY(my);	
+			gdata.setColor (stdRGB);
+			gdata.setLineStyle (LineStyle.SOLID);
+			gdata.setLineType (LineType.ARROW);
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Line)lastAdded).getEnd().getHandle();
+			isDragging = true;
+			break;
+		case NEWLINEDASHED:
+			gdata = new PathwayElement(ObjectType.LINE);
+			gdata.setMStartX(mx);
+			gdata.setMStartY(my);
+			gdata.setMEndX(mx);
+			gdata.setMEndY(my);	
+			gdata.setColor (stdRGB);
+			gdata.setLineStyle (LineStyle.DASHED);
+			gdata.setLineType (LineType.LINE);
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Line)lastAdded).getEnd().getHandle();
+			isDragging = true;
+			break;
+		case NEWLINEDASHEDARROW:
+			gdata = new PathwayElement(ObjectType.LINE);
+			gdata.setMStartX(mx);
+			gdata.setMStartY(my);
+			gdata.setMEndX(mx);
+			gdata.setMEndY(my);	
+			gdata.setColor (stdRGB);
+			gdata.setLineStyle (LineStyle.DASHED);
+			gdata.setLineType (LineType.ARROW);
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Line)lastAdded).getEnd().getHandle();
+			isDragging = true;
+			break;
+		case NEWLABEL:
+			gdata = new PathwayElement(ObjectType.LABEL);
+			gdata.setMCenterX(mx);
+			gdata.setMCenterY(my);
+			gdata.setMWidth(Label.M_INITIAL_WIDTH);
+			gdata.setMHeight(Label.M_INITIAL_HEIGHT);
+			gdata.setMFontSize (Label.M_INITIAL_FONTSIZE);
+			gdata.setGraphId(data.getUniqueId());
+			gdata.setTextLabel("Label");
+			data.add (gdata); // will cause lastAdded to be set
+			h = null;
+			break;
+		case NEWARC:
+			gdata = new PathwayElement(ObjectType.SHAPE);
+			gdata.setShapeType(ShapeType.ARC);
+			gdata.setMCenterX (mx);
+			gdata.setMCenterY (my);
+			gdata.setMWidth(1);
+			gdata.setMHeight(1);
+			gdata.setColor(stdRGB);
+			gdata.setRotation (0);
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Shape)lastAdded).handleSE;
+			isDragging = true;
+			break;
+		case NEWBRACE:
+			gdata = new PathwayElement(ObjectType.SHAPE);
+			gdata.setShapeType(ShapeType.BRACE);
+			gdata.setMCenterX (mx);
+			gdata.setMCenterY (my);
+			gdata.setMWidth(1);
+			gdata.setMHeight(1);
+			gdata.setOrientation(OrientationType.RIGHT);
+			gdata.setColor(stdRGB);
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Shape)lastAdded).handleSE;
+			isDragging = true;
+			break;
+		case NEWGENEPRODUCT:
+			gdata = new PathwayElement(ObjectType.DATANODE);
+			gdata.setMCenterX(mx);
+			gdata.setMCenterY(my);
+			gdata.setMWidth(1);
+			gdata.setMHeight(1);
+			gdata.setTextLabel("Gene");
+			gdata.setXref("");
+			gdata.setColor(stdRGB);
+			gdata.setGraphId(data.getUniqueId());
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((GeneProduct)lastAdded).handleSE;
+			isDragging = true;
+			break;
+		case NEWRECTANGLE:
+			gdata = new PathwayElement(ObjectType.SHAPE);
+			gdata.setShapeType(ShapeType.RECTANGLE);
+			gdata.setMCenterX (mx);
+			gdata.setMCenterY (my);
+			gdata.setMWidth(1);
+			gdata.setMHeight(1);
+			gdata.setColor(stdRGB);
+			gdata.setRotation (0);
+			gdata.setGraphId(data.getUniqueId());
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Shape)lastAdded).handleSE;
+			isDragging = true;
+			break;
+		case NEWOVAL:
+			gdata = new PathwayElement(ObjectType.SHAPE);
+			gdata.setShapeType(ShapeType.OVAL);
+			gdata.setMCenterX (mx);
+			gdata.setMCenterY (my);
+			gdata.setMWidth(1);
+			gdata.setMHeight(1);
+			gdata.setColor(stdRGB);
+			gdata.setRotation (0);
+			gdata.setGraphId(data.getUniqueId());
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Shape)lastAdded).handleSE;
+			isDragging = true;
+			break;
+		case NEWTBAR:
+			gdata = new PathwayElement(ObjectType.LINE);
+			gdata.setMStartX(mx);
+			gdata.setMStartY(my);
+			gdata.setMEndX(mx);
+			gdata.setMEndY(my);	
+			gdata.setColor (stdRGB);
+			gdata.setLineStyle (LineStyle.SOLID);
+			gdata.setLineType (LineType.TBAR);
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Line)lastAdded).getEnd().getHandle();
+			isDragging = true;
+			break;
+		case NEWRECEPTORROUND:
+			gdata = new PathwayElement(ObjectType.LINE);
+			gdata.setMStartX(mx);
+			gdata.setMStartY(my);
+			gdata.setMEndX(mx);
+			gdata.setMEndY(my);	
+			gdata.setColor (stdRGB);
+			gdata.setLineStyle (LineStyle.SOLID);
+			gdata.setLineType (LineType.RECEPTOR_ROUND);
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Line)lastAdded).getEnd().getHandle();
+			isDragging = true;
+			break;
+		case NEWRECEPTORSQUARE:
+			gdata = new PathwayElement(ObjectType.LINE);
+			gdata.setMStartX(mx);
+			gdata.setMStartY(my);
+			gdata.setMEndX(mx);
+			gdata.setMEndY(my);	
+			gdata.setColor (stdRGB);
+			gdata.setLineStyle (LineStyle.SOLID);
+			gdata.setLineType (LineType.RECEPTOR_SQUARE);
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Line)lastAdded).getEnd().getHandle();
+			isDragging = true;
+			break;
+		case NEWLIGANDROUND:
+			gdata = new PathwayElement(ObjectType.LINE);
+			gdata.setMStartX(mx);
+			gdata.setMStartY(my);
+			gdata.setMEndX(mx);
+			gdata.setMEndY(my);	
+			gdata.setColor (stdRGB);
+			gdata.setLineStyle (LineStyle.SOLID);
+			gdata.setLineType (LineType.LIGAND_ROUND);
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Line)lastAdded).getEnd().getHandle();
+			isDragging = true;
+			break;
+		case NEWLIGANDSQUARE:
+			gdata = new PathwayElement(ObjectType.LINE);
+			gdata.setMStartX(mx);
+			gdata.setMStartY(my);
+			gdata.setMEndX(mx);
+			gdata.setMEndY(my);	
+			gdata.setColor (stdRGB);
+			gdata.setLineStyle (LineStyle.SOLID);
+			gdata.setLineType (LineType.LIGAND_SQUARE);
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Line)lastAdded).getEnd().getHandle();
+			isDragging = true;
+			break;
+		}
+		
+		newObject = gdata;
+		selectObject(lastAdded);
+		pressedObject = h;
+		
+		vPreviousX = ve.x;
+		vPreviousY = ve.y;
+		
+		fireVPathwayEvent(new VPathwayEvent(this, lastAdded, VPathwayEvent.NEW_ELEMENT_ADDED));
+	}
+	
+
+	public static final int DRAW_ORDER_HANDLE = -1;
+	public static final int DRAW_ORDER_GROUP = 0;
+	public static final int DRAW_ORDER_SELECTIONBOX = 1;
+	public static final int DRAW_ORDER_SELECTED = 2;
+	public static final int DRAW_ORDER_GENEPRODUCT = 3;
+	public static final int DRAW_ORDER_LABEL = 4;
+	public static final int DRAW_ORDER_ARC = 5;
+	public static final int DRAW_ORDER_BRACE = 6;
+	public static final int DRAW_ORDER_SHAPE = 7;
+	public static final int DRAW_ORDER_LINE = 8;
+	public static final int DRAW_ORDER_LINESHAPE = 9;
+	public static final int DRAW_ORDER_MAPPINFO = 10;
+	public static final int DRAW_ORDER_DEFAULT = 11;
+	
+	public void mouseEnter(MouseEvent e) {}
+
+	public void mouseExit(MouseEvent e) {}
+	
+	/**
+	 * Responsible for drawing a tooltip displaying expression data when 
+	 * hovering over a geneproduct
+	 */
+	public void mouseHover(MouseEvent e) {
+		Visualization v = VisualizationManager.getCurrent();
+		if(v != null && v.usesToolTip()) {
+			Point2D p = new Point2D.Double(e.getX(), e.getY());
+			
+			VPathwayElement o = getObjectAt(p);
+			if(o != null && o instanceof Graphics) {
+//				Shell tip = v.visualizeToolTip(getShell(), this, (Graphics)o);
+//				if(tip == null) return;
+//				Point mp = toDisplay(e.x + 15, e.y + 15);
+//				tip.setLocation(mp.x, mp.y);
+//	            tip.setVisible(true);
+			}
+		}
+	}
+
+	private void selectGeneProducts() {
+		clearSelection();
+		for(VPathwayElement o : getDrawingObjects()) {
+			if(o instanceof GeneProduct) s.addToSelection(o);
+		}
+	}
+	
+	private void insertPressed() {
+		Set<VPathwayElement> objects = new HashSet<VPathwayElement>();
+		objects.addAll(s.getSelection());
+		for(VPathwayElement o : objects) {
+			if(o instanceof Line) {
+				PathwayElement g = ((Line)o).getGmmlData();
+				PathwayElement[] gNew = g.splitLine();
+							
+				removeDrawingObject(o); //Remove the old line
+				
+				//Clear refs on middle point (which is new)
+				gNew[0].getMEnd().setGraphRef(null);
+				gNew[1].getMStart().setGraphRef(null);
+				
+				gNew[1].setGraphId(data.getUniqueId());
+				data.add(gNew[0]);
+				Line l1 = (Line)lastAdded;
+				data.add(gNew[1]);
+				Line l2 = (Line)lastAdded;				
+				
+				l1.getEnd().link(l2.getStart());
+			}
+		}
+		s.addToSelection(lastAdded);
+	}
+	
+	public void createGroup() {
+		//GroupId is created on first getGroupId call
+		PathwayElement group = new PathwayElement(ObjectType.GROUP);
+		data.add(group);
+		
+		group.setTextLabel("new group");
+		group.setGroupStyle(GroupStyle.NONE);
+		
+		String id = group.getGroupId();
+		
+		//Add the selected pathway elements
+		List<Graphics> selection = getSelectedGraphics();
+		
+		for(Graphics g : selection) {
+			PathwayElement pe = g.getGmmlData(); 
+			String ref = pe.getGroupRef();
+			if(ref == null) {
+				pe.setGroupRef(id);
+			} else if(ref != id) {
+				PathwayElement refGroup = data.getGroupById(ref);
+				refGroup.setGroupRef(id);
+			}
+		}
+	}
+
+	public void keyPressed(KeyEvent e) { 
+		if(e.isKey(KeyEvent.INSERT)) insertPressed();
+		if(e.isKey('d') && e.isKeyDown(KeyEvent.M_CTRL)) //CTRL-D to select all gene-products 
+		{
+			selectGeneProducts();
+			redraw();
+		}
+//		System.out.println(e.getKeyCode());
+//		System.out.println("is g? " + e.isKey('g'));
+//		System.out.println("is CTRL down? " + e.isKeyDown(KeyEvent.CTRL));
+		if(e.isKey('g') && e.isKeyDown(KeyEvent.M_CTRL)) //CTRL-G to select all gene-products
+		{
+			createGroup();
+		}
+	}
+
+	
+	
+	public void keyReleased(KeyEvent e) {		
+		if(e.isKey(KeyEvent.DEL)) {
+			ArrayList<VPathwayElement> toRemove = new ArrayList<VPathwayElement>();
+			for(VPathwayElement o : drawingObjects)
+			{
+				if(!o.isSelected() || o == s || o == infoBox) continue; //Object not selected, skip
+				toRemove.add(o);
+			}
+			removeDrawingObjects(toRemove);
+		}
+	}
+	
+	/**
+	 * Removes the GmmlDrawingObjects in the ArrayList from the drawing
+	 * @param toRemove	The List containing the objects to be removed
+	 */
+	public void removeDrawingObjects(ArrayList<VPathwayElement>toRemove)
+	{
+		for(VPathwayElement o : toRemove)
+		{
+			removeDrawingObject(o);
+			
+		}
+		s.fitToSelection();
+	}
+	
+	public void removeDrawingObject(VPathwayElement toRemove) {
+		toRemove.destroy(); //Object will remove itself from the drawing
+		s.removeFromSelection(toRemove); //Remove from selection
+	}
+
+	Graphics lastAdded = null;
+	
+	public void gmmlObjectModified(PathwayEvent e) {
+		switch (e.getType())
+		{
+			case PathwayEvent.DELETED:
+				// TODO: affected object should be removed
+				addDirtyRect(null); // mark everything dirty
+				break;
+			case PathwayEvent.ADDED:
+				lastAdded = fromGmmlDataObject(e.getAffectedData());
+				addDirtyRect(null); // mark everything dirty
+				break;
+			case PathwayEvent.WINDOW:
+				int width = (int)vFromM(infoBox.getGmmlData().getMBoardWidth());
+				int height = (int)vFromM(infoBox.getGmmlData().getMBoardHeight());
+				if (parent != null)
+				{
+					parent.setVSize(width, height);
+				}
+				break;
+		}
+		redrawDirtyRect();
+	}
+		
+	/**
+	 * Makes a copy of all GmmlDataObjects in current selection,
+	 * and puts them in the global clipboard.
+	 *
+	 */
+	public void copyToClipboard()
+	{
+		//Clipboard clipboard = new Clipboard (this.getDisplay());
+		
+		List<PathwayElement> result = new ArrayList<PathwayElement>();
+		for (VPathwayElement g : drawingObjects)
+		{
+			if (g.isSelected() && g instanceof Graphics
+					&& !(g instanceof SelectionBox))
+			{
+				result.add(((Graphics)g).gdata.copy());
+			}
+		}
+		if (result.size() > 0)
+		{
+			Engine.clipboard = result;
+		}
+		else
+		{
+			Engine.clipboard = null;
+		}
+		
+		//clipboard.dispose();
+	}
+	
+	/**
+	 * Aligns selected objects based on user-selected align type
+	 * @param alignType
+	 */
+	public void alignSelected(char alignType)
+	{
+		List<Graphics> selectedGraphics = getSelectedGraphics();
+		
+		int aveC = 0;
+		int minC = java.lang.Integer.MAX_VALUE;
+		int maxC = 0;
+		
+		if (selectedGraphics.size() > 0){
+			switch (alignType){
+			case AlignActions.CENTERX : 
+				for(Graphics g : selectedGraphics) {
+					int c = g.getVCenterX();
+					aveC = aveC + c;
+				}
+				aveC = aveC/selectedGraphics.size();
+				for(Graphics g : selectedGraphics) {
+					g.vMoveBy(aveC - g.getVCenterX(), 0);
+				}
+				break;
+			case AlignActions.CENTERY : 
+				for(Graphics g : selectedGraphics) {
+					int c = g.getVCenterY();
+					aveC = aveC + c;
+				}
+				aveC = aveC/selectedGraphics.size();
+				for(Graphics g : selectedGraphics) {
+					g.vMoveBy(0, aveC-g.getVCenterY());
+				}
+				break;
+			case AlignActions.LEFT :
+				for(Graphics g : selectedGraphics) {
+					int c = g.getVLeft();
+					if (c < minC){ 
+						minC = c;
+						}
+				}
+				for(Graphics g : selectedGraphics) {	
+					g.vMoveBy(minC - g.getVLeft(),0);
+				}
+				break;
+			case AlignActions.RIGHT : 
+				for(Graphics g : selectedGraphics) {
+					int c = (g.getVLeft()+g.getVWidth());
+					if (c > maxC){
+						maxC = c;
+					}	
+				}
+				for(Graphics g : selectedGraphics) {
+					g.vMoveBy(maxC - (g.getVLeft()+g.getVWidth()),0);
+				}
+				break;
+			case AlignActions.TOP : 
+				for(Graphics g : selectedGraphics) {
+					int c = g.getVTop();
+					if (c < minC){
+						minC = c;
+					}
+				}
+				for(Graphics g : selectedGraphics) {
+					g.vMoveBy(0,minC - g.getVTop());
+				}
+				break;
+			case AlignActions.BOTTOM :
+				for(Graphics g : selectedGraphics) {
+					int c = (g.getVTop()+g.getVHeight());
+					if (c > maxC){
+						maxC = c;
+					}
+				}
+				for(Graphics g : selectedGraphics) {
+					g.getGmmlData().setMCenterY(mFromV(maxC-(g.getVHeight()/2)));
+					g.vMoveBy(0,maxC - (g.getVTop()+g.getVHeight()));
+				}
+				break;
+			}
+			redrawDirtyRect();
+	}
+	}
+	/**
+	 * Scales selected objects either by max width or max height
+	 * @param alignType
+	 */
+	public void scaleSelected (char alignType){
+		
+		List<Graphics> selectedGraphics = getSelectedGraphics();
+		double maxW = 0;
+		double maxH = 0;
+		
+		if (selectedGraphics.size() > 0){
+			switch (alignType){
+			case AlignActions.WIDTH:
+				for(Graphics g : selectedGraphics) {
+					Rectangle2D r = g.getVScaleRectangle();
+					double w = Math.abs(r.getWidth());
+					if (w > maxW){
+						maxW = w;
+					}
+				}
+				for(Graphics g : selectedGraphics) {
+					Rectangle2D r = g.getVScaleRectangle();
+					double oldWidth = r.getWidth();
+					if (oldWidth <0){
+						r.setRect(r.getX(), r.getY(), -(maxW), r.getHeight());
+						g.setVScaleRectangle(r);
+						g.vMoveBy((oldWidth+maxW)/2,0);
+					}
+					else{
+						r.setRect(r.getX(), r.getY(), maxW, r.getHeight());
+						g.setVScaleRectangle(r);
+						g.vMoveBy((oldWidth - maxW)/2,0);
+					}
+				}
+				break;
+			case AlignActions.HEIGHT:
+				for(Graphics g : selectedGraphics) {
+					Rectangle2D r = g.getVScaleRectangle();
+					double h = Math.abs(r.getHeight());
+					if (h > maxH){
+						maxH = h;
+					}
+				}
+				for(Graphics g : selectedGraphics) {
+					Rectangle2D r = g.getVScaleRectangle();
+					double oldHeight = r.getHeight();
+					if (oldHeight < 0){
+						r.setRect(r.getX(), r.getY(), r.getWidth(), -(maxH));
+						g.setVScaleRectangle(r);
+						g.vMoveBy(0,(maxH+oldHeight)/2);
+					}
+					else{
+					r.setRect(r.getX(), r.getY(), r.getWidth(), maxH);
+					g.setVScaleRectangle(r);
+					g.vMoveBy(0,(oldHeight - maxH)/2);
+					}
+				}
+				break;
+			}
+			redrawDirtyRect();
+		}
+	}
+	/**
+	 * TODO: document
+	 * @return
+	 */
+	public List<Graphics> getSelectedGraphics() {
+		List<Graphics> result = new ArrayList<Graphics>();
+		for (VPathwayElement g : drawingObjects)
+		{
+			if (g.isSelected() && g instanceof Graphics
+					&& !(g instanceof SelectionBox))
+			{
+				result.add((Graphics)g);
+			}
+		}
+		return result;
+	}
+	
+	/**
+	 * If global clipboard contains GmmlDataObjects,
+	 * makes another copy of these objects, and pastes them in. 
+	 * The clipboard contents will be moved 10 pixels souteast,
+	 * so they won't exactly overlap with the original.
+	 */
+	public void pasteFromClipboad()
+	{
+		if (Engine.clipboard != null)
+		{
+			clearSelection();
+			Map<String, String> idmap = new HashMap<String, String>();
+			Set<String> newids = new HashSet<String>();
+			
+			/*
+			 * Step 1: generate new unique ids for copied items
+			 */
+			for (PathwayElement o : Engine.clipboard)
+			{
+				String id = o.getGraphId();
+				if (id != null) 
+				{
+					String x;
+					do
+					{
+						/* generate a unique id.
+						 * at the same time, check that it is not 
+						 * equal to one of the unique ids
+						 * that we generated since the start of this
+						 * method
+						 */ 
+						x = data.getUniqueId();
+					} while (newids.contains(x));
+					newids.add(x); // make sure we don't generate this one again
+					
+					idmap.put(id, x);
+				}
+			}
+			/*
+			 * Step 2: do the actual copying 
+			 */
+			for (PathwayElement o : Engine.clipboard)
+			{
+				if (o.getObjectType() == ObjectType.MAPPINFO ||
+					o.getObjectType() == ObjectType.INFOBOX)
+				{
+					// these object types we skip,
+					// because they have to be unique in a pathway
+					continue;
+				}
+				
+				lastAdded = null;
+				o.setMStartX(o.getMStartX() + M_PASTE_OFFSET);
+				o.setMStartY(o.getMStartY() + M_PASTE_OFFSET);
+				o.setMEndX(o.getMEndX() + M_PASTE_OFFSET);
+				o.setMEndY(o.getMEndY() + M_PASTE_OFFSET);
+				o.setMLeft(o.getMLeft() + M_PASTE_OFFSET);
+				o.setMTop(o.getMTop() + M_PASTE_OFFSET);
+				// make another copy to preserve clipboard contents for next paste
+				PathwayElement p = o.copy();
+				
+				// set new unique id
+				if (p.getGraphId() != null)
+				{					
+					p.setGraphId(idmap.get(p.getGraphId()));					
+				}
+				// update graphref
+				String y = p.getStartGraphRef(); 
+				if (y != null)
+				{
+					//TODO: mapping graphrefs to newly created id's 
+					// doesn't work properly yet
+				/*	if (idmap.containsKey(y))
+					{
+						p.setStartGraphRef(idmap.get(y));
+					}
+					else
+					{*/
+						p.setStartGraphRef(null);
+					//}				
+				}
+				y = p.getEndGraphRef(); 
+				if (y != null)
+				{
+				/*	if (idmap.containsKey(y))
+					{
+						p.setEndGraphRef(idmap.get(y));
+					}
+					else
+					{*/
+						p.setEndGraphRef(null);
+				//	}				
+				}
+				
+				data.add (p); // causes lastAdded to be set
+				lastAdded.select();
+				s.addToSelection(lastAdded);
+			}
+		}
+	}
+
+	private List<VPathwayListener> listeners = new ArrayList<VPathwayListener>();
+	private List<VPathwayListener> removeListeners = new ArrayList<VPathwayListener>();
+	
+	public void addVPathwayListener(VPathwayListener l) {
+		listeners.add(l);
+	}
+	
+	public void removeVPathwayListener(VPathwayListener l) {
+		removeListeners.add(l);
+	}
+	
+	private void cleanupListeners() {
+		//Do not remove immediately, to prevent ConcurrentModificationException
+		//when the listener removes itself
+		listeners.removeAll(removeListeners);
+		removeListeners.clear();
+	}
+	
+	protected void fireVPathwayEvent(VPathwayEvent e) {
+		cleanupListeners();
+		for(VPathwayListener l : listeners) {
+			l.vPathwayEvent(e);
+		}
+	}
+	
+	public void visualizationEvent(VisualizationEvent e) {
+		switch(e.type) {
+		case(VisualizationEvent.COLORSET_MODIFIED):
+		case(VisualizationEvent.VISUALIZATION_SELECTED):
+		case(VisualizationEvent.VISUALIZATION_MODIFIED):
+		case(VisualizationEvent.PLUGIN_MODIFIED):
+			//getDisplay().syncExec(new Runnable() {
+			//	public void run() {
+					redraw();
+			//	}
+			//});
+		}
+	}	
+	
+	
+	/** 
+	 * helper method to convert view coordinates to model coordinates 
+	 * */
+	public double mFromV(double v) { return v / zoomFactor; }
+
+	/** 
+	 * helper method to convert view coordinates to model coordinates 
+	 * */
+	public double vFromM(double m) { return m * zoomFactor; }
+	
+} // end of class
Index: trunk/src/g2d/org/pathvisio/view/InfoBox.java
===================================================================
--- trunk/src/g2d/org/pathvisio/view/InfoBox.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/view/InfoBox.java	(revision 957)
@@ -0,0 +1,112 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import java.awt.Font;
+import java.awt.Graphics2D;
+import java.awt.Rectangle;
+import java.awt.Shape;
+import java.awt.font.FontRenderContext;
+import java.awt.font.TextLayout;
+import java.awt.geom.Rectangle2D;
+
+import org.pathvisio.model.PathwayElement;
+
+public class InfoBox extends Graphics {
+	static final int V_SPACING = 5;
+	static final int H_SPACING = 10;
+	
+	//Elements not stored in gpml
+	String fontName			= "Times New Roman";
+	String fontWeight		= "regular";
+	static final double M_INITIAL_FONTSIZE	= 10.0 * 15;
+	
+	int sizeX = 1;
+	int sizeY = 1; //Real size is calculated on first call to draw()
+	
+	public InfoBox (VPathway canvas, PathwayElement o) {
+		super(canvas, o);
+		canvas.setMappInfo(this);	
+	}
+	
+	public int getDrawingOrder() {
+		return VPathway.DRAW_ORDER_MAPPINFO;
+	}
+	
+	//public Point getBoardSize() { return new Point((int)gdata.getMBoardWidth(), (int)gdata.getMBoardHeight()); }
+	
+	int getVFontSize()
+	{
+		return (int)(vFromM(M_INITIAL_FONTSIZE));
+	}
+			
+	protected void vMoveBy(double vdx, double vdy)
+	{
+//		markDirty();
+		gdata.setMTop (gdata.getMTop()  + mFromV(vdy));
+		gdata.setMLeft (gdata.getMLeft() + mFromV(vdx));
+//		markDirty();
+	}
+	
+	public void doDraw(Graphics2D g) 
+	{		
+		Font f = new Font(fontName, Font.PLAIN, getVFontSize());
+		Font fb = new Font(f.getFontName(), Font.BOLD, f.getSize());
+		
+		if(isSelected()) {
+			g.setColor(selectColor);
+		}
+		
+		//Draw Name, Organism, Data-Source, Version, Author, Maintained-by, Email, Availability and last modified
+		String[][] text = new String[][] {
+				{"Name: ", gdata.getMapInfoName()},
+				{"Maintained by: ", gdata.getMaintainer()},
+				{"Email: ", gdata.getEmail()},
+				{"Availability: ", gdata.getCopyright()},
+				{"Last modified: ", gdata.getLastModified()},
+				{"Organism: ", gdata.getOrganism()},
+				{"Data Source: ", gdata.getDataSource()}};
+		int shift = 0;
+		int vLeft = (int)vFromM(gdata.getMLeft());
+		int vTop = (int)vFromM(gdata.getMTop());
+		
+		FontRenderContext frc = g.getFontRenderContext();
+		for(String[] s : text) {
+			if(s[1] == null || s[1].equals("")) continue; //Skip empty labels
+			TextLayout tl0 = new TextLayout(s[0], fb, frc);
+			TextLayout tl1 = new TextLayout(s[1], f, frc);
+			Rectangle2D b0 = tl0.getBounds();
+			Rectangle2D b1 = tl1.getBounds();
+			shift += (int)Math.max(b0.getHeight(), b1.getHeight()) + V_SPACING;
+			g.setFont(fb);
+			tl0.draw(g, vLeft, vTop + shift);
+			g.setFont(f);
+			tl1.draw(g, vLeft + (int)b0.getWidth() + H_SPACING, vTop + shift);
+			
+			sizeX = Math.max(sizeX, (int)b0.getWidth() + (int)b1.getWidth() + H_SPACING);
+		}
+		sizeY = shift;
+	}
+
+	protected Shape getVOutline() {
+		int vLeft = (int)vFromM(gdata.getMLeft());
+		int vTop = (int)vFromM(gdata.getMTop());
+		return new Rectangle(vLeft, vTop, sizeX, sizeY);
+	}
+
+}
+ 
\ No newline at end of file

Property changes on: trunk/src/g2d/org/pathvisio/view/InfoBox.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d/org/pathvisio/view/VPathwayWrapper.java
===================================================================
--- trunk/src/g2d/org/pathvisio/view/VPathwayWrapper.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/view/VPathwayWrapper.java	(revision 957)
@@ -0,0 +1,16 @@
+package org.pathvisio.view;
+
+import java.awt.Dimension;
+import java.awt.Rectangle;
+
+public abstract interface VPathwayWrapper {		
+	public void redraw();
+	public void redraw(Rectangle r);
+	public void setVSize(Dimension size);
+	public void setVSize(int w, int h);
+	public Dimension getVSize();
+	public Rectangle getVBounds();
+	public Dimension getViewportSize();
+	
+	public VPathway createVPathway();
+}
Index: trunk/src/g2d/org/pathvisio/view/VPathwayEvent.java
===================================================================
--- trunk/src/g2d/org/pathvisio/view/VPathwayEvent.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/view/VPathwayEvent.java	(revision 957)
@@ -0,0 +1,34 @@
+package org.pathvisio.view;
+
+import java.util.EventObject;
+
+public class VPathwayEvent extends EventObject {
+	public static final int NEW_ELEMENT_ADDED = 0;
+	public static final int EDIT_MODE_ON = 1;
+	public static final int EDIT_MODE_OFF = 2;
+	
+	int type;
+	VPathwayElement affectedElement;
+	
+	public VPathwayEvent(VPathway source, int type) {
+		super(source);
+		this.type = type;
+	}
+	
+	public VPathwayEvent(VPathway source, VPathwayElement affectedElement, int type) {
+		this(source, type);
+		this.affectedElement = affectedElement;
+	}
+	
+	public VPathwayElement getAffectedElement() {
+		return affectedElement;
+	}
+	
+	public int getType() {
+		return type;
+	}
+	
+	public VPathway getVPathway() {
+		return (VPathway)getSource();
+	}
+}
Index: trunk/src/g2d/org/pathvisio/view/LinAlg.java
===================================================================
--- trunk/src/g2d/org/pathvisio/view/LinAlg.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/view/LinAlg.java	(revision 957)
@@ -0,0 +1,103 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+/**
+ * Helper class for rotation calculations.
+ *
+ */
+public class LinAlg 
+{
+	
+	public static double angle(Point p1, Point p2) 
+	{
+		//Angle:
+		//					p1.p2	
+        //cos(angle) = --------------
+        //          	||p1||*||p2||
+		double cos = dot(p1,p2) / (p1.len() * p2.len());
+		return direction(p1,p2) * Math.acos(cos);
+	}
+		
+	/**
+	 * negative: ccw positive: cw
+	 */
+	public static double direction(Point p1, Point p2) 
+	{
+		return Math.signum(p1.x * p2.y - p1.y * p2.x);
+	}
+	
+	public static double dot(Point v1, Point v2) 
+	{
+		double[] d1 = v1.asArray();
+		double[] d2 = v2.asArray();
+		double sum = 0;
+		for(int i = 0; i < Math.min(d1.length, d2.length); i++) sum += d1[i]*d2[i];
+		return sum;
+	}
+	
+	public static Point project(Point p1, Point p2) 
+	{
+		//Projection of p1 on p2:
+		// p1.p2
+		// ----- . p2
+		// p2.p2
+		double c = dot(p1, p2) / dot(p2, p2);
+		return new Point(p2.x * c, p2.y * c);
+	}
+	
+	public static double distance(Point p1, Point p2) 
+	{
+		Point dp = p2.subtract(p1);
+		return dp.len();
+	}
+	
+	public static Point rotate(Point p, double angle) 
+	{
+		Point pr = new Point(0,0);
+		pr.x = p.x * Math.cos(angle) + p.y * Math.sin(angle);
+		pr.y = -p.x * Math.sin(angle) + p.y * Math.cos(angle);
+		return pr;
+	}
+	
+	public static class Point 
+	{
+		public double x, y;
+		public Point(double x, double y) { this.x = x; this.y = y;	}
+		
+		public int[] asIntArray() { return new int[] { (int)x, (int)y }; }
+		
+		public double[] asArray() { return new double[] { x, y }; }
+		
+		public Point norm() 
+		{
+			double l = len();
+			return new Point(x / l, y / l);
+		}
+		public double len() 
+		{
+			return Math.sqrt(dot(this, this));
+		}
+		
+		public Point add(Point p) { return new Point(x + p.x, y + p.y); }
+		public Point subtract(Point p) { return new Point(x - p.x, y - p.y); }
+		public Point multiply(double d) { return new Point(x *= d, y *= d); }
+				
+		public Point clone() { return new Point(x, y); }
+		public String toString() { return "Point: " + x + ", " + y; }
+	}
+}

Property changes on: trunk/src/g2d/org/pathvisio/view/LinAlg.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d/org/pathvisio/view/VPathwayListener.java
===================================================================
--- trunk/src/g2d/org/pathvisio/view/VPathwayListener.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/view/VPathwayListener.java	(revision 957)
@@ -0,0 +1,5 @@
+package org.pathvisio.view;
+
+public interface VPathwayListener {
+	public void vPathwayEvent(VPathwayEvent e);
+}
Index: trunk/src/g2d/org/pathvisio/view/VPathwayElement.java
===================================================================
--- trunk/src/g2d/org/pathvisio/view/VPathwayElement.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/view/VPathwayElement.java	(revision 957)
@@ -0,0 +1,285 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import java.awt.Graphics2D;
+import java.awt.Rectangle;
+import java.awt.Shape;
+import java.awt.geom.Point2D;
+import java.awt.geom.Rectangle2D;
+
+public abstract class VPathwayElement implements Comparable<VPathwayElement>
+{	
+	protected VPathway canvas;
+	
+	VPathwayElement(VPathway canvas) {
+		this.canvas = canvas;
+		canvas.addObject(this);
+	}
+	
+	private boolean isHighlighted;
+	private Rectangle oldrect = null;
+	
+	private boolean isSelected;
+		
+	public final void draw(Graphics2D g2d) {
+		//Create a copy to ensure that the state of this Graphics2D will be intact
+		//see: http://java.sun.com/docs/books/tutorial/uiswing/painting/concepts2.html
+		
+		Graphics2D g = (Graphics2D)g2d.create();
+				
+		//Perform the drawing
+		doDraw(g);
+		
+		//Free resources from the copied Graphics2D
+		g.dispose();
+	}
+		
+	protected abstract void doDraw(Graphics2D g2d);
+	
+	/** 
+	 * mark both the area currently and previously occupied by this object for redraw 
+	 */
+	protected void markDirty()
+	{
+		if (oldrect != null)
+		{
+			canvas.addDirtyRect(oldrect);
+		}
+		Rectangle newrect = getVBounds();
+		canvas.addDirtyRect(newrect);
+		oldrect = newrect;
+	}
+
+	/**
+	 * Get the drawing this object belongs to
+	 */
+	public VPathway getDrawing() {
+		return canvas;
+	}
+	
+	/**
+	 * Besides resetting isHighlighted, this accomplishes this:
+	 * - marking the area dirty, so the object has a chance to redraw itself in unhighlighted state
+	 */
+	public void unhighlight()
+	{
+		if(isHighlighted)
+		{
+			isHighlighted = false;
+			markDirty();
+		}
+	}
+
+	/**
+	 * Besides setting isHighlighted, this accomplishes this:
+	 * - marking the area dirty, so the object has a chance to redraw itself in highlighted state
+	 */
+	public void highlight()
+	{
+		if(!isHighlighted)
+		{
+			isHighlighted = true;
+			markDirty();
+		}
+	}
+	
+	/**
+	 * Returns true if this object is highlighted, false otherwise
+	 */
+	public boolean isHighlighted()
+	{
+		return isHighlighted;
+	}
+
+	/**
+	 * Determines whether a Graphics object intersects 
+	 * the rectangle specified
+	 * @param r - the rectangle to check
+	 * @return True if the object intersects the rectangle, false otherwise
+	 */
+	protected boolean vIntersects(Rectangle2D r)
+	{
+		return getVOutline().intersects(r);
+	}
+	
+	/**
+	 * Determines wheter a Graphics object contains
+	 * the point specified
+	 * @param point - the point to check
+	 * @return True if the object contains the point, false otherwise
+	 */
+	protected boolean vContains(Point2D point)
+	{
+		return getVOutline().contains(point);
+	}	
+
+
+	public boolean isSelected()
+	{
+		return isSelected;
+	}
+	
+	/**
+	 * Besides resetting isSelected, this accomplishes this:
+	 * - marking the area dirty, so the object has a chance to redraw itself in unselected state
+	 */
+	public void deselect()
+	{
+		if (isSelected)
+		{
+			isSelected = false;
+			markDirty();			
+		}
+	}
+
+	/**
+	 * Besides setting isSelected, this accomplishes this:
+	 * - marking the area dirty, so the object has a chance to redraw itself in selected state
+	 */
+	public void select()
+	{
+		if (!isSelected)
+		{
+			isSelected = true;
+			markDirty();			
+		}
+	}
+
+	/**
+	 * Transforms this object to fit to the coordinates
+	 * of the given handle
+	 * @param h	The Handle to adjust to
+	 */
+	protected void adjustToHandle(Handle h) {}
+
+	/**
+	 * Get all the handles belonging to this object
+	 * @return an array of GmmlHandles, an empty array if the object
+	 * has no handles
+	 */
+	protected Handle[] getHandles() { return new Handle[] {}; }
+	
+	/**
+	 * Moves this object by specified increments
+	 * @param dx - the value of x-increment
+	 * @param dy - the value of y-increment
+	 */
+	// TODO: should really be mMoveBy, using model coords,
+	// because implementations do a lot of conversions anyway
+	// perhaps could even be partially implemented in PathwayElement 
+	protected void vMoveBy(double dx, double dy) { }
+	
+	/**
+	 * Get the rectangular boundary of this object
+	 */
+	protected final Rectangle getVBounds()
+	{
+		return getVOutline().getBounds();
+	}
+	
+	/**
+	 * Get the outline of this element. The outline is used to check 
+	 * whether a point is contained in this element or not
+	 * @return the outline of this element
+	 */
+	abstract protected Shape getVOutline();
+
+	/**
+	 * Scales the object to the given rectangle
+	 * @param r
+	 */
+	protected void setVScaleRectangle(Rectangle2D r) { }
+	
+	/**
+	 * Gets the rectangle used to scale the object
+	 */
+	protected Rectangle2D getVScaleRectangle() { return new Rectangle2D.Double(); }
+
+	public int getDrawingOrder() {
+		return VPathway.DRAW_ORDER_DEFAULT;
+	}
+	
+	/**
+	 * Orders GmmlDrawingObjects by their drawingOrder.
+	 * The comparison is consistent with "equals", i.e. it doesn't return 0 if
+	 * the objects are different, even if their drawing order is the same.
+	 * 
+	 * @param d
+	 * @see #getDrawingOrder()
+	 */
+	public int compareTo(VPathwayElement d)
+	{
+		// same object? easy...
+		if (d == this)
+			return 0;
+		
+		int az, bz;
+		az = getDrawingOrder();
+		bz = d.getDrawingOrder();
+		
+		if(isSelected() && d.isSelected()) {
+			; //objects are both selected, keep original sort order
+		}
+		else if(isSelected() || isHighlighted())
+		{
+			az = VPathway.DRAW_ORDER_SELECTED;
+		}
+		else if(d.isSelected() || d.isHighlighted())
+		{
+			bz = VPathway.DRAW_ORDER_SELECTED;
+		}
+		
+		// note, if the drawing order is equal, that doesn't mean the objects are equal
+		// the construct with hashcodes give objects a defined sort order, even if their
+		// drawing orders are equal.		
+		if (az == bz)
+		{
+			az = hashCode();
+			bz = d.hashCode();		
+		}
+		// there is still a remote possibility that although the objects are not the same,
+		// the hashcode is the same. Even still, we shouldn't return 0.
+		if (az != bz) 
+			return bz - az; 
+		else
+			return -1;
+	}
+	
+	/** 
+	 * helper method to convert view coordinates to model coordinates 
+	 * */
+	protected double mFromV(double v) { return canvas.mFromV(v); }
+
+	/** 
+	 * helper method to convert view coordinates to model coordinates 
+	 * */
+	protected double vFromM(double m) { return canvas.vFromM(m); } 
+	
+	protected void destroyHandles() {
+		for(Handle h : getHandles()) {
+			h.destroy();
+		}
+	}
+	
+	protected void destroy() { 
+		//Remove from canvas
+		canvas.getDrawingObjects().remove(this);
+		destroyHandles();
+	}
+
+}

Property changes on: trunk/src/g2d/org/pathvisio/view/VPathwayElement.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d/org/pathvisio/view/Label.java
===================================================================
--- trunk/src/g2d/org/pathvisio/view/Label.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/view/Label.java	(revision 957)
@@ -0,0 +1,217 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import java.awt.Dimension;
+import java.awt.Font;
+import java.awt.Graphics2D;
+import java.awt.Rectangle;
+import java.awt.Shape;
+import java.awt.font.TextAttribute;
+import java.awt.geom.Rectangle2D;
+import java.text.AttributedString;
+
+import org.pathvisio.model.PathwayElement;
+
+public class Label extends GraphicsShape
+{
+	private static final long serialVersionUID = 1L;
+	
+	public static final int M_INITIAL_FONTSIZE = 10 * 15;
+	public static final int M_INITIAL_WIDTH = 80 * 15;
+	public static final int M_INITIAL_HEIGHT = 20 * 15;
+		
+	double getFontSize()
+	{
+		return gdata.getMFontSize() * canvas.getZoomFactor();
+	}
+	
+	void setFontSize(double v)
+	{
+		gdata.setMFontSize(v / canvas.getZoomFactor());
+	}
+				
+	/**
+	 * Constructor for this class
+	 * @param canvas - the VPathway this label will be part of
+	 */
+	public Label(VPathway canvas, PathwayElement o)
+	{
+		super(canvas, o);
+		setHandleLocation();
+	}
+	
+	public int getDrawingOrder() {
+		return VPathway.DRAW_ORDER_LABEL;
+	}
+	
+	public String getLabelText() {
+		return gdata.getTextLabel();
+	}
+	
+	String prevText = "";
+//	public void adjustWidthToText() {
+//		if(gdata.getTextLabel().equals(prevText)) return;
+//		
+//		prevText = getLabelText();
+//		
+//		Point mts = mComputeTextSize();
+//		
+//		//Keep center location
+//		double mWidth = mts.x;
+//		double mHeight = mts.y;
+//		
+//		listen = false; //Disable listener
+//		gdata.setMLeft(gdata.getMLeft() - (mWidth - gdata.getMWidth())/2);
+//		gdata.setMTop(gdata.getMTop() - (mHeight - gdata.getMHeight())/2);
+//		gdata.setMWidth(mWidth);
+//		gdata.setMHeight(mHeight);
+//		listen = true; //Enable listener
+//		
+//		setHandleLocation();
+//	}
+	
+//	private Text t;
+//	public void createTextControl()
+//	{
+//		Color background = canvas.getShell().getDisplay()
+//		.getSystemColor(SWT.COLOR_INFO_BACKGROUND);
+//		
+//		Composite textComposite = new Composite(canvas, SWT.NONE);
+//		textComposite.setLayout(new GridLayout());
+//		textComposite.setLocation(getVCenterX(), getVCenterY() - 10);
+//		textComposite.setBackground(background);
+//		
+//		org.eclipse.swt.widgets.Label label = new org.eclipse.swt.widgets.Label(textComposite, SWT.CENTER);
+//		label.setText("Specify label:");
+//		label.setBackground(background);
+//		t = new Text(textComposite, SWT.SINGLE | SWT.BORDER);
+//		t.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+//		t.addSelectionListener(new SelectionAdapter() {
+//			public void widgetDefaultSelected(SelectionEvent e) {
+//				disposeTextControl();
+//			}
+//		});
+//				
+//		t.setFocus();
+//		
+//		Button b = new Button(textComposite, SWT.PUSH);
+//		b.setText("OK");
+//		b.addSelectionListener(new SelectionAdapter() {
+//			public void widgetSelected(SelectionEvent e) {
+//				disposeTextControl();
+//			}
+//		});
+//		
+//		textComposite.pack();
+//	}
+	
+	Dimension computeTextSize(Graphics2D g) {
+		Rectangle2D tb = null;
+		if(g != null) {
+			 tb = g.getFontMetrics().getStringBounds(getVAttributedString().getIterator(), 0, gdata.getTextLabel().length(), g);
+		} else { //No graphics context, we can only guess...
+			tb = new Rectangle2D.Double(0, 0, getVWidthDouble(), getVHeightDouble()); 
+		}
+		return new Dimension((int)tb.getWidth(), (int)tb.getHeight());
+	}
+	
+//	protected void disposeTextControl()
+//	{
+//		gdata.setTextLabel(t.getText());
+//		Composite c = t.getParent();
+//		c.setVisible(false);
+//		c.dispose();
+//	}
+		
+	double getVFontSize()
+	{
+		return vFromM(gdata.getMFontSize());
+	}
+	
+	Font getVFont() {
+		String name = gdata.getFontName();
+		int style = getVFontStyle();
+		int size = (int)getVFontSize();
+		return new Font(name, style, size);
+	}
+	
+	AttributedString getVAttributedString() {
+		AttributedString ats = new AttributedString(gdata.getTextLabel());
+		if(gdata.isStrikethru()) {
+			ats.addAttribute(TextAttribute.STRIKETHROUGH, TextAttribute.STRIKETHROUGH_ON);
+		}
+		if(gdata.isUnderline()) {
+			ats.addAttribute(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON);
+		}
+		
+		ats.addAttribute(TextAttribute.FONT, getVFont());
+		return ats;
+	}
+	
+	Graphics2D g2d = null; //last Graphics2D for determining text size
+	public void doDraw(Graphics2D g)
+	{		
+		if(g2d != null) g2d.dispose();
+		g2d = (Graphics2D)g.create();
+		
+		if(isSelected()) {
+			g.setColor(selectColor);
+		} else {
+			g.setColor(gdata.getColor());
+		}
+						
+		Font f = getVFont();
+		g.setFont(f);
+		
+		Rectangle area = getVOutline().getBounds();
+		
+		String label = gdata.getTextLabel();
+		AttributedString ats = getVAttributedString();
+		
+		Rectangle2D tb = g.getFontMetrics().getStringBounds(ats.getIterator(), 0, label.length(), g);
+		g.drawString(ats.getIterator(), area.x + (int)(area.width / 2) - (int)(tb.getWidth() / 2), 
+					area.y + (int)(area.height / 2) + (int)(tb.getHeight() / 2));		
+	}
+		
+//	public void gmmlObjectModified(PathwayEvent e) {
+//		if(listen) {
+//			super.gmmlObjectModified(e);
+//			adjustWidthToText();
+//		}
+//	}
+	
+	/**
+	 * Outline of a label is determined by
+	 * - position of the handles
+	 * - size of the text
+	 * Because the text can sometimes be larger than the handles
+	 */
+	protected Shape getVOutline()
+	{
+		Rectangle bounds = super.getVOutline().getBounds();
+		Dimension mq = computeTextSize(g2d);
+		double vqx = mq.getWidth();
+		double vqy = mq.getHeight();
+		
+		LinAlg.Point c = getVCenter();
+		bounds.add(new Rectangle2D.Double(c.x - vqx / 2, c.y - vqy / 2, vqx, vqy));
+
+		return bounds;
+	}
+	
+}

Property changes on: trunk/src/g2d/org/pathvisio/view/Label.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d/org/pathvisio/view/GeneProduct.java
===================================================================
--- trunk/src/g2d/org/pathvisio/view/GeneProduct.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/view/GeneProduct.java	(revision 957)
@@ -0,0 +1,123 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import java.awt.BasicStroke;
+import java.awt.Color;
+import java.awt.Font;
+import java.awt.Graphics2D;
+import java.awt.Rectangle;
+import java.awt.font.TextLayout;
+import java.awt.geom.Rectangle2D;
+
+import org.pathvisio.data.DataSources;
+import org.pathvisio.model.PathwayElement;
+
+/**
+ * This class implements a geneproduct and 
+ * provides methods to resize and draw it.
+ */
+public class GeneProduct extends GraphicsShape
+{
+	private static final long serialVersionUID = 1L;
+	public static final Color INITIAL_FILL_COLOR = Color.WHITE;
+	
+	//note: not the same as color!
+	Color fillColor = INITIAL_FILL_COLOR;
+		
+	public GeneProduct (VPathway canvas, PathwayElement o) {
+		super(canvas, o);		
+		setHandleLocation();
+	}
+		
+	public int getDrawingOrder() {
+		return VPathway.DRAW_ORDER_GENEPRODUCT;
+	}
+	
+	/**
+	 * @deprecated get this info from PathwayElement directly
+	 */
+	public String getID() 
+	{
+		//Looks like the wrong way around, but in gpml the ID is attribute 'Name'
+		//NOTE: maybe change this in gpml?
+		return gdata.getGeneID();
+	}
+		
+	/**
+	 * Looks up the systemcode for this gene in Pathway.sysName2Code
+	 * @return	The system code or an empty string if the system is not found
+	 * 
+	 * @deprecated use PathwayElement.getSystemCode()
+	 */
+	public String getSystemCode()
+	{
+		String systemCode = "";
+		if(DataSources.sysName2Code.containsKey(gdata.getDataSource())) 
+			systemCode = DataSources.sysName2Code.get(gdata.getDataSource());
+		return systemCode;
+	}
+			
+	/**
+	 * Calculate the font size adjusted to the canvas zoom factor.
+	 */
+	private int getVFontSize()
+	{
+		return (int)(vFromM (gdata.getMFontSize()));
+	}
+
+	public void doDraw(Graphics2D g)
+	{
+		//Color
+		if(isSelected()) {
+			g.setColor(selectColor);
+		} else {
+			g.setColor(gdata.getColor());
+		}
+		
+		//Gene box
+		g.setStroke(new BasicStroke());
+		
+		Rectangle area = new Rectangle(
+				getVLeft(), getVTop(), getVWidth(), getVHeight());
+		
+		g.draw(area);
+		
+		//Label
+		//Don't draw label outside gene box
+		g.setClip ( area.x - 1, area.y - 1, area.width + 1, area.height + 1);
+	
+		g.setFont(new Font(gdata.getFontName(), getVFontStyle(), getVFontSize()));
+		
+		String label = gdata.getTextLabel();
+		TextLayout tl = new TextLayout(label, g.getFont(), g.getFontRenderContext());
+		Rectangle2D tb = tl.getBounds();
+		tl.draw(g, 	area.x + (int)(area.width / 2) - (int)(tb.getWidth() / 2), 
+					area.y + (int)(area.height / 2) + (int)(tb.getHeight() / 2));
+		
+		drawHighlight(g);
+	}
+	
+	public void drawHighlight(Graphics2D g)
+	{
+		if(isHighlighted()) {
+			int os = 1;
+			g.setColor(highlightColor);
+			g.drawRect(getVLeft() - os, getVTop() - os, getVWidth() + 2*os, getVHeight() + 2*os);
+		}
+	}
+}

Property changes on: trunk/src/g2d/org/pathvisio/view/GeneProduct.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d/org/pathvisio/view/VPoint.java
===================================================================
--- trunk/src/g2d/org/pathvisio/view/VPoint.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/view/VPoint.java	(revision 957)
@@ -0,0 +1,142 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import java.awt.Graphics2D;
+import java.awt.Shape;
+import java.util.HashSet;
+import java.util.Set;
+
+import org.pathvisio.model.PathwayElement.MPoint;
+
+public class VPoint extends VPathwayElement {
+	Handle handle;
+	Set<Line> lines;
+	Set<MPoint> mPoints;
+	
+	VPoint(VPathway canvas) {
+		super(canvas);
+		mPoints = new HashSet<MPoint>();
+		lines = new HashSet<Line>();
+		handle = new Handle(Handle.DIRECTION_FREE, this, canvas);
+	}
+	
+	public int getDrawingOrder() {
+		return VPathway.DRAW_ORDER_LINE;
+	}
+	
+	protected void addMPoint(MPoint p) {
+		mPoints.add(p);
+	}
+	
+	protected void removeMPoint(MPoint p) {
+		mPoints.remove(p);
+	}
+	
+	protected void addLine(Line l) {
+		lines.add(l);
+	}
+	
+	protected void removeLine(Line l) {
+		lines.remove(l);
+		//Remove this VPoint when it links to no lines no more
+		if(lines.size() == 0) {
+			destroy();
+		}
+	}
+	
+	protected Set<Line> getLines() { return lines; }
+	
+	protected void link(Graphics g) {
+		if(lines.contains(g)) return; //Prevent linking to self
+		String id = g.getGmmlData().getGraphId();
+		if(id == null) id = g.getGmmlData().setGeneratedGraphId();
+		for(MPoint p : mPoints) p.setGraphRef(id);
+	}
+	
+	protected void link(VPoint p) {
+		if(p == this) return; //Already linked
+		for(MPoint mp : p.mPoints) {
+			mPoints.add(mp);
+		}
+		for(Line l : p.lines) {
+			l.swapPoint(p, this);
+			addLine(l);
+		}
+		p.lines.clear();
+		p.destroy();
+	}
+	
+	protected double getVX() { return vFromM(getMPoint().getX()); }
+	protected double getVY() { return vFromM(getMPoint().getY()); }
+	
+	protected void setVLocation(double vx, double vy) {
+		for(MPoint p : mPoints) {
+			p.setX(mFromV(vx));
+			p.setY(mFromV(vy));
+		}
+	}
+	
+	protected void vMoveBy(double dx, double dy) {
+		for(MPoint p : mPoints) {
+			p.moveBy(mFromV(dx), mFromV(dy));
+		}
+	}
+	
+	protected void setHandleLocation() {
+		MPoint mp = getMPoint();
+		handle.setMLocation(mp.getX(), mp.getY());
+	}
+	
+	private MPoint getMPoint() {
+		for(MPoint p : mPoints) return p;
+		return null;
+	}
+	
+	protected void adjustToHandle(Handle h) {
+		double mcx = h.mCenterx;
+		double mcy = h.mCentery;
+		for(MPoint p : mPoints) {
+			p.setX(mcx);
+			p.setY(mcy);
+		}
+	}
+	
+	protected Handle getHandle() {
+		return handle;
+	}
+	
+	protected Handle[] getHandles() {
+		return new Handle[] { handle };
+	}
+	
+	protected void doDraw(Graphics2D g2d) {
+		// TODO Auto-generated method stub
+	}
+
+	protected Shape getVOutline() {
+		return handle.getVOutline();
+	}
+
+	protected void destroy() {
+		//Check if we can legally destroy this point
+		if(lines.size() > 0) 
+			throw new RuntimeException("VPoint cannot be destroyed: still linked to " + lines);
+
+		super.destroy();
+	}
+}
Index: trunk/src/g2d/org/pathvisio/view/GraphicsShape.java
===================================================================
--- trunk/src/g2d/org/pathvisio/view/GraphicsShape.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/view/GraphicsShape.java	(revision 957)
@@ -0,0 +1,482 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import java.awt.Polygon;
+import java.awt.Shape;
+import java.awt.geom.Rectangle2D;
+import java.util.HashSet;
+import java.util.Set;
+
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.PathwayEvent;
+import org.pathvisio.model.GraphLink.GraphRefContainer;
+import org.pathvisio.model.PathwayElement.MPoint;
+import org.pathvisio.view.LinAlg.Point;
+
+/**
+ * This is an {@link Graphics} class representing shapelike forms,
+ * and provides implementation for containing 8 handles placed in a 
+ * (rotated) rectangle around the shape and a rotation handle
+ */
+public abstract class GraphicsShape extends Graphics {
+
+	private static final double M_ROTATION_HANDLE_POSITION = 20.0 * 15;
+
+	//Side handles
+	Handle handleN;
+	Handle handleE;
+	Handle handleS;
+	Handle handleW;
+	//Corner handles
+	Handle handleNE;
+	Handle handleSE;
+	Handle handleSW;
+	Handle handleNW;
+	//Rotation handle
+	Handle handleR;
+		
+	final Handle[][] handleMatrix; //Used to get opposite handles
+	
+	public GraphicsShape(VPathway canvas, PathwayElement o) {
+		super(canvas, o);
+		
+		handleN	= new Handle(Handle.DIRECTION_Y, this, canvas);
+		handleE	= new Handle(Handle.DIRECTION_X, this, canvas);
+		handleS	= new Handle(Handle.DIRECTION_Y, this, canvas);
+		handleW	= new Handle(Handle.DIRECTION_X, this, canvas);
+				
+		handleNE = new Handle(Handle.DIRECTION_FREE, this, canvas);
+		handleSE = new Handle(Handle.DIRECTION_FREE, this, canvas);
+		handleSW = new Handle(Handle.DIRECTION_FREE, this, canvas);
+		handleNW = new Handle(Handle.DIRECTION_FREE, this, canvas);
+		
+		handleR = new Handle(Handle.DIRECTION_ROT, this, canvas);
+		
+		handleMatrix = new Handle[][] {
+				{ handleNW, 	handleNE },
+				{ handleSW, 	handleSE }};
+	}
+	
+	
+	/**
+	 * Adjust model to changes in the shape, 
+	 * and at the same time calculates the new position 
+	 * in gpml coordinates (so without zoom factor)
+	 */
+	private void setVShape(double vleft, double vtop, double vwidth, double vheight) 
+	{
+//		gdata.dontFireEvents(3);
+		gdata.setMWidth(mFromV(vwidth));
+		gdata.setMHeight(mFromV(vheight));
+		gdata.setMLeft(mFromV(vleft));
+		gdata.setMTop(mFromV(vtop));
+	}
+	
+	protected void vMoveBy(double vdx, double vdy)
+	{
+		gdata.setMLeft(gdata.getMLeft()  + mFromV(vdx));
+		gdata.setMTop(gdata.getMTop() + mFromV(vdy));
+		//Move graphRefs
+		//GraphLink.moveRefsBy(gdata, mFromV(vdx), mFromV(vdy));
+		Set<VPoint> toMove = new HashSet<VPoint>();
+		for(GraphRefContainer ref : gdata.getReferences()) {
+			if(ref instanceof MPoint) {
+				toMove.add(canvas.getPoint((MPoint)ref));
+			}
+		}
+		for(VPoint p : toMove) p.vMoveBy(vdx, vdy);
+	}
+
+	public void setVScaleRectangle(Rectangle2D r) {
+		setVShape(r.getX(), r.getY(), r.getWidth(), r.getHeight());
+	}
+	
+	protected Rectangle2D getVScaleRectangle() {
+		return new Rectangle2D.Double(getVLeftDouble(), getVTopDouble(), getVWidthDouble(), getVHeightDouble());
+	}
+	
+	public Handle[] getHandles()
+	{
+		if( this instanceof SelectionBox) {
+			// Only corner handles
+			return new Handle[] {
+					handleNE, handleSE,
+					handleSW, handleNW
+			};
+		}
+		if(	this instanceof GeneProduct || 
+			this instanceof Label) {
+			// No rotation handle for these objects
+			return new Handle[] {
+					handleN, handleNE, handleE, handleSE,
+					handleS, handleSW, handleW,	handleNW,
+			};
+		}
+		return new Handle[] {
+				handleN, handleNE, handleE, handleSE,
+				handleS, handleSW, handleW,	handleNW,
+				handleR
+		};
+	}
+	
+	/**
+	 * Translate the given point to internal coordinate system
+	 * (origin in center and axis direction rotated with this objects rotation
+	 * @param MPoint p
+	 */
+	private Point mToInternal(Point p) {
+		Point pt = mRelativeToCenter(p);
+		Point pr = LinAlg.rotate(pt, gdata.getRotation());
+		return pr;
+	}
+
+	/**
+	 * Translate the given point to external coordinate system (of the
+	 * drawing canvas)
+	 * @param MPoint p
+	 */
+	private Point mToExternal(Point p) {
+		Point pr = LinAlg.rotate(p, -gdata.getRotation());
+		Point pt = mRelativeToCanvas(pr);
+		return pt;
+	}
+
+	/**
+	 * Translate the given coordinates to external coordinate system (of the
+	 * drawing canvas)
+	 * @param x
+	 * @param y
+	 */
+	private Point mToExternal(double x, double y) {
+		return mToExternal(new Point(x, y));
+	}
+
+	/**
+	 * Get the coordinates of the given point relative
+	 * to this object's center
+	 * @param p
+	 */
+	private Point mRelativeToCenter(Point p) {
+		return p.subtract(getMCenter());
+	}
+
+	/**
+	 * Get the coordinates of the given point relative
+	 * to the canvas' origin
+	 * @param p
+	 */
+	private Point vRelativeToCanvas(Point p) {
+		return p.add(getVCenter());
+	}
+
+	private Point mRelativeToCanvas(Point p) {
+		return p.add(getMCenter());
+	}
+
+	/**
+	 * Get the center point of this object
+	 */
+	public Point getVCenter() {
+		return new Point(getVCenterX(), getVCenterY());
+	}
+
+	/**
+	 * Get the center point of this object
+	 */
+	public Point getMCenter() {
+		return new Point(gdata.getMCenterX(), gdata.getMCenterY());
+	}
+
+	/**
+	 * Set the center point of this object
+	 * @param cn
+	 */
+	public void setMCenter(Point mcn) {
+//		gdata.dontFireEvents(1);
+		gdata.setMCenterX(mcn.x);
+		gdata.setMCenterY(mcn.y);
+	}
+
+	public void setVCenter(Point vcn) {
+//		gdata.dontFireEvents(1);
+		gdata.setMCenterX(mFromV(vcn.x));
+		gdata.setMCenterY(mFromV(vcn.y));
+	}
+
+	/**
+	 * Calculate a new center point given the new width and height, in a
+	 * way that the center moves over the rotated axis of this object
+	 * @param mWidthNew
+	 * @param mHeightNew
+	 */
+	public Point mCalcNewCenter(double mWidthNew, double mHeightNew) {
+		Point mcn = new Point((mWidthNew - gdata.getMWidth())/2, (mHeightNew - gdata.getMHeight())/2);
+		Point mcr = LinAlg.rotate(mcn, -gdata.getRotation());
+		return mRelativeToCanvas(mcr);
+	}
+
+	public Point vCalcNewCenter(double vWidthNew, double vHeightNew) {
+		Point vcn = new Point((vWidthNew - getVWidth())/2, (vHeightNew - getVHeight())/2);
+		Point vcr = LinAlg.rotate(vcn, -gdata.getRotation());
+		return vRelativeToCanvas(vcr);
+	}
+
+	/**
+	 * Set the rotation of this object
+	 * @param angle angle of rotation in radians
+	 */
+	public void setRotation(double angle) {
+		if(angle < 0) gdata.setRotation(angle + Math.PI*2);
+		else if(angle > Math.PI*2) gdata.setRotation (angle - Math.PI*2);
+		else gdata.setRotation(angle);
+	}
+	
+//	/**
+//	 * Rotates the {@link GC} around the objects center
+//	 * @param gc	the {@link GC} to rotate
+//	 * @param tr	a {@link Transform} that can be used for rotation
+//	 */
+//	protected void rotateGC(GC gc, Transform tr) {		
+//		SwtUtils.rotateGC(gc, tr, (float)Math.toDegrees(gdata.getRotation()), 
+//				getVCenterX(), getVCenterY());
+//	}
+	
+	public void adjustToHandle(Handle h) {
+		//Rotation
+		if 	(h == handleR) {
+			Point def = mRelativeToCenter(getMHandleLocation(h));
+			Point cur = mRelativeToCenter(new Point(h.mCenterx, h.mCentery));
+			
+			setRotation(gdata.getRotation() + LinAlg.angle(def, cur));
+			
+			return;
+		}
+					
+		// Transformation
+		Point mih = mToInternal(new Point(h.mCenterx, h.mCentery));
+		
+		double mdx = 0;
+		double mdy = 0;
+		double mdw = 0;
+		double mdh = 0;
+			
+		if	(h == handleN || h == handleNE || h == handleNW) {
+			mdy = -(mih.y + gdata.getMHeight()/2);
+			mdh = -mdy;
+		}
+		if	(h == handleS || h == handleSE || h == handleSW ) {
+			mdy = mih.y - gdata.getMHeight()/2;
+			mdh = mdy;
+		}
+		if	(h == handleE || h == handleNE || h == handleSE) {
+			mdx = mih.x - gdata.getMWidth()/2;
+			mdw = mdx;
+		}
+		if	(h == handleW || h == handleNW || h== handleSW) {
+			mdx = -(mih.x + gdata.getMWidth()/2);
+			mdw = -mdx;
+		};
+		
+		Point mnc = mCalcNewCenter(gdata.getMWidth() + mdw, gdata.getMHeight() + mdh);
+//		gdata.dontFireEvents(1);
+		gdata.setMHeight(gdata.getMHeight() + mdy);
+		gdata.setMWidth(gdata.getMWidth() + mdx);
+		setMCenter(mnc);		
+	
+		//In case object had zero width, switch handles
+		if(gdata.getMWidth() < 0) {
+			negativeWidth(h);
+		}
+		if(gdata.getMHeight() < 0) {
+			negativeHeight(h);
+		}
+	}
+	
+	/**
+	 * This method implements actions performed when the width of
+	 * the object becomes negative after adjusting to a handle
+	 * @param h	The handle this object adjusted to
+	 */
+	public void negativeWidth(Handle h) {
+		if(h.getDirection() == Handle.DIRECTION_FREE)  {
+			h = getOppositeHandle(h, Handle.DIRECTION_X);
+		} else {
+			h = getOppositeHandle(h, Handle.DIRECTION_XY);
+		}
+		double mw = -gdata.getMWidth();
+		double msx = gdata.getMLeft() - mw;
+//		gdata.dontFireEvents(1);
+		gdata.setMWidth (mw);
+		gdata.setMLeft(msx);
+		canvas.setPressedObject(h);
+	}
+	
+	/**
+	 * This method implements actions performed when the height of
+	 * the object becomes negative after adjusting to a handle
+	 * @param h	The handle this object adjusted to
+	 */
+	public void negativeHeight(Handle h) {
+		if(h.getDirection() == Handle.DIRECTION_FREE)  {
+			h = getOppositeHandle(h, Handle.DIRECTION_Y);
+		} else {
+			h = getOppositeHandle(h, Handle.DIRECTION_XY);
+		}
+		double ht = -gdata.getMHeight();
+		double sy = gdata.getMTop() - ht;
+//		gdata.dontFireEvents(1);
+		gdata.setMHeight(ht);
+		gdata.setMTop(sy);
+		canvas.setPressedObject(h);
+	}
+	
+	/**
+	 * Sets the handles at the correct location;
+	 * @param ignore the position of this handle will not be adjusted
+	 */
+	private void setHandleLocation(Handle ignore)
+	{
+		Point p;
+		p = getMHandleLocation(handleN);
+		if(ignore != handleN) handleN.setMLocation(p.x, p.y);
+		p = getMHandleLocation(handleE);
+		if(ignore != handleE) handleE.setMLocation(p.x, p.y);
+		p = getMHandleLocation(handleS);
+		if(ignore != handleS) handleS.setMLocation(p.x, p.y);
+		p = getMHandleLocation(handleW);
+		if(ignore != handleW) handleW.setMLocation(p.x, p.y);
+		
+		p = getMHandleLocation(handleNE);
+		if(ignore != handleNE) handleNE.setMLocation(p.x, p.y);
+		p = getMHandleLocation(handleSE);
+		if(ignore != handleSE) handleSE.setMLocation(p.x, p.y);
+		p = getMHandleLocation(handleSW);
+		if(ignore != handleSW) handleSW.setMLocation(p.x, p.y);
+		p = getMHandleLocation(handleNW);
+		if(ignore != handleNW) handleNW.setMLocation(p.x, p.y);
+
+		p = getMHandleLocation(handleR);
+		if(ignore != handleR) handleR.setMLocation(p.x, p.y);
+		
+		for(Handle h : getHandles()) h.rotation = gdata.getRotation();
+	}
+	
+	/**
+	 * Sets the handles at the correct location
+	 */
+	public void setHandleLocation()
+	{
+		setHandleLocation(null);
+	}
+	
+	/**
+	 * Get the default location of the given handle 
+	 * (in coordinates relative to the canvas)
+	 * @param h
+	 */
+	protected Point getVHandleLocation(Handle h) 
+	{
+		Point mp = getMHandleLocation (h);
+		if (mp != null)			
+			return new Point (vFromM(mp.x), vFromM(mp.y));
+		else return null;
+	}
+
+	protected Point getMHandleLocation(Handle h) {
+		if(h == handleN) return mToExternal(0, -gdata.getMHeight()/2);
+		if(h == handleE) return mToExternal(gdata.getMWidth()/2, 0);
+		if(h == handleS) return mToExternal(0,  gdata.getMHeight()/2);
+		if(h == handleW) return mToExternal(-gdata.getMWidth()/2, 0);
+		
+		if(h == handleNE) return mToExternal(gdata.getMWidth()/2, -gdata.getMHeight()/2);
+		if(h == handleSE) return mToExternal(gdata.getMWidth()/2, gdata.getMHeight()/2);
+		if(h == handleSW) return mToExternal(-gdata.getMWidth()/2, gdata.getMHeight()/2);
+		if(h == handleNW) return mToExternal(-gdata.getMWidth()/2, -gdata.getMHeight()/2);
+
+		if(h == handleR) return mToExternal(gdata.getMWidth()/2 + M_ROTATION_HANDLE_POSITION, 0);
+		return null;
+	}
+	
+	/**
+	 * Gets the handle opposite to the given handle.
+	 * For directions N, E, S and W this is always their complement,
+	 * for directions NE, NW, SE, SW, you can constraint the direction, e.g.:
+	 * if direction is X, the opposite of NE will be NW instead of SW
+	 * @param h	The handle to find the opposite for
+	 * @param direction	Constraints on the direction, one of {@link Handle}#DIRECTION_*.
+	 * Will be ignored for N, E, S and W handles
+	 * @return	The opposite handle
+	 */
+	Handle getOppositeHandle(Handle h, int direction) {
+		//Ignore direction for N, E, S and W
+		if(h == handleN) return handleS;
+		if(h == handleE) return handleW;
+		if(h == handleS) return handleN;
+		if(h == handleW) return handleE;
+				
+		int[] pos = handleFromMatrix(h);
+		switch(direction) {
+		case Handle.DIRECTION_XY:
+		case Handle.DIRECTION_MINXY:
+		case Handle.DIRECTION_FREE:
+			return handleMatrix[ Math.abs(pos[0] - 1)][ Math.abs(pos[1] - 1)];
+		case Handle.DIRECTION_Y:
+			return handleMatrix[ Math.abs(pos[0] - 1)][pos[1]];
+		case Handle.DIRECTION_X:
+			return handleMatrix[ pos[0]][ Math.abs(pos[1] - 1)];
+		default:
+			return null;
+		}
+	}
+	
+	int[] handleFromMatrix(Handle h) {
+		for(int x = 0; x < 2; x++) {
+			for(int y = 0; y < 2; y++) {
+				if(handleMatrix[x][y] == h) return new int[] {x,y};
+			}
+		}
+		return null;
+	}
+	
+	/**
+	 * Creates a shape of the outline of this object
+	 */
+	protected Shape getVOutline()
+	{
+		int[] x = new int[4];
+		int[] y = new int[4];
+		
+		int[] p = getVHandleLocation(handleNE).asIntArray();
+		x[0] = p[0]; y[0] = p[1];
+		p = getVHandleLocation(handleSE).asIntArray();
+		x[1] = p[0]; y[1] = p[1];
+		p = getVHandleLocation(handleSW).asIntArray();
+		x[2] = p[0]; y[2] = p[1];
+		p = getVHandleLocation(handleNW).asIntArray();
+		x[3] = p[0]; y[3] = p[1];
+		
+		Polygon pol = new Polygon(x, y, 4);
+		return pol;
+	}
+			
+	public void gmmlObjectModified(PathwayEvent e) {		
+		markDirty(); // mark everything dirty
+		setHandleLocation();
+	}
+	
+}

Property changes on: trunk/src/g2d/org/pathvisio/view/GraphicsShape.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d/org/pathvisio/view/Line.java
===================================================================
--- trunk/src/g2d/org/pathvisio/view/Line.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/view/Line.java	(revision 957)
@@ -0,0 +1,440 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import java.awt.BasicStroke;
+import java.awt.Color;
+import java.awt.Graphics2D;
+import java.awt.Polygon;
+import java.awt.Shape;
+import java.awt.geom.AffineTransform;
+import java.awt.geom.Arc2D;
+import java.awt.geom.Line2D;
+import java.awt.geom.Point2D;
+import java.awt.geom.Rectangle2D;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.pathvisio.model.LineStyle;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.PathwayEvent;
+import org.pathvisio.model.GraphLink.GraphRefContainer;
+import org.pathvisio.model.PathwayElement.MPoint;
+ 
+/**
+ * This class implements and handles a line
+ */
+public class Line extends Graphics
+{
+	private static final int ARROWHEIGHT = 65;
+	private static final int ARROWWIDTH = 140;
+	private static final int TBARHEIGHT = 225;
+	private static final int TBARWIDTH = 15;
+	private static final int LRDIAM = 175;
+	private static final int RRDIAM = LRDIAM + 50;
+	private static final int LIGANDWIDTH = 125;
+	private static final int LIGANDHEIGHT = 175;
+	private static final int RECEPWIDTH = LIGANDWIDTH + 30;
+	private static final int RECEPHEIGHT = LIGANDHEIGHT + 30;
+	
+	private static final long serialVersionUID = 1L;
+	
+	private List<VPoint> points;
+	
+	/**
+	 * Constructor for this class
+	 * @param canvas - the VPathway this line will be part of
+	 */
+	public Line(VPathway canvas, PathwayElement o)
+	{
+		super(canvas, o);
+		
+		points = new ArrayList<VPoint>();
+		for(MPoint mp : o.getMPoints()) {
+			VPoint vp = canvas.getPoint(mp);
+			points.add(vp);
+			vp.addLine(this);
+			vp.setHandleLocation();
+		}
+	}
+	
+	public int getDrawingOrder() 
+	{
+		return VPathway.DRAW_ORDER_LINE;
+	}
+	
+	protected void swapPoint(VPoint pOld, VPoint pNew) 
+	{
+		int i = points.indexOf(pOld);
+		if(i > -1) {
+			points.remove(pOld);
+			points.add(i, pNew);
+		}
+	}
+			
+	public void doDraw(Graphics2D g)
+	{
+		Color c = gdata.getColor();
+		if(isSelected()) {
+			c = selectColor;
+		} else if (isHighlighted()) {
+			c = highlightColor;
+		}
+		g.setColor(c);
+				
+		int ls = gdata.getLineStyle();
+		if (ls == LineStyle.SOLID) {
+			g.setStroke(new BasicStroke());
+		}
+		else if (ls == LineStyle.DASHED) { 
+			g.setStroke(new BasicStroke(1, 
+									BasicStroke.CAP_SQUARE, BasicStroke.JOIN_MITER, 
+									10, new float[] {4, 4}, 0));
+		}			
+
+		Line2D l = getVLine();
+		Point2D start = l.getP1();
+		Point2D end = l.getP2();
+		
+		g.draw(l);
+		
+		double xs = start.getX();
+		double ys = start.getY();
+		double xe = end.getX();
+		double ye = end.getY();
+		
+		switch (gdata.getLineType()) {
+			case ARROW:				
+				paintArrowHead(g, xs, ys, xe, ye, vFromM(ARROWWIDTH), vFromM(ARROWHEIGHT));
+				break;
+			case TBAR:	
+				paintTBar(g, xs, ys, xe, ye, vFromM(TBARWIDTH), vFromM(TBARHEIGHT));
+				break;
+			case LIGAND_ROUND:	
+				paintLRound(g, xe, ye, vFromM(LRDIAM));
+				break;
+			case RECEPTOR_ROUND:
+				paintRRound(g, xs, ys, xe, ye, vFromM(RRDIAM));
+				break;
+			case RECEPTOR: //TODO: implement receptor
+			case RECEPTOR_SQUARE:
+				paintReceptor(g, xs, ys, xe, ye, vFromM(RECEPWIDTH), vFromM(RECEPHEIGHT));
+				break;
+			case LIGAND_SQUARE:
+			{
+				paintLigand(g, xs, ys, xe, ye, vFromM(LIGANDWIDTH), vFromM(LIGANDHEIGHT));
+			}
+			break;
+	}
+	}
+	
+	private double getAngle(double xs, double ys, double xe, double ye) {
+		if(xs == xe && ys == ye) return 0; //Unable to determine direction
+		Point2D ps = new Point2D.Double(xe - xs, ye - ys);
+		Point2D pe = new Point2D.Double(1, 0);
+		
+		return LinAlg.angle(new LinAlg.Point(ps.getX(), ps.getY()), new LinAlg.Point(pe.getX(), pe.getY()));
+	}
+	
+	private void paintArrowHead(Graphics2D g2d, double xs, double ys, double xe, double ye, double w, double h) {			
+		double angle = getAngle(xs, ys, xe, ye);
+		int[] xpoints = new int[] { (int)xe, (int)(xe - w), (int)(xe - w) };
+		int[] ypoints = new int[] { (int)ye, (int)(ye - h), (int)(ye + h) };
+		
+		Polygon arrow = new Polygon(xpoints, ypoints, 3);
+		AffineTransform f = new AffineTransform();
+		f.rotate(-angle, xe, ye);
+		Shape rotArrow = f.createTransformedShape(arrow);
+		g2d.fill(rotArrow);
+	}
+	
+	private void paintTBar(Graphics2D g2d, double xs, double ys, double xe, double ye, double w, double h) {
+		double angle = getAngle(xs, ys, xe, ye);
+	
+		Rectangle2D bar = new Rectangle2D.Double(xe - w, ye - h/2, w, h);
+		AffineTransform f = new AffineTransform();
+		f.rotate(-angle, xe, ye);
+		Shape rotBar = f.createTransformedShape(bar);
+		g2d.fill(rotBar);
+	}
+	
+	private void paintLRound(Graphics2D g2d, double xe, double ye, double d) {	
+		g2d.fillOval ((int)(xe - d/2), (int)(ye - d/2), (int)d, (int)d);
+	}
+	
+	private void paintRRound(Graphics2D g2d, double xs, double ys, double xe, double ye, double d) {
+		double angle = getAngle(xs, ys, xe, ye);
+		AffineTransform f = new AffineTransform();
+		f.rotate(-angle, xe, ye);
+		
+		Rectangle2D hideRect = new Rectangle2D.Double(xe - d/2, ye - 2, d/2 + 1, 4);
+		Shape hide = f.createTransformedShape(hideRect);
+		
+		Arc2D arc = new Arc2D.Double((int)(xe - d/2), (int)(ye - d/2), d, d, 90, 180, Arc2D.OPEN);
+		Shape rotArc = f.createTransformedShape(arc);
+		
+		//Hide top of line
+		Color cOld = g2d.getColor();
+		g2d.setColor(Color.WHITE);
+		g2d.fill(hide);
+		g2d.setColor(cOld);
+		g2d.draw(rotArc);		
+	}
+	
+	private void paintReceptor(Graphics2D g2d, double xs, double ys, double xe, double ye, double w, double h) {					
+		/* Path2D Only in Java 1.6....
+		Path2D rec = new Path2D.Double();
+		rec.moveTo(xe + w, ye + h/2);
+		rec.lineTo(xe, ye + h/2);
+		rec.lineTo(xe, ye - h/2);
+		rec.lineTo(xe + w, ye - h/2);
+		AffineTransform f = new AffineTransform();
+		f.rotate(-angle, xe, ye);
+		Shape rotRec = f.createTransformedShape(rec);
+		g2d.draw(rotRec);
+		*/
+		
+		double angle = getAngle(xs, ys, xe, ye);
+		AffineTransform f = new AffineTransform();
+		f.rotate(-angle, xe, ye);
+		
+		Rectangle2D hideRect = new Rectangle2D.Double(xe - w, ye - 2, w + 1, 4);
+		Shape hide = f.createTransformedShape(hideRect);
+		
+		//Hide top of line
+		Color cOld = g2d.getColor();
+		g2d.setColor(Color.WHITE);
+		g2d.fill(hide);
+		g2d.setColor(cOld);
+		
+		Shape l = new Line2D.Double(xe, ye + h/2, xe - w, ye + h/2);
+		Shape r = f.createTransformedShape(l);
+		g2d.draw(r);
+		l = new Line2D.Double(xe - w, ye + h/2, xe - w, ye - h/2);
+		r = f.createTransformedShape(l);
+		g2d.draw(r);
+		l = new Line2D.Double(xe - w, ye - h/2, xe, ye - h/2);
+		r = f.createTransformedShape(l);
+		g2d.draw(r);
+	}
+	
+	private void paintLigand(Graphics2D g2d, double xs, double ys, double xe, double ye, double w, double h) {
+		double angle = getAngle(xs, ys, xe, ye);
+	
+		Rectangle2D bar = new Rectangle2D.Double(xe - w, ye - h/2, w, h);
+		AffineTransform f = new AffineTransform();
+		f.rotate(-angle, xe, ye);
+		Shape rotBar = f.createTransformedShape(bar);
+		g2d.fill(rotBar);
+		g2d.draw(rotBar);
+	}
+	
+	protected Shape getVOutline()
+	{
+		//TODO: bigger than necessary, just to include the arrowhead / shape at the end
+		BasicStroke stroke = new BasicStroke(20);
+		Shape outline = stroke.createStrokedShape(getVLine());
+		return outline;
+	}	
+	
+//	/**
+//	 * If the line type is arrow, this method draws the arrowhead
+//	 */
+//	private void drawArrowhead(GC buffer) //TODO! clean up this mess.....
+//	{
+//		double angle = 25.0;
+//		double theta = Math.toRadians(180 - angle);
+//		double[] rot = new double[2];
+//		double[] p = new double[2];
+//		double[] q = new double[2];
+//		double a, b, norm;
+//		
+//		rot[0] = Math.cos(theta);
+//		rot[1] = Math.sin(theta);
+//		
+//		buffer.setLineStyle (SWT.LINE_SOLID);
+//		
+//		double vEndx = getVEndX();
+//		double vEndy = getVEndY();
+//		double vStartx = getVStartX();
+//		double vStarty = getVStartY();
+//		
+//		if(vStartx == vEndx && vStarty == vEndy) return; //Unable to determine direction
+//		
+//		a = vEndx-vStartx;
+//		b = vEndy-vStarty;
+//		norm = 8/(Math.sqrt((a*a)+(b*b)));				
+//		p[0] = ( a*rot[0] + b*rot[1] ) * norm + vEndx;
+//		p[1] = (-a*rot[1] + b*rot[0] ) * norm + vEndy;
+//		q[0] = ( a*rot[0] - b*rot[1] ) * norm + vEndx;
+//		q[1] = ( a*rot[1] + b*rot[0] ) * norm + vEndy;
+//		int[] points = {
+//			(int)vEndx, (int)vEndy,
+//			(int)(p[0]), (int)(p[1]),
+//			(int)(q[0]), (int)(q[1])
+//		};
+//		
+//		buffer.drawPolygon (points);
+//		buffer.fillPolygon (points);
+//	}
+
+	/**
+	 * Constructs the line for the coordinates stored in this class
+	 */
+	public Line2D getVLine()
+	{
+		return new Line2D.Double(getVStartX(), getVStartY(), getVEndX(), getVEndY());
+	}
+	
+	/**
+	 * Sets the line start and end to the coordinates specified
+	 * <DL><B>Parameters</B>
+	 * <DD>Double x1	- new startx 
+	 * <DD>Double y1	- new starty
+	 * <DD>Double x2	- new endx
+	 * <DD>Double y2	- new endy
+	 */
+	public void setVLine(double vx1, double vy1, double vx2, double vy2)
+	{
+		getStart().setVLocation(vx1, vy1);
+		getEnd().setVLocation(vx2, vy2);
+	}
+
+	public void setVScaleRectangle(Rectangle2D r) {
+		setVLine(r.getX(), r.getY(), r.getX() + r.getWidth(), r.getY() + r.getHeight());
+	}
+	
+	protected Rectangle2D getVScaleRectangle() {
+		return new Rectangle2D.Double(getVStartXDouble(), getVStartYDouble(), getVEndXDouble()
+				- getVStartXDouble(), getVEndYDouble() - getVStartYDouble());
+	}
+	
+	public Handle[] getHandles()
+	{
+		Handle[] handles = new Handle[points.size()];
+		for(int i = 0; i < handles.length; i++) {
+			handles[i] = points.get(i).getHandle();
+		}
+		return handles;
+	}
+		
+	public List<VPoint> getPoints() { return points; }
+	
+	public VPoint getStart() {
+		return points.get(0);
+	}
+	
+	public VPoint getEnd() {
+		return points.get(points.size() - 1);
+	}
+	
+	public int getVCenterX() {
+		// TODO Auto-generated method stub
+		double start = gdata.getMStart().getX();
+		double end = gdata.getMEnd().getX();
+		return (int)vFromM(start + (end - start) / 2);
+	}
+	
+	public int getVCenterY() {
+		// TODO Auto-generated method stub
+		double start = gdata.getMStart().getY();
+		double end = gdata.getMEnd().getY();
+		return (int)vFromM(start + (end - start) / 2);
+	}
+	
+	public int getVLeft() {
+		// TODO Auto-generated method stub
+		double start = gdata.getMStart().getX();
+		double end = gdata.getMEnd().getX();
+		return (int)vFromM(Math.min(start, end));
+	}
+	
+	public int getVWidth() {
+		// TODO Auto-generated method stub
+		double start = gdata.getMStart().getX();
+		double end = gdata.getMEnd().getX();
+		return (int)vFromM(Math.abs(start-end));
+	}
+	
+	public int getVHeight() {
+		// TODO Auto-generated method stub
+		double start = gdata.getMStart().getY();
+		double end = gdata.getMEnd().getY();
+		return (int)vFromM(Math.abs(start-end));
+	}	
+	
+	public int getVTop() {
+		// TODO Auto-generated method stub
+		double start = gdata.getMStart().getY();
+		double end = gdata.getMEnd().getY();
+		return (int)vFromM(Math.min(start, end));
+	}
+	
+	protected void vMoveBy(double vdx, double vdy)
+	{
+		for(VPoint p : points) {
+			p.vMoveBy(vdx, vdy);
+		}
+		//Move graphRefs
+		Set<VPoint> toMove = new HashSet<VPoint>();
+		for(GraphRefContainer ref : gdata.getReferences()) {
+			if(ref instanceof MPoint) {
+				toMove.add(canvas.getPoint((MPoint)ref));
+			}
+		}
+		toMove.removeAll(points);
+		for(VPoint p : toMove) p.vMoveBy(vdx, vdy);
+	}
+	
+	public void gmmlObjectModified(PathwayEvent e) {		
+		markDirty();
+		for(VPoint p : points) {
+			p.markDirty();
+			p.setHandleLocation();
+		}
+	}
+	
+	protected void destroyHandles() { 
+		//Do nothing, handles will be destroyed by VPoints
+	}
+	
+	protected void destroy() {
+		//don't call super.destroy(), this will destroy handles of VPoints
+		//which may be used by other lines
+		super.destroy();
+		
+		for(VPoint p : points) {
+			p.removeLine(this);
+		}
+		for(MPoint p : gdata.getMPoints()) {
+			canvas.pointsMtoV.remove(p);
+		}
+	}
+	
+	protected int getVStartX() { return (int)(vFromM(gdata.getMStartX())); }
+	protected int getVStartY() { return (int)(vFromM(gdata.getMStartY())); }
+	protected int getVEndX() { return (int)(vFromM(gdata.getMEndX())); }
+	protected int getVEndY() { return (int)(vFromM(gdata.getMEndY())); }
+
+	protected double getVStartXDouble() { return vFromM(gdata.getMStartX()); }
+	protected double getVStartYDouble() { return vFromM(gdata.getMStartY()); }
+	protected double getVEndXDouble() { return vFromM(gdata.getMEndX()); }
+	protected double getVEndYDouble() { return vFromM(gdata.getMEndY()); }
+
+}

Property changes on: trunk/src/g2d/org/pathvisio/view/Line.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d/org/pathvisio/view/MouseEvent.java
===================================================================
--- trunk/src/g2d/org/pathvisio/view/MouseEvent.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/view/MouseEvent.java	(revision 957)
@@ -0,0 +1,72 @@
+package org.pathvisio.view;
+
+import java.awt.Point;
+
+public abstract class MouseEvent extends InputEvent {
+
+	//Buttons
+	public static final int BUTTON_NONE = -1;
+	public static final int BUTTON1 = 1;
+	public static final int BUTTON2 = 2;
+	public static final int BUTTON3 = 3;
+	
+	//Types
+	public static final int MOUSE_DOWN = 10;
+	public static final int MOUSE_UP = 11;
+	public static final int MOUSE_MOVE = 12;
+	public static final int MOUSE_EXIT = 13;
+	public static final int MOUSE_ENTER = 14;
+	public static final int MOUSE_HOVER = 15;
+	public static final int MOUSE_CLICK = 16;
+	
+	private int type;
+	private int button;
+	private int clickCount;
+	private int x; //x relative to source
+	private int y; //y relative to source
+	
+	public MouseEvent(Object source, int type, int button, int x, int y, int clickCount, int modifier) {
+		super(source, modifier);
+		this.x = x;
+		this.y = y;
+		this.type = type;
+		this.button = button;
+		this.clickCount = clickCount;
+	}
+	
+	//public abstract Point getLocationOnScreen();
+
+	public int getButton() {
+		return button;
+	}
+
+	public int getClickCount() {
+		return clickCount;
+	}
+
+	public int getType() {
+		return type;
+	}
+
+	public int getX() {
+		return x;
+	}
+
+	public int getY() {
+		return y;
+	}
+	
+	public Point getLocation() {
+		return new Point(x, y);
+	}
+	
+	/*
+	public int getXOnScreen() {
+		return getLocationOnScreen().x;
+	}
+	
+	public int getYOnScreen() {
+		return getLocationOnScreen().y;
+	}
+	*/
+}
Index: trunk/src/g2d/org/pathvisio/view/KeyEvent.java
===================================================================
--- trunk/src/g2d/org/pathvisio/view/KeyEvent.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/view/KeyEvent.java	(revision 957)
@@ -0,0 +1,50 @@
+package org.pathvisio.view;
+
+
+public class KeyEvent extends InputEvent {
+	//Types
+	public static final int KEY_PRESSED = 0;
+	public static final int KEY_RELEASED = 1;
+	
+	//Keys
+	public static final int MIN_VALUE = Character.MAX_VALUE;
+	public static final int NONE = 0;
+	public static final int CTRL = MIN_VALUE + 1;
+	public static final int ALT = MIN_VALUE + 2;
+	public static final int SHIFT = MIN_VALUE + 3;
+	public static final int DEL = MIN_VALUE + 4;
+	public static final int INSERT = MIN_VALUE + 5;
+	
+	private static int twoPower(int p) { return (int)Math.pow(2, p); }
+
+	private int keyCode;
+	private int type;
+	
+	public KeyEvent(Object source, int keyCode, int type, int modifier) {
+		super(source, modifier);
+		this.keyCode = keyCode;
+		this.type = type;
+	}
+	
+	public KeyEvent(Object source, char keyCode, int type, int modifier) {
+		this(source, Character.getNumericValue(keyCode), type, modifier);
+	}
+	
+	public int getKeyCode() {
+		return keyCode;
+	}	
+	
+	public int getType() {
+		return type;
+	}
+	
+	public boolean isKey(char c) {
+		System.out.println("ask: " + (int)c);
+		System.out.println("have: " + keyCode);
+		return (int)c == keyCode;
+	}
+	
+	public boolean isKey(int i) {
+		return keyCode == i;
+	}
+}
Index: trunk/src/g2d/org/pathvisio/view/Handle.java
===================================================================
--- trunk/src/g2d/org/pathvisio/view/Handle.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/view/Handle.java	(revision 957)
@@ -0,0 +1,233 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import java.awt.Color;
+import java.awt.Graphics2D;
+import java.awt.Rectangle;
+import java.awt.Shape;
+import java.awt.geom.Ellipse2D;
+import java.awt.geom.Rectangle2D;
+
+import org.pathvisio.view.LinAlg.Point;
+
+/**
+ * This class implements and handles handles for 
+ * objects on the drawing which are used to 
+ * resize them or change their location.
+ */
+class Handle extends VPathwayElement
+{
+	private static final long serialVersionUID = 1L;
+	
+	/** 
+	 * because isSelected really doesn't make sense for GmmlHandles, 
+	 * I added this variable isVisible. It should be set automatically by its parent
+	 * through calls of show() and hide()
+	 */
+	private boolean isVisible = false;
+	
+	//The direction this handle is allowed to move in
+	int direction;
+	public static final int DIRECTION_FREE = 0;
+	public static final int DIRECTION_X	 = 1;
+	public static final int DIRECTION_Y  = 2; 
+	public static final int DIRECTION_ROT = 3;
+	public static final int DIRECTION_XY = 4;
+	public static final int DIRECTION_MINXY = 5;
+	
+	public static final int WIDTH 	= 8;
+	public static final int HEIGHT	= 8;
+	
+	VPathwayElement parent;
+	
+	double mCenterx;
+	double mCentery;
+	
+	double rotation;
+	
+	boolean visible;
+	
+	/**
+	 * Constructor for this class, creates a handle given the parent, direction and canvas
+	 * @param direction	Direction this handle can be moved in (one of DIRECTION_*)
+	 * @param parent	The object this handle belongs to
+	 * @param canvas	The {@link VPathway} to draw this handle on
+	 */
+	public Handle(int direction, VPathwayElement parent, VPathway canvas)
+	{
+		super(canvas);		
+		this.direction = direction;
+		this.parent = parent;
+	}
+
+	public int getDrawingOrder() {
+		return VPathway.DRAW_ORDER_HANDLE;
+	}
+	
+	/**
+	 * Get the direction this handle is allowed to move in
+	 * @return one of DIRECTION_*
+	 */
+	public int getDirection() { return direction; }
+	
+	public void setDirection(int direction) { this.direction = direction; }
+	
+	public void setVLocation(double vx, double vy)
+	{
+		markDirty();
+		mCenterx = mFromV(vx);
+		mCentery = mFromV(vy);
+		markDirty();
+	}
+
+	public void setMLocation(double mx, double my)
+	{
+		markDirty();
+		mCenterx = mx;
+		mCentery = my;
+		markDirty();
+	}
+	
+	public double getVCenterX() {
+		return vFromM(mCenterx);
+	}
+	
+	public double getVCenterY() {
+		return vFromM(mCentery);
+	}
+	
+	/**
+	 * returns the visibility of this handle
+	 * @see hide(), show()
+	 */
+	public boolean isVisible()
+	{
+		return isVisible;
+	}
+	
+	/**
+	 * call show() to cause this handle to show up and mark its area dirty 
+	 * A handle should show itself only if it's parent object is active / selected
+	 * @see hide(), isvisible()
+	 */
+	public void show()
+	{
+		if (!isVisible)
+		{
+			isVisible = true;
+			markDirty();
+		}
+	}
+	
+	/**
+	 * hide handle, and also mark its area dirty
+	 * @see show(), isvisible()
+	 */
+	public void hide()
+	{
+		if (isVisible)
+		{
+			isVisible = false;
+			markDirty();
+		}
+	}
+	
+	/**
+	 * draws itself, but only if isVisible() is true, there is 
+	 * no need for a check for isVisible() before calling draw().
+	 */
+	public void doDraw(Graphics2D g)
+	{
+		if(!isVisible) return;
+		
+		Shape outline = getVOutline();
+		
+		if(direction == DIRECTION_ROT) {
+			g.setColor(Color.GREEN);
+		} else {
+			g.setColor(Color.YELLOW);
+		}
+		
+		g.fill(outline);
+		
+		g.setColor(Color.BLACK);
+		
+		g.draw(outline);		
+	}
+		
+	/**
+	 * Moves this handle by the specified increments and
+	 * adjusts the {@link VPathwayElement} to the new position
+	 */
+	public void vMoveBy(double vdx, double vdy)
+	{	
+		markDirty();
+
+		if(direction != DIRECTION_FREE && direction != DIRECTION_ROT) {
+			Point v = new Point(0,0);
+			double xtraRot = 0;
+			if		(direction == DIRECTION_X) {
+				v = new Point(1,0);
+			}
+			else if	(direction == DIRECTION_Y) {
+				v = new Point(0,1);
+			}
+			else if (direction == DIRECTION_XY) {
+				Rectangle b = parent.getVBounds();
+				v = new Point(b.width + 1, b.height + 1);
+			}
+			else if (direction == DIRECTION_MINXY) {
+				xtraRot = Math.PI/2;
+				Rectangle b = parent.getVBounds();
+				v = new Point(b.height + 1, b.width + 1);
+			}
+			Point yr = LinAlg.rotate(v, -rotation + xtraRot);
+			Point prj = LinAlg.project(new Point(vdx, vdy), yr);
+			vdx = prj.x; vdy= prj.y;
+		}
+		
+		mCenterx += mFromV(vdx);
+		mCentery += mFromV(vdy);
+		
+		parent.adjustToHandle(this);
+		markDirty();
+	}
+			
+	public Shape getVOutline() {
+		Shape s = null;
+		switch(direction) {
+		case DIRECTION_ROT:
+			s = new Ellipse2D.Double(getVCenterX() - WIDTH/2, getVCenterY() - HEIGHT/2, 
+					WIDTH, HEIGHT);
+			break;
+		default:
+			s = new Rectangle2D.Double(getVCenterX() - WIDTH/2, getVCenterY() - HEIGHT/2, 
+					WIDTH, HEIGHT);
+			break;
+		}
+		return s;
+	}
+		
+	public String toString() { 
+		return 	"Handle with parent: " + parent.toString() +
+		" and direction " + direction; 
+	}
+			
+} // end of class
+
+

Property changes on: trunk/src/g2d/org/pathvisio/view/Handle.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d/org/pathvisio/view/Group.java
===================================================================
--- trunk/src/g2d/org/pathvisio/view/Group.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/view/Group.java	(revision 957)
@@ -0,0 +1,129 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import java.awt.Graphics2D;
+import java.awt.Rectangle;
+import java.awt.Shape;
+import java.awt.geom.Point2D;
+import java.awt.geom.Rectangle2D;
+import java.util.ArrayList;
+
+import org.pathvisio.model.PathwayElement;
+
+public class Group extends Graphics {
+
+	public Group(VPathway canvas, PathwayElement pe) {
+		super(canvas, pe);
+		// TODO Auto-generated constructor stub
+	}
+
+	/**
+	 * Determines wheter a Graphics object contains the point specified
+	 * 
+	 * @param point -
+	 *            the point to check
+	 * @return True if the object contains the point, false otherwise
+	 */
+	protected boolean vContains(Point2D point) {
+		for (VPathwayElement vpe : canvas.getDrawingObjects()) {
+			if (vpe != this && vpe.vContains(point)) {
+				if (vpe instanceof Graphics) {
+					PathwayElement pe = ((Graphics) vpe).getGmmlData();
+					String ref = pe.getGroupRef();
+					if (ref != null && ref.equals(getGmmlData().getGroupId())) {
+						System.out.println("TRUE!");
+						return true;
+					}
+				}
+			}
+		}
+		return false;
+	}
+
+	@Override
+	protected boolean vIntersects(Rectangle2D r) {
+		for (VPathwayElement vpe : canvas.getDrawingObjects()) {
+			if (vpe != this && vpe.vIntersects(r)) {
+				if (vpe instanceof Graphics) {
+					PathwayElement pe = ((Graphics) vpe).getGmmlData();
+					String ref = pe.getGroupRef();
+					if (ref != null && ref.equals(getGmmlData().getGroupId())) {
+						System.out.println("TRUE INTERSECTS!");
+						return true;
+					}
+				}
+			}
+		}
+		return false;
+	}
+	
+	public ArrayList<Graphics> getGroupGraphics(){
+		ArrayList<Graphics> gg = new ArrayList<Graphics>();
+		for (VPathwayElement vpe : canvas.getDrawingObjects()) {
+			if (vpe != this) {
+				if (vpe instanceof Graphics) {
+					Graphics vpeg = (Graphics) vpe;
+					PathwayElement pe =  vpeg.getGmmlData();
+					String ref = pe.getGroupRef();
+					if (ref != null && ref.equals(getGmmlData().getGroupId())) {
+						gg.add(vpeg);					
+					}
+				}
+			}
+		}
+		return gg;
+	}
+	
+	@Override
+	public void select() {
+		for(Graphics g: getGroupGraphics() ){
+			g.select();
+		}
+		super.select();
+	}
+
+	@Override
+	protected void vMoveBy(double dx, double dy) {
+		for(Graphics g: getGroupGraphics() ){
+			g.vMoveBy(dx, dy);
+		}
+		//super.vMoveBy(dx, dy);
+	}
+	
+	@Override
+	public int getDrawingOrder() {
+
+		return VPathway.DRAW_ORDER_GROUP;
+	}
+
+	@Override
+	protected void doDraw(Graphics2D g2d) {
+		// TODO make unique selection box for groups
+		
+	}
+	
+	@Override
+	protected Shape getVOutline() {
+		// TODO Return outline of the Group members, distinct from global selection box
+		
+		Rectangle rect = new Rectangle();
+
+		return rect;
+	}
+
+}
Index: trunk/src/g2d/org/pathvisio/view/SelectionBox.java
===================================================================
--- trunk/src/g2d/org/pathvisio/view/SelectionBox.java	(revision 0)
+++ trunk/src/g2d/org/pathvisio/view/SelectionBox.java	(revision 957)
@@ -0,0 +1,452 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import java.awt.BasicStroke;
+import java.awt.Graphics2D;
+import java.awt.Rectangle;
+import java.awt.geom.Point2D;
+import java.awt.geom.Rectangle2D;
+import java.util.ArrayList;
+import java.util.EventObject;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.pathvisio.model.ObjectType;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.GraphLink.GraphRefContainer;
+import org.pathvisio.model.PathwayElement.MPoint;
+
+/**
+ * This class implements a selectionbox 
+ */ 
+public class SelectionBox extends GraphicsShape
+{
+	private static final long serialVersionUID = 1L;
+		
+	private ArrayList<VPathwayElement> selection;
+	boolean isSelecting;
+	boolean isVisible;
+		
+	/**
+	 * Constructor for this class
+	 * @param canvas - the VPathway this selectionbox will be part of
+	 */
+	public SelectionBox(VPathway canvas)
+	{
+		// TODO: selectionbox shouldn't need a dataobject...
+		// note, not setting parent of PathwayElement here.
+		this(canvas, new PathwayElement(ObjectType.SHAPE));
+	}	
+	
+	public SelectionBox(VPathway canvas, PathwayElement pe)
+	{
+		super(canvas, pe);
+			
+		selection = new ArrayList<VPathwayElement>();
+	}	
+	
+	public int getDrawingOrder() {
+		return VPathway.DRAW_ORDER_SELECTIONBOX;
+	}
+	
+	public ArrayList<VPathwayElement> getSelection() {
+		return selection;
+	}
+	
+	/**
+	 * Add an object to the selection
+	 * @param o
+	 */
+	public void addToSelection(VPathwayElement o) {
+		if(o == this || selection.contains(o)) return; //Is selectionbox or already in selection
+		if(o instanceof VPoint) {
+			for(Line l : ((VPoint)o).getLines()) {
+				l.select();
+				doAdd(l);
+			}
+		} else {
+			o.select();
+			doAdd(o);
+		}
+		fireSelectionEvent(new SelectionEvent(this, SelectionEvent.OBJECT_ADDED, o));
+		if(isSelecting) return; //All we have to do if user is dragging selectionbox
+		if(hasMultipleSelection()) { 
+			stopSelecting(); //show and fit to SelectionBox if performed after dragging
+		}
+		 
+	}
+	
+	private void doAdd(VPathwayElement o) {
+		if(!selection.contains(o)) selection.add(o);
+	}
+	
+	/**
+	 * Remove an object from the selection
+	 * @param o
+	 */
+	public void removeFromSelection(VPathwayElement o) {
+		if(o == this) return;
+		selection.remove(o); 
+		o.deselect();
+		fireSelectionEvent(new SelectionEvent(this, SelectionEvent.OBJECT_REMOVED, o));
+		if(!isSelecting) fitToSelection();
+	}
+	
+	/**
+	 * Get the child object at the given coordinates (relative to canvas)
+	 * @param p
+	 * @return the child object or null if none is present at the given location
+	 */
+	public VPathwayElement getChild(Point2D p) {
+		//First check selection
+		for(VPathwayElement o : selection) {
+			if(o.vContains(p)) return o;
+		}
+		//Nothing in selection, check all other objects
+		for(VPathwayElement o : canvas.getDrawingObjects()) {
+			if(o.vContains(p) && o != this)
+				return o;
+		}
+		return null; //Nothing found
+	}
+	
+	/**
+	 * Removes or adds the object (if exists) at the given coordinates from the selection,
+	 * depending on its selection-state
+	 * @param p
+	 */
+	public void objectClicked(Point2D p) {
+		VPathwayElement clicked = getChild(p);
+		if(clicked == null) return; //Nothing clicked
+		if(clicked.isSelected()) 	//Object is selected, remove
+		{
+			removeFromSelection(clicked);
+		} 
+		else 						//Object is not selected, add
+		{
+			addToSelection(clicked);
+		}
+	}
+	
+	/**
+	 * Returns true if the selectionbox has multiple objects in its selection, false otherwise
+	 */
+	public boolean hasMultipleSelection() { return selection.size() > 1 ? true : false; }
+	
+	/**
+	 * Resets the selectionbox (unselect selected objects, clear selection, reset rectangle
+	 * to upperleft corner
+	 */
+	public void reset() { 
+		reset(0, 0, true);
+	}
+	
+	
+	/**
+	 * Resets the selectionbox (unselect selected objects, clear selection, reset rectangle
+	 * to upperleft corner
+	 * @param clearSelection if true the selection is cleared
+	 */
+	public void reset(boolean clearSelection) { 
+		reset(0, 0, clearSelection);
+	}
+	
+	public void reset(double vStartX, double vStartY) {
+		reset(vStartX, vStartY, true);
+	}
+	
+	private void reset(double vStartX, double vStartY, boolean clearSelection) {
+		for(VPathwayElement o : selection) o.deselect();
+		if(clearSelection) {
+			selection.clear();
+			fireSelectionEvent(
+					new SelectionEvent(this, SelectionEvent.SELECTION_CLEARED));
+		}
+		
+		gdata.setMLeft(mFromV(vStartX));
+		gdata.setMTop(mFromV(vStartY));
+		gdata.setMWidth(0);
+		gdata.setMHeight(0);
+	}
+
+	/**
+	 * Returns true if this selectionbox is in selecting state (selects containing objects when resized)
+	 */
+	public boolean isSelecting() { return isSelecting; }
+	
+	/**
+	 * Start selecting
+	 */
+	public void startSelecting() {
+		isSelecting = true;
+		setHandleRestriction(false);
+		show();
+	}
+	
+	/**
+	 * Stop selecting
+	 */
+	public void stopSelecting() {
+		isSelecting = false;
+		if(!hasMultipleSelection()) {
+			if(selection.size() == 1) {
+				VPathwayElement passTo = selection.get(0);
+				reset();
+				passTo.select();
+			} else {
+				reset();
+			}
+		} else {
+			select();
+			fitToSelection();
+			setHandleRestriction(true);
+		}
+	}
+	
+	/**
+	 * Sets movement direction restriction for this object's handles
+	 * @param restrict if true, handle movement is restricted in XY direction,
+	 * else handles can move freely
+	 */
+	private void setHandleRestriction(boolean restrict) {
+		if(restrict) {
+			handleNE.setDirection(Handle.DIRECTION_MINXY);
+			handleSW.setDirection(Handle.DIRECTION_MINXY);
+			handleNW.setDirection(Handle.DIRECTION_XY);
+			handleSE.setDirection(Handle.DIRECTION_XY);
+		} else {
+			for(Handle h : getHandles()) 
+				h.setDirection(Handle.DIRECTION_FREE); 
+		}
+	}
+	
+	public void select() {
+		super.select();
+		for(VPathwayElement o : selection) {
+			o.select();
+			for(Handle h : o.getHandles()) h.hide();
+		}
+	}
+	
+	/**
+	 * Fit the size of this object to the selected objects
+	 */
+	public void fitToSelection() {
+		if(selection.size() == 0) { //No objects in selection
+			hide(); 
+			return;
+		}
+		if(! hasMultipleSelection()) { //Only one object in selection, hide selectionbox
+			VPathwayElement passTo = selection.get(0);
+			hide(false);
+			passTo.select();
+			return;
+		}
+
+		Rectangle vr = null;
+		for(VPathwayElement o : selection) {
+			if(vr == null) vr = o.getVBounds();
+			else vr.add(o.getVBounds());
+			for(Handle h : o.getHandles()) h.hide();
+		}
+
+		gdata.setMWidth(mFromV(vr.width));
+		gdata.setMHeight(mFromV(vr.height));
+		gdata.setMLeft(mFromV(vr.x));
+		gdata.setMTop(mFromV(vr.y));
+		setHandleLocation();		
+	}
+			
+	/**
+	 * Show the selectionbox
+	 */
+	public void show() { 
+		isVisible = true; 
+		markDirty();
+	}
+	
+	/**
+	 * Hide the selectionbox
+	 */
+	public void hide() {
+		hide(true);
+	}
+	
+	public void hide(boolean reset) {
+		for(Handle h : getHandles()) h.hide();
+		isVisible = false;
+		if(reset) reset();
+	}
+	
+	/**
+	 * Gets the corner handle (South east) for start dragging
+	 */
+	public Handle getCornerHandle() { return handleSE; }
+	
+	public void adjustToHandle(Handle h) {	
+		//Store original size and location before adjusting to handle
+		double vWidthOld = getVWidthDouble();
+		double vHeightOld = getVHeightDouble();
+		double vCenterXOld = getVCenterXDouble();
+		double vCenterYOld = getVCenterYDouble();
+		
+		super.adjustToHandle(h);
+		if(isSelecting) { //Selecting, so add containing objects to selection
+			Rectangle vr = getVBounds();
+			Rectangle2D.Double bounds = new Rectangle2D.Double(vr.x, vr.y, vr.width, vr.height);
+			for(VPathwayElement o : canvas.getDrawingObjects()) {
+				if((o == this) || (o instanceof Handle)) continue;
+				if(o.vIntersects(bounds)) { 
+					addToSelection(o);
+				} else if(o.isSelected()) removeFromSelection(o);
+			}
+		} else { //Resizing, so resize child objects too
+			double widthRatio = getVWidthDouble() / vWidthOld;
+			double heightRatio = getVHeightDouble() / vHeightOld;
+			//Scale all selected objects in x and y direction, treat points seperately
+			Set<VPoint> points = new HashSet<VPoint>();
+			for(VPathwayElement o : selection) { 
+				if(o instanceof Line) {
+					points.addAll(((Line)o).getPoints());
+				} else { 
+					Rectangle2D vr = o.getVScaleRectangle();
+					double newObjectWidth = vr.getWidth() * widthRatio;
+					double newObjectHeight = vr.getHeight() * heightRatio;
+					double objectFromCenterX = (vr.getX() - vCenterXOld) * widthRatio;
+					double objectFromCenterY = (vr.getY() - vCenterYOld) * heightRatio;
+					o.setVScaleRectangle(new Rectangle2D.Double(
+							getVCenterXDouble() + objectFromCenterX, 
+							getVCenterYDouble() + objectFromCenterY, 
+							newObjectWidth, 
+							newObjectHeight));
+				}
+			}
+			for(VPoint p : points) {
+				double dx = (p.getVX() - vCenterXOld) * widthRatio;
+				double dy = (p.getVY() - vCenterYOld) * heightRatio;
+				p.setVLocation(getVCenterXDouble() + dx, getVCenterYDouble() + dy);
+			}
+		}
+	}
+	
+	public void vMoveBy(double vdx, double vdy) 
+	{
+
+		gdata.setMLeft(gdata.getMLeft() + mFromV(vdx)); 
+		gdata.setMTop(gdata.getMTop() + mFromV(vdy));
+
+		//Move selected object and their references
+		Set<GraphRefContainer> not = new HashSet<GraphRefContainer>(); //Will be moved by linking object
+		Set<VPoint> points = new HashSet<VPoint>(); //Will not be moved by linking object
+		
+		for(VPathwayElement o : selection) 
+		{
+			if (o instanceof Graphics)
+			{
+				PathwayElement g = ((Graphics)o).getGmmlData();
+				if(!(o instanceof Line)) {
+					o.vMoveBy(vdx, vdy);
+					not.addAll(g.getReferences());
+				}
+				if(g.getObjectType() == ObjectType.LINE) {
+					points.addAll(((Line)o).getPoints());
+				}
+			}
+
+		}
+		
+		for(GraphRefContainer ref : not) {
+			if(ref instanceof MPoint) {
+				points.remove(canvas.getPoint((MPoint)ref));
+			}
+		}
+			
+		for(VPoint p : points) {
+			p.vMoveBy(vdx, vdy);
+		}
+	}
+	
+	public void doDraw(Graphics2D g)
+	{
+		if(isVisible) {
+			g.setStroke(new BasicStroke(1, 
+					BasicStroke.CAP_SQUARE, BasicStroke.JOIN_MITER, 
+					1, new float[] {1, 2}, 0));
+			g.drawRect(getVLeft(), getVTop(), getVWidth(), getVHeight());
+		}
+	}
+		
+	public void adjustToZoom(double factor) { fitToSelection(); }
+	
+	static List<SelectionListener> listeners;
+
+	private static List<SelectionListener> getListeners() {
+		if(listeners == null)
+			listeners = new ArrayList<SelectionListener>();
+		return listeners;
+	}
+	
+	/**
+	 * Add a {@link SelectionListener}, that will be notified if a selection event occurs
+	 * @param l The {@link SelectionListener} to add
+	 */
+	public static void addListener(SelectionListener l) {
+		getListeners().add(l);
+	}
+
+	/**
+	 * Fire a {@link SelectionEvent} to notify all {@link SelectionListener}s registered
+	 * to this class
+	 * @param e
+	 */
+	public static void fireSelectionEvent(SelectionEvent e) {
+		for(SelectionListener l : getListeners()) {
+			l.drawingEvent(e);
+		}
+	}
+
+	public interface SelectionListener {
+		public void drawingEvent(SelectionEvent e);
+	}
+
+	public static class SelectionEvent extends EventObject {
+		private static final long serialVersionUID = 1L;
+		public static final int OBJECT_ADDED = 0;
+		public static final int OBJECT_REMOVED = 1;
+		public static final int SELECTION_CLEARED = 2;
+
+		public SelectionBox source;
+		public VPathwayElement affectedObject;
+		public int type;
+		public List<VPathwayElement> selection;
+
+		public SelectionEvent(SelectionBox source, int type, VPathwayElement affectedObject) {
+			super(source);
+			this.source = source;
+			this.type = type;
+			this.selection = source.selection;
+			this.affectedObject = affectedObject;
+		}
+		
+		public SelectionEvent(SelectionBox source, int type) {
+			this(source, type, null);
+		}
+	}	
+	
+}
\ No newline at end of file

Property changes on: trunk/src/g2d/org/pathvisio/view/SelectionBox.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/preferences/swt/SwtPreferences.java
===================================================================
--- trunk/src/swt/org/pathvisio/preferences/swt/SwtPreferences.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/preferences/swt/SwtPreferences.java	(revision 957)
@@ -0,0 +1,195 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.preferences.swt;
+
+import java.io.File;
+import java.io.IOException;
+
+import org.eclipse.jface.preference.PreferenceStore;
+import org.eclipse.jface.util.IPropertyChangeListener;
+import org.eclipse.jface.util.PropertyChangeEvent;
+import org.pathvisio.Engine;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.Preference;
+import org.pathvisio.preferences.PreferenceCollection;
+import org.pathvisio.util.ColorConverter;
+import org.pathvisio.view.Graphics;
+
+import com.sun.org.apache.xpath.internal.operations.Bool;
+
+/**
+ * This class contains all user preferences used in this application
+ */
+public class SwtPreferences extends PreferenceStore implements PreferenceCollection, IPropertyChangeListener {
+	private static final File preferenceFile = new File(SwtEngine.getApplicationDir(), ".PathVisio");
+	
+	public SwtPreferences() {
+		this(preferenceFile.toString());
+	}
+	
+	public SwtPreferences(String fileName) {
+		super(fileName);
+		loadPreferences();
+	}
+	
+	public Preference byName(String name) {
+		Preference p = null;
+		if(name.startsWith("SWT")) {
+			p = SwtPreference.valueOf(name);
+		} else {
+			p = GlobalPreference.valueOf(name);
+		}
+		return p;
+	}
+	
+	protected void toEnums(Preference[] enumPrefs) {
+		for(Preference p : enumPrefs) {
+			p.setValue(getString(p.name()));
+		}
+	}
+	
+	protected void toEnums() {
+		toEnums(SwtPreference.values());
+		toEnums(GlobalPreference.values());
+	}
+	
+	protected void fromEnums(Preference[] enumPrefs) {
+		for(Preference p : enumPrefs) {
+			setValue(p.name(), p.getValue());
+		}
+	}
+	
+	protected void fromEnums() {
+		fromEnums(SwtPreference.values());
+		fromEnums(GlobalPreference.values());
+	}
+	
+	public void save() throws IOException {
+		fromEnums();
+		super.save();
+	}
+	
+	/**
+	 * Loads all stored users preferences and set defaults
+	 */
+	private void loadPreferences()
+	{
+		addPropertyChangeListener(this);
+		
+		for(Preference p : GlobalPreference.values()) {
+			setDefault(p);
+		}
+		
+		for(Preference p : SwtPreference.values()) {
+			setDefault(p);
+		}
+		
+		try {
+			load();
+		} catch(Exception e) { 
+			Engine.log.error("Unable to load preferences", e);
+		}
+		
+		toEnums();
+		
+		createDataDirectories();
+		
+	}
+	
+	private void setDefault(Preference p) {
+		setDefault(p.name(), p.getDefault());
+	}
+	
+	private void createDataDirectories() {
+		// For the data directories: if not defined by user, create default directories
+		Preference[] dataProps = new Preference[] 
+		{ 
+			SwtPreference.SWT_DIR_EXPR, SwtPreference.SWT_DIR_GDB, 
+			SwtPreference.SWT_DIR_PWFILES, SwtPreference.SWT_DIR_RDATA 
+		};
+		
+		for(Preference prop : dataProps) {
+			File dir = new File(prop.getValue());
+			if(!dir.exists()) dir.mkdirs();
+		}
+	}
+	
+	public void propertyChange(PropertyChangeEvent e) {
+		Preference p = byName(e.getProperty());
+		if(p != null) {
+			p.setValue(e.getNewValue().toString());
+		}
+		
+		if(e.getProperty().equals(GlobalPreference.COLOR_SELECTED.name())) { 
+			//if(e.getNewValue() instanceof RGB) Graphics.selectColor = (RGB)e.getNewValue();
+			//else 
+				Graphics.selectColor = ColorConverter.parseColorString((String)e.getNewValue());
+			Engine.getActiveVPathway().redraw();
+		}
+		else if(e.getProperty().equals(GlobalPreference.COLOR_HIGHLIGHTED.name())) {
+			//if(e.getNewValue() instanceof RGB) Graphics.highlightColor = (RGB)e.getNewValue();
+			//else 
+				Graphics.highlightColor = ColorConverter.parseColorString((String)e.getNewValue());
+				Engine.getActiveVPathway().redraw();
+		}
+		else if(e.getProperty().startsWith("directories")) {
+			createDataDirectories();
+		}
+	}
+	
+	public enum SwtPreference implements Preference {
+		SWT_DIR_PWFILES(new File(SwtEngine.getDataDir().toString(), "pathways").toString()),
+		SWT_DIR_GDB(new File(SwtEngine.getDataDir().toString(), "gene databases").toString()),
+		SWT_DIR_EXPR(new File(SwtEngine.getDataDir().toString(), "expression datasets").toString()),
+		SWT_DIR_RDATA(new File(SwtEngine.getDataDir().toString(), "R data").toString()),
+
+		SWT_CURR_GDB("none"),
+		SWT_DB_ENGINE_GDB("org.pathvisio.data.DBConnDerby"),
+		SWT_DB_ENGINE_EXPR("org.pathvisio.data.DBConnDerby"),
+		SWT_SIDEPANEL_SIZE("30"),
+		
+		SWT_SHOW_ADVANCED_ATTR(Boolean.toString(false));
+		
+		SwtPreference(String defaultValue) {
+			this.defaultValue = defaultValue;
+		}
+
+		private String defaultValue;
+		private String value;
+		
+		public String getDefault() {
+			return defaultValue;
+		}
+		
+		public void setDefault(String defValue) {
+			defaultValue = defValue;
+		}
+		
+		public void setValue(String newValue) {
+			value = newValue;
+		}
+		
+		public String getValue() {
+			if(value != null) {
+				return value;
+			} else {
+				return defaultValue;
+			}
+		}
+	}
+}
\ No newline at end of file
Index: trunk/src/swt/org/pathvisio/preferences/swt/PreferenceDlg.java
===================================================================
--- trunk/src/swt/org/pathvisio/preferences/swt/PreferenceDlg.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/preferences/swt/PreferenceDlg.java	(revision 957)
@@ -0,0 +1,145 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.preferences.swt;
+
+import org.eclipse.jface.preference.BooleanFieldEditor;
+import org.eclipse.jface.preference.ColorFieldEditor;
+import org.eclipse.jface.preference.DirectoryFieldEditor;
+import org.eclipse.jface.preference.FieldEditorPreferencePage;
+import org.eclipse.jface.preference.FileFieldEditor;
+import org.eclipse.jface.preference.IntegerFieldEditor;
+import org.eclipse.jface.preference.PreferenceManager;
+import org.eclipse.jface.preference.PreferenceNode;
+import org.eclipse.jface.preference.StringFieldEditor;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+
+public class PreferenceDlg extends PreferenceManager {
+	
+	public PreferenceDlg() {
+		super();
+
+		PreferenceNode display = new PreferenceNode("display", new DisplayPage());
+	    PreferenceNode colors = new PreferenceNode("colors", new ColorsPage());
+	    PreferenceNode directories = new PreferenceNode("directories", new DirectoriesPage());
+	    PreferenceNode files = new PreferenceNode("files", new FilesPage());
+	    PreferenceNode database = new PreferenceNode("database", new DatabasePage());
+	    
+	    addToRoot(display);
+	    addTo("display", colors);
+	    addToRoot(directories);
+	    addToRoot(files);
+	    addToRoot(database);
+	}
+	
+	private class FilesPage extends FieldEditorPreferencePage {
+		public FilesPage() {
+			super("Files", GRID);
+		}
+		
+		protected void createFieldEditors() {
+			FileFieldEditor f1 = new FileFieldEditor(GlobalPreference.FILE_LOG.name(), "Log file:", getFieldEditorParent());
+			addField(f1);
+		}
+	}
+	
+	private class DirectoriesPage extends FieldEditorPreferencePage {
+		public DirectoriesPage() {
+			super("Directories", GRID);
+			noDefaultAndApplyButton();
+		}
+		
+		protected void createFieldEditors() {
+			DirectoryFieldEditor d1 = new DirectoryFieldEditor(SwtPreference.SWT_DIR_PWFILES.name(),
+					"Gpml pathways:", getFieldEditorParent());
+			addField(d1);
+			
+			DirectoryFieldEditor d2 = new DirectoryFieldEditor(SwtPreference.SWT_DIR_GDB.name(),
+					"Gene databases:", getFieldEditorParent());
+			addField(d2);
+			
+			DirectoryFieldEditor d3 = new DirectoryFieldEditor(SwtPreference.SWT_DIR_EXPR.name(),
+					"Expression datasets:", getFieldEditorParent());
+			addField(d3);
+
+			if(SwtEngine.isUseR()) {
+				DirectoryFieldEditor d4 = new DirectoryFieldEditor(SwtPreference.SWT_DIR_RDATA.name(),
+						"Results from pathway statistics:", getFieldEditorParent());
+				addField(d4);
+			}
+		}
+	}
+	
+	private class DisplayPage extends FieldEditorPreferencePage {
+		public DisplayPage() {
+			super("Display", GRID);
+		}
+		
+		protected void createFieldEditors() {
+			IntegerFieldEditor f = new IntegerFieldEditor(SwtPreference.SWT_SIDEPANEL_SIZE.name(),
+					"Initial side panel size (percent of window size):", getFieldEditorParent());
+			f.setValidRange(0, 100);
+			addField(f);
+			
+			BooleanFieldEditor f2 =	new BooleanFieldEditor (
+					SwtPreference.SWT_SHOW_ADVANCED_ATTR.name(),									   
+					"Show advanced attributes (e.g. references):", getFieldEditorParent());
+				addField (f2);
+		}
+	}
+	private class ColorsPage extends FieldEditorPreferencePage {
+		public ColorsPage() {
+			super("Colors", GRID);
+		}
+		
+		protected void createFieldEditors() {
+			ColorFieldEditor f1 = new ColorFieldEditor(GlobalPreference.COLOR_NO_CRIT_MET.name(), 
+					"Default color for 'no criteria met':", getFieldEditorParent());
+			addField(f1);
+			ColorFieldEditor f2 = new ColorFieldEditor(GlobalPreference.COLOR_NO_GENE_FOUND.name(), 
+					"Default color for 'gene not found':", getFieldEditorParent());
+			addField(f2);
+			ColorFieldEditor f3 = new ColorFieldEditor(GlobalPreference.COLOR_NO_DATA_FOUND.name(), 
+					"Default color for 'no data found':", getFieldEditorParent());
+			addField(f3);
+			ColorFieldEditor f4 = new ColorFieldEditor(GlobalPreference.COLOR_SELECTED.name(), 
+					"Line color for selected objects:", getFieldEditorParent());
+			addField(f4);
+			ColorFieldEditor f5 = new ColorFieldEditor(GlobalPreference.COLOR_HIGHLIGHTED.name(), 
+					"Line color for highlighted objects:", getFieldEditorParent());
+			addField(f5);
+			
+		}
+	}
+	
+	private class DatabasePage extends FieldEditorPreferencePage {
+		public DatabasePage() {
+			super("Database", GRID);
+		}
+		
+		protected void createFieldEditors() {
+			StringFieldEditor f1 = new StringFieldEditor(SwtPreference.SWT_DB_ENGINE_GDB.name(),
+					"Database connector class for gene database:", getFieldEditorParent());
+			addField(f1);
+			StringFieldEditor f2 = new StringFieldEditor(SwtPreference.SWT_DB_ENGINE_EXPR.name(),
+					"Database connector class for expression dataset:", getFieldEditorParent());
+			addField(f2);
+		}
+	}
+	
+}
\ No newline at end of file

Property changes on: trunk/src/swt/org/pathvisio/preferences/swt/PreferenceDlg.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/AboutDlg.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/AboutDlg.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/gui/swt/AboutDlg.java	(revision 957)
@@ -0,0 +1,95 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Dialog;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Listener;
+import org.eclipse.swt.widgets.Shell;
+import org.pathvisio.Globals;
+
+/**
+ * 
+ * A simple dialog box that shows about information
+ */
+public class AboutDlg extends Dialog
+{
+	private static final long serialVersionUID = 1L;
+
+	public AboutDlg(Shell parent) 
+	{
+		super (parent);
+	}
+
+	public AboutDlg(Shell parent, int style) 
+	{
+		super (parent, style);
+	}
+	
+	public void open()
+	{
+		Shell parent = getParent();
+		final Shell shell = new Shell (parent, SWT.TITLE | SWT.BORDER | SWT.APPLICATION_MODAL);
+
+		shell.setText ("About " + Globals.APPLICATION_VERSION_NAME);		
+		GridLayout ly = new GridLayout();
+		ly.numColumns = 2;
+		shell.setLayout (ly);
+		
+		Label lbl = new Label (shell, SWT.NULL);
+		lbl.setText (Globals.APPLICATION_VERSION_NAME + "\nRevision: " + Revision.REVISION);
+		GridData gd = new GridData (GridData.HORIZONTAL_ALIGN_CENTER);
+		gd.horizontalSpan = 2;		
+		lbl.setLayoutData (gd);
+		
+		lbl = new Label (shell, SWT.NULL);
+		lbl.setImage (SwtEngine.getImageRegistry().get("about.logo"));
+
+		lbl = new Label (shell, SWT.NULL);
+		lbl.setText ("R.M.H. Besseling\nS.P.M.Crijns\nI.Kaashoek\nM.M.Palm\n" +
+				"E.D Pelgrim\nT.A.J. Kelder\nM.P. van Iersel\nBiGCaT");
+		
+		final Button btnOk = new Button (shell, SWT.PUSH);
+		btnOk.setText ("OK");
+		gd = new GridData (GridData.HORIZONTAL_ALIGN_CENTER);
+		gd.horizontalSpan = 2;
+		gd.widthHint = 60;
+		btnOk.setLayoutData (gd);
+		
+		btnOk.addListener(SWT.Selection, new Listener() {
+			public void handleEvent (Event event) {
+					shell.dispose();
+			}
+		});
+			
+		shell.pack();
+		shell.open();
+		
+		Display display = parent.getDisplay();
+		while (!shell.isDisposed())
+		{
+			if (!display.readAndDispatch())
+				display.sleep();			
+		}
+	}
+}

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/AboutDlg.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/NewElementAction.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/NewElementAction.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/gui/swt/NewElementAction.java	(revision 957)
@@ -0,0 +1,225 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+
+package org.pathvisio.gui.swt;
+
+import java.net.URL;
+import java.util.Vector;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.action.ActionContributionItem;
+import org.eclipse.jface.action.IMenuCreator;
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Menu;
+import org.pathvisio.Engine;
+import org.pathvisio.view.VPathway;
+
+/**
+ * {@link Action} to add a new element to the gpml pathway
+ */
+public class NewElementAction extends Action
+{
+	MainWindow window;
+	int element;
+		
+	/**
+	 * Constructor for this class
+	 * @param e	type of element this action adds; a {@link VPathway} field constant
+	 */
+	public NewElementAction (int e)
+	{
+		// TODO: this should be moved to CommonActions, since it is both in v1 and v2
+		element = e;
+		
+		String toolTipText;
+		URL imageURL = null;
+		toolTipText = null;
+		switch(element) {
+		case VPathway.NEWLINE: 
+			toolTipText = "Draw new line";
+			imageURL = Engine.getResourceURL("icons/newline.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLINEARROW:
+			toolTipText = "Draw new arrow";
+			imageURL = Engine.getResourceURL("icons/newarrow.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLINEDASHED:
+			toolTipText = "Draw new dashed line";
+			imageURL = Engine.getResourceURL("icons/newdashedline.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLINEDASHEDARROW:
+			toolTipText = "Draw new dashed arrow";
+			imageURL = Engine.getResourceURL("icons/newdashedarrow.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLABEL:
+			toolTipText = "Draw new label";
+			imageURL = Engine.getResourceURL("icons/newlabel.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWARC:
+			toolTipText = "Draw new arc";
+			imageURL = Engine.getResourceURL("icons/newarc.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWBRACE:
+			toolTipText = "Draw new brace";
+			imageURL = Engine.getResourceURL("icons/newbrace.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWGENEPRODUCT:
+			toolTipText = "Draw new geneproduct";
+			imageURL = Engine.getResourceURL("icons/newgeneproduct.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWRECTANGLE:
+			imageURL = Engine.getResourceURL("icons/newrectangle.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWOVAL:
+			toolTipText = "Draw new oval";
+			imageURL = Engine.getResourceURL("icons/newoval.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWTBAR:
+			toolTipText = "Draw new TBar";
+			imageURL = Engine.getResourceURL("icons/newtbar.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWRECEPTORROUND:
+			toolTipText = "Draw new round receptor";
+			imageURL = Engine.getResourceURL("icons/newreceptorround.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWRECEPTORSQUARE:
+			toolTipText = "Draw new square receptor";
+			imageURL = Engine.getResourceURL("icons/newreceptorsquare.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLIGANDROUND:
+			toolTipText = "Draw new round ligand";
+			imageURL = Engine.getResourceURL("icons/newligandround.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLIGANDSQUARE:
+			toolTipText = "Draw new square ligand";
+			imageURL = Engine.getResourceURL("icons/newligandsquare.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLINEMENU:
+			setMenuCreator(new NewItemMenuCreator(VPathway.NEWLINEMENU));
+			imageURL = Engine.getResourceURL("icons/newlinemenu.gif");
+			toolTipText = "Draw new line or arrow";
+			break;
+		case VPathway.NEWLINESHAPEMENU:
+			setMenuCreator(new NewItemMenuCreator(VPathway.NEWLINESHAPEMENU));
+			imageURL = Engine.getResourceURL("icons/newlineshapemenu.gif");
+			toolTipText = "Draw new ligand or receptor";
+			break;
+		}
+		setToolTipText(toolTipText);
+		setId("newItemAction");
+		if(imageURL != null) setImageDescriptor(ImageDescriptor.createFromURL(imageURL));
+	}
+				
+	public void run () {
+		if(isChecked())
+		{
+			SwtEngine.getWindow().deselectNewItemActions();
+			setChecked(true);
+			Engine.getActiveVPathway().setNewGraphics(element);
+		}
+		else
+		{	
+			Engine.getActiveVPathway().setNewGraphics(VPathway.NEWNONE);
+		}
+	}
+
+	/**
+	 * {@link IMenuCreator} that creates the drop down menus for 
+	 * adding new line-type and -shape elements
+	 */
+	private class NewItemMenuCreator implements IMenuCreator
+	{
+		private Menu menu;
+		int element;
+		
+		/**
+		 * Constructor for this class
+		 * @param e	type of menu to create; one of {@link VPathway}.NEWLINEMENU
+		 * , {@link VPathway}.NEWLINESHAPEMENU
+		 */
+		public NewItemMenuCreator(int e) 
+		{
+			element = e;
+		}
+		
+		public Menu getMenu(Menu parent)
+		{
+			return null;
+		}
+
+		public Menu getMenu(Control parent)
+		{
+			if (menu != null)
+				menu.dispose();
+			
+			menu = new Menu(parent);
+			Vector<Action> actions = new Vector<Action>();
+			switch(element)
+			{
+			case VPathway.NEWLINEMENU:
+				actions.add(new NewElementAction(VPathway.NEWLINE));
+				actions.add(new NewElementAction(VPathway.NEWLINEARROW));
+				actions.add(new NewElementAction(VPathway.NEWLINEDASHED));
+				actions.add(new NewElementAction(VPathway.NEWLINEDASHEDARROW));
+				break;
+			case VPathway.NEWLINESHAPEMENU:
+				actions.add(new NewElementAction(VPathway.NEWLIGANDROUND));
+				actions.add(new NewElementAction(VPathway.NEWRECEPTORROUND));
+				actions.add(new NewElementAction(VPathway.NEWLIGANDSQUARE));
+				actions.add(new NewElementAction(VPathway.NEWRECEPTORSQUARE));
+			}
+			
+			for (Action act : actions)
+			{			
+				addActionToMenu(menu, act);
+			}
+
+			return menu;
+		}
+		
+		protected void addActionToMenu(Menu parent, Action a)
+		{
+			ActionContributionItem item = new ActionContributionItem(a);
+			item.fill(parent, -1);
+		}
+		
+		public void dispose() 
+		{
+			if (menu != null)  {
+				menu.dispose();
+				menu = null;
+			}
+		}
+	}
+
+}

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/NewElementAction.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/GdbCellEditor.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/GdbCellEditor.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/gui/swt/GdbCellEditor.java	(revision 957)
@@ -0,0 +1,262 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Statement;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.FocusAdapter;
+import org.eclipse.swt.events.FocusEvent;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Layout;
+import org.pathvisio.Engine;
+import org.pathvisio.data.DataSources;
+import org.pathvisio.data.Gdb;
+import org.pathvisio.gui.swt.PropertyPanel.AutoFillData;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.PropertyType;
+import org.pathvisio.util.SuggestCellEditor;
+import org.pathvisio.util.SuggestCombo;
+import org.pathvisio.util.SuggestCombo.SuggestionListener;
+import org.pathvisio.util.SuggestCombo.SuggestionProvider;
+
+public class GdbCellEditor extends SuggestCellEditor implements SuggestionProvider, SuggestionListener {
+	public static final int TYPE_IDENTIFIER = 0;
+	public static final int TYPE_SYMBOL = 1;
+	int type;
+	
+	public static final int NO_LIMIT = 0;
+	public static final int NO_TIMEOUT = 0;
+	public static int query_timeout = 5; //seconds
+	
+	HashMap<String, PropertyPanel.AutoFillData> suggested;
+	
+	Button button;
+	
+	GdbCellEditor(Composite parent, int type) {
+		super();
+		this.type = type;
+		create(parent); //Set type before creating contol
+		suggestCombo.addSuggetsionListener(this);
+		suggested = new HashMap<String, PropertyPanel.AutoFillData>();
+	}
+		
+	protected Control createControl(Composite parent) {
+		if(type == TYPE_IDENTIFIER) {
+			Composite comp = new Composite(parent, SWT.NULL);
+			super.createControl(comp);
+			button = new Button(comp, SWT.PUSH);
+			button.setText("Set Label");
+			button.setToolTipText("Set the Label property by looking up the gene symbol in the synonym database");
+			button.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					Object value = doGetValue();
+					if(value instanceof AutoFillData) {
+						AutoFillData afd = (AutoFillData) value;
+						afd.setDoGuessData(true);
+						fireApplyEditorValue();
+						afd.setDoGuessData(false);
+					}
+				}
+			});
+			comp.setLayout(new CellLayout());
+			return comp;
+		} else {
+			return super.createControl(parent);
+		}
+	}
+	
+	protected void setFocusListeners() {
+        suggestCombo.getControl().addFocusListener(new FocusAdapter() {
+            public void focusLost(FocusEvent e) {
+            	if(!suggestCombo.isSuggestFocus() &&
+            		(button != null && !button.isFocusControl())) { //Also check focus on button
+            		GdbCellEditor.this.focusLost();
+            	}
+            }
+        });
+	}
+	
+    private class CellLayout extends Layout {
+    	//Adapted from DialogCellEditor
+        public void layout(Composite editor, boolean force) {
+            Rectangle bounds = editor.getClientArea();
+            Point size = button.computeSize(SWT.DEFAULT, SWT.DEFAULT, force);
+			suggestCombo.setBounds(0, 0, bounds.width - size.x, bounds.height);
+            button.setBounds(bounds.width - size.x, 0, size.x, bounds.height);
+        }
+
+        public Point computeSize(Composite editor, int wHint, int hHint,
+                boolean force) {
+            if (wHint != SWT.DEFAULT && hHint != SWT.DEFAULT) {
+				return new Point(wHint, hHint);
+			}
+            Point contentsSize = suggestCombo.computeSize(SWT.DEFAULT, SWT.DEFAULT,
+                    force);
+            Point buttonSize = button.computeSize(SWT.DEFAULT, SWT.DEFAULT,
+            		force);
+            Point result = new Point(buttonSize.x, Math.max(contentsSize.y,
+            		buttonSize.y));
+            return result;
+        }
+    }
+
+    public String getLabel(AutoFillData adf) {
+    	String iddb = adf.getProperty(PropertyType.GENEID) + " (" +
+    	adf.getProperty(PropertyType.SYSTEMCODE) + ")";
+    	switch(type) {
+    	case TYPE_IDENTIFIER:
+    		return 	iddb;
+    	case TYPE_SYMBOL:
+    	default:
+    		return adf.getProperty(PropertyType.TEXTLABEL) + ": " + iddb;
+    	}
+				
+	}
+	
+	public SuggestionProvider getSuggestionProvider() {
+		return this;
+	}
+
+	public void suggestionSelected(String suggestion) {
+		suggestCombo.setText(suggestion);
+		fireApplyEditorValue();
+	}
+	
+	protected Object doGetValue() {
+		String text = suggestCombo.getText();
+		AutoFillData suggestion = suggested.get(text);
+		if(suggestion == null) {
+			suggested.put(text, suggestion = new GdbAutoFillData(getMainPropertyType(), text));
+		}
+		return suggestion;
+	}
+	
+	protected PropertyType getMainPropertyType() {
+		switch(type) {
+		case TYPE_IDENTIFIER:
+			return PropertyType.GENEID;
+		case TYPE_SYMBOL:
+		default:
+			return PropertyType.TEXTLABEL;
+		}
+	}
+	
+	public String[] getSuggestions(String text, SuggestCombo suggestCombo) {
+		int limit = getLimit();
+		
+		List<String> sugg = new ArrayList<String>();
+		try {
+			Statement s = Gdb.getCon().createStatement();
+			
+			s.setQueryTimeout(query_timeout);
+			if(limit > NO_LIMIT) s.setMaxRows(limit);
+			
+			String query = "";
+			switch(type) {
+			case TYPE_IDENTIFIER:
+				query =
+						"SELECT id, code FROM gene WHERE " +
+						"id LIKE '" + text + "%'";
+				break;
+			case TYPE_SYMBOL:
+			default:
+				query =
+						"SELECT id, code, backpageText FROM gene WHERE " +
+						"backpageText LIKE '%<TH>Gene Name:<TH>" + text + "%'";
+			}
+			
+			ResultSet r = s.executeQuery(query);
+	
+			while(r.next()) {
+				String sysCode = r.getString("code");
+				String sysName = DataSources.sysCode2Name.get(sysCode);
+				
+				AutoFillData adf = null;
+				switch(type) {
+				case TYPE_IDENTIFIER:
+					adf = new GdbAutoFillData(PropertyType.GENEID, r.getString("id"));
+					adf.setProperty(PropertyType.SYSTEMCODE, sysName);
+					break;
+				case TYPE_SYMBOL:
+				default:
+					String symbol = Gdb.parseGeneSymbol(r.getString("backpageText"));
+					adf = new GdbAutoFillData(PropertyType.TEXTLABEL, symbol);
+					adf.setProperty(PropertyType.SYSTEMCODE, sysName);
+					adf.setProperty(PropertyType.GENEID, r.getString("id"));
+					
+				}
+				
+				String label = getLabel(adf);
+				suggested.put(label, adf);
+				sugg.add(label);
+			}
+		} catch (SQLException e) {
+			Engine.log.error("Unable to query suggestions", e);
+		}
+		if(limit > NO_LIMIT && sugg.size() == limit) sugg.add("...results limited to " + limit);
+		return sugg.toArray(new String[sugg.size()]);
+	}
+
+	int getLimit() {
+		switch(type) {
+		case TYPE_IDENTIFIER:
+			return 100;
+		case TYPE_SYMBOL:
+		default:
+			return 100;
+		}
+	}
+
+	class GdbAutoFillData extends AutoFillData {
+		public GdbAutoFillData(PropertyType mainProperty, String mainValue) {
+			super(mainProperty, mainValue);
+		}
+		
+		protected void guessData(PathwayElement o) {
+			//Fetch info from self
+			String id = getProperty(PropertyType.GENEID);
+			String sysName = getProperty(PropertyType.SYSTEMCODE);
+			
+			//If null, fetch from dataobject
+			if(id == null) id = (String)o.getProperty(PropertyType.GENEID);
+			if(sysName == null) sysName = (String)o.getProperty(PropertyType.SYSTEMCODE);
+			
+			String code = sysName == null ? null : DataSources.sysName2Code.get(sysName);
+			
+			//Guess symbol
+			if(id != null && code != null) {
+				String symbol = Gdb.getGeneSymbol(id, code);
+				if(symbol != null) {
+					setProperty(PropertyType.TEXTLABEL, symbol);
+				}
+			}
+		}
+	}
+
+}
Index: trunk/src/swt/org/pathvisio/gui/swt/SwtEngine.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/SwtEngine.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/gui/swt/SwtEngine.java	(revision 957)
@@ -0,0 +1,443 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.io.File;
+import java.lang.reflect.InvocationTargetException;
+import java.net.URL;
+import java.util.List;
+
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.jface.dialogs.IDialogConstants;
+import org.eclipse.jface.dialogs.MessageDialog;
+import org.eclipse.jface.dialogs.ProgressMonitorDialog;
+import org.eclipse.jface.resource.ImageRegistry;
+import org.eclipse.jface.window.ApplicationWindow;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.graphics.DeviceData;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.FileDialog;
+import org.eclipse.swt.widgets.Shell;
+import org.pathvisio.Engine;
+import org.pathvisio.Globals;
+import org.pathvisio.Engine.ApplicationEvent;
+import org.pathvisio.debug.Sleak;
+import org.pathvisio.model.ConverterException;
+import org.pathvisio.model.Pathway;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.preferences.PreferenceCollection;
+import org.pathvisio.preferences.swt.SwtPreferences;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.util.SwtUtils.SimpleRunnableWithProgress;
+import org.pathvisio.view.VPathway;
+
+import edu.stanford.ejalbert.BrowserLauncher;
+import edu.stanford.ejalbert.exception.BrowserLaunchingExecutionException;
+import edu.stanford.ejalbert.exception.BrowserLaunchingInitializingException;
+import edu.stanford.ejalbert.exception.UnsupportedOperatingSystemException;
+
+/**
+ This class contains the essential parts of the program: the window, drawing and gpml data
+ It takes care of some basic Document handling facilities such as:
+ - creating a new document
+ - load / save / save as
+ - asking if a changed file should be saved before closing
+ */
+public class SwtEngine {
+	/**
+	 * {@link Pathway} object containing JDOM representation of the gpml pathway 
+	 * and handle gpml related actions
+	 */
+	
+	private static MainWindow window;
+	
+	private static ImageRegistry imageRegistry;
+	private static PreferenceCollection preferences;
+	
+	private static File DIR_APPLICATION;
+	private static File DIR_DATA;
+	static boolean USE_R;
+		
+	/**
+	 * application global clipboard.
+	 */
+	public static List<PathwayElement> clipboard = null;
+
+	/**
+	   Checks if the current pathway has changes, and if so, pops up a dialog
+	   offering to save.
+	   This should always be called before you change pathway
+
+	   @return returns false if the user pressed cancel. 
+	   
+	   TODO: Currently always asks, even if there were no changes since last save.
+	 */
+	static public boolean canDiscardPathway()
+	{
+		// checking not necessary if there is no pathway.
+		if (Engine.getActivePathway() == null) return true;
+		String[] opts =
+		{
+			IDialogConstants.YES_LABEL,
+			IDialogConstants.NO_LABEL,
+			IDialogConstants.CANCEL_LABEL
+		};
+		MessageDialog msgDlg = new MessageDialog (
+			window.getShell(),
+			"Save changes?",
+			null,
+			"Your pathway may have changed. Do you want to save?",
+			MessageDialog.QUESTION,
+			opts,
+			0);
+		int result = msgDlg.open();
+		if (result == 2) // cancel
+		{
+			return false;
+		}
+		else if (result == 0) // yes
+		{
+			// return false if save is cancelled.
+			return (savePathway());
+		}
+		// no
+		return true;
+	}
+	
+	public static void doOpenWebPage(String url) throws BrowserLaunchingInitializingException, BrowserLaunchingExecutionException, UnsupportedOperatingSystemException {
+		BrowserLauncher bl = new BrowserLauncher(null);
+		bl.openURLinBrowser(url);
+	}
+	
+	/**
+	 * Get the working directory of this application
+	 */
+	public static File getApplicationDir() {
+		if(DIR_APPLICATION == null) {
+			DIR_APPLICATION = new File(System.getProperty("user.home"), "." + Globals.APPLICATION_NAME);
+			if(!DIR_APPLICATION.exists()) DIR_APPLICATION.mkdir();
+		}
+		return DIR_APPLICATION;
+	}
+	
+	public static File getDataDir() {
+		if(DIR_DATA == null) {
+			DIR_DATA = new File(System.getProperty("user.home"), Globals.APPLICATION_NAME + "-Data");
+			if(!DIR_DATA.exists()) DIR_DATA.mkdir();
+		}
+		return DIR_DATA;
+	}
+		
+	/**
+	 * Get the {@link ImageRegistry} containing commonly used images
+	 */
+	public static ImageRegistry getImageRegistry() { 
+		if(imageRegistry == null) imageRegistry = new ImageRegistry();
+		return imageRegistry; 
+	}
+	
+	/**
+	 * Get the {@link SwtPreferences} containing the user preferences
+	 */
+	public static PreferenceCollection getPreferences() { 
+		if(preferences == null) preferences = new SwtPreferences();
+		return preferences; 
+	}
+	
+	/**
+	 * Get the {@link URL} for the resource stored in a jar file in the classpath
+	 * @param name	the filename of the resource
+	 * @return the URL pointing to the resource
+	 */
+	public static URL getResourceURL(String name) {
+		URL url = SwtEngine.class.getClassLoader().getResource(name);
+		if(url == null) Engine.log.error("Couldn't load resource '" + name + "'");
+		return url;
+	}
+		
+	/**
+	 * Initiates an instance of {@link MainWindow} that is monitored by Sleak.java,
+	 * to monitor what handles (to OS device context) are in use. For debug purposes only 
+	 * (to check for undisposed widgets)
+	 * @return The {@link MainWindow} monitored by Sleak.java
+	 */
+	public static MainWindow getSleakWindow() {
+		//<DEBUG to find undisposed system resources>
+		DeviceData data = new DeviceData();
+		data.tracking = true;
+		Display display = new Display(data);
+		Sleak sleak = new Sleak();
+		sleak.open();
+		
+		Shell shell = new Shell(display);
+		window = new MainWindow(shell);
+		return window;
+		//</DEBUG>
+	}
+	
+	/**
+	 * Get the {@link ApplicationWindow}, the UI of the program
+	 */
+	public static MainWindow getWindow() {
+		if(window == null) window = new MainWindow();
+		return window;
+	}
+	
+	public static boolean isUseR() { return USE_R; }
+
+	/**
+	 Create a new pathway (drawing + gpml data)
+	 Asks to discard an existing pathway
+	 */
+	public static void newPathway()
+	{
+		if (canDiscardPathway())
+		{
+			Pathway pathway = new Pathway();
+			pathway.initMappInfo();
+			VPathway vPathway = getWindow().createNewDrawing();
+			vPathway.fromGmmlData(pathway);
+			Engine.setActiveVPathway(pathway, vPathway);
+			Engine.fireApplicationEvent(new ApplicationEvent(vPathway, ApplicationEvent.PATHWAY_OPENED));
+			updateTitle();
+		}
+	}
+
+	/**
+	 Open a pathway from a gpml file
+	 Asks the user if the old pathway should be discarded, if necessary
+	 */
+	public static void openPathway(String pwf)
+	{
+		if (canDiscardPathway())
+		{
+			Pathway _gmmlData = null;
+			VPathway _drawing = getWindow().createNewDrawing();
+			
+			// initialize new JDOM gpml representation and read the file
+			try { 
+				Engine.openPathway(pwf);
+			} catch(ConverterException e) {		
+				if (e.getMessage().contains("Cannot find the declaration of element 'Pathway'"))
+				{
+					MessageDialog.openError(getWindow().getShell(), 
+						"Unable to open Gpml file", 
+						"Unable to open Gpml file.\n\n" +
+						"The most likely cause for this error is that you are trying to open an old Gpml file. " +
+						"Please note that the Gpml format has changed as of March 2007. " +
+						"The standard pathway set can be re-downloaded from http://pathvisio.org " +
+						"Non-standard pathways need to be recreated or upgraded. " +
+						"Please contact the authors at martijn.vaniersel@bigcat.unimaas.nl if you need help with this.\n" +
+						"\nSee error log for details");
+					Engine.log.error("Unable to open Gpml file", e);
+				}
+				else
+				{
+					MessageDialog.openError(getWindow().getShell(), 
+											"Unable to open Gpml file", e.getClass() + e.getMessage());
+					Engine.log.error("Unable to open Gpml file", e);
+				}
+			}
+			
+			if(_gmmlData != null) //Only continue if the data is correctly loaded
+			{
+				_drawing.fromGmmlData(_gmmlData);
+				Engine.setActiveVPathway(_gmmlData, _drawing);
+				updateTitle();
+				Engine.fireApplicationEvent(new ApplicationEvent(_drawing, ApplicationEvent.PATHWAY_OPENED));
+			}
+		}
+	}
+	
+	/**
+	   Opens a URL in the default webbrowser.  Uses a progress dialog
+	   if it takes a long time.  Shows an error message and returns
+	   false if it somehow failed to open the web page.
+	*/
+	public static boolean openWebPage(String url, String progressMsg, String errMsg) {
+		Shell shell = getWindow().getShell();
+		if(shell == null || shell.isDisposed()) return false;
+		
+		SimpleRunnableWithProgress rwp = new SimpleRunnableWithProgress(
+				Engine.class, "doOpenWebPage", new Class[] { String.class }, new Object[] { url }, null);
+		SimpleRunnableWithProgress.setMonitorInfo(progressMsg, IProgressMonitor.UNKNOWN);
+		ProgressMonitorDialog dialog = new ProgressMonitorDialog(shell);
+		try {
+			dialog.run(true, true, rwp);
+			return true;
+		} catch (InvocationTargetException e) {
+			Throwable cause = e.getCause();
+			String msg = cause == null ? null : cause.getMessage();
+			MessageDialog.openError(shell, "Error",
+			"Unable to open web browser" +
+			(msg == null ? "" : ": " + msg) +
+			"\n" + errMsg);
+			return false;
+		} catch (InterruptedException ignore) { return false; }
+	}
+	
+	/**
+	   save the current pathway
+	   returns false if the action was cancelled by the user
+	   
+	   Calls savePathwayAs if the filename of the current pathway is unknown,
+	   so that the user can set a location for this pathway
+	*/
+		public static boolean savePathway()
+		{
+			Pathway pathway = Engine.getActivePathway();
+			VPathway vPathway = Engine.getActiveVPathway();
+			
+			boolean result = true;
+			
+			double usedZoom = vPathway.getPctZoom();
+			// Set zoom to 100%
+			vPathway.setPctZoom(100);			
+			
+	        // Overwrite the existing xml file.
+			// If the target file is read-only, let the user select a new pathway
+			if (pathway.getSourceFile() != null && pathway.getSourceFile().canWrite())
+			{
+				try
+				{
+					Engine.savePathway();
+				}
+				catch (ConverterException e)
+				{
+					String msg = "While writing xml to " 
+						+ pathway.getSourceFile().getAbsolutePath();					
+					MessageDialog.openError (window.getShell(), "Error", 
+											 "Error: " + msg + "\n\n" + 
+											 "See the error log for details.");
+					Engine.log.error(msg, e);
+				}
+			}
+			else
+			{
+				result = savePathwayAs();
+			}
+			// Set zoom back
+			vPathway.setPctZoom(usedZoom);
+
+			return result;
+		}
+		
+	/**
+	   Opens a file dialog and lets user select a file.
+	   Then the pathways is saved to that file.
+	   returns false if the action was cancelled by the user
+	 */
+	public static boolean savePathwayAs()
+	{
+		Pathway pathway = Engine.getActivePathway();
+		VPathway vPathway = Engine.getActiveVPathway();
+		
+		// Check if a gpml pathway is loaded
+		if (pathway != null)
+		{
+			FileDialog fd = new FileDialog(window.getShell(), SWT.SAVE);
+			fd.setText("Save");
+			fd.setFilterExtensions(new String[] {"*." + Engine.PATHWAY_FILE_EXTENSION, "*.*"});
+			fd.setFilterNames(new String[] {Engine.PATHWAY_FILTER_NAME, "All files (*.*)"});
+			
+			File xmlFile = pathway.getSourceFile();
+			if(xmlFile != null) {
+				fd.setFileName(xmlFile.getName());
+				fd.setFilterPath(xmlFile.getPath());
+			} else {
+					fd.setFilterPath(SwtPreference.SWT_DIR_PWFILES.getValue());
+			}
+			String fileName = fd.open();
+			// Only proceed if user selected a file
+			
+			if(fileName == null) return false;
+			
+			// Append .gpml extension if not already present
+			if(!fileName.endsWith("." + Engine.PATHWAY_FILE_EXTENSION)) 
+				fileName += "." + Engine.PATHWAY_FILE_EXTENSION;
+			
+			File checkFile = new File(fileName);
+			boolean confirmed = true;
+			// If file exists, ask overwrite permission
+			if(checkFile.exists())
+			{
+				confirmed = MessageDialog.openQuestion(window.getShell(),"",
+													   "File already exists, overwrite?");
+			}
+			if(confirmed)
+			{
+				double usedZoom = vPathway.getPctZoom();
+				// Set zoom to 100%
+				vPathway.setPctZoom(100);					
+				// Overwrite the existing xml file
+				try
+				{
+					Engine.savePathway(checkFile);
+					updateTitle();
+					// Set zoom back
+					vPathway.setPctZoom(usedZoom);
+				}
+				catch (ConverterException e)
+				{
+					String msg = "While writing xml to " 
+						+ checkFile.getAbsolutePath();					
+					MessageDialog.openError (window.getShell(), "Error", 
+											 "Error: " + msg + "\n\n" + 
+											 "See the error log for details.");
+					Engine.log.error(msg, e);
+				}
+			}
+		}
+		else
+		{
+			MessageDialog.openError (window.getShell(), "Error", 
+									 "No gpml file loaded! Open or create a new gpml file first");
+		}			
+		return true;
+	}
+	
+	/**
+	 * Set the {@link ImageRegistry} containing commonly used images
+	 */
+	public static void setImageRegistry(ImageRegistry _imageRegistry) {
+		imageRegistry = _imageRegistry;
+	}
+	
+	/**
+	   Updates the title of the main window.
+	   Call at initialization of the program,
+	   whenever the filename of the current document has changed,
+	   or the change status has changed.
+	*/
+	public static void updateTitle()
+	{
+		if (Engine.getActivePathway() == null)
+		{
+			window.getShell().setText(Globals.APPLICATION_VERSION_NAME);
+		}
+		else
+		{
+			// get filename, or (New Pathway) if current pathway hasn't been opened yet
+			String fname = (Engine.getActivePathway().getSourceFile() == null) ? "(New Pathway)" :
+				Engine.getActivePathway().getSourceFile().getName();
+			window.getShell().setText(
+				"*" + fname + " - " +
+				Globals.APPLICATION_VERSION_NAME
+				);
+		}
+	}
+}
\ No newline at end of file

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/SwtEngine.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/PropertyPanel.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/PropertyPanel.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/gui/swt/PropertyPanel.java	(revision 957)
@@ -0,0 +1,657 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.awt.Color;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Set;
+
+import org.eclipse.jface.viewers.ArrayContentProvider;
+import org.eclipse.jface.viewers.CellEditor;
+import org.eclipse.jface.viewers.ColorCellEditor;
+import org.eclipse.jface.viewers.ComboBoxCellEditor;
+import org.eclipse.jface.viewers.ICellModifier;
+import org.eclipse.jface.viewers.ILabelProviderListener;
+import org.eclipse.jface.viewers.IStructuredContentProvider;
+import org.eclipse.jface.viewers.ITableLabelProvider;
+import org.eclipse.jface.viewers.TableViewer;
+import org.eclipse.jface.viewers.TextCellEditor;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.graphics.RGB;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Table;
+import org.eclipse.swt.widgets.TableColumn;
+import org.eclipse.swt.widgets.TableItem;
+import org.pathvisio.Engine;
+import org.pathvisio.biopax.gui.BiopaxCellEditor;
+import org.pathvisio.data.DataSources;
+import org.pathvisio.model.DataNodeType;
+import org.pathvisio.model.LineStyle;
+import org.pathvisio.model.LineType;
+import org.pathvisio.model.MappFormat;
+import org.pathvisio.model.ObjectType;
+import org.pathvisio.model.OrientationType;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.PathwayEvent;
+import org.pathvisio.model.PathwayListener;
+import org.pathvisio.model.PropertyClass;
+import org.pathvisio.model.PropertyType;
+import org.pathvisio.model.ShapeType;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.util.ColorConverter;
+import org.pathvisio.util.SuggestCellEditor;
+import org.pathvisio.util.TableColumnResizer;
+import org.pathvisio.view.Graphics;
+import org.pathvisio.view.SelectionBox;
+import org.pathvisio.view.SelectionBox.SelectionEvent;
+import org.pathvisio.view.SelectionBox.SelectionListener;
+
+/**
+ * This class implements the sidepanel where you can edit graphical properties
+ * of each object on the pathway.
+ */
+public class PropertyPanel extends Composite implements PathwayListener, SelectionListener {
+	public TableViewer tableViewer;
+	CellEditor[] cellEditors = new CellEditor[2];
+	TextCellEditor textEditor;
+	ColorCellEditor colorEditor;
+	ComboBoxCellEditor comboBoxEditor;
+	SuggestCellEditor identifierSuggestEditor;
+	SuggestCellEditor symbolSuggestEditor;
+	BiopaxCellEditor biopaxEditor;
+	
+	private List<PathwayElement> dataObjects;
+	
+	private List<PropertyType> attributes;
+	
+	final static int TYPES_DIFF = ObjectType.MIN_VALID -1;
+	final static Object VALUE_DIFF = new Object() {
+		public boolean equals(Object o) { return false; }
+		public String toString() { return "different values"; }
+	};
+
+	/**
+	 * Add a {@link PathwayElement} to the list of objects of which 
+	 * the properties are displayed
+	 * @param o
+	 */
+	public void addGmmlDataObject(PathwayElement o) {
+		if(!dataObjects.contains(o)) {
+			if(dataObjects.add(o)) {
+				o.addListener(this);
+				refresh();
+			}
+		}
+	}
+	
+	/**
+	 * Remove a {@link PathwayElement} from the list of objects of which 
+	 * the properties are displayed
+	 * @param o
+	 */
+	public void removeGmmlDataObject(PathwayElement o) {
+		if(dataObjects.remove(o)) {
+			o.removeListener(this);
+			refresh();
+		}
+	}
+	
+	/**
+	 * Clear the list of objects of which the properties are displayed
+	 */
+	public void clearGmmlDataObjects() {
+		for(PathwayElement o : dataObjects) o.removeListener(this);
+		dataObjects.clear();
+		refresh();
+	}
+	
+	/**
+	 * Refresh the table and attributes to display
+	 */
+	void refresh() {
+		setAttributes();
+		tableViewer.refresh();
+	}
+	
+	int getAggregateType() {
+		int type = TYPES_DIFF;
+		for(int i = 0; i < dataObjects.size(); i++) {
+			PathwayElement g = dataObjects.get(i);
+			
+			if(i != 0 && type != g.getObjectType()) return TYPES_DIFF;
+			
+			type = g.getObjectType();
+		}
+		return type;
+	}
+	
+	Object getAggregateValue(PropertyType key) {
+		Object value = VALUE_DIFF;
+		for(int i = 0; i < dataObjects.size(); i++) {
+			PathwayElement g = dataObjects.get(i);
+			Object o = g.getProperty(key);
+			if(i != 0 && (o == null || !o.equals(value))) return VALUE_DIFF;
+
+			value = o;
+		}
+		return value;
+	}
+		
+	/**
+	 * Sets the attributes for the selected objects
+	 * Only attributes that are present in all objects in the selection will be
+	 * added to the attributes list and shown in the property table
+	 */
+	public void setAttributes ()
+	{
+		HashMap<PropertyType, Integer> master = new HashMap<PropertyType, Integer>();
+		for (PathwayElement o : dataObjects)
+		{
+			// get attributes. Only get advanced attributes if the preferences say so.
+			for (PropertyType attr : o.getAttributes(
+					 GlobalPreference.getValueBoolean(SwtPreference.SWT_SHOW_ADVANCED_ATTR)))
+			{
+				if (master.containsKey(attr))
+				{
+					// increment
+					master.put(attr, master.get(attr) + 1);
+				}
+				else
+				{
+					// set to 1
+					master.put(attr, 1);
+				}
+			}
+		}
+		attributes.clear();
+		for (PropertyType attr : master.keySet())
+		{
+			if (master.get(attr) == dataObjects.size())
+			{
+				attributes.add(attr);
+			}
+		}
+		// sortAttributes();
+		Collections.sort (attributes);		
+	}
+	
+//	void sortAttributes() {
+//		Collections.sort(attributes, new Comparator() {
+//			public int compare(Object o1, Object o2) {
+//				return o1.ordinal() - o2.ordinal();
+//			}
+//		});
+//	}
+
+	final static String[] colNames = new String[] {"Property", "Value"};
+				
+	PropertyPanel(Composite parent, int style)
+	{
+		super(parent, style);
+		setLayout(new FillLayout());
+		Table t = new Table(this, style);
+		TableColumn tcName = new TableColumn(t, SWT.LEFT);
+		TableColumn tcValue = new TableColumn(t, SWT.LEFT);
+		tcName.setText(colNames[0]);
+		tcValue.setText(colNames[1]);
+		tcName.setWidth(80);
+		tcValue.setWidth(70);
+		tableViewer = new TableViewer(t);
+		tableViewer.getTable().setLinesVisible(true);
+		tableViewer.getTable().setHeaderVisible(true);
+		tableViewer.setContentProvider(tableContentProvider);
+		tableViewer.setLabelProvider(tableLabelProvider);
+		
+		cellEditors[1] = cellEditors[0] = textEditor = new TextCellEditor(tableViewer.getTable());
+		colorEditor = new ColorCellEditor(tableViewer.getTable());
+		comboBoxEditor = new ComboBoxCellEditor(tableViewer.getTable(), new String[] {""});
+		identifierSuggestEditor = new GdbCellEditor(tableViewer.getTable(), GdbCellEditor.TYPE_IDENTIFIER);
+		symbolSuggestEditor = new GdbCellEditor(tableViewer.getTable(), GdbCellEditor.TYPE_SYMBOL);
+		biopaxEditor = new BiopaxCellEditor(tableViewer.getTable(), "...");
+		
+		tableViewer.setCellEditors(cellEditors);
+		tableViewer.setColumnProperties(colNames);
+		tableViewer.setCellModifier(cellModifier);
+		
+		t.addControlListener(new TableColumnResizer(t, t.getParent()));
+		
+		dataObjects = new ArrayList<PathwayElement>();
+		attributes = new ArrayList<PropertyType>();
+		tableViewer.setInput(attributes);
+		
+		SelectionBox.addListener(this);
+	}
+	
+	/**
+	 * return the right cell editor for a certain object. Will return
+	 * one of existing editors. In the case of a list of possible values, 
+	 * a comboboxeditor will be set up with the proper values for
+	 * the drop down list.
+	 */
+	final static String[] orientation_names = OrientationType.getNames();
+	final static String[] linestyle_names = LineStyle.getNames();
+	final static String[] boolean_names = {"false", "true"};
+	final static String[] shape_names = ShapeType.getNames();
+	final static String[] linetype_names = LineType.getNames(); 
+	final static String[] genetype_names = DataNodeType.getNames();
+	
+	private CellEditor getCellEditor(Object element)
+	{
+		PropertyType key = (PropertyType)element;
+		PropertyClass type = key.type();
+		switch(type)
+		{
+			case FONT:				
+			case STRING:
+			case DOUBLE:
+			case ANGLE:
+			case INTEGER: 	return textEditor;
+			case COLOR: 	return colorEditor;
+			case LINETYPE:
+				comboBoxEditor.setItems(linetype_names);
+				return comboBoxEditor;
+			case SHAPETYPE:
+				comboBoxEditor.setItems(shape_names);
+				return comboBoxEditor;
+			case DATASOURCE:			
+				comboBoxEditor.setItems(DataSources.dataSources);
+				return comboBoxEditor;
+			case ORIENTATION:
+				comboBoxEditor.setItems(orientation_names);
+				return comboBoxEditor;
+			case LINESTYLE:
+				comboBoxEditor.setItems(linestyle_names);
+				return comboBoxEditor;
+			case BOOLEAN:
+				comboBoxEditor.setItems(boolean_names);
+				return comboBoxEditor;
+			case ORGANISM:
+				comboBoxEditor.setItems(MappFormat.organism_latin_name);
+				return comboBoxEditor;
+			case GENETYPE:
+				comboBoxEditor.setItems(genetype_names);
+				return comboBoxEditor;
+			case DB_ID:
+				return identifierSuggestEditor;
+			case DB_SYMBOL:
+				return textEditor;
+			case BIOPAXREF:
+				return biopaxEditor;
+				
+		}
+		return textEditor;
+	}
+	
+	private ICellModifier cellModifier = new ICellModifier()
+	{
+		public boolean canModify(Object element, String property) {
+			if (!colNames[1].equals(property))
+			{
+				return false;
+			}
+			
+			cellEditors[1] = getCellEditor(element);
+			return true;
+		}
+
+		/**
+		 * Getvalue is the value that is passed to the Cell Editor when it is 
+		 * activated.
+		 * It should return an Integer object for ComboboxCellEditors.
+		 */
+		public Object getValue(Object element, String property) 
+		{
+			PropertyType key = (PropertyType)element;
+			Object value = getAggregateValue(key);
+			if(value == VALUE_DIFF) {
+				return VALUE_DIFF.toString();
+			}
+			switch(key.type())
+			{
+				case ANGLE:
+				{
+					Double x = Math.round((Double)(value) * 1800.0 / Math.PI) / 10.0;
+					return x.toString();
+				}
+				case DOUBLE:
+				{
+					Double x = Math.round((Double)(value) * 100.0) / 100.0;
+					return x.toString();
+				}
+				case INTEGER: 
+					return value.toString();
+				case ORGANISM:
+					return Arrays.asList(MappFormat.organism_latin_name).indexOf((String)value);
+				case GENETYPE:
+					return Arrays.asList(genetype_names).indexOf((String)value);
+				case STRING:
+				case FONT:
+					return value == null ? "" : (String)value;
+				case DATASOURCE:
+					return DataSources.lDataSources.indexOf((String)value);				
+				// for all combobox types:
+				case BOOLEAN:
+					return ((Boolean)value) ? 1 : 0;
+				case SHAPETYPE:
+					return (((ShapeType)value).ordinal());
+				case LINETYPE:
+					return (((LineType)value).ordinal());
+				case COLOR:
+					if(value instanceof Color)
+						value = ColorConverter.toRGB((Color)value);
+					return (RGB)value;
+				case ORIENTATION:
+				case LINESTYLE:
+				{
+//					try 
+//					{
+						return (Integer)value;
+//					}
+//					catch (ClassCastException e)
+//					{
+//						MessageDialog.openWarning(getShell(), "warning", "Can't cast " + value + " to Integer!");
+//					}
+				}
+				case DB_ID:
+				case DB_SYMBOL:
+					if(value instanceof String) return (String)value;
+					if(value instanceof PropertyPanel.AutoFillData) 
+						return ((PropertyPanel.AutoFillData)value).getMainValue();
+				case BIOPAXREF:
+					return value;
+					
+			}
+			return null;
+		}
+		
+		public void modify(Object element, String property, Object value) {
+			PropertyType key = (PropertyType)((TableItem)element).getData();
+			
+			if(value == VALUE_DIFF || value == VALUE_DIFF.toString()) {
+				return;
+			}
+			/*
+			 * Here, we transform the output of the cell editor
+			 * to a value understood by PathwayElement.SetProperty().
+			 * 
+			 * The output of a comboboxCellEditor is Integer.
+			 * The output of a textCellEditor is String.
+			 * 
+			 * For linetype and shapetype we go from Integer to Integer. easy
+			 * For boolean, we go from Integer to Boolean
+			 * For Double / Integer, we go from String to Double
+			 * For Datasource, we go from Integer to String.
+			 */
+			switch(key.type())
+			{
+			case ANGLE: 	
+				try 
+				{ 
+					// convert degrees (property editor) to radians (model)
+					value = Double.parseDouble((String)value) * Math.PI / 180;					
+					break;
+				} 
+				catch(Exception e) 
+				{
+					// invalid input, ignore
+					return; 
+				}
+			case DOUBLE: 	
+				try 
+				{ 
+					value = Double.parseDouble((String)value); 
+					break; 
+				} 
+				catch(Exception e) 
+				{
+					// invalid input, ignore
+					return; 
+				}
+			case INTEGER: 	
+				try 
+				{ 
+					value = Integer.parseInt((String)value); 
+					break; 
+				}
+				catch(Exception e) 
+				{ 
+					// invalid input, ignore 
+					return; 
+				}
+			case DATASOURCE:
+				if((Integer)value == -1) return; //Nothing selected
+				value = DataSources.lDataSources.get((Integer)value);
+				break;
+			case BOOLEAN:
+				if ((Integer)value == 0)
+				{
+					value = new Boolean (false);
+				}
+				else
+				{
+					value = new Boolean (true);
+				}
+				break;
+			case ORGANISM:
+				if((Integer)value == -1) return; //Nothing selected
+				value = MappFormat.organism_latin_name[(Integer)value];
+				break;
+			case GENETYPE:
+				if((Integer)value == -1) return; //Nothing selected
+				value = genetype_names[(Integer)value];
+				break;
+			case COLOR:
+				value = ColorConverter.fromRGB((RGB)value);
+			case DB_SYMBOL:
+			case DB_ID:
+				if(value instanceof PropertyPanel.AutoFillData) {
+					PropertyPanel.AutoFillData adf = (PropertyPanel.AutoFillData)value;
+					for(PathwayElement o : dataObjects) {
+						if(o.getObjectType() == ObjectType.DATANODE) {
+							adf.fillData(o);
+						}
+					}
+					value = adf.getMainValue();
+				}
+				break;
+			}
+			for(PathwayElement o : dataObjects) {
+				o.setProperty(key, value);
+			}
+			tableViewer.refresh();
+			Engine.getActiveVPathway().redrawDirtyRect();
+		}
+	};
+	
+	private IStructuredContentProvider tableContentProvider = new ArrayContentProvider();
+	
+	private ITableLabelProvider tableLabelProvider = new ITableLabelProvider() {
+		public Image getColumnImage(Object element, int columnIndex) {
+			return null;
+		}
+		public String getColumnText(Object element, int columnIndex) {
+			PropertyType key = (PropertyType)element;
+			switch(columnIndex) {
+				case 0:
+					return key.desc();					
+				case 1:
+					//TODO: prettier labels for different value types
+					if(attributes.contains(key))
+					{
+						Object value = getAggregateValue(key);
+						if (value == null)
+						{
+							return null;
+						}
+						else 
+						{
+							switch (key.type())
+							{
+								case ANGLE:
+								{
+									if (value instanceof Double)
+									{
+										Double x = Math.round((Double)(value) * 1800.0 / Math.PI) / 10.0;
+										return x.toString();
+									}
+									else
+										return value.toString();
+								}
+								case DOUBLE:								
+									if (value instanceof Double)
+									{
+										Double x = Math.round((Double)(value) * 10.0) / 10.0;
+										return x.toString();
+									}
+									else
+										return value.toString();
+										
+								case BOOLEAN:
+								{
+									if (value instanceof Boolean)
+									{
+										return (Boolean)(value) ? "true" : "false";
+									}
+									else
+										return value.toString();
+								}
+								case LINETYPE:
+								{
+									if (value instanceof Integer)
+										return linetype_names[(Integer)(value)];
+									else
+										return value.toString();
+								}
+								case LINESTYLE:
+								{
+									if (value instanceof Integer)
+										return linestyle_names[(Integer)(value)];
+									else
+										return value.toString();
+								}
+								case ORIENTATION:
+								{
+									if (value instanceof Integer)
+										return orientation_names[(Integer)(value)];
+									else
+										return value.toString();									
+								}
+								case SHAPETYPE:
+								{
+									if (value instanceof Integer)
+										return shape_names[(Integer)(value)];
+									else
+										return value.toString();
+								}
+								case COLOR:
+									if(value instanceof Color) {
+										return ColorConverter.toRGB((Color)value).toString();
+									}
+								default:
+									return value.toString();
+							}
+						}
+					}
+			}
+			return null;
+			}
+		
+		public void addListener(ILabelProviderListener listener) { }
+		public void dispose() {}
+		public boolean isLabelProperty(Object element, String property) {
+			return false;
+		}
+		public void removeListener(ILabelProviderListener listener) { }
+	};
+
+	public void gmmlObjectModified(PathwayEvent e) {
+		tableViewer.refresh();
+	}
+
+	//TODO: implement all attribute types as subclasses of MyType.
+//	class MyType {
+//		abstract String getColumnText(Object value);
+//		abstract Object adjustedValue(Object value);
+//		abstract CellEditor getCellEditor()
+//	}
+	
+	public void drawingEvent(SelectionEvent e) {
+		switch(e.type) {
+		case SelectionEvent.OBJECT_ADDED:
+			if(e.affectedObject instanceof Graphics)
+				addGmmlDataObject(((Graphics)e.affectedObject).getGmmlData());
+			break;
+		case SelectionEvent.OBJECT_REMOVED:
+			if(e.affectedObject instanceof Graphics)
+				removeGmmlDataObject(((Graphics)e.affectedObject).getGmmlData());
+			break;
+		case SelectionEvent.SELECTION_CLEARED:
+			 clearGmmlDataObjects();
+			break;
+		}
+		
+	}
+
+	static class AutoFillData {
+		PropertyType mProp;
+		Object mValue;
+		HashMap<PropertyType, String> values;
+		
+		private boolean doGuess = false;
+		
+		public AutoFillData(PropertyType mainProperty, String mainValue) {
+			values = new HashMap<PropertyType, String>();
+			mProp = mainProperty;
+			mValue = mainValue;
+			setProperty(mainProperty, mainValue);
+		}
+		
+		public void setProperty(PropertyType property, String value) {
+			values.put(property, value);
+		}
+		
+		public PropertyType getMainProperty() { return mProp; }
+		public Object getMainValue() { return mValue; }
+		
+		public String getProperty(PropertyType property) { return values.get(property); }
+		
+		public Set<PropertyType> getProperties() { return values.keySet(); }
+		
+		public void fillData(PathwayElement o) {
+			if(doGuess) guessData(o);
+			for(PropertyType p : getProperties()) {
+				Object vNew = getProperty(p);
+				o.setProperty(p, vNew);
+			}
+		}
+		
+		public void setDoGuessData(boolean doGuessData) {
+			doGuess = doGuessData;
+		}
+		
+		protected void guessData(PathwayElement o) {
+		}
+	}
+}
+

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/PropertyPanel.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/SidePanel.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/SidePanel.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/gui/swt/SidePanel.java	(revision 957)
@@ -0,0 +1,212 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.SashForm;
+import org.eclipse.swt.custom.StackLayout;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Sash;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+
+/**
+ * This class can be extended to create a sidepanel with minimize button
+ * for use as component of a {@link SashForm}
+ */
+public class SidePanel extends Composite {
+	private SashForm parentSash;
+	private Composite contentComposite;
+	
+	/**
+	 * Constructor for this class
+	 * @param parent	The parent composite (needs to be an {@link SashForm} for the
+	 * minimize button to work
+	 * @param style
+	 */
+	public SidePanel(Composite parent, int style) {
+		super(parent, style);
+		if(parent instanceof SashForm) //Minimize button only works if parent is sashform
+			parentSash = (SashForm)parent;
+		createControls();
+	}
+
+	public Composite getContentComposite() { return contentComposite; }
+	
+	Composite buttonBar;
+	Composite stackComposite;
+	Composite emptyComposite;
+	StackLayout stackLayout;
+	Button minButton;
+	/**
+	 * Creates the button controls to minimize the sidepanel and a {@link Composite} for the contents
+	 */
+	public void createControls() {
+		GridLayout topLayout = new GridLayout();
+		topLayout.verticalSpacing = topLayout.marginTop = topLayout.marginWidth = 0;
+		setLayout(topLayout);
+		
+		if(parentSash != null) {
+			//Create minimize control on top of content
+			buttonBar = new Composite(this, SWT.NULL);
+			GridLayout barLayout = new GridLayout(2, true);
+			barLayout.marginBottom = barLayout.marginHeight = barLayout.marginWidth = 1;
+			buttonBar.setLayout(barLayout);
+						
+			minButton = new Button(buttonBar, SWT.TOGGLE);
+			minButton.setToolTipText("Minimize this sidepanel");
+			minButton.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					if(minButton.getSelection()) {
+						minimize();
+						minButton.setToolTipText("Restore this sidepanel");
+					}
+					else {
+						restore();
+						minButton.setToolTipText("Minimize this sidepanel");
+					}
+				}
+			});
+			minButton.setImage(SwtEngine.getImageRegistry().get("sidepanel.minimize"));
+			final Button hideButton = new Button(buttonBar, SWT.PUSH);
+			hideButton.setToolTipText("Close this sidepanel (use view menu to open again)");
+			hideButton.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					hide();
+					SwtEngine.getWindow().showRightPanelAction.setChecked(false);
+				}
+			});
+			hideButton.setImage(SwtEngine.getImageRegistry().get("sidepanel.hide"));
+			
+			GridData buttonGrid = new GridData();
+			buttonGrid.widthHint = 12;
+			buttonGrid.heightHint =  12;
+			hideButton.setLayoutData(buttonGrid);
+			minButton.setLayoutData(buttonGrid);
+			
+			buttonBar.pack();
+		}
+		stackComposite = new Composite(this, SWT.NULL);
+		stackComposite.setLayoutData(new GridData(GridData.FILL_BOTH));
+		stackLayout = new StackLayout();
+		stackComposite.setLayout(stackLayout);
+		emptyComposite = new Composite(stackComposite, SWT.NULL);
+		emptyComposite.setLayout(new FillLayout());
+		contentComposite = new Composite(stackComposite, SWT.NULL);
+		contentComposite.setLayout(new FillLayout());
+		
+		stackLayout.topControl = contentComposite;
+	}
+	
+	/**
+	 * Minimizes this panel, while the minimize button will still be visible
+	 */
+	public void minimize() {
+		parentSash.setWeights(calculateWeights(WEIGHTS_MINIMIZE));
+		stackLayout.topControl = emptyComposite;
+		stackComposite.layout();
+	}
+	
+	/**
+	 * Hides this panel, the minimize button will not be visible anymore
+	 */
+	public void hide() {
+		parentSash.setWeights(calculateWeights(WEIGHTS_HIDE));
+	}
+	
+	public void show() {
+		int sidePanelSize = GlobalPreference.getValueInt(SwtPreference.SWT_SIDEPANEL_SIZE);
+		if(sidePanelSize == 0) sidePanelSize = 10; //Force show if initial size = 0
+		parentSash.setWeights(calculateWeights(sidePanelSize));
+	}
+	
+	/**
+	 * Restores the size of the panel to its previous size
+	 */
+	public void restore() {
+		if(oldWeights == null) return;
+		parentSash.setWeights(oldWeights);
+		stackLayout.topControl = contentComposite;
+		stackComposite.layout();
+	}
+	
+	private int[] oldWeights;
+	private static final int WEIGHTS_HIDE = -1;
+	private static final int WEIGHTS_MINIMIZE = -2;
+	/**
+	 * Calculates weights that have to be passed to the parent {@link SashForm#setWeights(int[])}
+	 * to resize, minimize or hide this panel
+	 * @param percent percentage of total size for this panel or 
+	 * one of WEIGHTS_HIDE or WEIGHTS_MINIMIZE, in the first case the panel is hidden,
+	 * so its weight is set to zero, in the second case the panel is miminized in a way the minimize 
+	 * button is still visible
+	 * @return
+	 */
+	private int[] calculateWeights(int percent) {
+		Control[] controls = parentSash.getChildren();
+		int[] weights = parentSash.getWeights();
+		oldWeights = weights.clone();
+		//Get the index of this control in the sashform
+		int thisIndex = 0;
+		for(int i = 0; i < controls.length; i++) {
+			if(controls[i] == this) break;
+			if(!(controls[i] instanceof Sash)) thisIndex++; //Don't count sash controls
+		}
+		
+		int thisWeight = weights[thisIndex];
+		
+		//Get the index of the neighbouring composite
+		int neighbourIndex = -1;
+		if(thisIndex == weights.length - 1) neighbourIndex = thisIndex - 1;
+		else neighbourIndex = thisIndex + 1;
+		
+		//Calculate widths needed to calculate new weight 
+		int newWidth;
+		switch(percent) {
+		case WEIGHTS_MINIMIZE: newWidth = minButton.getSize().x; break;
+		case WEIGHTS_HIDE: newWidth = 0; break;
+		default:
+			//Calculate new weights
+			int percentLeft = 100 - percent;
+			int sum = 0;
+			for(int i = 0; i < weights.length; i++) {
+				sum += weights[i];
+				if(i == thisIndex) continue;
+				weights[i] = (int)(((double)weights[i] / 100) * percentLeft);
+			}
+			weights[thisIndex] = (int)(((double)percent / 100) * sum);
+			return weights;
+			}
+		
+		int thisWidth = getSize().x;
+		
+		//Calculate new weights
+		int newWeight = (int)(((double)newWidth / thisWidth) * thisWeight);
+		//Adjust the weight of this and the next control
+		weights[thisIndex] = newWeight;
+		weights[neighbourIndex] += thisWeight - newWeight;
+		return weights;
+	}
+
+}

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/SidePanel.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/TabbedSidePanel.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/TabbedSidePanel.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/gui/swt/TabbedSidePanel.java	(revision 957)
@@ -0,0 +1,175 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.util.HashMap;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.CTabFolder;
+import org.eclipse.swt.custom.CTabItem;
+import org.eclipse.swt.custom.SashForm;
+import org.eclipse.swt.events.DisposeEvent;
+import org.eclipse.swt.events.DisposeListener;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.TabFolder;
+import org.eclipse.swt.widgets.TabItem;
+
+/**
+ * This class represents a side panel with contents placed in different
+ * tabitems. Components to add needs to be children of the {@link TabFolder}
+ * returned by {@link #getTabFolder()}
+ */
+public class TabbedSidePanel extends SidePanel {
+	private CTabFolder tabFolder;
+	HashMap<String, Control> controls;
+	HashMap<String, CTabItem> tabItems;
+	
+	/**
+	 * Returns the {@link TabFolder} containing the different
+	 * tabItems of this sidepanel
+	 */
+	public CTabFolder getTabFolder() { return tabFolder; }
+	
+	public HashMap<String, CTabItem> getTabItemHash() { return tabItems; }
+	
+	/**
+	 * Constructor for this class
+	 * @param parent	The parent composite (needs to be an {@link SashForm} for the
+	 * minimize button to work
+	 * @param style		
+	 */
+	public TabbedSidePanel(Composite parent, int style) {
+		super(parent, style);
+		controls = new HashMap<String, Control>();
+		tabItems = new HashMap<String, CTabItem>();
+		
+		tabFolder = new CTabFolder(getContentComposite(), SWT.BORDER);
+		tabFolder.setSimple(false);
+	}
+	
+	/**
+	 * Add a TabItem containing the given Control.
+	 * @param content	{@link Control} that needs to be a child of the
+	 * TabFolder returned by {@link #getTabFolder()}
+	 * @param title		The title for the TabItem
+	 */
+	public void addTab(Control content, String title)
+	{		
+		createTabItem(content, title, false);
+		controls.put(title, content);
+	}
+	
+	public void addTab(Control content, String title, boolean close)
+	{		
+		createTabItem(content, title, close);
+		controls.put(title, content);
+	}
+	
+	/**
+	 * Creates an {@link TabItem} with the given control and title
+	 * @param content
+	 * @param title
+	 * @param close
+	 * @returns
+	 */
+	private CTabItem createTabItem(Control content, String title, boolean close)
+	{
+		return createTabItem(content, title, tabFolder.getItemCount(), close);
+	}
+	
+	/**
+	 * Creates an {@link TabItem} with the given control and title at the given index.
+	 * If the index is lower than the number of tabitems, the new tabitem is placed before the first,
+	 * otherwise it is placed after the last.
+	 * @param content
+	 * @param title
+	 * @returns
+	 * @param index
+	 * @return
+	 */
+	private CTabItem createTabItem(Control content, String title, int index, boolean close) {
+		int nrTabs = tabFolder.getItemCount();
+		
+		if(index > nrTabs) index = nrTabs; //If index is invalid, choose first or last tab
+		else if(index < 0) index = 0;
+		
+		final CTabItem ti = new CTabItem(tabFolder, close ? SWT.CLOSE : SWT.NULL, index);
+		ti.setText(title);
+		ti.setControl(content);
+		ti.addDisposeListener(new DisposeListener() {
+			public void widgetDisposed(DisposeEvent e) {
+				tabItems.remove(ti.getText());
+			}
+		});
+		tabItems.put(title, ti);
+		return ti;
+	}
+	
+	/**
+	 * Hides a tab (without disposing the containing {@link Control})
+	 * @param title The title of the tab
+	 */
+	public void hideTab(String title) {
+		if(!tabItems.containsKey(title)) return;
+		tabItems.get(title).dispose();
+		tabItems.remove(title);
+	}
+	
+	/**
+	 * Shows a tab if a control with the given title exists
+	 * @param title	The title of the tabitem, also serves to find the {@link Control} for the tabItem
+	 * @return true if the tab is added, false if not ({@link Control} not found)
+	 */
+	public boolean unhideTab(String title) {
+		return unhideTab(title, tabFolder.getItemCount());
+	}
+	
+	/**
+	 * Shows a tab if a control with the given title exists
+	 * @param title	The title of the tabitem, also serves to find the {@link Control} for the tabItem
+	 * @param position The index of the position to add the tab
+	 * @return true if the tab is added, false if not ({@link Control} not found)
+	 */
+	public boolean unhideTab(String title, int position) {
+		if(controls.containsKey(title)) {
+			createTabItem(controls.get(title), title, position, false);
+			return true;
+		}
+		return false;
+	}
+	
+	public void selectTab(String title) {
+		if(tabItems.containsKey(title)) 
+			tabFolder.setSelection(tabItems.get(title));
+	}
+	
+	/**
+	 * Checks whether a tabitem is visible
+	 */
+	public boolean isVisible(String title) {
+		return tabItems.containsKey(title) && controls.containsKey(title);
+	}
+	
+	/**
+	 * Check whether a tabitem with the given title exists
+	 * @param title
+	 */
+	public boolean hasTab(String title) {
+		return tabItems.containsKey(title);
+	}
+}

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/TabbedSidePanel.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/MainWindowBase.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/MainWindowBase.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/gui/swt/MainWindowBase.java	(revision 957)
@@ -0,0 +1,438 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.action.ActionContributionItem;
+import org.eclipse.jface.action.ControlContribution;
+import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.action.IContributionItem;
+import org.eclipse.jface.action.MenuManager;
+import org.eclipse.jface.action.ToolBarContributionItem;
+import org.eclipse.jface.action.ToolBarManager;
+import org.eclipse.jface.dialogs.MessageDialog;
+import org.eclipse.jface.dialogs.ProgressMonitorDialog;
+import org.eclipse.jface.window.ApplicationWindow;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.SashForm;
+import org.eclipse.swt.custom.ScrolledComposite;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.widgets.Combo;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Shell;
+import org.pathvisio.Engine;
+import org.pathvisio.Engine.ApplicationEvent;
+import org.pathvisio.Engine.ApplicationEventListener;
+import org.pathvisio.data.DBConnector;
+import org.pathvisio.data.Gdb;
+import org.pathvisio.data.Gex;
+import org.pathvisio.data.Gex.ExpressionDataEvent;
+import org.pathvisio.data.Gex.ExpressionDataListener;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.search.PathwaySearchComposite;
+import org.pathvisio.view.GeneProduct;
+import org.pathvisio.view.VPathway;
+import org.pathvisio.view.VPathwayEvent;
+import org.pathvisio.view.VPathwayListener;
+import org.pathvisio.visualization.LegendPanel;
+
+/**
+ * MainWindowBase is an abstract and incomplete Main Window that contains some
+ * core functionality. This way we can create different flavours of the main window
+ * without having too much duplicate code. Descendants should at least provide
+ * a constructor, and override createCoolBarManager and createMenuManager.
+ */
+public abstract class MainWindowBase extends ApplicationWindow implements 
+	ApplicationEventListener, ExpressionDataListener, VPathwayListener
+{
+	private static final long serialVersionUID = 1L;
+	static int ZOOM_TO_FIT = -1;
+		
+	protected CommonActions.UndoAction undoAction = new CommonActions.UndoAction(this);	
+	protected CommonActions.NewAction newAction = new CommonActions.NewAction (this);
+	protected CommonActions.OpenAction openAction = new CommonActions.OpenAction (this);	
+	protected CommonActions.ImportAction importAction = new CommonActions.ImportAction (this);	
+	protected CommonActions.SaveAction saveAction = new CommonActions.SaveAction(this);	
+	protected CommonActions.SaveAsAction saveAsAction = new CommonActions.SaveAsAction (this);
+	protected CommonActions.ExportAction exportAction = new CommonActions.ExportAction (this);
+	protected CommonActions.ExitAction exitAction = new CommonActions.ExitAction(this);
+	protected CommonActions.PreferencesAction preferencesAction = new CommonActions.PreferencesAction(this);
+	protected CommonActions.AboutAction aboutAction = new CommonActions.AboutAction(this);
+	protected CommonActions.CopyAction copyAction = new CommonActions.CopyAction(this);
+	protected CommonActions.HelpAction helpAction = new CommonActions.HelpAction(this);	
+	protected CommonActions.PasteAction pasteAction = new CommonActions.PasteAction(this);
+	protected CommonActions.SwitchEditModeAction switchEditModeAction = new CommonActions.SwitchEditModeAction(this);
+	public ShowRightPanelAction showRightPanelAction = new ShowRightPanelAction(this);
+	protected SelectGdbAction selectGdbAction = new SelectGdbAction(this);
+	protected AlignActions.AlignCenterXAction alignCenterXAction = new AlignActions.AlignCenterXAction(this);
+	protected AlignActions.AlignCenterYAction alignCenterYAction = new AlignActions.AlignCenterYAction(this);
+	protected AlignActions.AlignLeftAction alignLeftAction = new AlignActions.AlignLeftAction(this);
+	protected AlignActions.AlignRightAction alignRightAction = new AlignActions.AlignRightAction(this);
+	protected AlignActions.AlignTopAction alignTopAction = new AlignActions.AlignTopAction(this);
+	protected AlignActions.AlignBottomAction alignBottomAction = new AlignActions.AlignBottomAction(this);
+	protected AlignActions.SetCommonWidthAction setCommonWidthAction = new AlignActions.SetCommonWidthAction(this);
+	protected AlignActions.SetCommonHeightAction setCommonHeightAction = new AlignActions.SetCommonHeightAction(this);
+
+	/**
+	 * {@link Action} to select a Gene Database
+	 */
+	private class SelectGdbAction extends Action
+	{
+		MainWindowBase window;
+		public SelectGdbAction(MainWindowBase w)
+		{
+			window = w;
+			setText("Select &Gene Database");
+			setToolTipText("Select Gene Database");
+		}
+		
+		public void run () {			
+			try {
+				DBConnector dbcon = Gdb.getDBConnector();
+				String dbName = dbcon.openChooseDbDialog(getShell());
+				
+				if(dbName == null) return;
+				
+				Gdb.connect(dbName);
+				setStatus("Using Gene Database: '" + SwtPreference.SWT_CURR_GDB + "'");
+				cacheExpressionData();
+			} catch(Exception e) {
+				String msg = "Failed to open Gene Database; " + e.getMessage();
+				MessageDialog.openError (window.getShell(), "Error", 
+						"Error: " + msg + "\n\n" + 
+						"See the error log for details.");
+				Engine.log.error(msg, e);
+			}
+		}
+	}
+
+	/**
+	 * deselect all buttons in the alignActionsCI coolbar
+	 */
+	public void deselectAlignItemActions()
+	{
+		IContributionItem[] items = alignActionsCI.getToolBarManager().getItems();
+		for(int i = 0; i < items.length; i++)
+		{
+			if(items[i] instanceof ActionContributionItem)
+			{
+				((ActionContributionItem)items[i]).getAction().setChecked(false);
+			}
+		}
+		Engine.getActiveVPathway().setNewGraphics(VPathway.NEWNONE);
+	}
+	
+	/**
+	 * {@link Action} to show or hide the right sidepanel
+	 */
+	public class ShowRightPanelAction extends Action
+	{
+		MainWindowBase window;
+		public ShowRightPanelAction (MainWindowBase w)
+		{
+			super("Show &information panel", IAction.AS_CHECK_BOX);
+			window = w;
+			setChecked(true);
+		}
+		
+		public void run() {
+			if(isChecked()) rightPanel.show();
+			else rightPanel.hide();
+		}
+	}
+
+	/**
+	 * Loads expression data for all {@link GeneProduct}s in the loaded pathway
+	 */
+	private void cacheExpressionData()
+	{
+		if(Engine.isDrawingOpen())
+		{
+			VPathway drawing = Engine.getActiveVPathway();
+			//Check for neccesary connections
+			if(Gex.isConnected() && Gdb.isConnected())
+			{
+				ProgressMonitorDialog dialog = new ProgressMonitorDialog(getShell());
+				try {
+					dialog.run(true, true, Gex.createCacheRunnable(drawing.getMappIds(), drawing.getSystemCodes()));
+					drawing.redraw();
+				} catch(Exception e) {
+					String msg = "while caching expression data: " + e.getMessage();					
+					MessageDialog.openError (getShell(), "Error", 
+							"Error: " + msg + "\n\n" + 
+							"See the error log for details.");
+					Engine.log.error(msg, e);
+				}
+			}
+		}
+	}
+
+	/**
+	 * Deselects all {@link NewElementAction}s on the toolbar and sets 
+	 * {@link VPathway}.newGraphics to {@link VPathway}.NEWNONE
+	 */
+	public void deselectNewItemActions()
+	{
+		IContributionItem[] items = editActionsCI.getToolBarManager().getItems();
+		for(int i = 0; i < items.length; i++)
+		{
+			if(items[i] instanceof ActionContributionItem)
+			{
+				((ActionContributionItem)items[i]).getAction().setChecked(false);
+			}
+		}
+		Engine.getActiveVPathway().setNewGraphics(VPathway.NEWNONE);
+	}
+
+	// Elements of the coolbar
+	ToolBarContributionItem commonActionsCI;
+	ToolBarContributionItem editActionsCI;
+	ToolBarContributionItem alignActionsCI;
+	ToolBarContributionItem viewActionsCI;
+	
+	/**
+	 * Creates element of the coolbar containing common actions as new, save etc.
+	 */
+	protected void createCommonActionsCI()
+	{
+		ToolBarManager toolBarManager = new ToolBarManager(SWT.FLAT);
+		toolBarManager.add(newAction);
+		toolBarManager.add(openAction);
+		toolBarManager.add(saveAction);
+		commonActionsCI = new ToolBarContributionItem(toolBarManager, "CommonActions");
+	}
+
+	/**
+	 * Creates element of the coolbar only shown in edit mode (new element actions)
+	 */
+	protected void createEditActionsCI()
+	{
+		ToolBarManager toolBarManager = new ToolBarManager(SWT.FLAT);		
+		toolBarManager.add(new NewElementAction(VPathway.NEWGENEPRODUCT));
+		toolBarManager.add(new NewElementAction(VPathway.NEWLABEL));
+		toolBarManager.add(new NewElementAction(VPathway.NEWLINEMENU));
+		toolBarManager.add(new NewElementAction(VPathway.NEWRECTANGLE));
+		toolBarManager.add(new NewElementAction(VPathway.NEWOVAL));
+		toolBarManager.add(new NewElementAction(VPathway.NEWARC));
+		toolBarManager.add(new NewElementAction(VPathway.NEWBRACE));
+		toolBarManager.add(new NewElementAction(VPathway.NEWTBAR));
+		toolBarManager.add(new NewElementAction(VPathway.NEWLINESHAPEMENU));
+
+		editActionsCI = new ToolBarContributionItem(toolBarManager, "EditModeActions");
+	}
+	
+	/**
+	 * Creates element of the coolbar containing controls related to viewing a pathway
+	 */
+	protected void createViewActionsCI()
+	{
+		final MainWindowBase window = this;
+		ToolBarManager toolBarManager = new ToolBarManager(SWT.FLAT);
+		//Add zoomCombo
+		toolBarManager.add(new ControlContribution("ZoomCombo") {
+			protected Control createControl(Composite parent) {
+				final Combo zoomCombo = new Combo(parent, SWT.DROP_DOWN);
+				zoomCombo.setItems(new String[] { "200%", "100%", "75%", "50%", "Zoom to fit" });
+				zoomCombo.setText("100%");
+				zoomCombo.addSelectionListener(new SelectionAdapter() {
+					public void widgetSelected(SelectionEvent e) {
+						int pctZoom = 100;
+						String zoomText = zoomCombo.getText().replace("%", "");
+						try {
+							pctZoom = Integer.parseInt(zoomText);
+						} catch (Exception ex) { 
+							if(zoomText.equals("Zoom to fit"))
+									{ pctZoom = ZOOM_TO_FIT; } else { return; }
+						}
+						new CommonActions.ZoomAction(window, pctZoom).run();
+					}
+					public void widgetDefaultSelected(SelectionEvent e) { widgetSelected(e); }
+				});
+				return zoomCombo;
+			}
+		});
+		//Add swich to editmode
+		toolBarManager.add(switchEditModeAction);
+		
+		viewActionsCI =  new ToolBarContributionItem(toolBarManager, "SwitchActions");
+	}
+		
+	/**
+	 * Shows or hides the editActionsCI
+	 * @param show	true/false for either show or hide
+	 */
+	public void showEditActionsCI(boolean show)
+	{
+		if(show) {
+			getCoolBarManager().insertAfter(viewActionsCI.getId(), editActionsCI);
+		}
+		else {
+			getCoolBarManager().remove(editActionsCI);
+		}
+//		showVisualizationCI(!show); //Visualizations can show up in edit mode...
+		getCoolBarManager().update(true);
+	}
+
+	/**
+	   Shows or hides the alignActionsCI.
+	   @param show	true/false for either show or hide
+	*/
+	public void showAlignActionsCI(boolean show)
+	{
+		if(show) {
+			getCoolBarManager().insertAfter(editActionsCI.getId(), alignActionsCI);
+		}
+		else {
+			getCoolBarManager().remove(alignActionsCI);
+		}
+//		showVisualizationCI(!show); //Visualizations can show up in edit mode...
+		getCoolBarManager().update(true);
+	}
+	
+	//	KH 20070514 begin
+	/**
+	 * set up the alignActions coolbar
+	 */
+	protected void createAlignActionsCI()
+	{
+		ToolBarManager toolBarManager = new ToolBarManager(SWT.FLAT);
+		toolBarManager.add(alignCenterXAction);
+		toolBarManager.add(alignCenterYAction);
+		toolBarManager.add(alignLeftAction);
+		toolBarManager.add(alignRightAction);
+		toolBarManager.add(alignTopAction);
+		toolBarManager.add(alignBottomAction);
+		toolBarManager.add(setCommonWidthAction);
+		toolBarManager.add(setCommonHeightAction);
+	
+		alignActionsCI = new ToolBarContributionItem(toolBarManager, "AlignActions");
+	}
+	
+//	KH end
+	/**
+	   Invoked when user tries to close window.
+	   We'll ask the user if he wants to save the pathway
+	*/
+	protected boolean canHandleShellCloseEvent()
+	{
+		return SwtEngine.canDiscardPathway();
+	}
+	
+	protected MenuManager menuManager = null;
+	/**
+	 * can be accessed by plugins etc. 
+	 * to add menu items and even complete menus.
+	 * 
+	 * (plugin API)
+	 */
+	public MenuManager getMenuManager()
+	{
+		return menuManager;
+	}
+		
+	public boolean close() {
+		Engine.fireApplicationEvent(
+				new ApplicationEvent(this, ApplicationEvent.APPLICATION_CLOSE));
+		return super.close();
+	}
+	
+	public ScrolledComposite sc;
+	public BackpagePanel bpBrowser; //Browser for showing backpage information
+	public PropertyPanel propertyTable;	//Table showing properties of Graphics objects
+	SashForm sashForm; //SashForm containing the drawing area and sidebar
+	TabbedSidePanel rightPanel; //side panel containing backbage browser and property editor
+	PathwaySearchComposite pwSearchComposite; //Composite that handles pathway searches and displays results
+	LegendPanel legend; //Legend to display colorset information
+	
+	public TabbedSidePanel getSidePanel() { return rightPanel; }
+	
+	public LegendPanel getLegend() { return legend; }
+	
+	public void showLegend(boolean show) {	
+		if(show && Gex.isConnected()) {
+			if(rightPanel.isVisible("Legend")) return; //Legend already visible, only refresh
+			rightPanel.unhideTab("Legend", 0);
+			rightPanel.selectTab("Legend");
+		}
+		
+		else rightPanel.hideTab("Legend");
+	}
+	
+	/**
+	 * Creates a new empty drawing canvas
+	 * @return the empty {@link VPathway}
+	 */
+	public VPathway createNewDrawing()
+	{		
+		return new VPathway(sc, SWT.NO_BACKGROUND);
+	}
+				
+	public void applicationEvent(ApplicationEvent e) {
+		switch(e.type) {
+		case ApplicationEvent.PATHWAY_OPENED:
+			if(Gex.isConnected()) cacheExpressionData();
+			break;
+		}
+		switch(e.type) {
+		case ApplicationEvent.PATHWAY_NEW:
+		case ApplicationEvent.PATHWAY_OPENED:
+			Engine.getActiveVPathway().addVPathwayListener(this);
+		}
+	}
+
+	public void expressionDataEvent(ExpressionDataEvent e) {
+		switch(e.type) {
+		case ExpressionDataEvent.CONNECTION_CLOSED:
+			getShell().getDisplay().syncExec(new Runnable() {
+				public void run() {
+					showLegend(false);
+				}
+			});
+			break;
+		case ExpressionDataEvent.CONNECTION_OPENED:
+			getShell().getDisplay().syncExec(new Runnable() {
+				public void run() {
+					cacheExpressionData();
+					showLegend(true);
+				}
+			});
+			break;
+		}
+	}
+	
+	public void vPathwayEvent(VPathwayEvent e) {
+		switch(e.getType()) {
+		case VPathwayEvent.EDIT_MODE_OFF:
+			showLegend(true);
+			break;
+		case VPathwayEvent.EDIT_MODE_ON:
+			showLegend(false);
+			break;
+		case VPathwayEvent.NEW_ELEMENT_ADDED:
+			deselectNewItemActions();
+			break;
+		}
+	}
+	
+	public MainWindowBase(Shell shell)
+	{
+		super(shell);
+	}
+
+}

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/MainWindowBase.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/CommonActions.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/CommonActions.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/gui/swt/CommonActions.java	(revision 957)
@@ -0,0 +1,625 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.dialogs.MessageDialog;
+import org.eclipse.jface.preference.PreferenceDialog;
+import org.eclipse.jface.preference.PreferenceManager;
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.widgets.FileDialog;
+import org.pathvisio.Engine;
+import org.pathvisio.Globals;
+import org.pathvisio.Engine.ApplicationEvent;
+import org.pathvisio.Engine.ApplicationEventListener;
+import org.pathvisio.biopax.gui.BiopaxDialog;
+import org.pathvisio.model.ConverterException;
+import org.pathvisio.model.Pathway;
+import org.pathvisio.model.PathwayExporter;
+import org.pathvisio.preferences.swt.PreferenceDlg;
+import org.pathvisio.preferences.swt.SwtPreferences;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.view.VPathway;
+
+/**
+   This class contains a large number of JFace Actions that are both in V1 and V2.
+*/   
+public class CommonActions
+{
+	static class UndoAction extends Action
+	{
+		MainWindowBase window;
+		public UndoAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Undo@Ctrl+Z");
+			setToolTipText ("Undo last action");
+		}
+		public void run() 
+		{
+			if (Engine.getActivePathway() != null)
+			{
+				Engine.getActivePathway().undo();
+			}
+		}
+	}
+	
+	/**
+	 * {@link Action} to create a new gpml pathway
+	 */
+	static class NewAction extends Action 
+	{
+		MainWindowBase window;
+		public NewAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&New pathway@Ctrl+N");
+			setToolTipText ("Create new pathway");
+			setImageDescriptor(ImageDescriptor.createFromURL(
+					Engine.getResourceURL("icons/new.gif")));
+		}
+		public void run ()
+		{			
+			SwtEngine.newPathway();
+		}	
+	}
+	
+	/**
+	 * {@link Action} to create a new gpml pathway
+	 */
+	static class SvgExportAction extends Action 
+	{
+		MainWindowBase window;
+		public SvgExportAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("Export to SVG");
+			setToolTipText ("Export to Scalable Vector Graphics (SVG) " +
+					"for publication-quality images");
+		}
+		public void run () 
+		{
+			//TODO: move to engine, merge with "save"
+			VPathway drawing = Engine.getActiveVPathway();
+			Pathway gmmlData = Engine.getActivePathway();
+			// Check if a gpml pathway is loaded
+			if (drawing != null)
+			{
+				FileDialog fd = new FileDialog(window.getShell(), SWT.SAVE);
+				fd.setText("Save");
+				fd.setFilterExtensions(new String[] {"*." + Engine.SVG_FILE_EXTENSION, "*.*"});
+				fd.setFilterNames(new String[] {Engine.SVG_FILTER_NAME, "All files (*.*)"});
+				
+				File xmlFile = gmmlData.getSourceFile();
+				if(xmlFile != null) {
+					String name = xmlFile.getName();
+					if (name.endsWith("." + Engine.PATHWAY_FILE_EXTENSION))
+					{
+						name = name.substring(0, name.length() - 
+							Engine.PATHWAY_FILE_EXTENSION.length()) +
+							Engine.SVG_FILE_EXTENSION;
+					}
+					fd.setFileName(name);
+					fd.setFilterPath(xmlFile.getPath());
+				} else {
+					fd.setFileName(SwtPreference.SWT_DIR_PWFILES.getValue());
+				}
+				String fileName = fd.open();
+				// Only proceed if user selected a file
+				
+				if(fileName == null) return;
+				
+				// Append .svg extension if not already present
+				if(!fileName.endsWith("." + Engine.SVG_FILE_EXTENSION)) 
+					fileName += "." + Engine.SVG_FILE_EXTENSION;
+				
+				File checkFile = new File(fileName);
+				boolean confirmed = true;
+				// If file exists, ask overwrite permission
+				if(checkFile.exists())
+				{
+					confirmed = MessageDialog.openQuestion(window.getShell(),"",
+					"File already exists, overwrite?");
+				}
+				if(confirmed)
+				{
+					try
+					{
+						gmmlData.writeToSvg(checkFile);
+					}
+					catch (ConverterException e)
+					{
+						String msg = "While writing svg to " 
+							+ checkFile.getAbsolutePath();					
+						MessageDialog.openError (window.getShell(), "Error", 
+								"Error: " + msg + "\n\n" + 
+								"See the error log for details.");
+						Engine.log.error(msg, e);
+					}
+				}
+			}
+			else
+			{
+				MessageDialog.openError (window.getShell(), "Error", 
+					"No pathway to save! Open or create a new pathway first");
+			}			
+		}
+	}
+
+	/**
+	 * {@link Action} to open an gpml pathway
+	 */
+	static class OpenAction extends Action 
+	{
+		MainWindowBase window;
+		public OpenAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Open pathway@Ctrl+O");
+			setToolTipText ("Open pathway");
+			setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/open.gif")));
+		}
+		public void run () 
+		{
+			FileDialog fd = new FileDialog(window.getShell(), SWT.OPEN);
+			fd.setText("Open");
+			String pwpath = SwtPreference.SWT_DIR_PWFILES.getValue();
+			fd.setFilterPath(pwpath);
+			fd.setFilterExtensions(new String[] {"*." + Engine.PATHWAY_FILE_EXTENSION, "*.*"});
+			fd.setFilterNames(new String[] {Engine.PATHWAY_FILTER_NAME, "All files (*.*)"});
+	        String fnMapp = fd.open();
+	        // Only open pathway if user selected a file
+	        
+	        if(fnMapp != null) { 
+	        	SwtEngine.openPathway(fnMapp); 
+	        }
+		}
+	}
+
+	/**
+	 * {@link Action} to open an gpml pathway
+	 */
+	static class ImportAction extends Action 
+	{
+		MainWindowBase window;
+		public ImportAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Import");
+			setToolTipText ("Import Pathway in GenMAPP format");
+		}
+		public void run () 
+		{
+			if(SwtEngine.canDiscardPathway())
+			{
+				FileDialog fd = new FileDialog(window.getShell(), SWT.OPEN);
+				fd.setText("Open");
+				fd.setFilterPath(SwtPreference.SWT_DIR_PWFILES.getValue());
+				fd.setFilterExtensions(new String[] {"*." + Engine.GENMAPP_FILE_EXTENSION, "*.*"});
+				fd.setFilterNames(new String[] {Engine.GENMAPP_FILTER_NAME, "All files (*.*)"});
+	        	String fnMapp = fd.open();
+	        	// Only open pathway if user selected a file
+	        	
+	        	if(fnMapp != null) { 
+	        		SwtEngine.openPathway(fnMapp); 
+	        	}
+	        }
+		}
+	}
+
+	/**
+	 * {@link Action} to save a gpml pathway to a file specified by the user
+	 */
+	static class SaveAsAction extends Action 
+	{
+		MainWindowBase window;
+		public SaveAsAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("Save pathway &As");
+			setToolTipText ("Save pathway with new file name");
+		}
+		
+		public void run () 
+		{
+			SwtEngine.savePathwayAs();
+		}
+	}
+
+	
+	/**
+	 * {@link Action} to save a gpml pathway to a file specified by the user
+	 */
+	static class ExportAction extends Action 
+	{
+		MainWindowBase window;
+		public ExportAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Export");
+			setToolTipText ("Export Pathway to GenMAPP format");
+		}
+		public void run () {
+			//TODO: move to engine, merge with "save" or "saveAs"
+			VPathway drawing = Engine.getActiveVPathway();
+			Pathway gmmlData = Engine.getActivePathway();
+			// Check if a gpml pathway is loaded
+			if (drawing != null)
+			{
+				FileDialog fd = new FileDialog(window.getShell(), SWT.SAVE);
+				fd.setText("Export");
+				
+				class FileType implements Comparable<FileType> {
+					final String name;
+					final String ext;
+					public FileType(String n, String e) { name = n; ext = e; }
+					public int compareTo(FileType o) {
+						return name.compareTo(o.name);
+					}
+				}
+				
+				ArrayList<FileType> fts = new ArrayList<FileType>();
+				HashMap<String, PathwayExporter> exporters = Engine.getPathwayExporters();
+								
+				for(String ext : exporters.keySet()) {
+					fts.add(new FileType(
+								exporters.get(ext).getName() + " (*." + ext + ")",
+								"*." + ext));
+				}
+				Collections.sort(fts);
+				String[] exts = new String[fts.size()];
+				String[] nms = new String[fts.size()];
+				for(int i = 0; i < fts.size(); i++) {
+					FileType ft = fts.get(i);
+					exts[i] = ft.ext;
+					nms[i] = ft.name;
+				}
+				fd.setFilterExtensions(exts);
+				fd.setFilterNames(nms);
+								
+				File xmlFile = gmmlData.getSourceFile();
+				if(xmlFile != null) {
+					String name = xmlFile.getName();
+					if (name.endsWith("." + Engine.PATHWAY_FILE_EXTENSION))
+					{
+						name = name.substring(0, name.length() - 
+							Engine.PATHWAY_FILE_EXTENSION.length() - 1);
+					}
+					fd.setFileName(name);
+					fd.setFilterPath(xmlFile.getPath());
+				} else {
+					fd.setFileName(SwtPreference.SWT_DIR_PWFILES.getValue());
+				}
+				String fileName = fd.open();
+				// Only proceed if user selected a file
+				if(fileName == null) return;
+				
+				int dot = fileName.lastIndexOf('.');
+				String ext = Engine.GENMAPP_FILE_EXTENSION;
+				if(dot >= 0) {
+					ext = fileName.substring(dot + 1, fileName.length());
+				}
+				PathwayExporter exporter = Engine.getPathwayExporter(ext);
+				
+				if(exporter == null) 
+					MessageDialog.openError (window.getShell(), "Error", 
+					"No exporter for '" + ext +  "' files");
+								
+				File checkFile = new File(fileName);
+				boolean confirmed = true;
+				// If file exists, ask overwrite permission
+				if(checkFile.exists())
+				{
+					confirmed = MessageDialog.openQuestion(window.getShell(),"",
+					"File already exists, overwrite?");
+				}
+				if(confirmed)
+				{
+					try
+					{
+						//gmmlData.writeToMapp(checkFile);
+						exporter.doExport(checkFile, gmmlData);
+					}
+					catch (ConverterException e)
+					{
+						String msg = "While exporting to " 
+							+ checkFile.getAbsolutePath();					
+						MessageDialog.openError (window.getShell(), "Error", 
+								"Error: " + msg + "\n\n" + 
+								"See the error log for details.");
+						Engine.log.error(msg, e);
+					}
+				}
+			}
+			else
+			{
+				MessageDialog.openError (window.getShell(), "Error", 
+					"No pathway to save! Open or create a new pathway first");
+			}			
+		}
+	}
+
+	/**
+	 * {@link Action} to exit the application
+	 */
+	static class ExitAction extends Action 
+	{
+		MainWindowBase window;
+		public ExitAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("E&xit@Ctrl+X");
+			setToolTipText ("Exit Application");
+		}
+		public void run () 
+		{
+			if (SwtEngine.canDiscardPathway())
+			{
+				window.close();
+			}
+		}
+	}
+	
+	static class PreferencesAction extends Action
+	{
+		MainWindowBase window;
+		public PreferencesAction (MainWindowBase w)
+		{
+			window = w;
+			setText("&Preferences");
+			setToolTipText("Edit preferences");
+		}
+		public void run () {
+			PreferenceManager pg = new PreferenceDlg();
+			PreferenceDialog pd = new PreferenceDialog(window.getShell(), pg);
+			pd.setPreferenceStore((SwtPreferences)SwtEngine.getPreferences());
+			pd.open();
+		}
+	}
+
+	/**
+	 * {@link Action} that zooms a mapp to the specified zoomfactor
+	 */
+	static class ZoomAction extends Action 
+	{
+		MainWindowBase window;
+		int pctZoomFactor;
+		
+		/**
+		 * Constructor for this class
+		 * @param w {@link MainWindow} window this action belongs to
+		 * @param newPctZoomFactor the zoom factor as percentage of original
+		 */
+		public ZoomAction (MainWindowBase w, int newPctZoomFactor)
+		{
+			window = w;
+			pctZoomFactor = newPctZoomFactor;
+			if(pctZoomFactor == MainWindowBase.ZOOM_TO_FIT) 
+			{
+				setText ("Zoom to fit");
+				setToolTipText("Zoom mapp to fit window");
+			}
+			else
+			{
+				setText (pctZoomFactor + " %");
+				setToolTipText ("Zoom mapp to " + pctZoomFactor + " %");
+			}
+		}
+		public void run () {
+			VPathway drawing = Engine.getActiveVPathway();
+			if (drawing != null)
+			{
+				drawing.setPctZoom(pctZoomFactor);
+			}
+			else
+			{
+				MessageDialog.openError (window.getShell(), "Error", 
+					"No gpml file loaded! Open or create a new gpml file first");
+			}
+		}
+	}
+
+	/**
+	 * {@link Action} to open a {@link AboutDlg} window
+	 */
+	static class AboutAction extends Action 
+	{
+		MainWindowBase window;
+		public AboutAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&About");
+			setToolTipText ("About " + Globals.APPLICATION_VERSION_NAME);
+		}
+		public void run () {
+			AboutDlg gmmlAboutBox = new AboutDlg(window.getShell(), SWT.NONE);
+			gmmlAboutBox.open();
+		}
+	}
+	
+	/**
+	 * {@link Action} to open a Help window
+	 */
+	static class HelpAction extends Action 
+	{
+		MainWindowBase window;
+		public HelpAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Help@F1");
+			setToolTipText ("Opens " + Globals.APPLICATION_VERSION_NAME + " help in your web browser");
+		}
+		public void run ()
+		{
+			SwtEngine.openWebPage(Globals.HELP_URL, "Opening help page in broswer",
+						"Unable to open web browser" +
+						"\nYou can open the help page manually:\n" +
+						Globals.HELP_URL);
+		}
+	}
+
+	static class CopyAction extends Action
+	{
+		MainWindowBase window;
+		public CopyAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("Copy@Ctrl+C");
+			setToolTipText ("Copy selected objects to clipboard");
+		}
+		public void run()
+		{
+			Engine.getActiveVPathway().copyToClipboard();
+		}
+	}
+
+	static class PasteAction extends Action
+	{
+		MainWindowBase window;
+		public PasteAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("Paste@Ctrl+V");
+			setToolTipText ("Paste contents of clipboard");
+		}
+		public void run()
+		{
+			Engine.getActiveVPathway().pasteFromClipboad();
+		}
+	}
+	
+	/**
+	 * {@link Action} to save a gpml pathway
+	 */
+	static class SaveAction extends Action 
+	{
+		MainWindowBase window;
+		public SaveAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Save pathway@Ctrl+S");
+			setToolTipText ("Save pathway");
+			setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/save.gif")));
+		}
+		
+		public void run ()
+		{
+			SwtEngine.savePathway();
+		}
+	}
+	
+	static class BiopaxAction extends Action 
+	{
+		MainWindowBase window;
+		public BiopaxAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("Edit &BioPAX code");
+			setToolTipText ("Edit BioPAX code");
+		}
+		
+		public void run () {
+			BiopaxDialog d = new BiopaxDialog(window.getShell());
+			d.setPathway(Engine.getActivePathway());
+			d.open();
+		}
+	}
+	
+	/**
+	 * {@link Action} to switch between edit and view mode
+	 */
+	static class SwitchEditModeAction extends Action implements ApplicationEventListener
+	{
+		final String ttChecked = "Exit edit mode";
+		final String ttUnChecked = "Switch to edit mode to edit the pathway content";
+		MainWindowBase window;
+		public SwitchEditModeAction (MainWindowBase w)
+		{
+			super("&Edit mode", IAction.AS_CHECK_BOX);
+			setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/edit.gif")));
+			setToolTipText(ttUnChecked);
+			window = w;
+			
+			Engine.addApplicationEventListener(this);
+		}
+
+		public void run ()
+		{
+			if(Engine.isDrawingOpen())
+			{
+				VPathway drawing = Engine.getActiveVPathway();
+				Pathway pathway = Engine.getActivePathway();
+				if(isChecked())
+				{
+					// give a warning that this can't be edited.
+					if (pathway.getSourceFile() != null && !pathway.getSourceFile().canWrite())
+					{
+						MessageDialog.openWarning(
+								window.getShell(), "Read-only Warning",
+								"You're trying to edit a Read-only file.\n" +
+						"When you want to save your changes, you have to save to a different file.");
+					}
+					//Switch to edit mode: show edit toolbar, show property table in sidebar
+					drawing.setEditMode(true);
+					window.showEditActionsCI(true);
+					window.showAlignActionsCI(true);
+					window.rightPanel.getTabFolder().setSelection(1);
+				}
+				else
+				{
+					//Switch to view mode: hide edit toolbar, show backpage browser in sidebar
+					drawing.setEditMode(false);
+					window.showEditActionsCI(false);
+					window.showAlignActionsCI(false);
+					window.rightPanel.getTabFolder().setSelection(0);
+				}
+			}
+			else //No gpml pathway loaded, deselect action and do nothing
+			{
+				setChecked(false);
+			}
+			window.getCoolBarManager().update(true);
+		}
+		
+		public void setChecked(boolean check) {
+			super.setChecked(check);
+			setToolTipText(check ? ttChecked : ttUnChecked);
+		}
+
+		public void switchEditMode(boolean edit) {
+			setChecked(edit);
+			run();
+
+		}
+
+		public void applicationEvent(ApplicationEvent e) {
+			if(e.type == ApplicationEvent.PATHWAY_OPENED) {
+				Engine.getActiveVPathway().setEditMode(isChecked());
+			}
+			else if(e.type == ApplicationEvent.PATHWAY_NEW) {
+				switchEditMode(true);
+			}
+		}
+	}
+}

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/CommonActions.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/GuiMain.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/GuiMain.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/gui/swt/GuiMain.java	(revision 957)
@@ -0,0 +1,206 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.io.File;
+import java.io.PrintStream;
+
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.eclipse.jface.resource.ImageRegistry;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.graphics.ImageData;
+import org.eclipse.swt.widgets.Display;
+import org.pathvisio.Engine;
+import org.pathvisio.data.Gdb;
+import org.pathvisio.data.Gex;
+import org.pathvisio.model.ImageExporter;
+import org.pathvisio.model.MappFormat;
+import org.pathvisio.model.Pathway;
+import org.pathvisio.model.SvgFormat;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.Preference;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.util.SwtUtils;
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.plugins.PluginManager;
+
+/**
+ * This class contains the main method and is responsible for initiating 
+ * the application by setting up the user interface and creating all necessary objects
+ */
+public class GuiMain {
+	
+	/**
+	 * Main method which will be carried out when running the program
+	 */
+	public static void main(String[] args)
+	{
+		boolean debugHandles = false;
+		for(String a : args) {
+			if(		a.equalsIgnoreCase("--MonitorHandles") ||
+					a.equalsIgnoreCase("-mh")) {
+				debugHandles = true;
+			}
+			else if(a.equalsIgnoreCase("--UseR") ||
+					a.equalsIgnoreCase("-ur")) {
+				SwtEngine.USE_R = true;
+			}
+		}
+		
+		//Setup the application window
+		MainWindow window = null;
+		if(debugHandles)	window = SwtEngine.getSleakWindow();
+		else				window = SwtEngine.getWindow();
+		
+		initiate();
+		
+		window.setBlockOnOpen(true);
+		window.open();
+		
+		//Perform exit operations
+		//TODO: implement PropertyChangeListener and fire exit property when closing
+		// make classes themself responsible for closing when exit property is changed
+		Gex.close();
+		Gdb.close();
+		//Close log stream
+		Engine.log.getStream().close();
+		
+		Display.getCurrent().dispose();
+	}
+	
+	/**
+	 * Initiates some objects used by the program
+	 */
+	public static void initiate() {
+		//initiate logger
+		try { 
+			GlobalPreference.FILE_LOG.setDefault(new File(SwtEngine.getApplicationDir(), ".PathVisioLog").toString());
+			Engine.log.setStream(new PrintStream(GlobalPreference.FILE_LOG.getValue())); 
+		} catch(Exception e) {}
+		Engine.log.setLogLevel(true, true, true, true, true, true);//Modify this to adjust log level
+		Pathway.setLogger(Engine.log);
+		
+		//load the preferences
+		loadPreferences();
+		
+		//initiate Gene database (to load previously used gdb)
+		Gdb.init();
+		
+		//load visualizations and plugins
+		loadVisualizations();
+		
+		//create data directories if they don't exist yet
+		createDataDirectories();
+		
+		//register listeners for static classes
+		registerListeners();
+				
+		registerExporters();
+		
+		//NOTE: ImageRegistry will be initiated in "createContents" of MainWindow,
+		//since the window has to be opened first (need an active Display)
+	}
+	
+	/**
+	 * Creates data directories stored in preferences (if not exist)
+	 */
+	static void createDataDirectories() {
+		Preference[] dirPrefs = new Preference[] {
+				SwtPreference.SWT_DIR_EXPR,
+				SwtPreference.SWT_DIR_GDB,
+				SwtPreference.SWT_DIR_PWFILES,
+				SwtPreference.SWT_DIR_RDATA,
+		};
+		for(Preference p : dirPrefs) {
+			File dir = new File(p.getValue());
+			if(!dir.exists()) dir.mkdir();
+		}
+	}
+	
+			
+	static void registerListeners() {
+		VisualizationManager vmgr = new VisualizationManager();
+		Gex gex = new Gex();
+		
+		Engine.addApplicationEventListener(vmgr);
+		Engine.addApplicationEventListener(gex);
+	}
+	
+	static void registerExporters() {
+		Engine.addPathwayExporter(new MappFormat());
+		Engine.addPathwayExporter(new SvgFormat());
+		Engine.addPathwayExporter(new ImageExporter(ImageExporter.TYPE_PNG));
+		Engine.addPathwayExporter(new ImageExporter(ImageExporter.TYPE_TIFF));
+		Engine.addPathwayExporter(new ImageExporter(ImageExporter.TYPE_PDF));
+	}
+	
+	static void loadVisualizations() {
+		//load visualization plugins
+		try {
+			PluginManager.loadPlugins();
+		} catch (Throwable e) {
+			Engine.log.error("When loading visualization plugins", e);
+		}
+		
+		VisualizationManager.loadGeneric();
+	}
+	
+	static void loadPreferences() {
+		SwtEngine.getPreferences();
+	}
+	
+	/**
+	 * Loads images used throughout the applications into an {@link ImageRegistry}
+	 */
+	static void loadImages(Display display)
+	{
+		ClassLoader cl = GuiMain.class.getClassLoader();
+	
+		ImageRegistry imageRegistry = new ImageRegistry(display);
+		
+		// Labels for color by expressiondata (mRNA and Protein)
+		ImageData img = new ImageData(cl.getResourceAsStream("images/mRNA.bmp"));
+		img.transparentPixel = img.palette.getPixel(SwtUtils.color2rgb(Engine.TRANSPARENT_COLOR));
+		imageRegistry.put("data.mRNA",
+				new Image(display, img));
+		img = new ImageData(cl.getResourceAsStream("images/protein.bmp"));
+		img.transparentPixel = img.palette.getPixel(SwtUtils.color2rgb(Engine.TRANSPARENT_COLOR));
+		imageRegistry.put("data.protein",
+				new Image(display, img));
+		imageRegistry.put("sidepanel.minimize",
+				ImageDescriptor.createFromURL(cl.getResource("icons/minimize.gif")));
+		imageRegistry.put("sidepanel.hide",
+				ImageDescriptor.createFromURL(cl.getResource("icons/close.gif")));
+		imageRegistry.put("shell.icon", 
+				ImageDescriptor.createFromURL(cl.getResource("images/bigcateye.gif")));
+		imageRegistry.put("about.logo",
+				ImageDescriptor.createFromURL(cl.getResource("images/logo.jpg")));
+						imageRegistry.put("checkbox.unchecked",
+				ImageDescriptor.createFromURL(cl.getResource("icons/unchecked.gif")));
+		imageRegistry.put("checkbox.unavailable",
+				ImageDescriptor.createFromURL(cl.getResource("icons/unchecked_unavailable.gif")));
+		imageRegistry.put("checkbox.checked",
+				ImageDescriptor.createFromURL(cl.getResource("icons/checked.gif")));
+		imageRegistry.put("tree.collapsed",
+				ImageDescriptor.createFromURL(cl.getResource("icons/tree_collapsed.gif")));
+		imageRegistry.put("tree.expanded",
+				ImageDescriptor.createFromURL(cl.getResource("icons/tree_expanded.gif")));
+		SwtEngine.setImageRegistry(imageRegistry);
+	}
+	
+}
+

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/GuiMain.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/AlignActions.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/AlignActions.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/gui/swt/AlignActions.java	(revision 957)
@@ -0,0 +1,177 @@
+//	 PathVisio,
+//	 a tool for data visualization and analysis using Biological Pathways
+//	 Copyright 2006-2007 BiGCaT Bioinformatics
+	//
+//	 Licensed under the Apache License, Version 2.0 (the "License"); 
+//	 you may not use this file except in compliance with the License. 
+//	 You may obtain a copy of the License at 
+//	 
+//	 http://www.apache.org/licenses/LICENSE-2.0 
+//	  
+//	 Unless required by applicable law or agreed to in writing, software 
+//	 distributed under the License is distributed on an "AS IS" BASIS, 
+//	 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+//	 See the License for the specific language governing permissions and 
+//	 limitations under the License.
+	//
+
+package org.pathvisio.gui.swt;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.pathvisio.Engine;
+public class AlignActions {
+
+		
+	public static final char CENTERX = 'x';
+	public static final char CENTERY = 'y';
+	public static final char LEFT = 'l';
+	public static final char RIGHT = 'r';
+	public static final char TOP = 't';
+	public static final char BOTTOM = 'b';
+	public static final char WIDTH = 'w';
+	public static final char HEIGHT = 'h';
+	
+	
+		static class AlignCenterXAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignCenterXAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align horizontal centers");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/aligncenterx.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(CENTERX);
+				
+			}
+		}
+		
+		static class AlignCenterYAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignCenterYAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align vertical centers");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/aligncentery.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(CENTERY);
+				
+			}
+		}
+		static class AlignLeftAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignLeftAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align left edges");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/alignleft.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(LEFT);
+				
+			}
+		}
+		static class AlignRightAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignRightAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align right edges");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/alignright.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(RIGHT);
+				
+			}
+		}
+		static class AlignTopAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignTopAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align top edges");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/aligntop.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(TOP);
+				
+			}
+		}
+		static class AlignBottomAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignBottomAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align bottom edges");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/alignbottom.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(BOTTOM);
+				
+			}
+		}
+		static class SetCommonHeightAction extends Action 
+		{
+			MainWindowBase window;
+			public SetCommonHeightAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Set common height");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/sizeheight.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().scaleSelected(HEIGHT);
+				
+			}
+		}
+		static class SetCommonWidthAction extends Action 
+		{
+			MainWindowBase window;
+			public SetCommonWidthAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Set common width");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/sizewidth.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().scaleSelected(WIDTH);
+				
+			}
+		}
+
+
+	}
+
+
Index: trunk/src/swt/org/pathvisio/gui/swt/BackpagePanel.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/BackpagePanel.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/gui/swt/BackpagePanel.java	(revision 957)
@@ -0,0 +1,296 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.util.List;
+
+import org.eclipse.swt.browser.Browser;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.pathvisio.Engine;
+import org.pathvisio.data.DataSources;
+import org.pathvisio.data.Gdb;
+import org.pathvisio.data.Gex;
+import org.pathvisio.data.Gdb.IdCodePair;
+import org.pathvisio.util.Utils;
+import org.pathvisio.view.GeneProduct;
+import org.pathvisio.view.SelectionBox;
+import org.pathvisio.view.VPathwayElement;
+import org.pathvisio.view.SelectionBox.SelectionEvent;
+import org.pathvisio.view.SelectionBox.SelectionListener;
+
+/**
+ * Backpage browser - side panel that shows the backpage information when a GeneProduct is double-clicked
+ */
+public class BackpagePanel extends Composite implements SelectionListener {
+	/**
+	 * Directory containing HTML files needed to display the backpage information
+	 */
+	final static String BPDIR = "backpage";
+	/**
+	 * Header file, containing style information
+	 */
+	final static String HEADERFILE = "header.html";
+	
+	/**
+	 * Header for the gene information in HTML format
+	 */
+	final static String bpHeader = "<H1>Gene information</H1><P>";
+	/**
+	 * Header for the expression information in HTML format
+	 */
+	final static String gexHeader = "<H1>Expression data</H1><P>";
+	
+	private String bpText;
+	private String gexText;
+	private String header;
+	
+	private Browser bpBrowser;
+	
+	private GeneProduct geneProduct;
+	
+	/**
+	 * Constructor for this class
+	 * @param parent	Parent {@link Composite} for the Browser widget
+	 * @param style		Style for the Browser widget
+	 */
+	public BackpagePanel(Composite parent, int style) {
+		super(parent, style);
+		
+		initializeHeader(); //Load the header including style information
+		setLayout(new FillLayout());
+		bpBrowser = new Browser(this, style); //Set the Browser widget
+		setGeneText(null);
+		setGexText(null);
+		
+		SelectionBox.addListener(this);
+	}
+	
+	public void setGeneProduct(final GeneProduct gp) 
+	{ 
+		if(geneProduct == gp) return;
+		
+		Thread fetchThread = new Thread() {
+			public void run() {
+				geneProduct = gp;
+				if(gp == null) {
+					setGeneText(null);
+					setGexText(null);
+					return;
+				}
+				// Get the backpage text
+				String geneHeader = geneProduct.getGmmlData().getBackpageHead();
+				if (geneHeader == null) geneHeader = "";
+				String geneId = geneProduct.getGmmlData().getGeneID();
+				String systemCode = geneProduct.getGmmlData().getSystemCode();
+				String bpText = geneHeader.equals("") ? geneHeader : "<H2>" + geneHeader + "</H2><P>";
+				String bpInfo = Gdb.getBpInfo(geneId, systemCode);
+				bpText += bpInfo == null ? "<I>No gene information found</I>" : bpInfo;
+				String crossRefText = getCrossRefText(geneId, systemCode);
+				String gexText = Gex.getDataString(new IdCodePair(geneId, systemCode));
+				if (bpText != null) 	setGeneText(bpText);
+				if (gexText != null)	setGexText(gexText + crossRefText);
+				else 					setGexText("<I>No expression data found</I>");
+			}
+		};
+		
+		//Run in seperate thread so that this method can return
+		fetchThread.start();
+	}
+		
+	public String getCrossRefText(String id, String code) {
+		List<IdCodePair> crfs = Gdb.getCrossRefs(id, code);
+		if(crfs.size() == 0) return "";
+		StringBuilder crt = new StringBuilder("<H1>Cross references</H1><P>");
+		for(IdCodePair cr : crfs) {
+			String idtxt = cr.getId();
+			String url = getCrossRefLink(cr);
+			if(url != null) {
+				int os = Utils.getOS();
+				if(os == Utils.OS_WINDOWS) {
+					//In windows: open in new browser window
+					idtxt = "<a href='" + url + "' target='_blank'>" + idtxt + "</a>";
+				} else {
+					//This doesn't work under ubuntu, so no new windoe there
+					idtxt = "<a href='" + url + "'>" + idtxt + "</a>";
+				}
+				
+			}
+			String dbName = DataSources.sysCode2Name.get(cr.getCode());
+			crt.append( idtxt + ", " + (dbName != null ? dbName : cr.getCode()) + "<br>");
+		}
+		return crt.toString();
+	}
+	
+	String getCrossRefLink(IdCodePair idc) {
+		String c = idc.getCode();
+		String id = idc.getId();
+		if(c.equalsIgnoreCase("En"))
+			return "http://www.ensembl.org/Homo_sapiens/searchview?species=all&idx=Gene&q=" + id;
+		if(c.equalsIgnoreCase("P"))
+			return "http://www.expasy.org/uniprot/" + id;
+		if(c.equalsIgnoreCase("Q")) {
+			String pre = "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?";
+			if(id.startsWith("NM")) {
+				return pre + "db=Nucleotide&cmd=Search&term=" + id;
+			} else {
+				return pre + "db=Protein&cmd=search&term=" + id;
+			}
+		}
+		if(c.equalsIgnoreCase("T"))
+			return "http://godatabase.org/cgi-bin/go.cgi?view=details&search_constraint=terms&depth=0&query=" + id;
+		if(c.equalsIgnoreCase("I"))
+			return "http://www.ebi.ac.uk/interpro/IEntry?ac=" + id;
+		if(c.equalsIgnoreCase("Pd"))
+			return "http://bip.weizmann.ac.il/oca-bin/ocashort?id=" + id;
+		if(c.equalsIgnoreCase("X"))
+			return "http://www.ensembl.org/Homo_sapiens/featureview?type=OligoProbe;id=" + id;
+		if(c.equalsIgnoreCase("Em"))
+			return "http://www.ebi.ac.uk/cgi-bin/emblfetch?style=html&id=" + id;
+		if(c.equalsIgnoreCase("L"))
+			return "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=gene&cmd=Retrieve&dopt=full_report&list_uids=" + id;
+		if(c.equalsIgnoreCase("H"))
+			return "http://www.gene.ucl.ac.uk/cgi-bin/nomenclature/get_data.pl?hgnc_id=" + id;
+		if(c.equalsIgnoreCase("I"))
+			return "http://www.ebi.ac.uk/interpro/IEntry?ac=" + id;
+		if(c.equalsIgnoreCase("M"))
+			return "http://www.informatics.jax.org/searches/accession_report.cgi?id=" + id;
+		if(c.equalsIgnoreCase("Om"))
+			return "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=OMIM&cmd=Search&doptcmdl=Detailed&term=?" + id;
+		if(c.equalsIgnoreCase("Pf"))
+			return "http://www.sanger.ac.uk//cgi-bin/Pfam/getacc?" + id;
+		if(c.equalsIgnoreCase("R"))
+			return "http://rgd.mcw.edu/generalSearch/RgdSearch.jsp?quickSearch=1&searchKeyword=" + id;
+		if(c.equalsIgnoreCase("D"))
+			return "http://db.yeastgenome.org/cgi-bin/locus.pl?locus=" + id;
+		if(c.equalsIgnoreCase("S"))
+			return "http://www.expasy.org/uniprot/" + id;
+		if(c.equalsIgnoreCase("U")) {
+			String [] org_nr = id.split("\\.");
+			if(org_nr.length == 2) {
+				return "http://www.ncbi.nlm.nih.gov/UniGene/clust.cgi?ORG=" + 
+				org_nr[0] + "&CID=" + org_nr[1];
+			}
+			else {
+				return null;
+			}
+		}
+		if (c.equalsIgnoreCase("Nw"))
+		{
+			return "http://nugowiki.org/index.php/" + id;
+		}
+		if (c.equalsIgnoreCase("Ca"))
+		{
+			return "http://chem.sis.nlm.nih.gov/chemidplus/direct.jsp?regno=" + id;
+		}
+		if (c.equalsIgnoreCase("Cp"))
+		{
+			return "http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi?cid=" + id;
+		}
+		if (c.equalsIgnoreCase("Ce"))
+		{
+			return "http://www.ebi.ac.uk/chebi/searchId=CHEBI:" + id;
+		}
+		if (c.equalsIgnoreCase("Ch"))
+		{
+			return "http://www.hmdb.ca/scripts/show_card.cgi?METABOCARD=" + id + ".txt";
+		}
+		if (c.equalsIgnoreCase("Ck"))
+		{
+			return "http://www.genome.jp/dbget-bin/www_bget?cpd:" + id;
+		}
+		return null;
+	}
+	
+	/**
+	 * Sets the text for the Gene information part of the browser. Will be prepended by a paragraph
+	 * header as defined in bpHeader
+	 * @param bpText	Text to display in HTML format
+	 */
+	public void setGeneText(String bpText) {
+		if(bpText == null) { //In case no information has to be displayed
+			this.bpText = bpHeader + "<I>No gene selected</I>";
+		} else {
+			this.bpText = bpHeader + bpText;
+		}
+		refresh();
+	}
+	
+	/**
+	 * Sets the text for the expression part of the browser. Will be prepended by a paragraph
+	 * header as defined in gexHeader
+	 * @param gexText	Text to display in HTML format
+	 */
+	public void setGexText(String gexText) {
+		if(gexText != null) { //In case no information has to be displayed
+			this.gexText = gexHeader + gexText;
+		} else {
+			this.gexText = "";
+		}
+		refresh();
+	}
+	
+	/**
+	 * Refreshes the text displayed in the browser
+	 */
+	public void refresh() {
+		getDisplay().asyncExec(new Runnable() {
+			public void run() {
+				bpBrowser.setText(header + bpText + gexText);	
+			}
+		});
+	}
+	
+	/**
+	 * Reads the header of the HTML content displayed in the browser. This header is displayed in the
+	 * file specified in the {@link HEADERFILE} field
+	 */
+	private void initializeHeader() {
+		try {
+			BufferedReader input = new BufferedReader(new InputStreamReader(
+						Engine.getResourceURL(BPDIR + "/" + HEADERFILE).openStream()));
+			String line;
+			header = "";
+			while((line = input.readLine()) != null) {
+				header += line.trim();
+			}
+		} catch (Exception e) {
+			Engine.log.error("Unable to read header file for backpage browser: " + e.getMessage(), e);
+		}
+	}
+
+	public void drawingEvent(SelectionEvent e) {
+		switch(e.type) {
+		case SelectionEvent.OBJECT_ADDED:
+			//Just take the first GeneProduct in the selection
+			for(VPathwayElement o : e.selection) {
+				if(o instanceof GeneProduct) {
+					if(geneProduct != o) setGeneProduct((GeneProduct)o);
+					break; //Selects the first, TODO: use setGmmlDataObjects
+				}
+			}
+			break;
+		case SelectionEvent.OBJECT_REMOVED:
+			if(e.selection.size() != 0) break;
+		case SelectionEvent.SELECTION_CLEARED:
+			setGeneProduct(null);
+			break;
+		}
+	}
+}

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/BackpagePanel.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/view/GeneProduct.java
===================================================================
--- trunk/src/swt/org/pathvisio/view/GeneProduct.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/view/GeneProduct.java	(revision 957)
@@ -0,0 +1,204 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.Font;
+import org.eclipse.swt.graphics.FontData;
+import org.eclipse.swt.graphics.GC;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.RGB;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.graphics.Region;
+
+import org.pathvisio.util.SwtUtils;
+import org.pathvisio.data.DataSources;
+import org.pathvisio.model.PathwayElement;
+
+/**
+ * This class implements a geneproduct and 
+ * provides methods to resize and draw it.
+ */
+public class GeneProduct extends GraphicsShape
+{
+	private static final long serialVersionUID = 1L;
+	public static final RGB INITIAL_FILL_COLOR = new RGB(255, 255, 255);
+	
+	// note: not the same as color!
+	RGB fillColor = INITIAL_FILL_COLOR;
+		
+	public GeneProduct (VPathway canvas, PathwayElement o) {
+		super(canvas, o);		
+		setHandleLocation();
+	}
+		
+	public int getDrawingOrder() {
+		return VPathway.DRAW_ORDER_GENEPRODUCT;
+	}
+	
+	/**
+	 * @deprecated get this info from PathwayElement directly
+	 */
+	public String getID() 
+	{
+		//Looks like the wrong way around, but in gpml the ID is attribute 'Name'
+		//NOTE: maybe change this in gpml?
+		return gdata.getGeneID();
+	}
+		
+	/**
+	 * Looks up the systemcode for this gene in Pathway.sysName2Code
+	 * @return	The system code or an empty string if the system is not found
+	 * 
+	 * @deprecated use PathwayElement.getSystemCode()
+	 */
+	public String getSystemCode()
+	{
+		String systemCode = "";
+		if(DataSources.sysName2Code.containsKey(gdata.getDataSource())) 
+			systemCode = DataSources.sysName2Code.get(gdata.getDataSource());
+		return systemCode;
+	}
+	
+//	private Text t;
+//	public void createTextControl()
+//	{		
+//		Color background = canvas.getShell().getDisplay()
+//		.getSystemColor(SWT.COLOR_INFO_BACKGROUND);
+//		
+//		Composite textComposite = new Composite(canvas, SWT.NONE);
+//		textComposite.setLayout(new GridLayout());
+//		textComposite.setLocation(getCenterX(), getCenterY() - 10);
+//		textComposite.setBackground(background);
+//		
+//		Label label = new Label(textComposite, SWT.CENTER);
+//		label.setText("Specify gene name:");
+//		label.setBackground(background);
+//		t = new Text(textComposite, SWT.SINGLE | SWT.BORDER);
+//				
+//		t.addSelectionListener(new SelectionAdapter() {
+//			public void widgetDefaultSelected(SelectionEvent e) {
+//				disposeTextControl();
+//			}
+//		});
+//				
+//		t.setFocus();
+//		
+//		Button b = new Button(textComposite, SWT.PUSH);
+//		b.setText("OK");
+//		b.addSelectionListener(new SelectionAdapter() {
+//			public void widgetSelected(SelectionEvent e) {
+//				disposeTextControl();
+//			}
+//		});
+//		
+//		textComposite.pack();
+//	}
+	
+//	protected void disposeTextControl()
+//	{	
+//		markDirty();
+//		gdata.setGeneID (t.getText());
+//		markDirty();
+//		//TODO: implement listener. 
+//		//canvas.updatePropertyTable(this);
+//		Composite c = t.getParent();
+//		c.setVisible(false);
+//		c.dispose();
+//		
+//		canvas.redrawDirtyRect();
+//	}
+			
+	/**
+	 * Calculate the font size adjusted to the canvas zoom factor.
+	 */
+	private int getVFontSize()
+	{
+		return (int)(vFromM (gdata.getMFontSize()));
+	}
+
+	public void draw(PaintEvent e, GC buffer)
+	{
+		Color c = null;
+		Color b = SwtUtils.changeColor(c, new RGB(255, 255, 255), e.display);
+		Font f = null;
+		
+		if(isSelected())
+		{
+			c = SwtUtils.changeColor(c, selectColor, e.display);
+		}
+		else 
+		{
+			c = SwtUtils.changeColor(c, gdata.getColor(), e.display);
+		}
+		
+		buffer.setForeground(c);
+		buffer.setBackground(b);
+		buffer.setLineStyle (SWT.LINE_SOLID);
+		buffer.setLineWidth (1);		
+		
+		Rectangle area = new Rectangle(
+				getVLeft(), getVTop(), getVWidth(), getVHeight());
+		
+		buffer.fillRectangle (area); // white background
+		buffer.drawRectangle (area);
+		
+		buffer.setClipping ( area.x - 1, area.y - 1, area.width + 1, area.height + 1);
+		
+		f = SwtUtils.changeFont(f, new FontData(gdata.getFontName(), getVFontSize(), SWT.NONE), e.display);
+		buffer.setFont(f);
+		
+		String label = gdata.getTextLabel();
+		Point textSize = buffer.textExtent (label);
+		buffer.drawString (label, 
+				area.x + (int)(area.width / 2) - (int)(textSize.x / 2),
+				area.y + (int)(area.height / 2) - (int)(textSize.y / 2), true);
+				
+				
+		Region r = null;
+		buffer.setClipping(r);
+		
+		c.dispose();
+		b.dispose();
+		f.dispose();
+	}
+	
+	protected void draw(PaintEvent e)
+	{
+		draw(e, e.gc);
+	}
+	
+	public void drawHighlight(PaintEvent e, GC buffer)
+	{
+		if(isHighlighted())
+		{
+			Color c = null;
+			c = SwtUtils.changeColor(c, highlightColor, e.display);
+			buffer.setForeground(c);
+			buffer.setLineWidth(2);
+			buffer.drawRectangle (
+					getVLeft() - 1,
+					getVTop() - 1,
+					getVWidth() + 3,
+					getVHeight() + 3
+				);
+			if(c != null) c.dispose();
+		}
+	}
+}
Index: trunk/src/swt/org/pathvisio/view/Label.java
===================================================================
--- trunk/src/swt/org/pathvisio/view/Label.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/view/Label.java	(revision 957)
@@ -0,0 +1,257 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import java.awt.Polygon;
+import java.awt.Rectangle;
+import java.awt.Shape;
+import java.awt.geom.Rectangle2D;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.Font;
+import org.eclipse.swt.graphics.GC;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.RGB;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Text;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.PathwayEvent;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.util.SwtUtils;
+
+public class Label extends GraphicsShape
+{
+	private static final long serialVersionUID = 1L;
+	
+	public static final int M_INITIAL_FONTSIZE = 10 * 15;
+	public static final int M_INITIAL_WIDTH = 80 * 15;
+	public static final int M_INITIAL_HEIGHT = 20 * 15;
+		
+	double getFontSize()
+	{
+		return gdata.getMFontSize() * canvas.getZoomFactor();
+	}
+	
+	void setFontSize(double v)
+	{
+		gdata.setMFontSize(v / canvas.getZoomFactor());
+	}
+				
+	/**
+	 * Constructor for this class
+	 * @param canvas - the VPathway this label will be part of
+	 */
+	public Label(VPathway canvas, PathwayElement o)
+	{
+		super(canvas, o);
+		setHandleLocation();
+	}
+	
+	public int getDrawingOrder() {
+		return VPathway.DRAW_ORDER_LABEL;
+	}
+	
+	public String getLabelText() {
+		return gdata.getTextLabel();
+	}
+	
+	String prevText = "";
+	public void adjustWidthToText() {
+		if(gdata.getTextLabel().equals(prevText)) return;
+		
+		prevText = getLabelText();
+		
+		Point mts = mComputeTextSize();
+		
+		//Keep center location
+		double mWidth = mts.x;
+		double mHeight = mts.y;
+		
+		listen = false; //Disable listener
+		gdata.setMLeft(gdata.getMLeft() - (mWidth - gdata.getMWidth())/2);
+		gdata.setMTop(gdata.getMTop() - (mHeight - gdata.getMHeight())/2);
+		gdata.setMWidth(mWidth);
+		gdata.setMHeight(mHeight);
+		listen = true; //Enable listener
+		
+		setHandleLocation();
+	}
+	
+	private Text t;
+	public void createTextControl()
+	{
+		Color background = canvas.getShell().getDisplay()
+		.getSystemColor(SWT.COLOR_INFO_BACKGROUND);
+		
+		Composite textComposite = new Composite(canvas, SWT.NONE);
+		textComposite.setLayout(new GridLayout());
+		textComposite.setLocation(getVCenterX(), getVCenterY() - 10);
+		textComposite.setBackground(background);
+		
+		org.eclipse.swt.widgets.Label label = new org.eclipse.swt.widgets.Label(textComposite, SWT.CENTER);
+		label.setText("Specify label:");
+		label.setBackground(background);
+		t = new Text(textComposite, SWT.SINGLE | SWT.BORDER);
+		t.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+		t.addSelectionListener(new SelectionAdapter() {
+			public void widgetDefaultSelected(SelectionEvent e) {
+				disposeTextControl();
+			}
+		});
+				
+		t.setFocus();
+		
+		Button b = new Button(textComposite, SWT.PUSH);
+		b.setText("OK");
+		b.addSelectionListener(new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				disposeTextControl();
+			}
+		});
+		
+		textComposite.pack();
+	}
+	
+	Point mComputeTextSize() {
+		GC gc = new GC(canvas.getDisplay());
+		Font f = new Font(canvas.getDisplay(), 
+				gdata.getFontName(), 
+				(int)gdata.getMFontSize(), getFontStyle());
+		gc.setFont (f);
+		Point ts = gc.textExtent(gdata.getTextLabel());
+		f.dispose();
+		gc.dispose();
+		
+		return ts;
+	}
+	
+	protected void disposeTextControl()
+	{
+		gdata.setTextLabel(t.getText());
+		Composite c = t.getParent();
+		c.setVisible(false);
+		c.dispose();
+	}
+		
+	double getVFontSize()
+	{
+		return vFromM(gdata.getMFontSize());
+	}
+
+	private int getFontStyle() {
+		int style = SWT.NONE;
+		
+		if (gdata.isBold())
+		{
+			style |= SWT.BOLD;
+		}
+		
+		if (gdata.isItalic())
+		{
+			style |= SWT.ITALIC;
+		}
+		return style;
+	}
+	
+	public void draw(PaintEvent e, GC buffer)
+	{
+		int style = getFontStyle();
+		
+		Font f = new Font(e.display, gdata.getFontName(), (int)getVFontSize(), style);
+		
+		buffer.setFont (f);
+		
+		Point textSize = buffer.textExtent (gdata.getTextLabel());
+		
+		Color c = null;
+		if (isSelected())
+		{
+			c = SwtUtils.changeColor(c, selectColor, e.display);
+		}
+		else if (isHighlighted())
+		{
+			RGB rgb = SwtUtils.color2rgb(GlobalPreference.getValueColor(GlobalPreference.COLOR_HIGHLIGHTED));
+			c = SwtUtils.changeColor(c, rgb, e.display);
+		}
+		else 
+		{
+			c = SwtUtils.changeColor(c, gdata.getColor(), e.display);
+		}
+		buffer.setForeground (c);
+		
+		buffer.drawString (gdata.getTextLabel(), 
+			(int) getVCenterX() - (textSize.x / 2) , 
+			(int) getVCenterY() - (textSize.y / 2), true);
+		
+		f.dispose();
+		c.dispose();
+		
+	}
+	
+	protected void draw(PaintEvent e)
+	{
+		draw(e, e.gc);
+	}	
+	
+	public void gmmlObjectModified(PathwayEvent e) {
+		if(listen) {
+			super.gmmlObjectModified(e);
+			adjustWidthToText();
+		}
+	}
+	
+	/**
+	 * Outline of a label is determined by
+	 * - position of the handles
+	 * - size of the text
+	 * Because the text can sometimes be larger than the handles
+	 */
+	protected Shape getVOutline()
+	{
+		int[] vx = new int[4];
+		int[] vy = new int[4];
+		
+		int[] p = getVHandleLocation(handleNE).asIntArray();
+		vx[0] = p[0]; vy[0] = p[1];
+		p = getVHandleLocation(handleSE).asIntArray();
+		vx[1] = p[0]; vy[1] = p[1];
+		p = getVHandleLocation(handleSW).asIntArray();
+		vx[2] = p[0]; vy[2] = p[1];
+		p = getVHandleLocation(handleNW).asIntArray();
+		vx[3] = p[0]; vy[3] = p[1];
+		
+		Polygon pol = new Polygon(vx, vy, 4);		
+		Rectangle bounds = pol.getBounds();
+		
+		Point mq = mComputeTextSize();
+		double vqx = vFromM(mq.x);
+		double vqy = vFromM(mq.y);
+		
+		LinAlg.Point c = getVCenter();
+		bounds.add(new Rectangle2D.Double(c.x - vqx / 2, c.y - vqy / 2, vqx, vqy)); 
+		
+		return bounds;
+	}
+	
+}
Index: trunk/src/swt/org/pathvisio/view/Graphics.java
===================================================================
--- trunk/src/swt/org/pathvisio/view/Graphics.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/view/Graphics.java	(revision 957)
@@ -0,0 +1,131 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import java.awt.Color;
+
+import org.eclipse.swt.graphics.Region;
+import org.pathvisio.model.Pathway;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.PathwayEvent;
+import org.pathvisio.model.PathwayListener;
+import org.pathvisio.preferences.GlobalPreference;
+
+
+/**
+ * This class is a parent class for all graphics
+ * that can be added to a VPathway.
+ */
+public abstract class Graphics extends VPathwayElement implements PathwayListener
+{
+	public static Color selectColor = GlobalPreference.getValueColor(GlobalPreference.COLOR_SELECTED);
+	public static Color highlightColor = GlobalPreference.getValueColor(GlobalPreference.COLOR_HIGHLIGHTED);
+	
+	protected PathwayElement gdata = null;
+	
+	public Graphics(VPathway canvas, PathwayElement o) {
+		super(canvas);
+		o.addListener(this);
+		gdata = o;
+	}
+	
+	public void select()
+	{
+		super.select();
+		for (Handle h : getHandles())
+		{
+			h.show();
+		}
+	}
+	
+	public void deselect()
+	{
+		super.deselect();
+		for (Handle h : getHandles())
+		{
+			h.hide();
+		}
+	}
+	
+	public PathwayElement getGmmlData() {
+		return gdata;
+	}
+	
+//	public List getAttributes() { return gdata.getAttributes() ;}
+	boolean listen = true;
+	public void gmmlObjectModified(PathwayEvent e) {	
+		if(listen) markDirty(); // mark everything dirty
+	}
+	
+	public Region createVisualizationRegion() {
+		Region region = new Region();
+		java.awt.Rectangle r = getVBounds();
+		region.add(r.x, r.y, r.width, r.height);
+		return region;
+	}
+	
+	
+	/**
+	 * Get the x-coordinate of the center point of this object
+	 * adjusted to the current zoom factor
+
+	 * @return the center x-coordinate as integer
+	 */
+	public int getVCenterX() { return (int)(vFromM(gdata.getMCenterX())); }
+	
+	/**
+	 * Get the y-coordinate of the center point of this object
+	 * adjusted to the current zoom factor
+	 * 
+	 * @return the center y-coordinate as integer
+	 */
+	public int getVCenterY() { return (int)(vFromM(gdata.getMCenterY())); }
+
+	public int getVLeft() { return (int)(vFromM(gdata.getMLeft())); }
+	public int getVWidth() { return (int)(vFromM(gdata.getMWidth()));  }
+	public int getVTop() { return (int)(vFromM(gdata.getMTop())); }
+	public int getVHeight() { return (int)(vFromM(gdata.getMHeight())); }
+	
+	/**
+	 * Get the x-coordinate of the center point of this object
+	 * adjusted to the current zoom factor
+
+	 * @return the center x-coordinate as double
+	 */
+	public double getVCenterXDouble() { return vFromM(gdata.getMCenterX()); }
+	
+	/**
+	 * Get the y-coordinate of the center point of this object
+	 * adjusted to the current zoom factor
+	 * 
+	 * @return the center y-coordinate as double
+	 */
+	public double getVCenterYDouble() { return vFromM(gdata.getMCenterY()); }
+
+	public double getVLeftDouble() { return vFromM(gdata.getMLeft()); }
+	public double getVWidthDouble() { return vFromM(gdata.getMWidth());  }
+	public double getVTopDouble() { return vFromM(gdata.getMTop()); }
+	public double getVHeightDouble() { return vFromM(gdata.getMHeight()); }
+	
+	protected void destroy() {
+		super.destroy();
+		gdata.removeListener(canvas);
+		Pathway parent = gdata.getParent();
+		if(parent != null) parent.remove(gdata);
+	}
+	
+}
\ No newline at end of file
Index: trunk/src/swt/org/pathvisio/view/Shape.java
===================================================================
--- trunk/src/swt/org/pathvisio/view/Shape.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/view/Shape.java	(revision 957)
@@ -0,0 +1,147 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.GC;
+import org.eclipse.swt.graphics.RGB;
+import org.eclipse.swt.graphics.Transform;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.util.SwtUtils;
+
+/**
+ * This class represents a GMMLShape, which can be a 
+ * rectangle or ellips, depending of its type.
+ */
+public class Shape extends GraphicsShape
+{
+	private static final long serialVersionUID = 1L;
+			
+	/**
+	 * Constructor for this class
+	 * @param canvas - the VPathway this Shape will be part of
+	 */
+	public Shape(VPathway canvas, PathwayElement o)
+	{
+		super(canvas, o);
+		setHandleLocation();
+	}
+		
+	public int getDrawingOrder() {
+		switch(gdata.getShapeType()) {
+		case BRACE:
+			return VPathway.DRAW_ORDER_BRACE;
+		default:
+			return VPathway.DRAW_ORDER_SHAPE;
+		}
+	}
+	
+	public void draw(PaintEvent e, GC buffer)
+	{	
+		Color c = null;
+		Color b = null;
+		if (isSelected())
+		{
+			c = SwtUtils.changeColor(c, selectColor, e.display);
+		}
+		else if (isHighlighted())
+		{
+			RGB rgb = SwtUtils.color2rgb(GlobalPreference.getValueColor(GlobalPreference.COLOR_HIGHLIGHTED));
+			c = SwtUtils.changeColor(c, rgb, e.display);
+		}
+		else 
+		{
+			c = SwtUtils.changeColor(c, gdata.getColor(), e.display);
+		}
+		buffer.setForeground (c);
+		buffer.setLineStyle (SWT.LINE_SOLID);
+		b = SwtUtils.changeColor(c, gdata.getFillColor(), e.display);
+		buffer.setBackground (b);
+		
+		Transform tr = new Transform(e.display);
+		rotateGC(buffer, tr);
+		
+		int vStartX = getVLeft();
+		int vStartY = getVTop();
+		int vWidth = getVWidth();
+		int vHeight = getVHeight();
+		
+		switch (gdata.getShapeType())
+		{
+			case RECTANGLE: 
+				buffer.setLineWidth (1);
+				if (!gdata.isTransparent())
+					buffer.fillRectangle (
+						vStartX,	vStartY,	vWidth, vHeight);
+				buffer.drawRectangle (
+					vStartX,	vStartY,	vWidth, vHeight);				
+				break;
+			case OVAL:				
+				buffer.setLineWidth (1);
+				if (!gdata.isTransparent())
+					buffer.fillOval (
+						vStartX, vStartY,	vWidth, vHeight);
+				buffer.drawOval (
+					vStartX, vStartY,	vWidth, vHeight);
+				break;
+			case ARC:
+				buffer.setLineWidth (1);
+				/**
+				 * Arcs are different from Oval and Rect, in that
+				 * they are not filled in GenMAPP, and that the
+				 * color column is used for the line color.
+				 * Likewise, we don't fill them in PathVisio.
+				 */
+//				if (!gdata.isTransparent())
+//					buffer.fillArc(
+//							startX, startY,	width, height, 0, 180);					
+				buffer.drawArc(
+						vStartX, vStartY,	vWidth, vHeight, 0, -180);
+				break;
+			case BRACE:
+				buffer.setLineWidth (2);
+								
+				int cx = getVCenterX();
+				int cy = getVCenterY();
+				int w = getVWidth();
+				int d = getVHeight();
+				
+				buffer.drawLine (cx + d/2, cy, cx + w/2 - d/2, cy); //line on the right
+				buffer.drawLine (cx - d/2, cy, cx - w/2 + d/2, cy); //line on the left
+				buffer.drawArc (cx - w/2, cy, d, d, -180, -90); //arc on the left
+				buffer.drawArc (cx - d, cy - d,	d, d, -90, 90); //left arc in the middle
+				buffer.drawArc (cx, cy - d, d, d, -90, -90); //right arc in the middle
+				buffer.drawArc (cx + w/2 - d, cy, d, d, 0, 90); //arc on the right
+				break;
+		}
+
+		buffer.setTransform(null);
+		
+		c.dispose();
+		b.dispose();
+		tr.dispose();
+	}
+	
+	protected void draw(PaintEvent e)
+	{
+		draw(e, e.gc);
+	}
+	
+}
\ No newline at end of file
Index: trunk/src/swt/org/pathvisio/view/GraphicsShape.java
===================================================================
--- trunk/src/swt/org/pathvisio/view/GraphicsShape.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/view/GraphicsShape.java	(revision 957)
@@ -0,0 +1,486 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import java.awt.Polygon;
+import java.awt.Shape;
+import java.awt.geom.Rectangle2D;
+import java.util.HashSet;
+import java.util.Set;
+
+import org.eclipse.swt.graphics.GC;
+import org.eclipse.swt.graphics.Transform;
+
+import org.pathvisio.util.SwtUtils;
+import org.pathvisio.view.LinAlg.Point;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.PathwayEvent;
+import org.pathvisio.model.PathwayElement.MPoint;
+import org.pathvisio.model.GraphLink.GraphRefContainer;
+
+/**
+ * This is an {@link Graphics} class representing shapelike forms,
+ * and provides implementation for containing 8 handles placed in a 
+ * (rotated) rectangle around the shape and a rotation handle
+ */
+public abstract class GraphicsShape extends Graphics {
+
+	private static final double M_ROTATION_HANDLE_POSITION = 20.0 * 15;
+
+	//Side handles
+	Handle handleN;
+	Handle handleE;
+	Handle handleS;
+	Handle handleW;
+	//Corner handles
+	Handle handleNE;
+	Handle handleSE;
+	Handle handleSW;
+	Handle handleNW;
+	//Rotation handle
+	Handle handleR;
+		
+	final Handle[][] handleMatrix; //Used to get opposite handles
+	
+	public GraphicsShape(VPathway canvas, PathwayElement o) {
+		super(canvas, o);
+		
+		handleN	= new Handle(Handle.DIRECTION_Y, this, canvas);
+		handleE	= new Handle(Handle.DIRECTION_X, this, canvas);
+		handleS	= new Handle(Handle.DIRECTION_Y, this, canvas);
+		handleW	= new Handle(Handle.DIRECTION_X, this, canvas);
+				
+		handleNE = new Handle(Handle.DIRECTION_FREE, this, canvas);
+		handleSE = new Handle(Handle.DIRECTION_FREE, this, canvas);
+		handleSW = new Handle(Handle.DIRECTION_FREE, this, canvas);
+		handleNW = new Handle(Handle.DIRECTION_FREE, this, canvas);
+		
+		handleR = new Handle(Handle.DIRECTION_ROT, this, canvas);
+		
+		handleMatrix = new Handle[][] {
+				{ handleNW, 	handleNE },
+				{ handleSW, 	handleSE }};
+	}
+	
+	
+	/**
+	 * Adjust model to changes in the shape, 
+	 * and at the same time calculates the new position 
+	 * in gpml coordinates (so without zoom factor)
+	 */
+	private void setVShape(double vleft, double vtop, double vwidth, double vheight) 
+	{
+//		gdata.dontFireEvents(3);
+		gdata.setMWidth(mFromV(vwidth));
+		gdata.setMHeight(mFromV(vheight));
+		gdata.setMLeft(mFromV(vleft));
+		gdata.setMTop(mFromV(vtop));
+	}
+	
+	protected void vMoveBy(double vdx, double vdy)
+	{
+		gdata.setMLeft(gdata.getMLeft()  + mFromV(vdx));
+		gdata.setMTop(gdata.getMTop() + mFromV(vdy));
+		//Move graphRefs
+		//GraphLink.moveRefsBy(gdata, mFromV(vdx), mFromV(vdy));
+		Set<VPoint> toMove = new HashSet<VPoint>();
+		for(GraphRefContainer ref : gdata.getReferences()) {
+			if(ref instanceof MPoint) {
+				toMove.add(canvas.getPoint((MPoint)ref));
+			}
+		}
+		for(VPoint p : toMove) p.vMoveBy(vdx, vdy);
+	}
+
+	public void setVScaleRectangle(Rectangle2D.Double r) {
+		setVShape(r.x, r.y, r.width, r.height);
+	}
+	
+	protected Rectangle2D.Double getVScaleRectangle() {
+		return new Rectangle2D.Double(getVLeftDouble(), getVTopDouble(), getVWidthDouble(), getVHeightDouble());
+	}
+	
+	public Handle[] getHandles()
+	{
+		if( this instanceof SelectionBox) {
+			// Only corner handles
+			return new Handle[] {
+					handleNE, handleSE,
+					handleSW, handleNW
+			};
+		}
+		if(	this instanceof GeneProduct || 
+			this instanceof Label) {
+			// No rotation handle for these objects
+			return new Handle[] {
+					handleN, handleNE, handleE, handleSE,
+					handleS, handleSW, handleW,	handleNW,
+			};
+		}
+		return new Handle[] {
+				handleN, handleNE, handleE, handleSE,
+				handleS, handleSW, handleW,	handleNW,
+				handleR
+		};
+	}
+	
+	/**
+	 * Translate the given point to internal coordinate system
+	 * (origin in center and axis direction rotated with this objects rotation
+	 * @param MPoint p
+	 */
+	private Point mToInternal(Point p) {
+		Point pt = mRelativeToCenter(p);
+		Point pr = LinAlg.rotate(pt, gdata.getRotation());
+		return pr;
+	}
+
+	/**
+	 * Translate the given point to external coordinate system (of the
+	 * drawing canvas)
+	 * @param MPoint p
+	 */
+	private Point mToExternal(Point p) {
+		Point pr = LinAlg.rotate(p, -gdata.getRotation());
+		Point pt = mRelativeToCanvas(pr);
+		return pt;
+	}
+
+	/**
+	 * Translate the given coordinates to external coordinate system (of the
+	 * drawing canvas)
+	 * @param x
+	 * @param y
+	 */
+	private Point mToExternal(double x, double y) {
+		return mToExternal(new Point(x, y));
+	}
+
+	/**
+	 * Get the coordinates of the given point relative
+	 * to this object's center
+	 * @param p
+	 */
+	private Point mRelativeToCenter(Point p) {
+		return p.subtract(getMCenter());
+	}
+
+	/**
+	 * Get the coordinates of the given point relative
+	 * to the canvas' origin
+	 * @param p
+	 */
+	private Point vRelativeToCanvas(Point p) {
+		return p.add(getVCenter());
+	}
+
+	private Point mRelativeToCanvas(Point p) {
+		return p.add(getMCenter());
+	}
+
+	/**
+	 * Get the center point of this object
+	 */
+	public Point getVCenter() {
+		return new Point(getVCenterX(), getVCenterY());
+	}
+
+	/**
+	 * Get the center point of this object
+	 */
+	public Point getMCenter() {
+		return new Point(gdata.getMCenterX(), gdata.getMCenterY());
+	}
+
+	/**
+	 * Set the center point of this object
+	 * @param cn
+	 */
+	public void setMCenter(Point mcn) {
+//		gdata.dontFireEvents(1);
+		gdata.setMCenterX(mcn.x);
+		gdata.setMCenterY(mcn.y);
+	}
+
+	public void setVCenter(Point vcn) {
+//		gdata.dontFireEvents(1);
+		gdata.setMCenterX(mFromV(vcn.x));
+		gdata.setMCenterY(mFromV(vcn.y));
+	}
+
+	/**
+	 * Calculate a new center point given the new width and height, in a
+	 * way that the center moves over the rotated axis of this object
+	 * @param mWidthNew
+	 * @param mHeightNew
+	 */
+	public Point mCalcNewCenter(double mWidthNew, double mHeightNew) {
+		Point mcn = new Point((mWidthNew - gdata.getMWidth())/2, (mHeightNew - gdata.getMHeight())/2);
+		Point mcr = LinAlg.rotate(mcn, -gdata.getRotation());
+		return mRelativeToCanvas(mcr);
+	}
+
+	public Point vCalcNewCenter(double vWidthNew, double vHeightNew) {
+		Point vcn = new Point((vWidthNew - getVWidth())/2, (vHeightNew - getVHeight())/2);
+		Point vcr = LinAlg.rotate(vcn, -gdata.getRotation());
+		return vRelativeToCanvas(vcr);
+	}
+
+	/**
+	 * Set the rotation of this object
+	 * @param angle angle of rotation in radians
+	 */
+	public void setRotation(double angle) {
+		if(angle < 0) gdata.setRotation(angle + Math.PI*2);
+		else if(angle > Math.PI*2) gdata.setRotation (angle - Math.PI*2);
+		else gdata.setRotation(angle);
+	}
+	
+	/**
+	 * Rotates the {@link GC} around the objects center
+	 * @param gc	the {@link GC} to rotate
+	 * @param tr	a {@link Transform} that can be used for rotation
+	 */
+	protected void rotateGC(GC gc, Transform tr) {		
+		SwtUtils.rotateGC(gc, tr, (float)Math.toDegrees(gdata.getRotation()), 
+				getVCenterX(), getVCenterY());
+	}
+	
+	public void adjustToHandle(Handle h) {
+		//Rotation
+		if 	(h == handleR) {
+			Point def = mRelativeToCenter(getMHandleLocation(h));
+			Point cur = mRelativeToCenter(new Point(h.mCenterx, h.mCentery));
+			
+			setRotation(gdata.getRotation() + LinAlg.angle(def, cur));
+			
+			return;
+		}
+					
+		// Transformation
+		Point mih = mToInternal(new Point(h.mCenterx, h.mCentery));
+		
+		double mdx = 0;
+		double mdy = 0;
+		double mdw = 0;
+		double mdh = 0;
+			
+		if	(h == handleN || h == handleNE || h == handleNW) {
+			mdy = -(mih.y + gdata.getMHeight()/2);
+			mdh = -mdy;
+		}
+		if	(h == handleS || h == handleSE || h == handleSW ) {
+			mdy = mih.y - gdata.getMHeight()/2;
+			mdh = mdy;
+		}
+		if	(h == handleE || h == handleNE || h == handleSE) {
+			mdx = mih.x - gdata.getMWidth()/2;
+			mdw = mdx;
+		}
+		if	(h == handleW || h == handleNW || h== handleSW) {
+			mdx = -(mih.x + gdata.getMWidth()/2);
+			mdw = -mdx;
+		};
+		
+		Point mnc = mCalcNewCenter(gdata.getMWidth() + mdw, gdata.getMHeight() + mdh);
+//		gdata.dontFireEvents(1);
+		gdata.setMHeight(gdata.getMHeight() + mdy);
+		gdata.setMWidth(gdata.getMWidth() + mdx);
+		setMCenter(mnc);		
+	
+		//In case object had zero width, switch handles
+		if(gdata.getMWidth() < 0) {
+			negativeWidth(h);
+		}
+		if(gdata.getMHeight() < 0) {
+			negativeHeight(h);
+		}
+	}
+	
+	/**
+	 * This method implements actions performed when the width of
+	 * the object becomes negative after adjusting to a handle
+	 * @param h	The handle this object adjusted to
+	 */
+	public void negativeWidth(Handle h) {
+		if(h.getDirection() == Handle.DIRECTION_FREE)  {
+			h = getOppositeHandle(h, Handle.DIRECTION_X);
+		} else {
+			h = getOppositeHandle(h, Handle.DIRECTION_XY);
+		}
+		double mw = -gdata.getMWidth();
+		double msx = gdata.getMLeft() - mw;
+//		gdata.dontFireEvents(1);
+		gdata.setMWidth (mw);
+		gdata.setMLeft(msx);
+		canvas.setPressedObject(h);
+	}
+	
+	/**
+	 * This method implements actions performed when the height of
+	 * the object becomes negative after adjusting to a handle
+	 * @param h	The handle this object adjusted to
+	 */
+	public void negativeHeight(Handle h) {
+		if(h.getDirection() == Handle.DIRECTION_FREE)  {
+			h = getOppositeHandle(h, Handle.DIRECTION_Y);
+		} else {
+			h = getOppositeHandle(h, Handle.DIRECTION_XY);
+		}
+		double ht = -gdata.getMHeight();
+		double sy = gdata.getMTop() - ht;
+//		gdata.dontFireEvents(1);
+		gdata.setMHeight(ht);
+		gdata.setMTop(sy);
+		canvas.setPressedObject(h);
+	}
+	
+	/**
+	 * Sets the handles at the correct location;
+	 * @param ignore the position of this handle will not be adjusted
+	 */
+	private void setHandleLocation(Handle ignore)
+	{
+		Point p;
+		p = getMHandleLocation(handleN);
+		if(ignore != handleN) handleN.setMLocation(p.x, p.y);
+		p = getMHandleLocation(handleE);
+		if(ignore != handleE) handleE.setMLocation(p.x, p.y);
+		p = getMHandleLocation(handleS);
+		if(ignore != handleS) handleS.setMLocation(p.x, p.y);
+		p = getMHandleLocation(handleW);
+		if(ignore != handleW) handleW.setMLocation(p.x, p.y);
+		
+		p = getMHandleLocation(handleNE);
+		if(ignore != handleNE) handleNE.setMLocation(p.x, p.y);
+		p = getMHandleLocation(handleSE);
+		if(ignore != handleSE) handleSE.setMLocation(p.x, p.y);
+		p = getMHandleLocation(handleSW);
+		if(ignore != handleSW) handleSW.setMLocation(p.x, p.y);
+		p = getMHandleLocation(handleNW);
+		if(ignore != handleNW) handleNW.setMLocation(p.x, p.y);
+
+		p = getMHandleLocation(handleR);
+		if(ignore != handleR) handleR.setMLocation(p.x, p.y);
+		
+		for(Handle h : getHandles()) h.rotation = gdata.getRotation();
+	}
+	
+	/**
+	 * Sets the handles at the correct location
+	 */
+	public void setHandleLocation()
+	{
+		setHandleLocation(null);
+	}
+	
+	/**
+	 * Get the default location of the given handle 
+	 * (in coordinates relative to the canvas)
+	 * @param h
+	 */
+	protected Point getVHandleLocation(Handle h) 
+	{
+		Point mp = getMHandleLocation (h);
+		if (mp != null)			
+			return new Point (vFromM(mp.x), vFromM(mp.y));
+		else return null;
+	}
+
+	protected Point getMHandleLocation(Handle h) {
+		if(h == handleN) return mToExternal(0, -gdata.getMHeight()/2);
+		if(h == handleE) return mToExternal(gdata.getMWidth()/2, 0);
+		if(h == handleS) return mToExternal(0,  gdata.getMHeight()/2);
+		if(h == handleW) return mToExternal(-gdata.getMWidth()/2, 0);
+		
+		if(h == handleNE) return mToExternal(gdata.getMWidth()/2, -gdata.getMHeight()/2);
+		if(h == handleSE) return mToExternal(gdata.getMWidth()/2, gdata.getMHeight()/2);
+		if(h == handleSW) return mToExternal(-gdata.getMWidth()/2, gdata.getMHeight()/2);
+		if(h == handleNW) return mToExternal(-gdata.getMWidth()/2, -gdata.getMHeight()/2);
+
+		if(h == handleR) return mToExternal(gdata.getMWidth()/2 + M_ROTATION_HANDLE_POSITION, 0);
+		return null;
+	}
+	
+	/**
+	 * Gets the handle opposite to the given handle.
+	 * For directions N, E, S and W this is always their complement,
+	 * for directions NE, NW, SE, SW, you can constraint the direction, e.g.:
+	 * if direction is X, the opposite of NE will be NW instead of SW
+	 * @param h	The handle to find the opposite for
+	 * @param direction	Constraints on the direction, one of {@link Handle}#DIRECTION_*.
+	 * Will be ignored for N, E, S and W handles
+	 * @return	The opposite handle
+	 */
+	Handle getOppositeHandle(Handle h, int direction) {
+		//Ignore direction for N, E, S and W
+		if(h == handleN) return handleS;
+		if(h == handleE) return handleW;
+		if(h == handleS) return handleN;
+		if(h == handleW) return handleE;
+				
+		int[] pos = handleFromMatrix(h);
+		switch(direction) {
+		case Handle.DIRECTION_XY:
+		case Handle.DIRECTION_MINXY:
+		case Handle.DIRECTION_FREE:
+			return handleMatrix[ Math.abs(pos[0] - 1)][ Math.abs(pos[1] - 1)];
+		case Handle.DIRECTION_Y:
+			return handleMatrix[ Math.abs(pos[0] - 1)][pos[1]];
+		case Handle.DIRECTION_X:
+			return handleMatrix[ pos[0]][ Math.abs(pos[1] - 1)];
+		default:
+			return null;
+		}
+	}
+	
+	int[] handleFromMatrix(Handle h) {
+		for(int x = 0; x < 2; x++) {
+			for(int y = 0; y < 2; y++) {
+				if(handleMatrix[x][y] == h) return new int[] {x,y};
+			}
+		}
+		return null;
+	}
+	
+	/**
+	 * Creates a shape of the outline of this object
+	 */
+	protected Shape getVOutline()
+	{
+		int[] x = new int[4];
+		int[] y = new int[4];
+		
+		int[] p = getVHandleLocation(handleNE).asIntArray();
+		x[0] = p[0]; y[0] = p[1];
+		p = getVHandleLocation(handleSE).asIntArray();
+		x[1] = p[0]; y[1] = p[1];
+		p = getVHandleLocation(handleSW).asIntArray();
+		x[2] = p[0]; y[2] = p[1];
+		p = getVHandleLocation(handleNW).asIntArray();
+		x[3] = p[0]; y[3] = p[1];
+		
+		Polygon pol = new Polygon(x, y, 4);
+		return pol;
+	}
+			
+	public void gmmlObjectModified(PathwayEvent e) {		
+		markDirty(); // mark everything dirty
+		setHandleLocation();
+	}
+	
+}
Index: trunk/src/swt/org/pathvisio/view/VPathway.java
===================================================================
--- trunk/src/swt/org/pathvisio/view/VPathway.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/view/VPathway.java	(revision 957)
@@ -0,0 +1,1469 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+
+import java.awt.Color;
+import java.awt.Rectangle;
+import java.awt.geom.Point2D;
+import java.awt.geom.Rectangle2D;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.KeyEvent;
+import org.eclipse.swt.events.KeyListener;
+import org.eclipse.swt.events.MouseEvent;
+import org.eclipse.swt.events.MouseListener;
+import org.eclipse.swt.events.MouseMoveListener;
+import org.eclipse.swt.events.MouseTrackListener;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.events.PaintListener;
+import org.eclipse.swt.graphics.GC;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.widgets.Canvas;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Shell;
+import org.pathvisio.Engine;
+import org.pathvisio.gui.swt.AlignActions;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.model.GroupStyle;
+import org.pathvisio.model.LineStyle;
+import org.pathvisio.model.LineType;
+import org.pathvisio.model.ObjectType;
+import org.pathvisio.model.OrientationType;
+import org.pathvisio.model.Pathway;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.PathwayEvent;
+import org.pathvisio.model.PathwayListener;
+import org.pathvisio.model.ShapeType;
+import org.pathvisio.model.PathwayElement.MPoint;
+import org.pathvisio.visualization.Visualization;
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+import org.pathvisio.visualization.VisualizationManager.VisualizationListener;
+
+/**
+ * This class implements and handles a drawing.
+ * Graphics objects are stored in the drawing and can be 
+ * visualized. The class also provides methods for mouse  and key
+ * event handling.
+ */
+public class VPathway extends Canvas implements MouseListener, MouseMoveListener, 
+PaintListener, MouseTrackListener, KeyListener, PathwayListener, VisualizationListener
+{	
+	private static final long serialVersionUID = 1L;
+	static final double M_PASTE_OFFSET = 10 * 15;
+	
+	/**
+	 * All objects that are visible on this mapp, including the handles
+	 * but excluding the legend, mappInfo and selectionBox objects
+	 */
+	private ArrayList<VPathwayElement> drawingObjects;
+	public ArrayList<VPathwayElement> getDrawingObjects() { return drawingObjects; }
+	
+	/**
+	 * The {@link VPathwayElement} that is pressed last mouseDown event}
+	 */
+	VPathwayElement pressedObject	= null;	
+	
+	/**
+	 * The {@link Graphics} that is directly selected since last mouseDown event
+	 */
+	public Graphics selectedGraphics = null;
+	
+	/**
+	 * {@link InfoBox} object that contains information about this pathway,
+	 * currently only used for information in {@link gmmlVision.PropertyPanel}
+	 * (TODO: has to be implemented to behave the same as any Graphics object
+	 * when displayed on the drawing)
+	 */
+	InfoBox infoBox;
+	private Pathway data;
+	public Pathway getGmmlData()
+	{
+		return data;
+	}
+	
+	SelectionBox s; 
+		
+	private boolean editMode;
+	/**
+	 * Checks if this drawing is in edit mode
+	 * @return false if in edit mode, true if not
+	 */
+	public boolean isEditMode() { return editMode; }
+	
+	/**
+	 * Map the contents of a single data object to this VPathway
+	 */	
+	private Graphics fromGmmlDataObject (PathwayElement o)
+	{
+		Graphics result = null;
+		switch (o.getObjectType())
+		{
+			case ObjectType.DATANODE: result = new GeneProduct(this, o); break;
+			case ObjectType.SHAPE: result = new Shape(this, o); break;
+			case ObjectType.LINE: result = new Line(this, o); break;
+			case ObjectType.MAPPINFO: 
+				InfoBox mi = new InfoBox(this, o);
+				addObject(mi); 
+				setMappInfo(mi);
+				result = mi; 
+				break;				
+			case ObjectType.LABEL: result = new Label(this, o); break;					
+			case ObjectType.GROUP: result = new Group(this, o); break;					
+		}
+		return result;
+	}
+	
+	/**
+	 * Maps the contents of a pathway to this VPathway
+	 */	
+	public void fromGmmlData(Pathway _data)
+	{		
+		data = _data;
+			
+		for (PathwayElement o : data.getDataObjects())
+		{
+			fromGmmlDataObject (o);
+		}
+		int width = (int)vFromM(infoBox.getGmmlData().getMBoardWidth());
+		int height = (int)vFromM(infoBox.getGmmlData().getMBoardHeight());
+		setSize(width, height); 
+		data.fireObjectModifiedEvent(new PathwayEvent(null, PathwayEvent.MODIFIED_GENERAL));
+		data.addListener(this);
+	}
+
+	private int newGraphics = NEWNONE;
+	/**
+	 * Method to set the new graphics type that has to be added next time the user clicks on the
+	 * drawing. 
+	 * @param type One of the NEWXX fields of this class, where XX stands for the type of graphics to draw
+	 */
+	public void setNewGraphics(int type) { newGraphics = type; }
+	
+	private Rectangle dirtyRect = null;
+	/**
+	 * Adds object boundaries to the 'dirty rectangle', which marks the area that needs to be redrawn
+	 */
+	public void addDirtyRect(Rectangle r)
+	{
+		if(r == null) { //In case r is null, add whole drawing
+			org.eclipse.swt.graphics.Rectangle b = getBounds();
+			r = new Rectangle(b.x, b.y, b.width, b.height);
+		}
+		if(dirtyRect == null)
+			dirtyRect = r;
+		else
+			dirtyRect.add(r);	
+	}
+	
+	/**
+	 * Redraw parts marked dirty
+	 * reset dirty rect afterwards
+	 */
+	public void redrawDirtyRect()
+	{
+		if (dirtyRect != null)
+			redraw (dirtyRect.x, dirtyRect.y, dirtyRect.width + 1, dirtyRect.height + 1, false);
+		dirtyRect = null;
+	}
+	
+	/**
+	 *Constructor for this class
+	 */	
+	public VPathway(Composite parent, int style)
+	{
+		super (parent, style);
+		
+		drawingObjects	= new ArrayList<VPathwayElement>();
+		
+		s = new SelectionBox(this);
+		
+		addMouseListener(this);
+		addMouseMoveListener(this);
+		addPaintListener (this);
+		addMouseTrackListener(this);
+		addKeyListener(this);
+		VisualizationManager.addListener(this);
+	}
+		
+	/**
+	 * Sets the MappInfo containing information on the pathway
+	 * @param mappInfo
+	 */
+	public void setMappInfo(InfoBox mappInfo)
+	{
+		this.infoBox = mappInfo;
+		infoBox.getGmmlData().addListener(this);
+	}
+
+	/**
+	 * Gets the MappInfo containing information on the pathway
+	 */
+	public InfoBox getMappInfo() { return infoBox; }
+		
+	/**
+	 * Adds an element to the drawing
+	 * @param o the element to add
+	 */
+	public void addObject(VPathwayElement o)
+	{
+		if(!drawingObjects.contains(o)) { //Don't add duplicates!
+			drawingObjects.add(o);
+		}
+		
+	}
+
+	HashMap<MPoint, VPoint> pointsMtoV = new HashMap<MPoint, VPoint>();
+	protected VPoint getPoint(MPoint mPoint) {
+		VPoint p = pointsMtoV.get(mPoint);
+		if(p == null) {
+			p = newPoint(mPoint);
+		}
+		return p;
+	}
+	
+	
+	private VPoint newPoint(MPoint mPoint) {
+		VPoint p = null;
+		for(MPoint ep : mPoint.getEqualPoints()) {
+			p = pointsMtoV.get(ep);
+			if(p != null) {
+				p.addMPoint(mPoint);
+				pointsMtoV.put(mPoint, p);
+				break;
+			}
+		}
+		if(p == null) p = new VPoint(this);
+		p.addMPoint(mPoint);
+		pointsMtoV.put(mPoint, p);
+		return p;
+	}
+	
+	/**
+	 * Get the gene identifiers of all genes in this pathway
+	 * @return	List containing an identifier for every gene on the mapp
+	 * @deprecated get this info from Pathway directly
+	 */
+	public ArrayList<String> getMappIds()
+	{
+		ArrayList<String> mappIds = new ArrayList<String>();
+		for(VPathwayElement o : drawingObjects)
+		{
+			if(o instanceof GeneProduct)
+			{
+				mappIds.add(((GeneProduct)o).getID());
+			}
+		}
+		return mappIds;
+	}
+	
+	/**
+	 * Get the systemcodes of all genes in this pathway
+	 * @return	List containing a systemcode for every gene on the mapp
+	 * 
+	 * @deprecated get this info from Pathway directly
+	 */
+	public ArrayList<String> getSystemCodes()
+	{
+		ArrayList<String> systemCodes = new ArrayList<String>();
+		for(VPathwayElement o : drawingObjects)
+		{
+			if(o instanceof GeneProduct)
+			{
+				systemCodes.add(((GeneProduct)o).getSystemCode());
+			}
+		}
+		return systemCodes;
+	}
+	
+	/**
+	 * Set this drawing to editmode
+	 * @param editMode	true if editmode has to be enabled, false if disabled (view mode)
+	 */
+	public void setEditMode(boolean editMode)
+	{
+		this.editMode = editMode;
+		if(!editMode)
+		{
+			clearSelection();
+		}
+		SwtEngine.getWindow().showLegend(!editMode);	
+		redraw();
+	}
+	
+	private double zoomFactor = 1.0/15.0;
+	/**
+	 * Get the current zoomfactor used. 
+	 * 1/15 means 100%, 15 gpml unit = 1 pixel
+	 * 2/15 means 200%, 7.5 gpml unit = 1 pixel
+	 * 
+	 * The 15/1 ratio is there because of 
+	 * the Visual Basic legacy of GenMAPP
+	 * 
+	 * To distinguish between model coordinates and view coordinates,
+	 * we prefix all coordinates with either v or m (or V or M). For example:
+	 * 
+	 * mTop = gdata.getMTop();
+	 * vTop = GeneProduct.getVTop();
+	 * 
+	 * Calculations done on M's and V's should always match.
+	 * The only way to convert is to use the functions
+	 * mFromV and vFromM.
+	 * 
+	 * Correct: mRight = mLeft + mWidth;
+	 * Wrong: mLeft += vDx; 
+	 * Fixed: mLeft += mFromV(vDx);
+	 * 
+	 * @return	the current zoomfactor
+	 */
+	public double getZoomFactor() { return zoomFactor; }
+
+	/**
+	 * same as getZoomFactor, but in %
+	 * @return
+	 */
+	public double getPctZoom() { return zoomFactor * 100 * 15.0; }
+
+	/**
+	 * Sets the drawings zoom in percent
+	 * @param pctZoomFactor zoomfactor in percent
+	 */
+	public void setPctZoom(double pctZoomFactor)
+	{
+		zoomFactor = pctZoomFactor / 100.0 / 15.0;
+		int width = (int)vFromM(infoBox.getGmmlData().getMBoardWidth());
+		int height = (int)vFromM(infoBox.getGmmlData().getMBoardHeight());
+		setSize(width, height); 				
+		redraw();
+	}
+
+	public void setPressedObject(VPathwayElement o) {
+		pressedObject = o;
+	}
+	
+	int vPreviousX;
+	int vPreviousY;
+	boolean isDragging;
+	/**
+	 * handles mouse movement
+	 */
+	public void mouseMove(MouseEvent ve)
+	{
+		boolean altPressed = (ve.stateMask & SWT.ALT) != 0;
+		// If draggin, drag the pressed object
+		if (pressedObject != null && isDragging)
+		{
+			double vdx = ve.x - vPreviousX;
+			double vdy = ve.y - vPreviousY;
+			pressedObject.vMoveBy(vdx, vdy);
+				
+			vPreviousX = ve.x;
+			vPreviousY = ve.y;
+			
+			if (pressedObject instanceof Handle && altPressed && newGraphics == NEWNONE &&
+					((Handle)pressedObject).parent instanceof VPoint)
+			{
+				resetHighlight();
+				Point2D p2d = new Point2D.Double(ve.x, ve.y);
+				List<VPathwayElement> objects = getObjectsAt (p2d);
+				Collections.sort(objects);
+				Handle g = (Handle)pressedObject;
+				VPoint p = (VPoint)g.parent;
+				VPathwayElement x = null;
+				for (VPathwayElement o : objects)
+				{
+					if (o instanceof VPoint && o != p) {
+						x = o;
+						p.link((VPoint)o);
+						break;
+					} else if(o instanceof Graphics && !(o instanceof Line)) {
+						x = o;
+						p.link((Graphics)o);
+						break;
+					} 
+				}
+				if(x != null) x.highlight();
+			}
+			redrawDirtyRect();
+		}
+	}
+	
+	public void selectObject(VPathwayElement o) {
+		clearSelection();
+		lastAdded.select();
+		s.addToSelection(lastAdded);
+	}
+	
+	/**
+	 * Handles mouse Pressed input
+	 */
+	public void mouseDown(MouseEvent e)
+	{		
+		setFocus();
+		if (editMode)
+		{
+			if (newGraphics != NEWNONE)
+			{
+				newObject(new Point(e.x, e.y));
+				SwtEngine.getWindow().deselectNewItemActions();
+			}
+			else
+			{
+				editObject(new Point(e.x, e.y), e);
+			}
+		}
+		else
+		{
+			mouseDownViewMode(e);
+		}
+
+	}
+		
+	/**
+	 * Handles mouse Released input
+	 */
+	public void mouseUp(MouseEvent e)
+	{
+		if(isDragging)
+		{
+			resetHighlight();
+			if(s.isSelecting()) { //If we were selecting, stop it
+				s.stopSelecting();
+			}
+			// check if we placed a new object by clicking or dragging
+			// if it was a click, give object the initial size.
+			else if (newObject != null && 
+					Math.abs(newObjectDragStart.x - e.x) <= MIN_DRAG_LENGTH &&
+					Math.abs(newObjectDragStart.y - e.y) <= MIN_DRAG_LENGTH)
+			{
+				newObject.setInitialSize();
+			}
+			newObject = null;
+			redrawDirtyRect();
+		}
+		isDragging = false;
+	}
+	
+	/**
+	 * Handles mouse entered input
+	 */
+	public void mouseDoubleClick(MouseEvent e) {	}
+
+	/**
+	 * Paints all components in the drawing.
+	 * This method is called automatically in the 
+	 * painting process
+	 */
+	public void paintControl (PaintEvent e)
+	{		
+		Image image = (Image)getData("double-buffer-image");
+		// create an image for double-buffering, if it doesn't exist 
+		// or the component has been resized
+		if(image == null
+				|| image.getBounds().width != getSize().x
+				|| image.getBounds().height != getSize().y)
+		{
+			Engine.log.trace("Creating image of size " + getSize().x + ", " + getSize().y);
+			image = new Image(getDisplay(), getSize().x, getSize().y);
+			setData("double-buffer-image", image);
+		}
+
+		GC buffer = new GC(image);
+		buffer.setBackground(e.display.getSystemColor(SWT.COLOR_WHITE));
+		buffer.fillRectangle(e.x, e.y, e.width, e.height);
+		
+		buffer.setAntialias(SWT.ON);
+		
+		Rectangle2D.Double r = new Rectangle.Double(e.x, e.y, e.width, e.height);
+		    	
+		Collections.sort(drawingObjects);
+		
+		Visualization v = VisualizationManager.getCurrent();
+		for(VPathwayElement o : drawingObjects)
+		{
+			if(o.vIntersects(r))
+			{
+				if(checkDrawAllowed(o)) {
+					o.draw (e, buffer);
+				}
+				
+				if(v != null && o instanceof Graphics) {
+						try {
+							v.visualizeDrawing((Graphics) o, e, buffer);
+						} catch(Exception ex) {
+							Engine.log.error(
+									"Unable to apply visualization " + v + " on " + o, ex);
+							ex.printStackTrace();
+						}
+				}
+				if(o instanceof GeneProduct) ((GeneProduct)o).drawHighlight(e, buffer);
+			}
+		}
+		
+		e.gc.drawImage(image, 0, 0);
+		buffer.dispose();
+	}
+
+	boolean checkDrawAllowed(VPathwayElement o) {
+		if(isEditMode()) return true;
+		else return !(	o instanceof Handle ||
+						(o == s && !isDragging)
+					);
+	}
+
+	/**
+	 * deselect all elements on the drawing
+	 */
+	private void clearSelection()
+	{
+		for(VPathwayElement o : drawingObjects) o.deselect(); //Deselect all objects
+		s.reset();
+	}
+
+	/**
+	 * Handles event when on mouseDown in case the drawing is in view mode
+	 * (does nothing yet)
+	 * @param e	the mouse event to handle
+	 */
+	private void mouseDownViewMode(MouseEvent e) 
+	{
+		Point2D p2d = new Point2D.Double(e.x, e.y);
+
+		pressedObject = getObjectAt(p2d);
+		
+		if (pressedObject != null)
+			doClickSelect(p2d, e);
+		else
+			startSelecting(p2d);
+	}
+	
+	/**
+	 * Initializes selection, resetting the selectionbox
+	 * and then setting it to the position specified
+	 * @param vp - the point to start with the selection
+	 */
+	private void startSelecting(Point2D vp)
+	{
+		vPreviousX = (int)vp.getX();
+		vPreviousY = (int)vp.getY();
+		isDragging = true;
+		
+		clearSelection();
+		s.reset(vp.getX(), vp.getY());
+		s.startSelecting();
+		pressedObject = s.getCornerHandle();
+	}
+		
+	/**
+	 * Resets highlighting, unhighlights all GmmlDrawingObjects
+	 */
+	public void resetHighlight() 
+	{
+		for(VPathwayElement o : drawingObjects) o.unhighlight();
+		redraw();
+	}
+	
+	/**
+	 * Called by MouseDown, when we're in editting mode and we're not adding new objects
+	 * prepares for dragging the object
+	 */
+	private void editObject(Point p, MouseEvent e)
+	{
+		Point2D p2d = new Point2D.Double(p.x, p.y);
+		
+		pressedObject = getObjectAt(p2d);
+		
+		// if we clicked on an object
+		if (pressedObject != null)
+		{
+			// if our object is an handle, select also it's parent.
+			if(pressedObject instanceof Handle)
+			{
+				((Handle)pressedObject).parent.select();
+			} else {
+				doClickSelect(p2d, e);
+			}
+			
+			// start dragging
+			vPreviousX = p.x;
+			vPreviousY = p.y;
+			
+			isDragging = true;		
+		}
+		else
+		{
+			// start dragging selectionbox	
+			startSelecting(p2d);
+		}		
+	}
+
+	/**
+	 * Find the object at a particular location on the drawing
+	 * 
+	 * if you want to get more than one @see #getObjectsAt(Point2D)
+	 */
+	VPathwayElement getObjectAt(Point2D p2d) {
+		Collections.sort(drawingObjects);
+		VPathwayElement probj = null;
+		for (VPathwayElement o : drawingObjects)
+		{
+			if (o.vContains(p2d))
+			{
+				// select this object, unless it is an invisible gmmlHandle
+				if (o instanceof Handle && !((Handle)o).isVisible()) 
+					;
+				else 
+					probj = o;
+			}
+		}
+		return probj;
+	}
+	
+	/**
+	 * Find all objects at a particular location on the drawing
+	 * 
+	 * if you only need the top object, @see #getObjectAt(Point2D)
+	 */
+	List<VPathwayElement> getObjectsAt(Point2D p2d) 
+	{
+		List<VPathwayElement> result = new ArrayList<VPathwayElement>();
+		for (VPathwayElement o : drawingObjects)
+		{
+			if (o.vContains(p2d))
+			{
+				// select this object, unless it is an invisible gmmlHandle
+				if (o instanceof Handle && !((Handle)o).isVisible()) 
+					;
+				else 
+					result.add(o);
+			}
+		}
+		return result;
+	}
+	
+	void doClickSelect(Point2D p2d, MouseEvent e) {
+		//Ctrl pressed, add/remove from selection
+		boolean ctrlPressed =  (e.stateMask & SWT.CTRL) != 0;
+		if(ctrlPressed) 
+		{
+			if(pressedObject instanceof SelectionBox) {
+				//Object inside selectionbox clicked, pass to selectionbox
+				s.objectClicked(p2d);
+			}
+			else if(pressedObject.isSelected()) { //Already in selection: remove
+				s.removeFromSelection(pressedObject);
+			} else {
+				s.addToSelection(pressedObject); //Not in selection: add
+			}
+			pressedObject = null; //Disable dragging
+		} 
+		else //Ctrl not pressed
+		{
+			//If pressedobject is not selectionbox:
+			//Clear current selection and select pressed object
+			if(!(pressedObject instanceof SelectionBox))
+			{
+				clearSelection();
+				s.addToSelection(pressedObject);
+			} else { //Check if clicked object inside selectionbox
+				if(s.getChild(p2d) == null) clearSelection();
+			}
+		}
+		redrawDirtyRect();
+	}
+	
+	public static final int NEWNONE = -1;
+	public static final int NEWLINE = 0;
+	public static final int NEWLABEL = 1;
+	public static final int NEWARC = 2;
+	public static final int NEWBRACE = 3;
+	public static final int NEWGENEPRODUCT = 4;
+	public static final int NEWLINEDASHED = 5;
+	public static final int NEWLINEARROW = 6;
+	public static final int NEWLINEDASHEDARROW = 7;
+	public static final int NEWRECTANGLE = 8;
+	public static final int NEWOVAL = 9;
+	public static final int NEWTBAR = 10;
+	public static final int NEWRECEPTORROUND = 11;
+	public static final int NEWLIGANDROUND = 12;
+	public static final int NEWRECEPTORSQUARE = 13;
+	public static final int NEWLIGANDSQUARE = 14;
+	public static final int NEWLINEMENU = 15;
+	public static final int NEWLINESHAPEMENU = 16;
+	public static final Color stdRGB = new Color(0, 0, 0);
+
+	/**
+	 * pathvisio distinguishes between placing objects with a click
+	 * or with a drag. If you don't move the cursor in between the mousedown
+	 * and mouseup event, the object is placed with a default initial size.
+	 * 
+	 * newObjectDragStart is used to determine the mousemovement during the click.
+	 */
+	private Point newObjectDragStart;
+	
+	/** newly placed object, is set to null again when mouse button is released */
+	private PathwayElement newObject = null;
+	/** minimum drag length for it to be considered a drag and not a click */
+	private static final int MIN_DRAG_LENGTH = 3;
+
+	/**
+	 * Add a new object to the drawing
+	 * {@see VPathway#setNewGraphics(int)}
+	 * @param p	The point where the user clicked on the drawing to add a new graphics
+	 */
+	private void newObject(Point ve)
+	{
+		newObjectDragStart = ve;
+		int mx = (int)mFromV((double)ve.x);
+		int my = (int)mFromV((double)ve.y); 
+		
+		PathwayElement gdata = null;
+		Handle h = null;
+		lastAdded = null; // reset lastAdded class member
+		switch(newGraphics) {
+		case NEWNONE:
+			return;
+		case NEWLINE:
+			gdata = new PathwayElement(ObjectType.LINE);
+			gdata.setMStartX(mx);
+			gdata.setMStartY(my);
+			gdata.setMEndX(mx);
+			gdata.setMEndY(my);	
+			gdata.setColor (stdRGB);
+			gdata.setLineStyle (LineStyle.SOLID);
+			gdata.setLineType (LineType.LINE);
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Line)lastAdded).getEnd().getHandle();
+			isDragging = true;
+			break;
+		case NEWLINEARROW:
+			gdata = new PathwayElement(ObjectType.LINE);
+			gdata.setMStartX(mx);
+			gdata.setMStartY(my);
+			gdata.setMEndX(mx);
+			gdata.setMEndY(my);	
+			gdata.setColor (stdRGB);
+			gdata.setLineStyle (LineStyle.SOLID);
+			gdata.setLineType (LineType.ARROW);
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Line)lastAdded).getEnd().getHandle();
+			isDragging = true;
+			break;
+		case NEWLINEDASHED:
+			gdata = new PathwayElement(ObjectType.LINE);
+			gdata.setMStartX(mx);
+			gdata.setMStartY(my);
+			gdata.setMEndX(mx);
+			gdata.setMEndY(my);	
+			gdata.setColor (stdRGB);
+			gdata.setLineStyle (LineStyle.DASHED);
+			gdata.setLineType (LineType.LINE);
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Line)lastAdded).getEnd().getHandle();
+			isDragging = true;
+			break;
+		case NEWLINEDASHEDARROW:
+			gdata = new PathwayElement(ObjectType.LINE);
+			gdata.setMStartX(mx);
+			gdata.setMStartY(my);
+			gdata.setMEndX(mx);
+			gdata.setMEndY(my);	
+			gdata.setColor (stdRGB);
+			gdata.setLineStyle (LineStyle.DASHED);
+			gdata.setLineType (LineType.ARROW);
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Line)lastAdded).getEnd().getHandle();
+			isDragging = true;
+			break;
+		case NEWLABEL:
+			gdata = new PathwayElement(ObjectType.LABEL);
+			gdata.setMCenterX(mx);
+			gdata.setMCenterY(my);
+			gdata.setMWidth(Label.M_INITIAL_WIDTH);
+			gdata.setMHeight(Label.M_INITIAL_HEIGHT);
+			gdata.setMFontSize (Label.M_INITIAL_FONTSIZE);
+			gdata.setGraphId(data.getUniqueId());
+			data.add (gdata); // will cause lastAdded to be set
+			((Label)lastAdded).createTextControl();
+			h = null;
+			break;
+		case NEWARC:
+			gdata = new PathwayElement(ObjectType.SHAPE);
+			gdata.setShapeType(ShapeType.ARC);
+			gdata.setMCenterX (mx);
+			gdata.setMCenterY (my);
+			gdata.setMWidth(1);
+			gdata.setMHeight(1);
+			gdata.setColor(stdRGB);
+			gdata.setRotation (0);
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Shape)lastAdded).handleSE;
+			isDragging = true;
+			break;
+		case NEWBRACE:
+			gdata = new PathwayElement(ObjectType.SHAPE);
+			gdata.setShapeType(ShapeType.BRACE);
+			gdata.setMCenterX (mx);
+			gdata.setMCenterY (my);
+			gdata.setMWidth(1);
+			gdata.setMHeight(1);
+			gdata.setOrientation(OrientationType.RIGHT);
+			gdata.setColor(stdRGB);
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Shape)lastAdded).handleSE;
+			isDragging = true;
+			break;
+		case NEWGENEPRODUCT:
+			gdata = new PathwayElement(ObjectType.DATANODE);
+			gdata.setMCenterX(mx);
+			gdata.setMCenterY(my);
+			gdata.setMWidth(1);
+			gdata.setMHeight(1);
+			gdata.setTextLabel("Gene");
+			gdata.setXref("");
+			gdata.setColor(stdRGB);
+			gdata.setGraphId(data.getUniqueId());
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((GeneProduct)lastAdded).handleSE;
+			isDragging = true;
+			break;
+		case NEWRECTANGLE:
+			gdata = new PathwayElement(ObjectType.SHAPE);
+			gdata.setShapeType(ShapeType.RECTANGLE);
+			gdata.setMCenterX (mx);
+			gdata.setMCenterY (my);
+			gdata.setMWidth(1);
+			gdata.setMHeight(1);
+			gdata.setColor(stdRGB);
+			gdata.setRotation (0);
+			gdata.setGraphId(data.getUniqueId());
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Shape)lastAdded).handleSE;
+			isDragging = true;
+			break;
+		case NEWOVAL:
+			gdata = new PathwayElement(ObjectType.SHAPE);
+			gdata.setShapeType(ShapeType.OVAL);
+			gdata.setMCenterX (mx);
+			gdata.setMCenterY (my);
+			gdata.setMWidth(1);
+			gdata.setMHeight(1);
+			gdata.setColor(stdRGB);
+			gdata.setRotation (0);
+			gdata.setGraphId(data.getUniqueId());
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Shape)lastAdded).handleSE;
+			isDragging = true;
+			break;
+		case NEWTBAR:
+			gdata = new PathwayElement(ObjectType.LINE);
+			gdata.setMStartX(mx);
+			gdata.setMStartY(my);
+			gdata.setMEndX(mx);
+			gdata.setMEndY(my);	
+			gdata.setColor (stdRGB);
+			gdata.setLineStyle (LineStyle.SOLID);
+			gdata.setLineType (LineType.TBAR);
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Line)lastAdded).getEnd().getHandle();
+			isDragging = true;
+			break;
+		case NEWRECEPTORROUND:
+			gdata = new PathwayElement(ObjectType.LINE);
+			gdata.setMStartX(mx);
+			gdata.setMStartY(my);
+			gdata.setMEndX(mx);
+			gdata.setMEndY(my);	
+			gdata.setColor (stdRGB);
+			gdata.setLineStyle (LineStyle.SOLID);
+			gdata.setLineType (LineType.RECEPTOR_ROUND);
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Line)lastAdded).getEnd().getHandle();
+			isDragging = true;
+			break;
+		case NEWRECEPTORSQUARE:
+			gdata = new PathwayElement(ObjectType.LINE);
+			gdata.setMStartX(mx);
+			gdata.setMStartY(my);
+			gdata.setMEndX(mx);
+			gdata.setMEndY(my);	
+			gdata.setColor (stdRGB);
+			gdata.setLineStyle (LineStyle.SOLID);
+			gdata.setLineType (LineType.RECEPTOR_SQUARE);
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Line)lastAdded).getEnd().getHandle();
+			isDragging = true;
+			break;
+		case NEWLIGANDROUND:
+			gdata = new PathwayElement(ObjectType.LINE);
+			gdata.setMStartX(mx);
+			gdata.setMStartY(my);
+			gdata.setMEndX(mx);
+			gdata.setMEndY(my);	
+			gdata.setColor (stdRGB);
+			gdata.setLineStyle (LineStyle.SOLID);
+			gdata.setLineType (LineType.LIGAND_ROUND);
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Line)lastAdded).getEnd().getHandle();
+			isDragging = true;
+			break;
+		case NEWLIGANDSQUARE:
+			gdata = new PathwayElement(ObjectType.LINE);
+			gdata.setMStartX(mx);
+			gdata.setMStartY(my);
+			gdata.setMEndX(mx);
+			gdata.setMEndY(my);	
+			gdata.setColor (stdRGB);
+			gdata.setLineStyle (LineStyle.SOLID);
+			gdata.setLineType (LineType.LIGAND_SQUARE);
+			data.add (gdata); // will cause lastAdded to be set
+			h = ((Line)lastAdded).getEnd().getHandle();
+			isDragging = true;
+			break;
+		}
+		
+		newObject = gdata;
+		selectObject(lastAdded);
+		pressedObject = h;
+		
+		vPreviousX = ve.x;
+		vPreviousY = ve.y;
+				
+	}
+	
+
+	public static final int DRAW_ORDER_HANDLE = -1;
+	public static final int DRAW_ORDER_GROUP = 0;
+	public static final int DRAW_ORDER_SELECTIONBOX = 1;
+	public static final int DRAW_ORDER_SELECTED = 2;
+	public static final int DRAW_ORDER_GENEPRODUCT = 3;
+	public static final int DRAW_ORDER_LABEL = 4;
+	public static final int DRAW_ORDER_ARC = 5;
+	public static final int DRAW_ORDER_BRACE = 6;
+	public static final int DRAW_ORDER_SHAPE = 7;
+	public static final int DRAW_ORDER_LINE = 8;
+	public static final int DRAW_ORDER_LINESHAPE = 9;
+	public static final int DRAW_ORDER_MAPPINFO = 10;
+	public static final int DRAW_ORDER_DEFAULT = 11;
+	
+	public void mouseEnter(MouseEvent e) {}
+
+	public void mouseExit(MouseEvent e) {}
+	
+	/**
+	 * Responsible for drawing a tooltip displaying expression data when 
+	 * hovering over a geneproduct
+	 */
+	public void mouseHover(MouseEvent e) {
+		Visualization v = VisualizationManager.getCurrent();
+		if(v != null && v.usesToolTip()) {
+			Point2D p = new Point2D.Double(e.x, e.y);
+			
+			VPathwayElement o = getObjectAt(p);
+			if(o != null && o instanceof Graphics) {
+				Shell tip = v.visualizeToolTip(getShell(), this, (Graphics)o);
+				if(tip == null) return;
+				Point mp = toDisplay(e.x + 15, e.y + 15);
+				tip.setLocation(mp.x, mp.y);
+	            tip.setVisible(true);
+			}
+		}
+	}
+
+	private void selectGeneProducts() {
+		clearSelection();
+		for(VPathwayElement o : getDrawingObjects()) {
+			if(o instanceof GeneProduct) s.addToSelection(o);
+		}
+	}
+	
+	private void insertPressed() {
+		Set<VPathwayElement> objects = new HashSet<VPathwayElement>();
+		objects.addAll(s.getSelection());
+		for(VPathwayElement o : objects) {
+			if(o instanceof Line) {
+				PathwayElement g = ((Line)o).getGmmlData();
+				PathwayElement[] gNew = g.splitLine();
+							
+				removeDrawingObject(o); //Remove the old line
+				
+				//Clear refs on middle point (which is new)
+				gNew[0].getMEnd().setGraphRef(null);
+				gNew[1].getMStart().setGraphRef(null);
+				
+				gNew[1].setGraphId(data.getUniqueId());
+				data.add(gNew[0]);
+				Line l1 = (Line)lastAdded;
+				data.add(gNew[1]);
+				Line l2 = (Line)lastAdded;				
+				
+				l1.getEnd().link(l2.getStart());
+			}
+		}
+		s.addToSelection(lastAdded);
+	}
+	
+	public void createGroup() {
+		//GroupId is created on first getGroupId call
+		PathwayElement group = new PathwayElement(ObjectType.GROUP);
+		data.add(group);
+		
+		group.setTextLabel("new group");
+		group.setGroupStyle(GroupStyle.NONE);
+		
+		String id = group.getGroupId();
+		
+		//Add the selected pathway elements
+		List<Graphics> selection = getSelectedGraphics();
+		
+		for(Graphics g : selection) {
+			PathwayElement pe = g.getGmmlData(); 
+			String ref = pe.getGroupRef();
+			if(ref == null) {
+				pe.setGroupRef(id);
+			} else if(ref != id) {
+				PathwayElement refGroup = data.getGroupById(ref);
+				refGroup.setGroupRef(id);
+			}
+		}
+	}
+
+	public void keyPressed(KeyEvent e) { 
+		//if(e.keyCode == SWT.CTRL) ctrlPressed();
+		//if(e.keyCode == SWT.ALT) altPressed();
+		if(e.keyCode == SWT.INSERT) insertPressed();
+		if(e.keyCode == 100) //CTRL-D to select all gene-products
+			if((e.stateMask & SWT.CTRL) != 0) {
+				selectGeneProducts();
+				redraw();
+			}
+		if(e.keyCode == 103) //CTRL-G to select all gene-products
+			if((e.stateMask & SWT.CTRL) != 0) {
+				//do group thing
+				createGroup();
+			}
+	}
+
+	
+	
+	public void keyReleased(KeyEvent e) {		
+		//if(e.keyCode == SWT.CTRL) ctrlReleased();
+		//if(e.keyCode == SWT.ALT) altReleased();
+		if(e.keyCode == SWT.DEL) {
+			ArrayList<VPathwayElement> toRemove = new ArrayList<VPathwayElement>();
+			for(VPathwayElement o : drawingObjects)
+			{
+				if(!o.isSelected() || o == s || o == infoBox) continue; //Object not selected, skip
+				toRemove.add(o);
+			}
+			removeDrawingObjects(toRemove);
+		}
+	}
+	
+	/**
+	 * Removes the GmmlDrawingObjects in the ArrayList from the drawing
+	 * @param toRemove	The List containing the objects to be removed
+	 */
+	public void removeDrawingObjects(ArrayList<VPathwayElement>toRemove)
+	{
+		for(VPathwayElement o : toRemove)
+		{
+			removeDrawingObject(o);
+			
+		}
+		s.fitToSelection();
+	}
+	
+	public void removeDrawingObject(VPathwayElement toRemove) {
+		toRemove.destroy(); //Object will remove itself from the drawing
+		s.removeFromSelection(toRemove); //Remove from selection
+	}
+
+	Graphics lastAdded = null;
+	
+	public void gmmlObjectModified(PathwayEvent e) {
+		switch (e.getType())
+		{
+			case PathwayEvent.DELETED:
+				// TODO: affected object should be removed
+				addDirtyRect(null); // mark everything dirty
+				break;
+			case PathwayEvent.ADDED:
+				lastAdded = fromGmmlDataObject(e.getAffectedData());
+				addDirtyRect(null); // mark everything dirty
+				break;
+			case PathwayEvent.WINDOW:
+				int width = (int)vFromM(infoBox.getGmmlData().getMBoardWidth());
+				int height = (int)vFromM(infoBox.getGmmlData().getMBoardHeight());
+				setSize(width, height); 
+				break;
+		}
+		redrawDirtyRect();
+	}
+		
+	/**
+	 * Makes a copy of all GmmlDataObjects in current selection,
+	 * and puts them in the global clipboard.
+	 *
+	 */
+	public void copyToClipboard()
+	{
+		//Clipboard clipboard = new Clipboard (this.getDisplay());
+		
+		List<PathwayElement> result = new ArrayList<PathwayElement>();
+		for (VPathwayElement g : drawingObjects)
+		{
+			if (g.isSelected() && g instanceof Graphics
+					&& !(g instanceof SelectionBox))
+			{
+				result.add(((Graphics)g).gdata.copy());
+			}
+		}
+		if (result.size() > 0)
+		{
+			SwtEngine.clipboard = result;
+		}
+		else
+		{
+			SwtEngine.clipboard = null;
+		}
+		
+		//clipboard.dispose();
+	}
+	
+	/**
+	 * Aligns selected objects based on user-selected align type
+	 * @param alignType
+	 */
+	public void alignSelected(char alignType)
+	{
+		List<Graphics> selectedGraphics = getSelectedGraphics();
+		
+		int aveC = 0;
+		int minC = java.lang.Integer.MAX_VALUE;
+		int maxC = 0;
+		
+		if (selectedGraphics.size() > 0){
+			switch (alignType){
+			case AlignActions.CENTERX : 
+				for(Graphics g : selectedGraphics) {
+					int c = g.getVCenterX();
+					aveC = aveC + c;
+				}
+				aveC = aveC/selectedGraphics.size();
+				for(Graphics g : selectedGraphics) {
+					g.vMoveBy(aveC - g.getVCenterX(), 0);
+				}
+				break;
+			case AlignActions.CENTERY : 
+				for(Graphics g : selectedGraphics) {
+					int c = g.getVCenterY();
+					aveC = aveC + c;
+				}
+				aveC = aveC/selectedGraphics.size();
+				for(Graphics g : selectedGraphics) {
+					g.vMoveBy(0, aveC-g.getVCenterY());
+				}
+				break;
+			case AlignActions.LEFT :
+				for(Graphics g : selectedGraphics) {
+					int c = g.getVLeft();
+					if (c < minC){ 
+						minC = c;
+						}
+				}
+				for(Graphics g : selectedGraphics) {	
+					g.vMoveBy(minC - g.getVLeft(),0);
+				}
+				break;
+			case AlignActions.RIGHT : 
+				for(Graphics g : selectedGraphics) {
+					int c = (g.getVLeft()+g.getVWidth());
+					if (c > maxC){
+						maxC = c;
+					}	
+				}
+				for(Graphics g : selectedGraphics) {
+					g.vMoveBy(maxC - (g.getVLeft()+g.getVWidth()),0);
+				}
+				break;
+			case AlignActions.TOP : 
+				for(Graphics g : selectedGraphics) {
+					int c = g.getVTop();
+					if (c < minC){
+						minC = c;
+					}
+				}
+				for(Graphics g : selectedGraphics) {
+					g.vMoveBy(0,minC - g.getVTop());
+				}
+				break;
+			case AlignActions.BOTTOM :
+				for(Graphics g : selectedGraphics) {
+					int c = (g.getVTop()+g.getVHeight());
+					if (c > maxC){
+						maxC = c;
+					}
+				}
+				for(Graphics g : selectedGraphics) {
+					g.getGmmlData().setMCenterY(mFromV(maxC-(g.getVHeight()/2)));
+					g.vMoveBy(0,maxC - (g.getVTop()+g.getVHeight()));
+				}
+				break;
+			}
+			redrawDirtyRect();
+	}
+	}
+	/**
+	 * Scales selected objects either by max width or max height
+	 * @param alignType
+	 */
+	public void scaleSelected (char alignType){
+		
+		List<Graphics> selectedGraphics = getSelectedGraphics();
+		double maxW = 0;
+		double maxH = 0;
+		
+		if (selectedGraphics.size() > 0){
+			switch (alignType){
+			case AlignActions.WIDTH:
+				for(Graphics g : selectedGraphics) {
+					Rectangle2D.Double r = g.getVScaleRectangle();
+					double w = Math.abs(r.width);
+					if (w > maxW){
+						maxW = w;
+					}
+				}
+				for(Graphics g : selectedGraphics) {
+					Rectangle2D.Double r = g.getVScaleRectangle();
+					double oldWidth = r.width;
+					if (oldWidth <0){
+						r.setRect(r.getX(), r.getY(), -(maxW), r.getHeight());
+						g.setVScaleRectangle(r);
+						g.vMoveBy((oldWidth+maxW)/2,0);
+					}
+					else{
+						r.setRect(r.getX(), r.getY(), maxW, r.getHeight());
+						g.setVScaleRectangle(r);
+						g.vMoveBy((oldWidth - maxW)/2,0);
+					}
+				}
+				break;
+			case AlignActions.HEIGHT:
+				for(Graphics g : selectedGraphics) {
+					Rectangle2D.Double r = g.getVScaleRectangle();
+					double h = Math.abs(r.height);
+					if (h > maxH){
+						maxH = h;
+					}
+				}
+				for(Graphics g : selectedGraphics) {
+					Rectangle2D.Double r = g.getVScaleRectangle();
+					double oldHeight = r.height;
+					if (oldHeight < 0){
+						r.setRect(r.getX(), r.getY(), r.getWidth(), -(maxH));
+						g.setVScaleRectangle(r);
+						g.vMoveBy(0,(maxH+oldHeight)/2);
+					}
+					else{
+					r.setRect(r.getX(), r.getY(), r.getWidth(), maxH);
+					g.setVScaleRectangle(r);
+					g.vMoveBy(0,(oldHeight - maxH)/2);
+					}
+				}
+				break;
+			}
+			redrawDirtyRect();
+		}
+	}
+	/**
+	 * TODO: document
+	 * @return
+	 */
+	public List<Graphics> getSelectedGraphics() {
+		List<Graphics> result = new ArrayList<Graphics>();
+		for (VPathwayElement g : drawingObjects)
+		{
+			if (g.isSelected() && g instanceof Graphics
+					&& !(g instanceof SelectionBox))
+			{
+				result.add((Graphics)g);
+			}
+		}
+		return result;
+	}
+	
+	/**
+	 * If global clipboard contains GmmlDataObjects,
+	 * makes another copy of these objects, and pastes them in. 
+	 * The clipboard contents will be moved 10 pixels souteast,
+	 * so they won't exactly overlap with the original.
+	 */
+	public void pasteFromClipboad()
+	{
+		if (SwtEngine.clipboard != null)
+		{
+			clearSelection();
+			Map<String, String> idmap = new HashMap<String, String>();
+			Set<String> newids = new HashSet<String>();
+			
+			/*
+			 * Step 1: generate new unique ids for copied items
+			 */
+			for (PathwayElement o : SwtEngine.clipboard)
+			{
+				String id = o.getGraphId();
+				if (id != null) 
+				{
+					String x;
+					do
+					{
+						/* generate a unique id.
+						 * at the same time, check that it is not 
+						 * equal to one of the unique ids
+						 * that we generated since the start of this
+						 * method
+						 */ 
+						x = data.getUniqueId();
+					} while (newids.contains(x));
+					newids.add(x); // make sure we don't generate this one again
+					
+					idmap.put(id, x);
+				}
+			}
+			/*
+			 * Step 2: do the actual copying 
+			 */
+			for (PathwayElement o : SwtEngine.clipboard)
+			{
+				if (o.getObjectType() == ObjectType.MAPPINFO ||
+					o.getObjectType() == ObjectType.INFOBOX)
+				{
+					// these object types we skip,
+					// because they have to be unique in a pathway
+					continue;
+				}
+				
+				lastAdded = null;
+				o.setMStartX(o.getMStartX() + M_PASTE_OFFSET);
+				o.setMStartY(o.getMStartY() + M_PASTE_OFFSET);
+				o.setMEndX(o.getMEndX() + M_PASTE_OFFSET);
+				o.setMEndY(o.getMEndY() + M_PASTE_OFFSET);
+				o.setMLeft(o.getMLeft() + M_PASTE_OFFSET);
+				o.setMTop(o.getMTop() + M_PASTE_OFFSET);
+				// make another copy to preserve clipboard contents for next paste
+				PathwayElement p = o.copy();
+				
+				// set new unique id
+				if (p.getGraphId() != null)
+				{					
+					p.setGraphId(idmap.get(p.getGraphId()));					
+				}
+				// update graphref
+				String y = p.getStartGraphRef(); 
+				if (y != null)
+				{
+					//TODO: mapping graphrefs to newly created id's 
+					// doesn't work properly yet
+				/*	if (idmap.containsKey(y))
+					{
+						p.setStartGraphRef(idmap.get(y));
+					}
+					else
+					{*/
+						p.setStartGraphRef(null);
+					//}				
+				}
+				y = p.getEndGraphRef(); 
+				if (y != null)
+				{
+				/*	if (idmap.containsKey(y))
+					{
+						p.setEndGraphRef(idmap.get(y));
+					}
+					else
+					{*/
+						p.setEndGraphRef(null);
+				//	}				
+				}
+				
+				data.add (p); // causes lastAdded to be set
+				lastAdded.select();
+				s.addToSelection(lastAdded);
+			}
+		}
+	}
+
+	private List<VPathwayListener> listeners = new ArrayList<VPathwayListener>();
+	private List<VPathwayListener> removeListeners = new ArrayList<VPathwayListener>();
+	
+	public void addVPathwayListener(VPathwayListener l) {
+		listeners.add(l);
+	}
+	
+	public void removeVPathwayListener(VPathwayListener l) {
+		removeListeners.add(l);
+	}
+	
+	private void cleanupListeners() {
+		//Do not remove immediately, to prevent ConcurrentModificationException
+		//when the listener removes itself
+		listeners.removeAll(removeListeners);
+		removeListeners.clear();
+	}
+	
+	protected void fireVPathwayEvent(VPathwayEvent e) {
+		cleanupListeners();
+		for(VPathwayListener l : listeners) {
+			l.vPathwayEvent(e);
+		}
+	}
+	
+	public void visualizationEvent(VisualizationEvent e) {
+		switch(e.type) {
+		case(VisualizationEvent.COLORSET_MODIFIED):
+		case(VisualizationEvent.VISUALIZATION_SELECTED):
+		case(VisualizationEvent.VISUALIZATION_MODIFIED):
+		case(VisualizationEvent.PLUGIN_MODIFIED):
+			getDisplay().syncExec(new Runnable() {
+				public void run() {
+					redraw();
+				}
+			});
+		}
+	}		
+	
+	/** 
+	 * helper method to convert view coordinates to model coordinates 
+	 * */
+	public double mFromV(double v) { return v / zoomFactor; }
+
+	/** 
+	 * helper method to convert view coordinates to model coordinates 
+	 * */
+	public double vFromM(double m) { return m * zoomFactor; }
+	
+} // end of class
Index: trunk/src/swt/org/pathvisio/view/InfoBox.java
===================================================================
--- trunk/src/swt/org/pathvisio/view/InfoBox.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/view/InfoBox.java	(revision 957)
@@ -0,0 +1,122 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import java.awt.Rectangle;
+import java.awt.Shape;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.graphics.Font;
+import org.eclipse.swt.graphics.GC;
+import org.eclipse.swt.graphics.Point;
+
+import org.pathvisio.model.PathwayElement;
+
+public class InfoBox extends Graphics {
+	
+	//Elements not stored in gpml
+	String fontName			= "Times New Roman";
+	String fontWeight		= "regular";
+	static final double M_INITIAL_FONTSIZE	= 10.0 * 15;
+	
+	int sizeX = 1;
+	int sizeY = 1; //Real size is calculated on first call to draw()
+	
+	public InfoBox (VPathway canvas, PathwayElement o) {
+		super(canvas, o);
+		canvas.setMappInfo(this);	
+	}
+	
+	public int getDrawingOrder() {
+		return VPathway.DRAW_ORDER_MAPPINFO;
+	}
+	
+	public Point getBoardSize() { return new Point((int)gdata.getMBoardWidth(), (int)gdata.getMBoardHeight()); }
+	
+	int getVFontSize()
+	{
+		return (int)(vFromM(M_INITIAL_FONTSIZE));
+	}
+			
+	protected void vMoveBy(double vdx, double vdy)
+	{
+//		markDirty();
+		gdata.setMTop (gdata.getMTop()  + mFromV(vdy));
+		gdata.setMLeft (gdata.getMLeft() + mFromV(vdx));
+//		markDirty();
+	}
+	
+	public void draw(PaintEvent e) 
+	{
+		draw(e, e.gc);
+	}
+	
+	public void draw(PaintEvent e, GC buffer) 
+	{		
+		sizeX = 1; //Reset sizeX
+		
+		Font fBold = new Font(e.display, fontName, getVFontSize(), SWT.BOLD);
+		Font fNormal = new Font(e.display, fontName, getVFontSize(), SWT.NONE);
+		
+		if (isSelected())
+		{
+			buffer.setForeground(e.display.getSystemColor(SWT.COLOR_RED));
+		}
+		else 
+		{
+			buffer.setForeground(e.display.getSystemColor(SWT.COLOR_BLACK));
+		}
+				
+		//Draw Name, Organism, Data-Source, Version, Author, Maintained-by, Email, Availability and last modified
+		String[][] text = new String[][] {
+				{"Name: ", gdata.getMapInfoName()},
+				{"Maintained by: ", gdata.getMaintainer()},
+				{"Email: ", gdata.getEmail()},
+				{"Availability: ", gdata.getCopyright()},
+				{"Last modified: ", gdata.getLastModified()},
+				{"Organism: ", gdata.getOrganism()},
+				{"Data Source: ", gdata.getDataSource()}};
+		int shift = 0;
+		int vLeft = (int)vFromM(gdata.getMLeft());
+		int vTop = (int)vFromM(gdata.getMTop());
+		for(String[] s : text)
+		{
+			if(s[1] == null || s[1].equals("")) continue; //Skip empty labels
+			buffer.setFont(fBold);
+			Point labelSize = buffer.textExtent(s[0], SWT.DRAW_TRANSPARENT);
+			buffer.drawString(s[0], vLeft, vTop + shift, true);
+			buffer.setFont(fNormal);
+			Point infoSize = buffer.textExtent(s[1], SWT.DRAW_TRANSPARENT);
+			buffer.drawString(s[1], vLeft + labelSize.x, vTop + shift, true);
+			shift += Math.max(infoSize.y, labelSize.y);
+			sizeX = Math.max(sizeX, infoSize.x + labelSize.x);
+		}
+		sizeY = shift;
+		
+		fBold.dispose();
+		fNormal.dispose();
+	}
+
+	protected Shape getVOutline() {
+		int vLeft = (int)vFromM(gdata.getMLeft());
+		int vTop = (int)vFromM(gdata.getMTop());
+		return new Rectangle(vLeft, vTop, sizeX, sizeY);
+	}
+
+}
+ 
\ No newline at end of file
Index: trunk/src/swt/org/pathvisio/view/LinAlg.java
===================================================================
--- trunk/src/swt/org/pathvisio/view/LinAlg.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/view/LinAlg.java	(revision 957)
@@ -0,0 +1,103 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+/**
+ * Helper class for rotation calculations.
+ *
+ */
+public class LinAlg 
+{
+	
+	public static double angle(Point p1, Point p2) 
+	{
+		//Angle:
+		//					p1.p2	
+        //cos(angle) = --------------
+        //          	||p1||*||p2||
+		double cos = dot(p1,p2) / (p1.len() * p2.len());
+		return direction(p1,p2) * Math.acos(cos);
+	}
+		
+	/**
+	 * negative: ccw positive: cw
+	 */
+	public static double direction(Point p1, Point p2) 
+	{
+		return Math.signum(p1.x * p2.y - p1.y * p2.x);
+	}
+	
+	public static double dot(Point v1, Point v2) 
+	{
+		double[] d1 = v1.asArray();
+		double[] d2 = v2.asArray();
+		double sum = 0;
+		for(int i = 0; i < Math.min(d1.length, d2.length); i++) sum += d1[i]*d2[i];
+		return sum;
+	}
+	
+	public static Point project(Point p1, Point p2) 
+	{
+		//Projection of p1 on p2:
+		// p1.p2
+		// ----- . p2
+		// p2.p2
+		double c = dot(p1, p2) / dot(p2, p2);
+		return new Point(p2.x * c, p2.y * c);
+	}
+	
+	public static double distance(Point p1, Point p2) 
+	{
+		Point dp = p2.subtract(p1);
+		return dp.len();
+	}
+	
+	public static Point rotate(Point p, double angle) 
+	{
+		Point pr = new Point(0,0);
+		pr.x = p.x * Math.cos(angle) + p.y * Math.sin(angle);
+		pr.y = -p.x * Math.sin(angle) + p.y * Math.cos(angle);
+		return pr;
+	}
+	
+	public static class Point 
+	{
+		public double x, y;
+		public Point(double x, double y) { this.x = x; this.y = y;	}
+		
+		public int[] asIntArray() { return new int[] { (int)x, (int)y }; }
+		
+		public double[] asArray() { return new double[] { x, y }; }
+		
+		public Point norm() 
+		{
+			double l = len();
+			return new Point(x / l, y / l);
+		}
+		public double len() 
+		{
+			return Math.sqrt(dot(this, this));
+		}
+		
+		public Point add(Point p) { return new Point(x + p.x, y + p.y); }
+		public Point subtract(Point p) { return new Point(x - p.x, y - p.y); }
+		public Point multiply(double d) { return new Point(x *= d, y *= d); }
+				
+		public Point clone() { return new Point(x, y); }
+		public String toString() { return "Point: " + x + ", " + y; }
+	}
+}
Index: trunk/src/swt/org/pathvisio/view/Line.java
===================================================================
--- trunk/src/swt/org/pathvisio/view/Line.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/view/Line.java	(revision 957)
@@ -0,0 +1,424 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import java.awt.BasicStroke;
+import java.awt.Shape;
+import java.awt.geom.Line2D;
+import java.awt.geom.Rectangle2D;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.GC;
+import org.eclipse.swt.graphics.RGB;
+import org.pathvisio.model.LineStyle;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.PathwayEvent;
+import org.pathvisio.model.GraphLink.GraphRefContainer;
+import org.pathvisio.model.PathwayElement.MPoint;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.util.SwtUtils;
+ 
+/**
+ * This class implements and handles a line
+ */
+public class Line extends Graphics
+{
+
+	private static final long serialVersionUID = 1L;
+	
+	private List<VPoint> points;
+	
+	/**
+	 * Constructor for this class
+	 * @param canvas - the VPathway this line will be part of
+	 */
+	public Line(VPathway canvas, PathwayElement o)
+	{
+		super(canvas, o);
+		
+		points = new ArrayList<VPoint>();
+		for(MPoint mp : o.getMPoints()) {
+			VPoint vp = canvas.getPoint(mp);
+			points.add(vp);
+			vp.addLine(this);
+			vp.setHandleLocation();
+		}
+	}
+	
+	public int getDrawingOrder() 
+	{
+		return VPathway.DRAW_ORDER_LINE;
+	}
+	
+	protected void swapPoint(VPoint pOld, VPoint pNew) 
+	{
+		int i = points.indexOf(pOld);
+		if(i > -1) {
+			points.remove(pOld);
+			points.add(i, pNew);
+		}
+	}
+			
+	public void draw(PaintEvent e, GC buffer)
+	{
+		double vEndx = getVEndX();
+		double vEndy = getVEndY();
+		double vStartx = getVStartX();
+		double vStarty = getVStartY();
+
+		Color c = null;
+		if (isSelected())
+		{
+			c = SwtUtils.changeColor(c, selectColor, e.display);
+		}
+		else if (isHighlighted())
+		{
+			RGB rgb = SwtUtils.color2rgb(GlobalPreference.getValueColor(GlobalPreference.COLOR_HIGHLIGHTED));
+			c = SwtUtils.changeColor(c, rgb, e.display);
+		}
+		else 
+		{
+			c = SwtUtils.changeColor(c, gdata.getColor(), e.display);
+		}
+		buffer.setForeground (c);
+		buffer.setBackground (c);
+		
+		buffer.setLineWidth (1);
+		int ls = gdata.getLineStyle();
+		if (ls == LineStyle.SOLID)
+		{
+			buffer.setLineStyle (SWT.LINE_SOLID);
+		}
+		else if (ls == LineStyle.DASHED)
+		{ 
+			// TODO: This works well on windows. I wonder if this is the same on all platforms
+			buffer.setLineDash (new int[] {4, 4});
+		}			
+
+		double s = Math.sqrt(((vEndx-vStartx)*(vEndx-vStartx)) + ((vEndy - vStarty)*(vEndy - vStarty)));
+		
+		switch (gdata.getLineType())
+		{
+		
+			case LINE:
+				buffer.drawLine ((int)vStartx, (int)vStarty, (int)vEndx, (int)vEndy);
+				break;
+			case ARROW:				
+				buffer.drawLine ((int)vStartx, (int)vStarty, (int)vEndx, (int)vEndy);
+				drawArrowhead(buffer);
+				break;
+			case TBAR:
+			{
+				s /= 8;
+	
+				double capx1 = ((-vEndy + vStarty)/s) + vEndx;
+				double capy1 = (( vEndx - vStartx)/s) + vEndy;
+				double capx2 = (( vEndy - vStarty)/s) + vEndx;
+				double capy2 = ((-vEndx + vStartx)/s) + vEndy;
+	
+				buffer.drawLine ((int)vStartx, (int)vStarty, (int)vEndx, (int)vEndy);
+				buffer.drawLine ((int)capx1, (int)capy1, (int)capx2, (int)capy2);
+			}
+				break;
+			case LIGAND_ROUND:
+			{
+				if (vEndx != vStartx || vEndy != vStarty)
+				{
+					double dx = (vEndx - vStartx)/s;
+					double dy = (vEndy - vStarty)/s;
+								
+					buffer.drawLine ((int)vStartx, (int)vStarty, (int)(vEndx - 6 * dx), (int)(vEndy - 6 * dy));
+					buffer.drawOval ((int)vEndx - 5, (int)vEndy - 5, 10, 10);
+					buffer.fillOval ((int)vEndx - 5, (int)vEndy - 5, 10, 10);
+				}
+			}
+				break;
+			case RECEPTOR_ROUND:
+			{
+				if (vEndx != vStartx || vEndy != vStarty)
+				{
+					double theta 	= Math.toDegrees(Math.atan2((vEndx - vStartx),(vEndy - vStarty)));
+					double dx 		= (vEndx - vStartx)/s;
+					double dy 		= (vEndy - vStarty)/s;	
+					
+					buffer.drawLine ((int)vStartx, (int)vStarty, (int)(vEndx - (8*dx)), (int)(vEndy - (8*dy)));
+					buffer.drawArc ((int)vEndx - 8, (int)vEndy - 8, 16, 16, (int)theta + 180, -180);
+				}
+			}
+				break;
+			case RECEPTOR: //TODO: implement receptor
+			case RECEPTOR_SQUARE:
+			{
+				if (vEndx != vStartx || vEndy != vStarty)
+				{
+					s /= 8;
+					
+					double x3 		= vEndx - ((vEndx - vStartx)/s);
+					double y3 		= vEndy - ((vEndy - vStarty)/s);
+					double capx1 	= ((-vEndy + vStarty)/s) + x3;
+					double capy1 	= (( vEndx - vStartx)/s) + y3;
+					double capx2 	= (( vEndy - vStarty)/s) + x3;
+					double capy2 	= ((-vEndx + vStartx)/s) + y3;			
+					double rx1		= capx1 + 1.5*(vEndx - vStartx)/s;
+					double ry1 		= capy1 + 1.5*(vEndy - vStarty)/s;
+					double rx2 		= capx2 + 1.5*(vEndx - vStartx)/s;
+					double ry2 		= capy2 + 1.5*(vEndy - vStarty)/s;
+				
+					buffer.drawLine ((int)vStartx, (int)vStarty, (int)x3, (int)y3);
+					buffer.drawLine ((int)capx1, (int)capy1, (int)capx2, (int)capy2);
+					buffer.drawLine ((int)capx1, (int)capy1, (int)rx1, (int)ry1);
+					buffer.drawLine ((int)capx2, (int)capy2, (int)rx2, (int)ry2);
+				}
+			}
+				break;
+			case LIGAND_SQUARE:
+			{
+				if (vEndx != vStartx || vEndy != vStarty)
+				{
+					s /= 6;
+					double x3 		= vEndx - ((vEndx - vStartx)/s);
+					double y3 		= vEndy - ((vEndy - vStarty)/s);
+		
+					int[] points = new int[4 * 2];
+					
+					points[0] = (int) (((-vEndy + vStarty)/s) + x3);
+					points[1] = (int) ((( vEndx - vStartx)/s) + y3);
+					points[2] = (int) ((( vEndy - vStarty)/s) + x3);
+					points[3] = (int) (((-vEndx + vStartx)/s) + y3);
+		
+					points[4] = (int) (points[2] + 1.5*(vEndx - vStartx)/s);
+					points[5] = (int) (points[3] + 1.5*(vEndy - vStarty)/s);
+					points[6] = (int) (points[0] + 1.5*(vEndx - vStartx)/s);
+					points[7] = (int) (points[1] + 1.5*(vEndy - vStarty)/s);
+					
+					buffer.drawLine ((int)vStartx, (int)vStarty, (int)x3, (int)y3);
+					buffer.drawPolygon(points);
+					buffer.fillPolygon(points);
+				}
+			}
+				break;
+		}
+		
+		c.dispose();
+
+		
+	}
+	
+	protected void draw(PaintEvent e)
+	{
+		draw(e, e.gc);
+	}
+		
+	protected Shape getVOutline()
+	{
+		//TODO: bigger than necessary, just to include the arrowhead / shape at the end
+		BasicStroke stroke = new BasicStroke(20);
+		Shape outline = stroke.createStrokedShape(getVLine());
+		return outline;
+	}	
+	
+	/**
+	 * If the line type is arrow, this method draws the arrowhead
+	 */
+	private void drawArrowhead(GC buffer) //TODO! clean up this mess.....
+	{
+		double angle = 25.0;
+		double theta = Math.toRadians(180 - angle);
+		double[] rot = new double[2];
+		double[] p = new double[2];
+		double[] q = new double[2];
+		double a, b, norm;
+		
+		rot[0] = Math.cos(theta);
+		rot[1] = Math.sin(theta);
+		
+		buffer.setLineStyle (SWT.LINE_SOLID);
+		
+		double vEndx = getVEndX();
+		double vEndy = getVEndY();
+		double vStartx = getVStartX();
+		double vStarty = getVStartY();
+		
+		if(vStartx == vEndx && vStarty == vEndy) return; //Unable to determine direction
+		
+		a = vEndx-vStartx;
+		b = vEndy-vStarty;
+		norm = 8/(Math.sqrt((a*a)+(b*b)));				
+		p[0] = ( a*rot[0] + b*rot[1] ) * norm + vEndx;
+		p[1] = (-a*rot[1] + b*rot[0] ) * norm + vEndy;
+		q[0] = ( a*rot[0] - b*rot[1] ) * norm + vEndx;
+		q[1] = ( a*rot[1] + b*rot[0] ) * norm + vEndy;
+		int[] points = {
+			(int)vEndx, (int)vEndy,
+			(int)(p[0]), (int)(p[1]),
+			(int)(q[0]), (int)(q[1])
+		};
+		
+		buffer.drawPolygon (points);
+		buffer.fillPolygon (points);
+	}
+
+	/**
+	 * Constructs the line for the coordinates stored in this class
+	 */
+	public Line2D getVLine()
+	{
+		return new Line2D.Double(getVStartX(), getVStartY(), getVEndX(), getVEndY());
+	}
+	
+	/**
+	 * Sets the line start and end to the coordinates specified
+	 * <DL><B>Parameters</B>
+	 * <DD>Double x1	- new startx 
+	 * <DD>Double y1	- new starty
+	 * <DD>Double x2	- new endx
+	 * <DD>Double y2	- new endy
+	 */
+	public void setVLine(double vx1, double vy1, double vx2, double vy2)
+	{
+		getStart().setVLocation(vx1, vy1);
+		getEnd().setVLocation(vx2, vy2);
+	}
+
+	public void setVScaleRectangle(Rectangle2D.Double r) {
+		setVLine(r.x, r.y, r.x + r.width, r.y + r.height);
+	}
+	
+	protected Rectangle2D.Double getVScaleRectangle() {
+		return new Rectangle2D.Double(getVStartXDouble(), getVStartYDouble(), getVEndXDouble()
+				- getVStartXDouble(), getVEndYDouble() - getVStartYDouble());
+	}
+	
+	public Handle[] getHandles()
+	{
+		Handle[] handles = new Handle[points.size()];
+		for(int i = 0; i < handles.length; i++) {
+			handles[i] = points.get(i).getHandle();
+		}
+		return handles;
+	}
+		
+	public List<VPoint> getPoints() { return points; }
+	
+	public VPoint getStart() {
+		return points.get(0);
+	}
+	
+	public VPoint getEnd() {
+		return points.get(points.size() - 1);
+	}
+	
+	public int getVCenterX() {
+		// TODO Auto-generated method stub
+		double start = gdata.getMStart().getX();
+		double end = gdata.getMEnd().getX();
+		return (int)vFromM(start + (end - start) / 2);
+	}
+	
+	public int getVCenterY() {
+		// TODO Auto-generated method stub
+		double start = gdata.getMStart().getY();
+		double end = gdata.getMEnd().getY();
+		return (int)vFromM(start + (end - start) / 2);
+	}
+	
+	public int getVLeft() {
+		// TODO Auto-generated method stub
+		double start = gdata.getMStart().getX();
+		double end = gdata.getMEnd().getX();
+		return (int)vFromM(Math.min(start, end));
+	}
+	
+	public int getVWidth() {
+		// TODO Auto-generated method stub
+		double start = gdata.getMStart().getX();
+		double end = gdata.getMEnd().getX();
+		return (int)vFromM(Math.abs(start-end));
+	}
+	
+	public int getVHeight() {
+		// TODO Auto-generated method stub
+		double start = gdata.getMStart().getY();
+		double end = gdata.getMEnd().getY();
+		return (int)vFromM(Math.abs(start-end));
+	}	
+	
+	public int getVTop() {
+		// TODO Auto-generated method stub
+		double start = gdata.getMStart().getY();
+		double end = gdata.getMEnd().getY();
+		return (int)vFromM(Math.min(start, end));
+	}
+	
+	protected void vMoveBy(double vdx, double vdy)
+	{
+		for(VPoint p : points) {
+			p.vMoveBy(vdx, vdy);
+		}
+		//Move graphRefs
+		Set<VPoint> toMove = new HashSet<VPoint>();
+		for(GraphRefContainer ref : gdata.getReferences()) {
+			if(ref instanceof MPoint) {
+				toMove.add(canvas.getPoint((MPoint)ref));
+			}
+		}
+		toMove.removeAll(points);
+		for(VPoint p : toMove) p.vMoveBy(vdx, vdy);
+	}
+	
+	public void gmmlObjectModified(PathwayEvent e) {		
+		markDirty();
+		for(VPoint p : points) {
+			p.markDirty();
+			p.setHandleLocation();
+		}
+	}
+	
+	protected void destroyHandles() { 
+		//Do nothing, handles will be destroyed by VPoints
+	}
+	
+	protected void destroy() {
+		//don't call super.destroy(), this will destroy handles of VPoints
+		//which may be used by other lines
+		super.destroy();
+		
+		for(VPoint p : points) {
+			p.removeLine(this);
+		}
+		for(MPoint p : gdata.getMPoints()) {
+			canvas.pointsMtoV.remove(p);
+		}
+	}
+	
+	protected int getVStartX() { return (int)(vFromM(gdata.getMStartX())); }
+	protected int getVStartY() { return (int)(vFromM(gdata.getMStartY())); }
+	protected int getVEndX() { return (int)(vFromM(gdata.getMEndX())); }
+	protected int getVEndY() { return (int)(vFromM(gdata.getMEndY())); }
+
+	protected double getVStartXDouble() { return vFromM(gdata.getMStartX()); }
+	protected double getVStartYDouble() { return vFromM(gdata.getMStartY()); }
+	protected double getVEndXDouble() { return vFromM(gdata.getMEndX()); }
+	protected double getVEndYDouble() { return vFromM(gdata.getMEndY()); }
+
+}
Index: trunk/src/swt/org/pathvisio/view/Handle.java
===================================================================
--- trunk/src/swt/org/pathvisio/view/Handle.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/view/Handle.java	(revision 957)
@@ -0,0 +1,249 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import java.awt.Rectangle;
+import java.awt.Shape;
+import java.awt.geom.Rectangle2D;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.graphics.GC;
+import org.pathvisio.view.LinAlg.Point;
+
+/**
+ * This class implements and handles handles for 
+ * objects on the drawing which are used to 
+ * resize them or change their location.
+ */
+class Handle extends VPathwayElement
+{
+	private static final long serialVersionUID = 1L;
+	
+	/** 
+	 * because isSelected really doesn't make sense for GmmlHandles, 
+	 * I added this variable isVisible. It should be set automatically by its parent
+	 * through calls of show() and hide()
+	 */
+	private boolean isVisible = false;
+	
+	//The direction this handle is allowed to move in
+	int direction;
+	public static final int DIRECTION_FREE = 0;
+	public static final int DIRECTION_X	 = 1;
+	public static final int DIRECTION_Y  = 2; 
+	public static final int DIRECTION_ROT = 3;
+	public static final int DIRECTION_XY = 4;
+	public static final int DIRECTION_MINXY = 5;
+	
+	public static final int WIDTH 	= 8;
+	public static final int HEIGHT	= 8;
+	
+	VPathwayElement parent;
+	
+	double mCenterx;
+	double mCentery;
+	
+	double rotation;
+	
+	boolean visible;
+	
+	/**
+	 * Constructor for this class, creates a handle given the parent, direction and canvas
+	 * @param direction	Direction this handle can be moved in (one of DIRECTION_*)
+	 * @param parent	The object this handle belongs to
+	 * @param canvas	The {@link VPathway} to draw this handle on
+	 */
+	public Handle(int direction, VPathwayElement parent, VPathway canvas)
+	{
+		super(canvas);		
+		this.direction = direction;
+		this.parent = parent;
+	}
+
+	public int getDrawingOrder() {
+		return VPathway.DRAW_ORDER_HANDLE;
+	}
+	
+	/**
+	 * Get the direction this handle is allowed to move in
+	 * @return one of DIRECTION_*
+	 */
+	public int getDirection() { return direction; }
+	
+	public void setDirection(int direction) { this.direction = direction; }
+	
+	public void setVLocation(double vx, double vy)
+	{
+		markDirty();
+		mCenterx = mFromV(vx);
+		mCentery = mFromV(vy);
+		markDirty();
+	}
+
+	public void setMLocation(double mx, double my)
+	{
+		markDirty();
+		mCenterx = mx;
+		mCentery = my;
+		markDirty();
+	}
+	
+	public double getVCenterX() {
+		return vFromM(mCenterx);
+	}
+	
+	public double getVCenterY() {
+		return vFromM(mCentery);
+	}
+	
+	/**
+	 * returns the visibility of this handle
+	 * @see hide(), show()
+	 */
+	public boolean isVisible()
+	{
+		return isVisible;
+	}
+	
+	/**
+	 * call show() to cause this handle to show up and mark its area dirty 
+	 * A handle should show itself only if it's parent object is active / selected
+	 * @see hide(), isvisible()
+	 */
+	public void show()
+	{
+		if (!isVisible)
+		{
+			isVisible = true;
+			markDirty();
+		}
+	}
+	
+	/**
+	 * hide handle, and also mark its area dirty
+	 * @see show(), isvisible()
+	 */
+	public void hide()
+	{
+		if (isVisible)
+		{
+			isVisible = false;
+			markDirty();
+		}
+	}
+	
+	/**
+	 * draws itself, but only if isVisible() is true, there is 
+	 * no need for a check for isVisible() before calling draw().
+	 */
+	public void draw(PaintEvent e, GC buffer)
+	{
+		if (!isVisible) return;
+		double vCenterx = vFromM (mCenterx);
+		double vCentery = vFromM (mCentery);
+		
+		if(direction == DIRECTION_ROT) {
+			buffer.setLineWidth (1);
+			buffer.setLineStyle(SWT.LINE_SOLID);
+			buffer.setBackground (e.display.getSystemColor (SWT.COLOR_GREEN));
+			buffer.setForeground (e.display.getSystemColor (SWT.COLOR_BLACK));
+			buffer.fillOval(
+					(int)(vCenterx - WIDTH/2), 
+					(int)(vCentery - HEIGHT/2), 
+					(int)WIDTH, 
+					(int)HEIGHT);
+			buffer.drawOval(
+					(int)(vCenterx - WIDTH/2), 
+					(int)(vCentery - HEIGHT/2), 
+					(int)WIDTH, 
+					(int)HEIGHT);
+		} else {			
+			buffer.setLineWidth (1);
+			buffer.setLineStyle(SWT.LINE_SOLID);
+			buffer.setBackground (e.display.getSystemColor (SWT.COLOR_YELLOW));
+			buffer.setForeground (e.display.getSystemColor (SWT.COLOR_BLACK));
+			buffer.fillRectangle (
+					(int)(vCenterx - WIDTH/2), 
+					(int)(vCentery - HEIGHT/2), 
+					(int)WIDTH, 
+					(int)HEIGHT);	
+			buffer.drawRectangle (
+					(int)(vCenterx - WIDTH/2), 
+					(int)(vCentery - HEIGHT/2), 
+					(int)WIDTH, 
+					(int)HEIGHT);	
+		}
+		
+	}
+	
+	protected void draw(PaintEvent e)
+	{
+		draw(e, e.gc);
+	}
+		
+	/**
+	 * Moves this handle by the specified increments and
+	 * adjusts the {@link VPathwayElement} to the new position
+	 */
+	public void vMoveBy(double vdx, double vdy)
+	{	
+		markDirty();
+
+		if(direction != DIRECTION_FREE && direction != DIRECTION_ROT) {
+			Point v = new Point(0,0);
+			double xtraRot = 0;
+			if		(direction == DIRECTION_X) {
+				v = new Point(1,0);
+			}
+			else if	(direction == DIRECTION_Y) {
+				v = new Point(0,1);
+			}
+			else if (direction == DIRECTION_XY) {
+				Rectangle b = parent.getVBounds();
+				v = new Point(b.width + 1, b.height + 1);
+			}
+			else if (direction == DIRECTION_MINXY) {
+				xtraRot = Math.PI/2;
+				Rectangle b = parent.getVBounds();
+				v = new Point(b.height + 1, b.width + 1);
+			}
+			Point yr = LinAlg.rotate(v, -rotation + xtraRot);
+			Point prj = LinAlg.project(new Point(vdx, vdy), yr);
+			vdx = prj.x; vdy= prj.y;
+		}
+		
+		mCenterx += mFromV(vdx);
+		mCentery += mFromV(vdy);
+		
+		parent.adjustToHandle(this);
+		markDirty();
+	}
+			
+	public Shape getVOutline() {
+		return new Rectangle2D.Double(vFromM(mCenterx) - WIDTH/2, vFromM(mCentery) - HEIGHT/2, 
+				WIDTH, HEIGHT);
+	}
+		
+	public String toString() { 
+		return 	"Handle with parent: " + parent.toString() +
+		" and direction " + direction; 
+	}
+			
+} // end of class
+
+
Index: trunk/src/swt/org/pathvisio/view/Group.java
===================================================================
--- trunk/src/swt/org/pathvisio/view/Group.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/view/Group.java	(revision 957)
@@ -0,0 +1,136 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import java.awt.Rectangle;
+import java.awt.Shape;
+import java.awt.geom.Point2D;
+import java.awt.geom.Rectangle2D.Double;
+import java.util.ArrayList;
+
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.graphics.GC;
+import org.pathvisio.model.PathwayElement;
+
+public class Group extends Graphics {
+
+	public Group(VPathway canvas, PathwayElement pe) {
+		super(canvas, pe);
+		// TODO Auto-generated constructor stub
+	}
+
+	/**
+	 * Determines wheter a Graphics object contains the point specified
+	 * 
+	 * @param point -
+	 *            the point to check
+	 * @return True if the object contains the point, false otherwise
+	 */
+	protected boolean vContains(Point2D point) {
+		for (VPathwayElement vpe : canvas.getDrawingObjects()) {
+			if (vpe != this && vpe.vContains(point)) {
+				if (vpe instanceof Graphics) {
+					PathwayElement pe = ((Graphics) vpe).getGmmlData();
+					String ref = pe.getGroupRef();
+					if (ref != null && ref.equals(getGmmlData().getGroupId())) {
+						System.out.println("TRUE!");
+						return true;
+					}
+				}
+			}
+		}
+		return false;
+	}
+
+	@Override
+	protected boolean vIntersects(Double r) {
+		for (VPathwayElement vpe : canvas.getDrawingObjects()) {
+			if (vpe != this && vpe.vIntersects(r)) {
+				if (vpe instanceof Graphics) {
+					PathwayElement pe = ((Graphics) vpe).getGmmlData();
+					String ref = pe.getGroupRef();
+					if (ref != null && ref.equals(getGmmlData().getGroupId())) {
+						System.out.println("TRUE INTERSECTS!");
+						return true;
+					}
+				}
+			}
+		}
+		return false;
+	}
+	
+	public ArrayList<Graphics> getGroupGraphics(){
+		ArrayList<Graphics> gg = new ArrayList<Graphics>();
+		for (VPathwayElement vpe : canvas.getDrawingObjects()) {
+			if (vpe != this) {
+				if (vpe instanceof Graphics) {
+					Graphics vpeg = (Graphics) vpe;
+					PathwayElement pe =  vpeg.getGmmlData();
+					String ref = pe.getGroupRef();
+					if (ref != null && ref.equals(getGmmlData().getGroupId())) {
+						gg.add(vpeg);					
+					}
+				}
+			}
+		}
+		return gg;
+	}
+	
+	@Override
+	public void select() {
+		for(Graphics g: getGroupGraphics() ){
+			g.select();
+		}
+		super.select();
+	}
+
+	@Override
+	protected void vMoveBy(double dx, double dy) {
+		for(Graphics g: getGroupGraphics() ){
+			g.vMoveBy(dx, dy);
+		}
+		//super.vMoveBy(dx, dy);
+	}
+	
+	@Override
+	public int getDrawingOrder() {
+
+		return VPathway.DRAW_ORDER_GROUP;
+	}
+
+	@Override
+	protected void draw(PaintEvent e) {
+		// TODO make unique selection box for groups
+		
+	}
+
+	@Override
+	public void draw(PaintEvent e, GC buffer) {
+		// TODO make unique selection box for groups
+		
+	}
+
+	@Override
+	protected Shape getVOutline() {
+		// TODO Return outline of the Group members, distinct from global selection box
+		
+		Rectangle rect = new Rectangle();
+
+		return rect;
+	}
+
+}
Index: trunk/src/swt/org/pathvisio/view/VPathwayElement.java
===================================================================
--- trunk/src/swt/org/pathvisio/view/VPathwayElement.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/view/VPathwayElement.java	(revision 957)
@@ -0,0 +1,276 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import java.awt.Rectangle;
+import java.awt.Shape;
+import java.awt.geom.Point2D;
+import java.awt.geom.Rectangle2D;
+
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.graphics.GC;
+
+public abstract class VPathwayElement implements Comparable<VPathwayElement>
+{	
+	protected VPathway canvas;
+	
+	VPathwayElement(VPathway canvas) {
+		this.canvas = canvas;
+		canvas.addObject(this);
+	}
+	
+	private boolean isHighlighted;
+	private Rectangle oldrect = null;
+	
+	private boolean isSelected;
+		
+	protected abstract void draw(PaintEvent e);
+	
+	/**
+	 * Draws the VPathwayElement object on the VPathway
+	 * it is part of
+	 */
+	public abstract void draw(PaintEvent e, GC buffer);
+	
+	/** 
+	 * mark both the area currently and previously occupied by this object for redraw 
+	 */
+	protected void markDirty()
+	{
+		if (oldrect != null)
+		{
+			canvas.addDirtyRect(oldrect);
+		}
+		Rectangle newrect = getVBounds();
+		canvas.addDirtyRect(newrect);
+		oldrect = newrect;
+	}
+
+	/**
+	 * Get the drawing this object belongs to
+	 */
+	public VPathway getDrawing() {
+		return canvas;
+	}
+	
+	/**
+	 * Besides resetting isHighlighted, this accomplishes this:
+	 * - marking the area dirty, so the object has a chance to redraw itself in unhighlighted state
+	 */
+	public void unhighlight()
+	{
+		if(isHighlighted)
+		{
+			isHighlighted = false;
+			markDirty();
+		}
+	}
+
+	/**
+	 * Besides setting isHighlighted, this accomplishes this:
+	 * - marking the area dirty, so the object has a chance to redraw itself in highlighted state
+	 */
+	public void highlight()
+	{
+		if(!isHighlighted)
+		{
+			isHighlighted = true;
+			markDirty();
+		}
+	}
+	
+	/**
+	 * Returns true if this object is highlighted, false otherwise
+	 */
+	public boolean isHighlighted()
+	{
+		return isHighlighted;
+	}
+
+	/**
+	 * Determines whether a Graphics object intersects 
+	 * the rectangle specified
+	 * @param r - the rectangle to check
+	 * @return True if the object intersects the rectangle, false otherwise
+	 */
+	protected boolean vIntersects(Rectangle2D.Double r)
+	{
+		return getVOutline().intersects(r);
+	}
+	
+	/**
+	 * Determines wheter a Graphics object contains
+	 * the point specified
+	 * @param point - the point to check
+	 * @return True if the object contains the point, false otherwise
+	 */
+	protected boolean vContains(Point2D point)
+	{
+		return getVOutline().contains(point);
+	}	
+
+
+	public boolean isSelected()
+	{
+		return isSelected;
+	}
+	
+	/**
+	 * Besides resetting isSelected, this accomplishes this:
+	 * - marking the area dirty, so the object has a chance to redraw itself in unselected state
+	 */
+	public void deselect()
+	{
+		if (isSelected)
+		{
+			isSelected = false;
+			markDirty();			
+		}
+	}
+
+	/**
+	 * Besides setting isSelected, this accomplishes this:
+	 * - marking the area dirty, so the object has a chance to redraw itself in selected state
+	 */
+	public void select()
+	{
+		if (!isSelected)
+		{
+			isSelected = true;
+			markDirty();			
+		}
+	}
+
+	/**
+	 * Transforms this object to fit to the coordinates
+	 * of the given handle
+	 * @param h	The Handle to adjust to
+	 */
+	protected void adjustToHandle(Handle h) {}
+
+	/**
+	 * Get all the handles belonging to this object
+	 * @return an array of GmmlHandles, an empty array if the object
+	 * has no handles
+	 */
+	protected Handle[] getHandles() { return new Handle[] {}; }
+	
+	/**
+	 * Moves this object by specified increments
+	 * @param dx - the value of x-increment
+	 * @param dy - the value of y-increment
+	 */
+	// TODO: should really be mMoveBy, using model coords,
+	// because implementations do a lot of conversions anyway
+	// perhaps could even be partially implemented in PathwayElement 
+	protected void vMoveBy(double dx, double dy) { }
+	
+	/**
+	 * Get the rectangular boundary of this object
+	 */
+	protected final Rectangle getVBounds()
+	{
+		return getVOutline().getBounds();
+	}
+	
+	abstract protected Shape getVOutline();
+
+
+	/**
+	 * Scales the object to the given rectangle
+	 * @param r
+	 */
+	protected void setVScaleRectangle(Rectangle2D.Double r) { }
+	
+	/**
+	 * Gets the rectangle used to scale the object
+	 */
+	protected Rectangle2D.Double getVScaleRectangle() { return new Rectangle2D.Double(); }
+
+	public int getDrawingOrder() {
+		return VPathway.DRAW_ORDER_DEFAULT;
+	}
+	
+	/**
+	 * Orders GmmlDrawingObjects by their drawingOrder.
+	 * The comparison is consistent with "equals", i.e. it doesn't return 0 if
+	 * the objects are different, even if their drawing order is the same.
+	 * 
+	 * @param d
+	 * @see #getDrawingOrder()
+	 */
+	public int compareTo(VPathwayElement d)
+	{
+		// same object? easy...
+		if (d == this)
+			return 0;
+		
+		int az, bz;
+		az = getDrawingOrder();
+		bz = d.getDrawingOrder();
+		
+		if(isSelected() && d.isSelected()) {
+			; //objects are both selected, keep original sort order
+		}
+		else if(isSelected() || isHighlighted())
+		{
+			az = VPathway.DRAW_ORDER_SELECTED;
+		}
+		else if(d.isSelected() || d.isHighlighted())
+		{
+			bz = VPathway.DRAW_ORDER_SELECTED;
+		}
+		
+		// note, if the drawing order is equal, that doesn't mean the objects are equal
+		// the construct with hashcodes give objects a defined sort order, even if their
+		// drawing orders are equal.		
+		if (az == bz)
+		{
+			az = hashCode();
+			bz = d.hashCode();		
+		}
+		// there is still a remote possibility that although the objects are not the same,
+		// the hashcode is the same. Even still, we shouldn't return 0.
+		if (az != bz) 
+			return bz - az; 
+		else
+			return -1;
+	}
+	
+	/** 
+	 * helper method to convert view coordinates to model coordinates 
+	 * */
+	protected double mFromV(double v) { return canvas.mFromV(v); }
+
+	/** 
+	 * helper method to convert view coordinates to model coordinates 
+	 * */
+	protected double vFromM(double m) { return canvas.vFromM(m); } 
+	
+	protected void destroyHandles() {
+		for(Handle h : getHandles()) {
+			h.destroy();
+		}
+	}
+	
+	protected void destroy() { 
+		//Remove from canvas
+		canvas.getDrawingObjects().remove(this);
+		destroyHandles();
+	}
+
+}
Index: trunk/src/swt/org/pathvisio/view/SelectionBox.java
===================================================================
--- trunk/src/swt/org/pathvisio/view/SelectionBox.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/view/SelectionBox.java	(revision 957)
@@ -0,0 +1,457 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import java.awt.Rectangle;
+import java.awt.geom.Point2D;
+import java.awt.geom.Rectangle2D;
+import java.util.ArrayList;
+import java.util.EventObject;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.graphics.GC;
+import org.pathvisio.model.ObjectType;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.GraphLink.GraphRefContainer;
+import org.pathvisio.model.PathwayElement.MPoint;
+
+/**
+ * This class implements a selectionbox 
+ */ 
+public class SelectionBox extends GraphicsShape
+{
+	private static final long serialVersionUID = 1L;
+		
+	private ArrayList<VPathwayElement> selection;
+	boolean isSelecting;
+	boolean isVisible;
+		
+	/**
+	 * Constructor for this class
+	 * @param canvas - the VPathway this selectionbox will be part of
+	 */
+	public SelectionBox(VPathway canvas)
+	{
+		// TODO: selectionbox shouldn't need a dataobject...
+		// note, not setting parent of PathwayElement here.
+		this(canvas, new PathwayElement(ObjectType.SHAPE));
+	}	
+	
+	public SelectionBox(VPathway canvas, PathwayElement pe)
+	{
+		super(canvas, pe);
+			
+		selection = new ArrayList<VPathwayElement>();
+	}	
+	
+	public int getDrawingOrder() {
+		return VPathway.DRAW_ORDER_SELECTIONBOX;
+	}
+	
+	public ArrayList<VPathwayElement> getSelection() {
+		return selection;
+	}
+	
+	/**
+	 * Add an object to the selection
+	 * @param o
+	 */
+	public void addToSelection(VPathwayElement o) {
+		if(o == this || selection.contains(o)) return; //Is selectionbox or already in selection
+		if(o instanceof VPoint) {
+			for(Line l : ((VPoint)o).getLines()) {
+				l.select();
+				doAdd(l);
+			}
+		} else {
+			o.select();
+			doAdd(o);
+		}
+		fireSelectionEvent(new SelectionEvent(this, SelectionEvent.OBJECT_ADDED, o));
+		if(isSelecting) return; //All we have to do if user is dragging selectionbox
+		if(hasMultipleSelection()) { 
+			stopSelecting(); //show and fit to SelectionBox if performed after dragging
+		}
+		 
+	}
+	
+	private void doAdd(VPathwayElement o) {
+		if(!selection.contains(o)) selection.add(o);
+	}
+	
+	/**
+	 * Remove an object from the selection
+	 * @param o
+	 */
+	public void removeFromSelection(VPathwayElement o) {
+		if(o == this) return;
+		selection.remove(o); 
+		o.deselect();
+		fireSelectionEvent(new SelectionEvent(this, SelectionEvent.OBJECT_REMOVED, o));
+		if(!isSelecting) fitToSelection();
+	}
+	
+	/**
+	 * Get the child object at the given coordinates (relative to canvas)
+	 * @param p
+	 * @return the child object or null if none is present at the given location
+	 */
+	public VPathwayElement getChild(Point2D p) {
+		//First check selection
+		for(VPathwayElement o : selection) {
+			if(o.vContains(p)) return o;
+		}
+		//Nothing in selection, check all other objects
+		for(VPathwayElement o : canvas.getDrawingObjects()) {
+			if(o.vContains(p) && o != this)
+				return o;
+		}
+		return null; //Nothing found
+	}
+	
+	/**
+	 * Removes or adds the object (if exists) at the given coordinates from the selection,
+	 * depending on its selection-state
+	 * @param p
+	 */
+	public void objectClicked(Point2D p) {
+		VPathwayElement clicked = getChild(p);
+		if(clicked == null) return; //Nothing clicked
+		if(clicked.isSelected()) 	//Object is selected, remove
+		{
+			removeFromSelection(clicked);
+		} 
+		else 						//Object is not selected, add
+		{
+			addToSelection(clicked);
+		}
+	}
+	
+	/**
+	 * Returns true if the selectionbox has multiple objects in its selection, false otherwise
+	 */
+	public boolean hasMultipleSelection() { return selection.size() > 1 ? true : false; }
+	
+	/**
+	 * Resets the selectionbox (unselect selected objects, clear selection, reset rectangle
+	 * to upperleft corner
+	 */
+	public void reset() { 
+		reset(0, 0, true);
+	}
+	
+	
+	/**
+	 * Resets the selectionbox (unselect selected objects, clear selection, reset rectangle
+	 * to upperleft corner
+	 * @param clearSelection if true the selection is cleared
+	 */
+	public void reset(boolean clearSelection) { 
+		reset(0, 0, clearSelection);
+	}
+	
+	public void reset(double vStartX, double vStartY) {
+		reset(vStartX, vStartY, true);
+	}
+	
+	private void reset(double vStartX, double vStartY, boolean clearSelection) {
+		for(VPathwayElement o : selection) o.deselect();
+		if(clearSelection) {
+			selection.clear();
+			fireSelectionEvent(
+					new SelectionEvent(this, SelectionEvent.SELECTION_CLEARED));
+		}
+		
+		gdata.setMLeft(mFromV(vStartX));
+		gdata.setMTop(mFromV(vStartY));
+		gdata.setMWidth(0);
+		gdata.setMHeight(0);
+	}
+
+	/**
+	 * Returns true if this selectionbox is in selecting state (selects containing objects when resized)
+	 */
+	public boolean isSelecting() { return isSelecting; }
+	
+	/**
+	 * Start selecting
+	 */
+	public void startSelecting() {
+		isSelecting = true;
+		setHandleRestriction(false);
+		show();
+	}
+	
+	/**
+	 * Stop selecting
+	 */
+	public void stopSelecting() {
+		isSelecting = false;
+		if(!hasMultipleSelection()) {
+			if(selection.size() == 1) {
+				VPathwayElement passTo = selection.get(0);
+				reset();
+				passTo.select();
+			} else {
+				reset();
+			}
+		} else {
+			select();
+			fitToSelection();
+			setHandleRestriction(true);
+		}
+	}
+	
+	/**
+	 * Sets movement direction restriction for this object's handles
+	 * @param restrict if true, handle movement is restricted in XY direction,
+	 * else handles can move freely
+	 */
+	private void setHandleRestriction(boolean restrict) {
+		if(restrict) {
+			handleNE.setDirection(Handle.DIRECTION_MINXY);
+			handleSW.setDirection(Handle.DIRECTION_MINXY);
+			handleNW.setDirection(Handle.DIRECTION_XY);
+			handleSE.setDirection(Handle.DIRECTION_XY);
+		} else {
+			for(Handle h : getHandles()) 
+				h.setDirection(Handle.DIRECTION_FREE); 
+		}
+	}
+	
+	public void select() {
+		super.select();
+		for(VPathwayElement o : selection) {
+			o.select();
+			for(Handle h : o.getHandles()) h.hide();
+		}
+	}
+	
+	/**
+	 * Fit the size of this object to the selected objects
+	 */
+	public void fitToSelection() {
+		if(selection.size() == 0) { //No objects in selection
+			hide(); 
+			return;
+		}
+		if(! hasMultipleSelection()) { //Only one object in selection, hide selectionbox
+			VPathwayElement passTo = selection.get(0);
+			hide(false);
+			passTo.select();
+			return;
+		}
+
+		Rectangle vr = null;
+		for(VPathwayElement o : selection) {
+			if(vr == null) vr = o.getVBounds();
+			else vr.add(o.getVBounds());
+			for(Handle h : o.getHandles()) h.hide();
+		}
+
+		gdata.setMWidth(mFromV(vr.width));
+		gdata.setMHeight(mFromV(vr.height));
+		gdata.setMLeft(mFromV(vr.x));
+		gdata.setMTop(mFromV(vr.y));
+		setHandleLocation();		
+	}
+			
+	/**
+	 * Show the selectionbox
+	 */
+	public void show() { 
+		isVisible = true; 
+		markDirty();
+	}
+	
+	/**
+	 * Hide the selectionbox
+	 */
+	public void hide() {
+		hide(true);
+	}
+	
+	public void hide(boolean reset) {
+		for(Handle h : getHandles()) h.hide();
+		isVisible = false;
+		if(reset) reset();
+	}
+	
+	/**
+	 * Gets the corner handle (South east) for start dragging
+	 */
+	public Handle getCornerHandle() { return handleSE; }
+	
+	public void adjustToHandle(Handle h) {	
+		//Store original size and location before adjusting to handle
+		double vWidthOld = getVWidthDouble();
+		double vHeightOld = getVHeightDouble();
+		double vCenterXOld = getVCenterXDouble();
+		double vCenterYOld = getVCenterYDouble();
+		
+		super.adjustToHandle(h);
+		if(isSelecting) { //Selecting, so add containing objects to selection
+			Rectangle vr = getVBounds();
+			Rectangle2D.Double bounds = new Rectangle2D.Double(vr.x, vr.y, vr.width, vr.height);
+			for(VPathwayElement o : canvas.getDrawingObjects()) {
+				if((o == this) || (o instanceof Handle)) continue;
+				if(o.vIntersects(bounds)) { 
+					addToSelection(o);
+				} else if(o.isSelected()) removeFromSelection(o);
+			}
+		} else { //Resizing, so resize child objects too
+			double widthRatio = getVWidthDouble() / vWidthOld;
+			double heightRatio = getVHeightDouble() / vHeightOld;
+			//Scale all selected objects in x and y direction, treat points seperately
+			Set<VPoint> points = new HashSet<VPoint>();
+			for(VPathwayElement o : selection) { 
+				if(o instanceof Line) {
+					points.addAll(((Line)o).getPoints());
+				} else { 
+					Rectangle2D.Double vr = o.getVScaleRectangle();
+					double newObjectWidth = vr.width * widthRatio;
+					double newObjectHeight = vr.height * heightRatio;
+					double objectFromCenterX = (vr.x - vCenterXOld) * widthRatio;
+					double objectFromCenterY = (vr.y - vCenterYOld) * heightRatio;
+					o.setVScaleRectangle(new Rectangle2D.Double(
+							getVCenterXDouble() + objectFromCenterX, 
+							getVCenterYDouble() + objectFromCenterY, 
+							newObjectWidth, 
+							newObjectHeight));
+				}
+			}
+			for(VPoint p : points) {
+				double dx = (p.getVX() - vCenterXOld) * widthRatio;
+				double dy = (p.getVY() - vCenterYOld) * heightRatio;
+				p.setVLocation(getVCenterXDouble() + dx, getVCenterYDouble() + dy);
+			}
+		}
+	}
+	
+	public void vMoveBy(double vdx, double vdy) 
+	{
+
+		gdata.setMLeft(gdata.getMLeft() + mFromV(vdx)); 
+		gdata.setMTop(gdata.getMTop() + mFromV(vdy));
+
+		//Move selected object and their references
+		Set<GraphRefContainer> not = new HashSet<GraphRefContainer>(); //Will be moved by linking object
+		Set<VPoint> points = new HashSet<VPoint>(); //Will not be moved by linking object
+		
+		for(VPathwayElement o : selection) 
+		{
+			if (o instanceof Graphics)
+			{
+				PathwayElement g = ((Graphics)o).getGmmlData();
+				if(!(o instanceof Line)) {
+					o.vMoveBy(vdx, vdy);
+					not.addAll(g.getReferences());
+				}
+				if(g.getObjectType() == ObjectType.LINE) {
+					points.addAll(((Line)o).getPoints());
+				}
+			}
+
+		}
+		
+		for(GraphRefContainer ref : not) {
+			if(ref instanceof MPoint) {
+				points.remove(canvas.getPoint((MPoint)ref));
+			}
+		}
+			
+		for(VPoint p : points) {
+			p.vMoveBy(vdx, vdy);
+		}
+	}
+	
+	public void draw(PaintEvent e, GC buffer)
+	{
+		if(isVisible) {
+			buffer.setAntialias(SWT.OFF);
+			buffer.setForeground (e.display.getSystemColor (SWT.COLOR_BLACK));
+			buffer.setBackground (e.display.getSystemColor (SWT.COLOR_BLACK));
+			buffer.setLineStyle (SWT.LINE_DOT);
+			buffer.setLineWidth (1);
+			buffer.drawRectangle (getVLeft(), getVTop(), getVWidth(), getVHeight());
+			buffer.setAntialias(SWT.ON);
+		}
+	}
+	
+	protected void draw(PaintEvent e)
+	{
+		draw(e, e.gc);
+	}
+	
+	public void adjustToZoom(double factor) { fitToSelection(); }
+	
+	static List<SelectionListener> listeners;
+
+	/**
+	 * Add a {@link SelectionListener}, that will be notified if a selection event occurs
+	 * @param l The {@link SelectionListener} to add
+	 */
+	public static void addListener(SelectionListener l) {
+		if(listeners == null)
+			listeners = new ArrayList<SelectionListener>();
+		listeners.add(l);
+	}
+
+	/**
+	 * Fire a {@link SelectionEvent} to notify all {@link SelectionListener}s registered
+	 * to this class
+	 * @param e
+	 */
+	public static void fireSelectionEvent(SelectionEvent e) {
+		for(SelectionListener l : listeners) {
+			l.drawingEvent(e);
+		}
+	}
+
+	public interface SelectionListener {
+		public void drawingEvent(SelectionEvent e);
+	}
+
+	public static class SelectionEvent extends EventObject {
+		private static final long serialVersionUID = 1L;
+		public static final int OBJECT_ADDED = 0;
+		public static final int OBJECT_REMOVED = 1;
+		public static final int SELECTION_CLEARED = 2;
+
+		public SelectionBox source;
+		public VPathwayElement affectedObject;
+		public int type;
+		public List<VPathwayElement> selection;
+
+		public SelectionEvent(SelectionBox source, int type, VPathwayElement affectedObject) {
+			super(source);
+			this.source = source;
+			this.type = type;
+			this.selection = source.selection;
+			this.affectedObject = affectedObject;
+		}
+		
+		public SelectionEvent(SelectionBox source, int type) {
+			this(source, type, null);
+		}
+	}	
+	
+}
\ No newline at end of file
Index: trunk/build.xml
===================================================================
--- trunk/build.xml	(revision 956)
+++ trunk/build.xml	(revision 957)
@@ -63,18 +63,20 @@
 	</target>
 	
 	<target name="compile-v1" depends="prepare,resources-jar" description="Compile all sources">
-		<javac srcdir="src" debug="true"
-			includes="v1/**,core/**"
+		<javac srcdir="." debug="true"
+			includes="src/v1/**,src/core/**,swing/**"
 			destdir="${build.v1.dir}">
 			<classpath refid="project.v1.class.path"/>
 		</javac>
 	</target>
 
 	<target name="compile-v2" depends="prepare,resources-jar" description="Compile all sources">
-		<javac srcdir="src" 
-                    includes="v2/**,core/**"
-                    destdir="${build.v2.dir}">
-                    <classpath refid="project.v2.class.path"/>
+		<javac srcdir="." 
+               includes="src/v2/**,src/core/**,swing/**"
+			   excludes="core/org/pathvisio/view/VPathwayOld.java"
+			   
+               destdir="${build.v2.dir}">
+          <classpath refid="project.v2.class.path"/>
 		</javac>
 		<javac srcdir="src" 
                     includes="plugins/**"
Index: trunk/tools/gpmldiff/build.xml
===================================================================
--- trunk/tools/gpmldiff/build.xml	(revision 956)
+++ trunk/tools/gpmldiff/build.xml	(revision 957)
@@ -1,3 +1,4 @@
+<<<<<<< .working
 <?xml version="1.0"?>
 <project name="GpmlDiff" default="compile" basedir=".">
 	
@@ -67,3 +68,90 @@
 	</target>
 	
 </project>
+=======
+<?xml version="1.0"?>
+<project name="GpmlDiff" default="compile" basedir=".">
+	
+	<property name="src.dir" value="src"/>        
+	<property name="build.dir" value="build"/>
+
+    <property name="apidoc.dir" value="apidoc"/>
+	
+	<path id="project.class.path">
+		<pathelement location="${build.dir}"/>
+		<fileset dir="../../lib">
+		        <include name="**/*.jar"/>
+		</fileset>
+	</path>
+
+	<target name="prepare">
+		<mkdir dir="${build.dir}"/>
+		<mkdir dir="${apidoc.dir}"/>	
+	</target>
+	
+	<target name="clean" description="Remove all generated files.">
+		<delete dir="${build.dir}"/>
+		<delete dir="${apidoc.dir}"/>
+	</target>
+	
+	<target name="compile" depends="prepare" description="Compile all sources">
+		<javac srcdir="${src.dir}" debug="true"	destdir="${build.dir}">
+			<classpath refid="project.class.path"/>
+		</javac>
+		<!--
+		<javac srcdir="../../src/"
+			   includes="core/**,v2/**"
+			   destdir="${build.dir}">
+		  <classpath refid="project.class.path"/>
+		</javac>
+		!-->
+		<javac srcdir="../../src/core"
+			   includes="**"
+			   destdir="${build.dir}">
+		  <classpath refid="project.class.path"/>
+		</javac>
+		<javac srcdir="../../src/v2"
+			   includes="**"
+			   destdir="${build.dir}">
+		  <classpath refid="project.class.path"/>
+		</javac>
+	</target>
+	
+	<target name="jar" depends="compile" description="Generates executable jar file">
+		<jar jarfile="gpmldiff.jar" manifest="src/MANIFEST.MF">
+			<fileset dir="${build.dir}" includes="**/*.class"/>			
+		</jar>
+    </target>
+	
+	<target name="docs" depends="prepare" description="generate api-docs">
+		<tstamp /> <!-- set ${TODAY} -->
+		<javadoc destdir="${apidoc.dir}" 
+			doctitle="PathVisio"
+			footer="Generated ${TODAY}">
+			<classpath refid="project.class.path"/>
+			<package name="org.pathvisio.gpmldiff"/>
+			<sourcepath>			
+				<pathelement location="${src.dir}"/>
+			</sourcepath>
+		</javadoc>		
+	</target>
+		
+	<target name="test" depends="compile">
+		<javac srcdir="src"
+					includes="**"
+					destdir="${build.dir}">
+					<classpath refid="project.class.path"/>
+		</javac>
+		<junit printsummary="on" haltonfailure="true" fork="true">
+			<formatter type="brief" usefile="false"/>
+			<classpath refid="project.class.path"/>
+			<batchtest>
+				<fileset dir="src">
+					<include name="**/Test.java"/>
+				</fileset>
+			</batchtest>
+		</junit>
+	</target>
+	
+</project>
+>>>>>>> .merge-right.r956
Index: trunk/icons/paste.gif
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/icons/paste.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: trunk/icons/export.gif
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/icons/export.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: trunk/icons/copy.gif
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/icons/copy.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: trunk/icons/import.gif
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/icons/import.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

