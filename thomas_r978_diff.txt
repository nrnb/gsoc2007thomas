Index: trunk/src/core/org/pathvisio/data/DBConnector.java
===================================================================
--- trunk/src/core/org/pathvisio/data/DBConnector.java	(revision 0)
+++ trunk/src/core/org/pathvisio/data/DBConnector.java	(revision 978)
@@ -0,0 +1,21 @@
+package org.pathvisio.data;
+
+import java.sql.Connection;
+
+public interface DBConnector {
+	public static final int PROP_NONE = 0;
+	public static final int PROP_RECREATE = 4;
+	public static final int PROP_FINALIZE = 8;
+	
+	/**
+	 * Type for gene database
+	 */
+	public static final int TYPE_GDB = 0;
+	/**
+	 * Type for expression database
+	 */
+	public static final int TYPE_GEX = 1;
+	
+	public abstract Connection createConnection(String dbName) throws Exception;
+	public abstract Connection createConnection(String dbName, int props) throws Exception;	
+}
Index: trunk/src/core/org/pathvisio/view/swing/VPathwaySwing.java
===================================================================
--- trunk/src/core/org/pathvisio/view/swing/VPathwaySwing.java	(revision 977)
+++ trunk/src/core/org/pathvisio/view/swing/VPathwaySwing.java	(revision 978)
@@ -76,6 +76,8 @@
 	}
 
 	protected void paintComponent(Graphics g) {
+		Dimension vps = getViewportSize();
+		g.setClip(new Rectangle(0, 0, vps.width, vps.height));
 		child.draw((Graphics2D) g);
 	}
 
Index: trunk/src/core/org/pathvisio/util/ProgressKeeper.java
===================================================================
--- trunk/src/core/org/pathvisio/util/ProgressKeeper.java	(revision 0)
+++ trunk/src/core/org/pathvisio/util/ProgressKeeper.java	(revision 978)
@@ -0,0 +1,45 @@
+package org.pathvisio.util;
+
+public class ProgressKeeper {
+	volatile String taskName;
+	volatile boolean cancelled;
+	
+	int total;
+	int progress;
+	
+	public ProgressKeeper(int totalWork) {
+		total = totalWork;
+	}
+	
+	public void worked(int w) {
+		progress += w;
+	}
+	
+	public final void worked(double d) {
+		worked((int)d);
+	}
+	
+	public void setTaskName(String name) {
+		taskName = name;
+	}
+	
+	public void finished() {
+		progress = total;
+	}
+	
+	public void cancel() {
+		cancelled = true;
+	}
+	
+	public boolean isCancelled() {
+		return cancelled;
+	}
+	
+	public int getTotalWork() {
+		return total;
+	}
+	
+	public void report(String message) {
+		//To be implemented by subclasses if needed
+	}
+}
Index: trunk/src/swt/org/pathvisio/data/GexImportWizard.java
===================================================================
--- trunk/src/swt/org/pathvisio/data/GexImportWizard.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/data/GexImportWizard.java	(revision 978)
@@ -0,0 +1,556 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.data;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.IOException;
+
+import org.eclipse.jface.dialogs.MessageDialog;
+import org.eclipse.jface.wizard.IWizardPage;
+import org.eclipse.jface.wizard.Wizard;
+import org.eclipse.jface.wizard.WizardPage;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.ControlAdapter;
+import org.eclipse.swt.events.ControlEvent;
+import org.eclipse.swt.events.ModifyEvent;
+import org.eclipse.swt.events.ModifyListener;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Combo;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.FileDialog;
+import org.eclipse.swt.widgets.Group;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.List;
+import org.eclipse.swt.widgets.Spinner;
+import org.eclipse.swt.widgets.Table;
+import org.eclipse.swt.widgets.TableColumn;
+import org.eclipse.swt.widgets.TableItem;
+import org.eclipse.swt.widgets.Text;
+import org.pathvisio.Engine;
+import org.pathvisio.Globals;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.util.swt.TableColumnResizer;
+
+/**
+ * This class is a {@link Wizard} that guides the user trough the process to
+ * create an expression dataset from a delimited text file
+ */
+public class GexImportWizard extends Wizard {
+	ImportInformation importInformation;
+
+	public GexImportWizard() {
+		importInformation = new ImportInformation();
+
+		setWindowTitle("Create an expression dataset");
+		setNeedsProgressMonitor(true);
+	}
+
+	public void addPages() {
+		addPage(new FilePage());
+		addPage(new HeaderPage());
+		addPage(new ColumnPage());
+		addPage(new ImportPage());
+	}
+
+	boolean importFinished;
+
+	public boolean performFinish() {
+		if (!importFinished) {
+			ImportPage ip = (ImportPage) getPage("ImportPage");
+			getContainer().showPage(ip);
+			try {
+				// Start import process
+				getContainer().run(true, true,
+						new GexSwt.ImportProgressKeeper(
+								(ImportPage) getPage("ImportPage"), importInformation));
+			} catch (Exception e) {
+				Engine.log.error("while running expression data import process: " + e.getMessage(), e);
+			} // TODO: handle exception
+			ip.setTitle("Import finished");
+			ip.setDescription("Press finish to return to " + Globals.APPLICATION_VERSION_NAME);
+			importFinished = true;
+			return false;
+		}
+		if (importFinished
+				&& getContainer().getCurrentPage().getName().equals(
+						"ImportPage")) {
+			return true;
+		}
+		return false;
+	}
+
+	public boolean performCancel() {
+		return true; // Do nothing, just close wizard
+	}
+
+	/**
+	 * This is the wizard page to specify the location of the text file
+	 * containing expression data and the location to store the new expression
+	 * dataset
+	 */
+	public class FilePage extends WizardPage {
+		boolean txtFileComplete;
+
+		boolean gexFileComplete;
+
+		public FilePage() {
+			super("FilePage");
+			setTitle("File locations");
+			setDescription("Specify the locations of the file containing the expression data "
+					+ "and where to store the expression dataset");
+			setPageComplete(false);
+		}
+
+		public void createControl(Composite parent) {
+			final FileDialog fileDialog = new FileDialog(getShell(), SWT.OPEN);
+
+			Composite composite = new Composite(parent, SWT.NULL);
+			composite.setLayout(new GridLayout(2, false));
+
+			GridData labelGrid = new GridData(GridData.FILL_HORIZONTAL);
+			labelGrid.horizontalSpan = 2;
+
+			Label txtLabel = new Label(composite, SWT.FLAT);
+			txtLabel
+					.setText("Specify location of text file containing expression data");
+			txtLabel.setLayoutData(labelGrid);
+
+			final Text txtText = new Text(composite, SWT.SINGLE | SWT.BORDER);
+			txtText.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+			Button txtButton = new Button(composite, SWT.PUSH);
+			txtButton.setText("Browse");
+
+			Label gexLabel = new Label(composite, SWT.FLAT);
+			gexLabel.setText("Specify location to save the expression dataset");
+			gexLabel.setLayoutData(labelGrid);
+
+			final Text gexText = new Text(composite, SWT.SINGLE | SWT.BORDER);
+			gexText.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+			Button gexButton = new Button(composite, SWT.PUSH);
+			gexButton.setText("Browse");
+
+			txtButton.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					fileDialog
+							.setText("Select tab delimited text file containing expression data");
+					fileDialog.setFilterExtensions(new String[] { "*.txt",
+							"*.*" });
+					fileDialog.setFilterNames(new String[] { "Text file",
+							"All files" });
+					fileDialog.setFilterPath(SwtPreference.SWT_DIR_EXPR.getValue());
+					String file = fileDialog.open();
+					if (file != null) {
+						txtText.setText(file);
+						gexText.setText(file.replace(file.substring(file
+								.lastIndexOf(".")), ""));
+					}
+				}
+			});
+
+			gexButton.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					try {
+						DBConnectorSwt dbcon = Gex.getDBConnector();
+						String dbName = dbcon.openNewDbDialog(getShell(), gexText.getText());
+						if(dbName != null) gexText.setText(dbName);
+						
+					} catch(Exception ex) {
+						MessageDialog.openError(getShell(), "Error", "Unable to open connection dialog");
+						Engine.log.error("", ex);
+					}
+				}
+			});
+
+			txtText.addModifyListener(new ModifyListener() {
+				public void modifyText(ModifyEvent e) {
+					setTxtFile(new File(txtText.getText()));
+					setPageComplete(txtFileComplete && gexFileComplete);
+				}
+			});
+
+			gexText.addModifyListener(new ModifyListener() {
+				public void modifyText(ModifyEvent e) {
+					setDbName(gexText.getText());
+					setPageComplete(txtFileComplete && gexFileComplete);
+				}
+			});
+
+			composite.pack();
+			setControl(composite);
+		}
+
+		/**
+		 * Stores the given {@link File} pointing to the file containing the expresssion
+		 * data in text form to the {@link ImportInformation} object
+		 * @param file
+		 */
+		private void setTxtFile(File file) {
+			if (!file.exists()) {
+				setErrorMessage("Specified file to import does not exist");
+				txtFileComplete = false;
+				return;
+			}
+			if (!file.canRead()) {
+				setErrorMessage("Can't access specified file containing expression data");
+				txtFileComplete = false;
+				return;
+			}
+			importInformation.setTxtFile(file);
+			setErrorMessage(null);
+			txtFileComplete = true;
+		}
+
+		/**
+		 * Sets the name of the database to save the
+		 * expression database to the {@link ImportInformation} object
+		 * @param file
+		 */
+		private void setDbName(String name) {
+			importInformation.dbName = name;
+			setMessage("Expression dataset location: " + name);
+			gexFileComplete = true;
+		}
+
+		public IWizardPage getNextPage() {
+			setPreviewTableContent(previewTable); //Content of previewtable depends on file locations
+			return super.getNextPage();
+		}
+	}
+
+	Table previewTable;
+	
+	/**
+	 * This {@link WizardPage} is used to ask the user information about on which line the
+	 * column headers are and on which line the data starts
+	 */
+	public class HeaderPage extends WizardPage {
+
+		public HeaderPage() {
+			super("HeaderPage");
+			setTitle("Header information");
+			setDescription("Specify the line with the column headers and from where the data starts");
+			setPageComplete(true);
+		}
+		
+		Spinner startSpinner;
+		Spinner headerSpinner;
+		public void createControl(Composite parent) {
+			Composite composite = new Composite(parent, SWT.NULL);
+			composite.setLayout(new GridLayout(2, false));
+
+			Label headerLabel = new Label(composite, SWT.FLAT);
+			headerLabel.setText("Column headers at line: ");
+			headerSpinner = new Spinner(composite, SWT.BORDER);
+			headerSpinner.setMinimum(1);
+			headerSpinner.setSelection(importInformation.headerRow);
+
+			Label startLabel = new Label(composite, SWT.FLAT);
+			startLabel.setText("Data starts at line: ");
+			startSpinner = new Spinner(composite, SWT.BORDER);
+			startSpinner.setMinimum(1);
+			startSpinner.setSelection(importInformation.firstDataRow);
+
+			Group tableGroup = new Group(composite, SWT.SHADOW_ETCHED_IN);
+			GridData groupGrid = new GridData(GridData.FILL_BOTH);
+			groupGrid.horizontalSpan = 2;
+			groupGrid.widthHint = 300;
+			tableGroup.setLayoutData(groupGrid);
+			tableGroup.setLayout(new FillLayout());
+			tableGroup.setText("Preview of file to import");
+
+			previewTable = new Table(tableGroup, SWT.SINGLE | SWT.BORDER);
+			previewTable.setLinesVisible(true);
+			previewTable.setHeaderVisible(true);
+			TableColumn nrCol = new TableColumn(previewTable, SWT.LEFT);
+			nrCol.setText("line");
+			TableColumn txtCol = new TableColumn(previewTable, SWT.LEFT);
+			txtCol.setText("data");
+			nrCol.setWidth(40);
+			nrCol.setResizable(false);
+			previewTable.addControlListener(new TableColumnResizer(previewTable, tableGroup, new int[] {0, 100}));
+
+			composite.pack();
+			setControl(composite);
+		}
+
+		public IWizardPage getNextPage() {
+			importInformation.headerRow = headerSpinner.getSelection();
+			importInformation.firstDataRow = startSpinner.getSelection();
+			setColumnTableContent(columnTable);
+			setColumnControlsContent();
+			return super.getNextPage();
+		}
+	}
+
+	Table columnTable;
+	List columnList;
+	Combo codeCombo;
+	Combo idCombo;
+
+	/**
+	 * This is the wizard page to specify column information, e.g. which
+	 * are the gene id and systemcode columns
+	 */
+	public class ColumnPage extends WizardPage {
+
+		public ColumnPage() {
+			super("ColumnPage");
+			setTitle("Column information");
+			setDescription("Specify which columns contain the gene information and "
+					+ "which columns should not be treated as numeric data");
+			setPageComplete(true);
+		}
+
+		public void createControl(Composite parent) {
+			Composite composite = new Composite(parent, SWT.NULL);
+			composite.setLayout(new GridLayout(1, false));
+
+			Label idLabel = new Label(composite, SWT.FLAT);
+			idLabel.setText("Select column with gene identifiers");
+			idCombo = new Combo(composite, SWT.READ_ONLY);
+			idCombo.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+			
+			Label sysLabel = new Label(composite, SWT.FLAT);
+			sysLabel.setText("Select column with Systemcode");
+			codeCombo = new Combo(composite, SWT.READ_ONLY);
+			codeCombo.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+			
+			Label columnLabel = new Label(composite, SWT.FLAT | SWT.WRAP);
+			columnLabel
+					.setText("Select the columns containing data that should NOT be treated"
+							+ " as NUMERIC from the list below");
+
+			columnList = new List(composite, SWT.BORDER | SWT.MULTI
+					| SWT.V_SCROLL);
+			GridData listGrid = new GridData(GridData.FILL_HORIZONTAL);
+			listGrid.heightHint = 150;
+			columnList.setLayoutData(listGrid);
+			columnList.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					importInformation.setStringCols(columnList
+							.getSelectionIndices());
+				}
+			});
+			idCombo.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					importInformation.idColumn = idCombo.getSelectionIndex();
+				}
+			});
+			codeCombo.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					importInformation.codeColumn = codeCombo
+							.getSelectionIndex();
+				}
+			});
+
+			Group tableGroup = new Group(composite, SWT.SHADOW_ETCHED_IN);
+			GridData tableGrid = new GridData(GridData.FILL_BOTH);
+			tableGrid.heightHint = 100;
+			tableGroup.setLayoutData(tableGrid);
+			tableGroup.setLayout(new FillLayout());
+			tableGroup.setText("Preview of file to import");
+
+			columnTable = new Table(tableGroup, SWT.SINGLE | SWT.BORDER);
+			columnTable.setLinesVisible(true);
+			columnTable.setHeaderVisible(true);
+			columnTable.addControlListener(new TableColumnResizer(columnTable, tableGroup));
+
+			composite.pack();
+			setControl(composite);
+		}
+	}
+
+	/**
+	 * Sets the content of the Controls on the {@link ColumnPage}
+	 */
+	public void setColumnControlsContent() {
+		columnList.setItems(importInformation.getColNames());
+		columnList.setSelection(importInformation.getStringCols());
+		idCombo.setItems(importInformation.getColNames());
+		idCombo.select(importInformation.idColumn);
+		codeCombo.setItems(importInformation.getColNames());
+		codeCombo.select(importInformation.codeColumn);
+	}
+
+	/**
+	 * Sets the content of the given preview table (containing 2 columns: linenumber and textdata)
+	 * @param previewTable
+	 */
+	public void setPreviewTableContent(Table previewTable) {
+		previewTable.removeAll();
+		try {
+			int n = 50; // nr of lines to include in the preview
+			BufferedReader in = importInformation.getBufferedReader();
+			String line;
+			int i = 1;
+			while ((line = in.readLine()) != null && i <= n) {
+				TableItem ti = new TableItem(previewTable, SWT.NULL);
+				ti.setText(0, Integer.toString(i++));
+				ti.setText(1, line);
+			}
+		} catch (IOException e) { // TODO: handle IOException
+			Engine.log.error("while generating preview for importing expression data: " + e.getMessage(), e);
+		}
+		previewTable.pack();
+	}
+
+	/**
+	 * Sets teh content of the given columnTable (previews how the data will be divided in columns)
+	 * @param columnTable
+	 */
+	public void setColumnTableContent(Table columnTable) {
+		columnTable.removeAll();
+		for (TableColumn col : columnTable.getColumns())
+			col.dispose();
+		for (String colName : importInformation.getColNames()) {
+			TableColumn tc = new TableColumn(columnTable, SWT.NONE);
+			tc.setText(colName);
+		}
+		try {
+			int n = 50; // nr of lines to include in the preview
+			BufferedReader in = importInformation.getBufferedReader();
+			String line;
+			for (int i = 0; i < importInformation.firstDataRow - 1; i++)
+				in.readLine(); // Go to line where data starts
+			int j = 1;
+			while ((line = in.readLine()) != null && j++ < n) {
+				TableItem ti = new TableItem(columnTable, SWT.NULL);
+				ti.setText(line.split(ImportInformation.DELIMITER));
+			}
+		} catch (IOException e) { // TODO: handle IOException
+			Engine.log.error("while generating preview for importing expression data: " + e.getMessage(), e);
+		}
+		columnTable.pack();
+	}
+
+	/**
+	 * This page shows the progress and status of the import process
+	 */
+	public class ImportPage extends WizardPage {
+		Text progressText;
+
+		public ImportPage() {
+			super("ImportPage");
+			setTitle("Create expression dataset");
+			setDescription("Press finish button to create the expression dataset");
+			setPageComplete(true);
+
+		}
+
+		public void createControl(Composite parent) {
+			Composite composite = new Composite(parent, SWT.NULL);
+			composite.setLayout(new FillLayout());
+
+			progressText = new Text(composite, SWT.READ_ONLY | SWT.BORDER
+					| SWT.WRAP);
+			progressText.setText("Ready to import data" + Text.DELIMITER);
+			progressText.append("> Using gene database: "
+					+ Gdb.getDbName()
+					+ Text.DELIMITER);
+			progressText
+					.append("> If this is not the correct gene database, close this window"
+							+ " and change the gene database in the menu 'data' -> 'choose gene database'\n");
+			setControl(composite);
+		}
+
+		public void println(String text) {
+			appendProgressText(text, true);
+		}
+
+		public void print(String text) {
+			appendProgressText(text, false);
+		}
+		
+		public void appendProgressText(final String updateText,
+				final boolean newLine) {
+			if (progressText != null && !progressText.isDisposed())
+				progressText.getDisplay().asyncExec(new Runnable() {
+					public void run() {
+						progressText.append(updateText
+								+ (newLine ? progressText.getLineDelimiter()
+										: ""));
+					}
+				});
+		}
+
+		public IWizardPage getPreviousPage() {
+			// User pressed back, probably to change settings and redo the
+			// importing, so set importFinished to false
+			importFinished = false;
+			return super.getPreviousPage();
+		}
+	}
+
+	/**
+	 * {@link ControlAdapter} to fit the size of the table columns (for both previewTable and
+	 * columnTable) to the size of its parent composite
+	 */
+	class TableControlAdapter extends ControlAdapter {
+		Table table;
+
+		public TableControlAdapter(Table table) {
+			this.table = table;
+		}
+
+		public void controlResized(ControlEvent e) {
+			TableColumn[] cols = table.getColumns();
+			Rectangle area = table.getParent().getClientArea();
+			Point preferredSize = table.computeSize(SWT.DEFAULT, SWT.DEFAULT);
+			int width = area.width - 2 * table.getBorderWidth();
+			if (preferredSize.y > area.height + table.getHeaderHeight()) {
+				// Subtract the scrollbar width from the total column width
+				// if a vertical scrollbar will be required
+				Point vBarSize = table.getVerticalBar().getSize();
+				width -= vBarSize.x;
+			}
+			Point oldSize = table.getSize();
+			if (oldSize.x > area.width) {
+				// table is getting smaller so make the columns
+				// smaller first and then resize the table to
+				// match the client area width
+				if (cols.length == 2) { // This is the previewTable
+					cols[1].setWidth(width - cols[0].getWidth());
+				} else { // This is the columnTable
+					for (TableColumn col : cols) {
+						col.setWidth(width / cols.length);
+					}
+				}
+				table.setSize(area.width, area.height);
+			} else {
+				// table is getting bigger so make the table
+				// bigger first and then make the columns wider
+				// to match the client area width
+				table.setSize(area.width, area.height);
+				if (cols.length == 2) { // This is the previewTable
+					cols[1].setWidth(width - cols[0].getWidth());
+				} else { // This is the columnTable
+					for (TableColumn col : cols) {
+						col.setWidth(width / cols.length);
+					}
+				}
+			}
+		}
+	}
+}
\ No newline at end of file
Index: trunk/src/swt/org/pathvisio/data/ImportInformation.java
===================================================================
--- trunk/src/swt/org/pathvisio/data/ImportInformation.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/data/ImportInformation.java	(revision 978)
@@ -0,0 +1,186 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.data;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.Engine;
+
+/**
+ * This class contains the information needed to start importing a delimited
+ * text file to an expression dataset. This information can be gathered using
+ * the {@link GexImportWizard} or can be filled automatically
+ */
+public class ImportInformation {
+	/**
+	 * Points to the text file containing the expression data
+	 */
+	private File txtFile;
+	/**
+	 * Sets the text file containing the expression data
+	 * @param txtFile {@link File} to set
+	 */
+	public void setTxtFile(File txtFile)
+	{
+		//Close the connection to the previous file if exist
+		if(in != null) {
+			try { in.close(); } catch(Exception e) { 
+				Engine.log.error("on closing file " + this.txtFile + ": " + e.getMessage(), e);
+			}
+			in = null;
+		}
+		this.txtFile = txtFile;
+	}
+	/**
+	 * Get the private {@link File} txtFile
+	 * @return {@link File} object pointing to the text file that contains the
+	 * expression data
+	 */
+	public File getTxtFile() { return txtFile; } 
+	
+	/**
+	 * The database name in which the expression data is saved
+	 */
+	public String dbName;
+
+	/**
+	 * linenumber (first line is 1) of the line where the data begins
+	 */
+	int firstDataRow;
+	/**
+	 * linenumber (first line is 1) of the line containing the column headers
+	 */
+	int headerRow;
+	/**
+	 * Column number (first column is 0) of the column containing the gene identifier
+	 */
+	int idColumn;
+
+	/**
+	 * Column number (first column is 0) of the column containing the systemcode
+	 */
+	int codeColumn;
+
+	/**
+	 * Delimiter used to seperate columns in the text file containing expression data
+	 * TODO: let the user specify a delimiter
+	 */
+	static final String DELIMITER = "\t";
+
+	/**
+	 * Column numbers (first column is 0) of the columns of which the data should not be treated
+	 * as numberic
+	 */
+	private int[] stringCols;
+
+	/**
+	 * Constructor for this class
+	 * Sets the default values
+	 */
+	public ImportInformation() {
+		// Set the defaults
+		firstDataRow = 2;
+		headerRow = 1;
+		idColumn = 0;
+		codeColumn = 1;
+	}
+
+	/**
+	 * {@link BufferedReader} to the text file, maintained while the wizard is open
+	 */
+	BufferedReader in;
+
+	/**
+	 * Get a {@link BufferedReader} to the text file containing the expression data
+	 * Creates a new one 
+	 * @return
+	 */
+	public BufferedReader getBufferedReader() {
+		try {
+			if (in == null) {
+				in = new BufferedReader(new FileReader(txtFile));
+				// changed readahead from 10000 to 50000
+				// see http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4616869
+				// TODO: this may still fail for long lines (more than 50000 bytes in 50 lines) 
+				in.mark(50000);
+			} else {
+				in.reset();
+			}
+		} catch (Exception e) {
+			Engine.log.error("Error reading file", e);
+		} // TODO: handle exception
+		return in;
+	}
+
+	/**
+	 * Sets the private property stringCols
+	 * @param cols	Column numbers (start with 0) of columns containing data that
+	 * should not be treated as numeric
+	 */
+	public void setStringCols(int[] cols) {
+		stringCols = cols;
+	}
+
+	/**
+	 * Sets the private property stringCols
+	 * @return	Column numbers (start with 0) of columns containing data that
+	 * should not be treated as numeric, or an empty String[]
+	 */
+	public int[] getStringCols() {
+		if (stringCols == null)
+			stringCols = new int[] {};
+		return stringCols;
+	}
+
+	/**
+	 * Checks if the column for the given column index is marked as 'string column' and
+	 * should not be treated as numeric
+	 * @param colIndex	the index of the column to check (start with 0)
+	 * @return true if the column is marked as 'string column', false if not
+	 */
+	public boolean isStringCol(int colIndex) {
+		if (stringCols == null)
+			return false;
+		for (int col : stringCols)
+			if (col == colIndex)
+				return true;
+		return false;
+	}
+
+	/**
+	 * Reads the column names from the text file containing the expression data at the
+	 * header row specified by the user
+	 * @return the column names
+	 */
+	public String[] getColNames() {
+		try {
+			BufferedReader in = getBufferedReader();
+			int i = 0;
+			while (i < headerRow - 1 && in.readLine() != null)
+				i++; // Go to headerline
+			return in.readLine().split(ImportInformation.DELIMITER);
+		} catch (IOException e) { // TODO: handle IOException
+			Engine.log.error("Unable to get column names for importing expression data: " + e.getMessage(), e);
+			return new String[] {};
+		}
+	}
+
+}
Index: trunk/src/swt/org/pathvisio/data/DBConnHsqldb.java
===================================================================
--- trunk/src/swt/org/pathvisio/data/DBConnHsqldb.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/data/DBConnHsqldb.java	(revision 978)
@@ -0,0 +1,132 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.data;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.sql.Connection;
+import java.sql.DriverManager;
+import java.sql.SQLException;
+import java.sql.Statement;
+import java.util.Properties;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.widgets.FileDialog;
+import org.eclipse.swt.widgets.Shell;
+import org.pathvisio.Engine;
+import org.pathvisio.debug.StopWatch;
+
+/**
+   DBConnector implementation using the hsqldb driver
+*/
+public class DBConnHsqldb extends DBConnectorSwt
+{
+	static final String DB_FILE_EXT = "properties";
+	static final String[] DB_EXT = new String[] { "*." + DB_FILE_EXT };
+	static final String[] DB_EXT_NAMES = new String[] { "Hsqldb Database" };
+	
+	public Connection createConnection(String dbName) throws Exception {
+		return createConnection(dbName, PROP_NONE);
+	}
+	
+	public Connection createConnection(String dbName, int props) throws Exception {
+		boolean recreate = (props & PROP_RECREATE) != 0;
+		if(recreate) {
+			File dbFile = dbName2File(dbName);
+			if(dbFile.exists()) dbFile.delete();
+		}
+		
+		dbName = file2DbName(dbName);
+		
+		Class.forName("org.hsqldb.jdbcDriver");
+		Properties prop = new Properties();
+		prop.setProperty("user","sa");
+		prop.setProperty("password","");
+		prop.setProperty("hsqldb.default_table_type", "cached");
+		prop.setProperty("ifexists", Boolean.toString(!recreate));
+		
+		StopWatch timer = new StopWatch();
+		timer.start();
+		Connection con = DriverManager.getConnection("jdbc:hsqldb:file:" + dbName, prop);
+		Engine.log.info("Connecting with hsqldb to " + dbName + ":\t" + timer.stop());
+		return con;
+	}
+
+	public void closeConnection(Connection con) throws SQLException {
+		closeConnection(con, PROP_NONE);
+	}
+	
+	public void closeConnection(Connection con, int props) throws SQLException {
+		boolean compact = (props & PROP_FINALIZE) != 0;
+		if(con != null) {
+			Statement sh = con.createStatement();
+			sh.executeQuery("SHUTDOWN" + (compact ? " COMPACT" : ""));
+			sh.close();
+			con.close();
+		}
+	}
+	
+	File dbName2File(String dbName) {
+		return new File(dbName + '.' + DB_FILE_EXT);
+	}
+	
+	String file2DbName(String fileName) {
+		String end = '.' + DB_FILE_EXT;
+		return fileName.endsWith(end) ? 
+				fileName.substring(0, fileName.length() -  end.length()) : fileName;
+	}
+	
+	public void setDatabaseReadonly(String dbName, boolean readonly) {
+		 setPropertyReadOnly(dbName, readonly);
+	}
+	
+	void setPropertyReadOnly(String dbName, boolean readonly) {
+    	Properties prop = new Properties();
+		try {
+			File propertyFile = dbName2File(dbName);
+			prop.load(new FileInputStream(propertyFile));
+			prop.setProperty("hsqldb.files_readonly", Boolean.toString(readonly));
+			prop.store(new FileOutputStream(propertyFile), "HSQL Database Engine");
+			} catch (Exception e) {
+				Engine.log.error("Unable to set database properties to readonly", e);
+			}
+	}
+
+	Connection newDbCon;
+	public Connection createNewDatabaseConnection(String dbName) throws Exception {
+		newDbCon = createConnection(dbName, PROP_RECREATE);
+		return newDbCon;
+	}
+
+	public String finalizeNewDatabase(String dbName) throws Exception {
+		if(newDbCon != null) closeConnection(newDbCon, PROP_FINALIZE);
+		setPropertyReadOnly(dbName, true);
+		return dbName;
+	}
+
+	public String openChooseDbDialog(Shell shell) {
+		FileDialog fd = createFileDialog(shell, SWT.OPEN, DB_EXT, DB_EXT_NAMES);
+		return fd.open();
+	}
+
+	public String openNewDbDialog(Shell shell, String defaultName) {
+		FileDialog fd = createFileDialog(shell, SWT.SAVE, DB_EXT, DB_EXT_NAMES);
+		if(defaultName != null) fd.setFileName(defaultName);
+		return fd.open();
+	}
+}
Index: trunk/src/swt/org/pathvisio/data/GexSwt.java
===================================================================
--- trunk/src/swt/org/pathvisio/data/GexSwt.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/data/GexSwt.java	(revision 978)
@@ -0,0 +1,123 @@
+package org.pathvisio.data;
+
+import java.lang.reflect.InvocationTargetException;
+import java.util.ArrayList;
+
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.jface.dialogs.ProgressMonitorDialog;
+import org.eclipse.jface.operation.IRunnableWithProgress;
+import org.eclipse.jface.wizard.IWizard;
+import org.eclipse.jface.wizard.WizardDialog;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.widgets.Shell;
+import org.pathvisio.data.GexImportWizard.ImportPage;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.util.ProgressKeeper;
+
+public class GexSwt {
+	
+	public static DBConnectorSwt getDBConnector() throws ClassNotFoundException, InstantiationException, IllegalAccessException {
+		return SwtEngine.getSwtDbConnector(DBConnectorSwt.TYPE_GEX);
+	}
+	
+	public static class ProgressWizardDialog extends WizardDialog {
+		ProgressKeeper progress;
+		public ProgressWizardDialog(Shell shell, IWizard wizard) {
+			super(shell, wizard);
+		}
+		
+		public void run(boolean fork, boolean cancellable, IRunnableWithProgress runnable) throws InvocationTargetException, InterruptedException {
+			//Add another selection listener to cancel ProgressKeeper
+			//Overriding cancelPressed() doesn't work when using progress monitor
+			getButton(WizardDialog.CANCEL).addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					if(progress != null) progress.cancel();
+				}
+			});
+			if(runnable instanceof ProgressKeeper) {
+				progress = (ProgressKeeper)runnable;
+			}
+			super.run(fork, cancellable, runnable);
+		}
+	}
+	
+	public static class ProgressKeeperDialog extends ProgressMonitorDialog {
+		ProgressKeeper progress;
+		
+		public ProgressKeeperDialog(Shell shell) {
+			super(shell);
+		}
+
+		public void run(boolean fork, boolean cancellable, IRunnableWithProgress runnable) throws InvocationTargetException, InterruptedException {
+			if(runnable instanceof ProgressKeeper) progress = (ProgressKeeper)runnable;
+			super.run(fork, cancellable, runnable);
+		}
+		
+		protected void cancelPressed() {
+			if(progress != null) progress.cancel();
+			super.cancelPressed();
+		}
+	}
+	
+	private static abstract class SwtProgressKeeper extends ProgressKeeper implements IRunnableWithProgress {
+		IProgressMonitor monitor;
+		
+		public SwtProgressKeeper(int totalWork) {
+			super(totalWork);
+		}
+		
+		public void run(IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
+			this.monitor = monitor;
+		}
+		
+		public void worked(int w) {
+			super.worked(w);
+			monitor.worked(w);
+		}
+		
+		public void setTaskName(String name) {
+			super.setTaskName(name);
+			monitor.setTaskName(name);
+		}
+		
+		public void finished() {
+			super.finished();
+			monitor.done();
+		}
+	}
+	
+	public static class CacheProgressKeeper extends SwtProgressKeeper implements IRunnableWithProgress {
+		ArrayList<String> ids;
+		ArrayList<String> codes;
+		
+		public CacheProgressKeeper(ArrayList<String> ids, ArrayList<String> codes) {
+			super(ids.size());
+			this.ids = ids;
+			this.codes = codes;
+		}
+		
+		public void run(IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
+			super.run(monitor);
+			monitor.beginTask("Loading data", getTotalWork());
+			Gex.cacheData(ids, codes, this);
+		}
+	}
+	
+	public static class ImportProgressKeeper extends SwtProgressKeeper {
+		ImportPage page;
+		ImportInformation info;
+		
+		public ImportProgressKeeper(ImportPage page, ImportInformation info) {
+			super((int)1E6);
+			this.page = page;
+			this.info = info;
+		}
+
+		public void run(IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
+			super.run(monitor);
+			monitor.beginTask("Importing data", getTotalWork());
+			Gex.importFromTxt(info, this);
+		}
+	}	
+}
Index: trunk/src/swt/org/pathvisio/data/DBConnDerby.java
===================================================================
--- trunk/src/swt/org/pathvisio/data/DBConnDerby.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/data/DBConnDerby.java	(revision 978)
@@ -0,0 +1,247 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.data;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.sql.CallableStatement;
+import java.sql.Connection;
+import java.sql.DriverManager;
+import java.sql.SQLException;
+import java.util.Properties;
+import java.util.zip.CRC32;
+import java.util.zip.CheckedInputStream;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipOutputStream;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.widgets.FileDialog;
+import org.eclipse.swt.widgets.Shell;
+import org.pathvisio.Engine;
+import org.pathvisio.debug.StopWatch;
+import org.pathvisio.util.FileUtils;
+
+/**
+   DBConnector implementation using the Derby driver, with the database in a
+   single, uncompressed zip archive
+*/
+public class DBConnDerby extends DBConnectorSwt {
+	static final String DB_FILE_EXT_GDB = "pgdb";
+	static final String DB_FILE_EXT_GEX = "pgex";
+	static final String[] DB_EXTS_GEX = new String[] { "*." + DB_FILE_EXT_GEX, "*.*"};
+	static final String[] DB_EXTS_GDB = new String[] { "*." + DB_FILE_EXT_GDB, "*.*"};
+	static final String[] DB_EXT_NAMES_GEX = new String[] { "Expression dataset", "All files" };
+	static final String[] DB_EXT_NAMES_GDB = new String[] { "Gene database", "All files" };
+	
+	public static final String DB_NAME_IN_ZIP = "database";
+	String lastDbName;
+	
+	public Connection createConnection(String dbName) throws Exception {
+		return createConnection(dbName, PROP_NONE);
+	}
+	
+	public Connection createConnection(String dbName, int props) throws Exception {
+		boolean recreate = (props & PROP_RECREATE) != 0;
+		if(recreate) {
+			File dbFile = new File(dbName);
+			FileUtils.deleteRecursive(dbFile);
+		}
+		
+		Properties sysprop = System.getProperties();
+		sysprop.setProperty("derby.storage.tempDirectory", System.getProperty("java.io.tmpdir"));
+		sysprop.setProperty("derby.stream.error.file", File.createTempFile("derby",".log").toString());
+		
+		Class.forName("org.apache.derby.jdbc.EmbeddedDriver");
+		Properties prop = new Properties();
+		prop.setProperty("create", Boolean.toString(recreate));
+		
+		StopWatch timer = new StopWatch();
+		timer.start();
+		
+		String url = "jdbc:derby:";
+		File dbFile = new File(dbName);
+		if(dbFile.isDirectory() || recreate) {
+			url += dbName;
+		} else {
+			url += "jar:(" + dbFile.toString() + ")" + DB_NAME_IN_ZIP;
+		}
+		Connection con = DriverManager.getConnection(url, prop);
+		
+		Engine.log.info("Connecting with derby to " + dbName + ":\t" + timer.stop());
+		
+		lastDbName = dbName;
+		return con;
+	}
+	
+	public Connection createNewDatabaseConnection(String dbName) throws Exception {
+		return createConnection(FileUtils.removeExtension(dbName), PROP_RECREATE);
+	}
+	
+	public String finalizeNewDatabase(String dbName) throws Exception {
+		//Transfer db to zip and clear old dbfiles
+		File dbDir = new File(FileUtils.removeExtension(dbName));
+		try {
+			DriverManager.getConnection("jdbc:derby:" + FileUtils.removeExtension(dbName) + ";shutdown=true");
+		} catch(Exception e) {
+			Engine.log.error("Database closed", e);
+		}
+		File zipFile = new File(dbName.endsWith(getDbExt()) ? dbName : dbName + "." + getDbExt());
+		toZip(zipFile, dbDir);
+		
+		FileUtils.deleteRecursive(dbDir);
+		
+		//Return new database file
+		return zipFile.toString();
+	}
+	
+	public void closeConnection(Connection con) throws SQLException {
+		closeConnection(con, PROP_NONE);
+	}
+	
+	public void closeConnection(Connection con, int props) throws SQLException {
+		if(con != null) {
+			if(lastDbName != null) 
+				DriverManager.getConnection("jdbc:derby:" + lastDbName + ";shutdown=true");
+			con.close();
+		}
+	}
+	
+	public void compact(Connection con) throws SQLException {
+		con.setAutoCommit(true);
+
+		CallableStatement cs = con.prepareCall
+		("CALL SYSCS_UTIL.SYSCS_COMPRESS_TABLE(?, ?, ?)");
+		//Expression table
+		cs.setString(1, "APP");
+		cs.setString(2, "EXPRESSION");
+		cs.setShort(3, (short) 1);
+		cs.execute();
+		
+		con.commit(); //Just to be sure...
+	}
+		
+	void toZip(File zipFile, File dbDir) {
+		try {			
+			if(zipFile.exists()) zipFile.delete();
+			
+			zipFiles(zipFile, dbDir);
+			
+			String zipPath = zipFile.getAbsolutePath().replace(File.separatorChar, '/');
+			String url = "jdbc:derby:jar:(" + zipPath + ")" + DB_NAME_IN_ZIP;
+
+			DriverManager.getConnection(url);
+		
+		} catch(Exception e) {
+			e.printStackTrace();
+		}
+	}
+	
+	void zipFiles(File zipFile, File dir) throws Exception {
+		ZipOutputStream out = new ZipOutputStream(new FileOutputStream(zipFile));
+		out.setMethod(ZipOutputStream.STORED);
+		for(File f : dir.listFiles()) addFiles(f, DB_NAME_IN_ZIP + '/', out);
+		out.closeEntry();
+		out.close();
+	}
+	
+	byte[] buf = new byte[1024];
+	void addFiles(File file, String dir, ZipOutputStream out) throws Exception {
+		if(file.isDirectory()) {
+			if(file.getName().equals("tmp")) return; //Skip 'tmp' directory
+			
+			String newDir = dir + file.getName() + '/';
+			ZipEntry add = new ZipEntry(newDir);
+			setZipEntryAttributes(file, add);
+			out.putNextEntry(add);
+			
+			for(File f : file.listFiles()) addFiles(f, newDir,out);
+		} else {
+			if(file.getName().endsWith(".lck")) return; //Skip '*.lck' files
+			ZipEntry add = new ZipEntry(dir + file.getName());
+			
+			setZipEntryAttributes(file, add);
+			
+			out.putNextEntry(add);
+				        
+			FileInputStream in = new FileInputStream(file);
+			int len;
+			while ((len = in.read(buf)) > 0) {
+				out.write(buf, 0, len);
+			}
+			in.close();
+		}
+	}
+	
+	void setZipEntryAttributes(File f, ZipEntry z) throws IOException {
+		z.setTime(f.lastModified());
+		z.setMethod(ZipEntry.STORED);
+				
+		if(f.isDirectory()) {
+			z.setCrc(0);
+			z.setSize(0);
+			z.setCompressedSize(0);
+		} else {			
+			z.setSize(f.length());
+			z.setCompressedSize(f.length());
+			z.setCrc(computeCheckSum(f));
+		}
+	}
+	
+	long computeCheckSum(File f) throws IOException {
+		CheckedInputStream cis = new CheckedInputStream(
+				new FileInputStream(f), new CRC32());
+		byte[] tempBuf = new byte[128];
+		while (cis.read(tempBuf) >= 0) { }
+		return cis.getChecksum().getValue();
+	}
+	
+	String getDbExt() {
+		switch(getDbType()) {
+		case TYPE_GDB: return DB_FILE_EXT_GDB;
+		case TYPE_GEX: return DB_FILE_EXT_GEX;
+		default: return "";
+		}
+	}
+	String[] getDbExts() {
+		switch(getDbType()) {
+		case TYPE_GDB: return DB_EXTS_GDB;
+		case TYPE_GEX: return DB_EXTS_GEX;
+		default: return null;
+		}
+	}
+	
+	String[] getDbExtNames() {
+		switch(getDbType()) {
+		case TYPE_GDB: return DB_EXT_NAMES_GDB;
+		case TYPE_GEX: return DB_EXT_NAMES_GEX;
+		default: return null;
+		}
+	}
+	
+	public String openChooseDbDialog(Shell shell) {
+		FileDialog fd = createFileDialog(shell, SWT.OPEN, getDbExts(), getDbExtNames());
+		return fd.open();
+	}
+
+	public String openNewDbDialog(Shell shell, String defaultName) {
+		FileDialog fd = createFileDialog(shell, SWT.SAVE, getDbExts(), getDbExtNames());
+		if(defaultName != null) fd.setFileName(defaultName);
+		return fd.open();
+	}
+}
Index: trunk/src/swt/org/pathvisio/data/DBConnDerbyDirectory.java
===================================================================
--- trunk/src/swt/org/pathvisio/data/DBConnDerbyDirectory.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/data/DBConnDerbyDirectory.java	(revision 978)
@@ -0,0 +1,52 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.data;
+
+import java.sql.DriverManager;
+
+import org.eclipse.swt.widgets.DirectoryDialog;
+import org.eclipse.swt.widgets.Shell;
+import org.pathvisio.Engine;
+import org.pathvisio.util.FileUtils;
+
+/**
+   Implementation of DBConnector using the Derby Driver,
+   with the database stored as multiple files in a directory
+*/
+public class DBConnDerbyDirectory extends DBConnDerby {	
+	String lastDbName;
+		
+	public String finalizeNewDatabase(String dbName) throws Exception {
+		try {
+			DriverManager.getConnection("jdbc:derby:" + FileUtils.removeExtension(dbName) + ";shutdown=true");
+		} catch(Exception e) {
+			Engine.log.error("Database closed", e);
+		}
+		return dbName;
+	}
+	
+	public String openChooseDbDialog(Shell shell) {
+		DirectoryDialog dd = createDirectoryDialog(shell);
+		return dd.open();
+	}
+
+	public String openNewDbDialog(Shell shell, String defaultName) {
+		DirectoryDialog dd = createDirectoryDialog(shell);
+		if(defaultName != null) dd.setFilterPath(defaultName);
+		return dd.open();
+	}
+}
Index: trunk/src/swt/org/pathvisio/data/DBConnectorSwt.java
===================================================================
--- trunk/src/swt/org/pathvisio/data/DBConnectorSwt.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/data/DBConnectorSwt.java	(revision 978)
@@ -0,0 +1,246 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.data;
+
+import java.sql.Connection;
+import java.sql.SQLException;
+import java.sql.Statement;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.widgets.DirectoryDialog;
+import org.eclipse.swt.widgets.FileDialog;
+import org.eclipse.swt.widgets.Shell;
+import org.pathvisio.Engine;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+
+/**
+ * This class provides the connection for the databases (annotation and expression database) used
+ * in PathVisio. Implement the abstract methods when you want to add support for a new database engine.
+ * @author Thomas
+ */
+public abstract class DBConnectorSwt implements DBConnector {
+	private int dbType;
+	
+	public abstract Connection createConnection(String dbName) throws Exception;
+	public abstract Connection createConnection(String dbName, int props) throws Exception;	
+	
+	/**
+	 * Close the given connection
+	 * @param con The connection to be closed
+	 * @throws Exception
+	 */
+	public void closeConnection(Connection con) throws Exception {
+		closeConnection(con, PROP_NONE);
+	}
+	
+	/**
+	 * Close the given connection, and optionally finalize it after creation (using {@link #PROP_FINALIZE})
+	 * @param con The connection to be closed
+	 * @param props Close properties (one of {@link #PROP_NONE}, {@link #PROP_FINALIZE} or {@link #PROP_RECREATE})
+	 * @throws Exception
+	 */
+	void closeConnection(Connection con, int props) throws Exception {
+		con.close();
+	}
+	
+	/**
+	 * Create a new database with the given name. This includes creating tables.
+	 * @param dbName The name of the database to create
+	 * @return A connection to the newly created database
+	 * @throws Exception
+	 */
+	protected final Connection createNewDatabase(String dbName) throws Exception {
+		Connection con = createNewDatabaseConnection(dbName);
+		createTables(con);
+		return con;
+	}
+	
+	private Connection createNewDatabaseConnection(String dbName) throws Exception {
+		return createConnection(dbName, PROP_RECREATE);
+	}
+	
+	/**
+	 * This method is called to finalize the given database after creation
+	 * (e.g. set read-only, archive files). The database name needs to returned, this
+	 * may change when finalizing the database modifies the storage type (e.g. from directory
+	 * to single file).
+	 * @param dbName The name of the database to finalize	
+	 * @throws Exception
+	 * @return The name of the finalized database
+	 */
+	protected abstract String finalizeNewDatabase(String dbName) throws Exception;
+	
+	/**
+	 * This method will be called when the user
+	 * needs to select a database. Open a dialog (e.g. FileDialog) in this
+	 * method to let the user select the database and return the database name.
+	 * @param shell The shell to create the dialog
+	 * @return The database name that was selected by the user, or null if no database was selected
+	 */
+	public abstract String openChooseDbDialog(Shell shell);
+	
+	/**
+	 * This method will be called when the user
+	 * needs to select a database to create. Open a dialog (e.g. FileDialog) in this
+	 * method to let the user select the new database name/file/directory and return the database name.
+	 * @param shell The shell to create the dialog
+	 * @return The database name to create, or null if no database was specified
+	 */
+	public abstract String openNewDbDialog(Shell shell, String defaultName);
+	
+	/**
+	 * Set the database type (one of {@link #TYPE_GDB} or {@link #TYPE_GEX})
+	 * @param type The type of the database that will be used for this class
+	 */
+	public void setDbType(int type) { dbType = type; }
+	/**
+	 * Get the database type (one of {@link #TYPE_GDB} or {@link #TYPE_GEX})
+	 * return The type of the database that is used for this class
+	 */
+	public int getDbType() { return dbType; }
+	
+	/**
+	 * Excecutes several SQL statements to create the tables and indexes for storing 
+	 * the expression data
+	 */
+	protected static void createTables(Connection con) throws Exception {	
+			con.setReadOnly(false);
+			Statement sh = con.createStatement();
+			try { sh.execute("DROP TABLE info"); } catch(SQLException e) { Engine.log.error("Error: unable to drop expression data tables: "+e.getMessage(), e); }
+			try { sh.execute("DROP TABLE samples"); } catch(SQLException e) { Engine.log.error("Error: unable to drop expression data tables: "+e.getMessage(), e); }
+			try { sh.execute("DROP TABLE expression"); } catch(SQLException e) { Engine.log.error("Error: unable to drop expression data tables: "+e.getMessage(), e); }
+			
+			sh.execute(
+					"CREATE TABLE					" +
+					"		info							" +
+					"(	  version INTEGER PRIMARY KEY		" +
+					")");
+			sh.execute( //Add compatibility version of GEX
+					"INSERT INTO info VALUES ( " + Gex.COMPAT_VERSION + ")");
+			sh.execute(
+					"CREATE TABLE                    " +
+					"		samples							" +
+					" (   idSample INTEGER PRIMARY KEY,		" +
+					"     name VARCHAR(50),					" +
+					"	  dataType INTEGER					" +
+			" )										");
+			
+			sh.execute(
+					"CREATE TABLE					" +
+					"		expression						" +
+					" (   id VARCHAR(50),					" +
+					"     code VARCHAR(50),					" +
+					"	  ensId VARCHAR(50),				" +
+					"     idSample INTEGER,					" +
+					"     data VARCHAR(50),					" +
+					"	  groupId INTEGER 					" +
+//					"     PRIMARY KEY (id, code, idSample, data)	" +
+					")										");
+	}
+	
+	/**
+	 * Creates indices for a newly created expression database.
+	 * @param con The connection to the expression database
+	 * @throws SQLException
+	 */
+	protected void createIndices(Connection con) throws SQLException {
+		con.setReadOnly(false);
+		Statement sh = con.createStatement();
+		sh.execute(
+				"CREATE INDEX i_expression_id " +
+		"ON expression(id)			 ");
+		sh.execute(
+				"CREATE INDEX i_expression_ensId " +
+		"ON expression(ensId)			 ");
+		sh.execute(
+				"CREATE INDEX i_expression_idSample " +
+		"ON expression(idSample)	 ");
+		sh.execute(
+				"CREATE INDEX i_expression_data " +
+		"ON expression(data)	     ");
+		sh.execute(
+				"CREATE INDEX i_expression_code " +
+		"ON expression(code)	 ");
+		sh.execute(
+				"CREATE INDEX i_expression_groupId" +
+		" ON expression(groupId)	");
+	}
+	
+	/**
+	 * This method may be implemented when the database files need to be
+	 * compacted or defragmented after creation of a new database. It will be called
+	 * after all data is added to the database.
+	 * @param con A connection to the database
+	 * @throws SQLException
+	 */
+	protected void compact(Connection con) throws SQLException {
+		//May be implemented by subclasses
+	}
+	
+	/**
+	 * Shortcut for creating a file dialog that has the right default directories for
+	 * the database type of this connector
+	 * @param shell
+	 * @param type
+	 * @param filterExtensions
+	 * @param filterNames
+	 * @return A file dialog with the default directories set
+	 */
+	protected FileDialog createFileDialog(Shell shell, int type, String[] filterExtensions, String[] filterNames) {
+		FileDialog fileDialog = new FileDialog(shell, type);
+		fileDialog.setText("Select database file");
+		
+		String filterPath = null;
+		switch(getDbType()) {
+		case TYPE_GDB: 
+			filterPath = SwtPreference.SWT_DIR_GDB.getValue();
+			break;
+		case TYPE_GEX:
+			filterPath = SwtPreference.SWT_DIR_EXPR.getValue();
+			break;
+		}
+		if(filterPath != null) fileDialog.setFilterPath(filterPath);
+		if(filterExtensions != null) fileDialog.setFilterExtensions(filterExtensions);
+		if(filterNames != null) fileDialog.setFilterNames(filterNames);
+		
+		return fileDialog;
+	}
+	
+	/**
+	 * Shortcut for creating a directory dialog that has the right default directories for
+	 * the database type of this connector
+	 * @param shell
+	 * @return A directory dialog with the default directories set
+	 */
+	protected DirectoryDialog createDirectoryDialog(Shell shell) {
+		DirectoryDialog dirDialog = new DirectoryDialog(shell, SWT.NONE);
+		dirDialog.setText("Select database file");
+		
+		String filterPath = null;
+		switch(getDbType()) {
+		case TYPE_GDB: 
+			filterPath = SwtPreference.SWT_DIR_GDB.getValue();
+			break;
+		case TYPE_GEX:
+			filterPath = SwtPreference.SWT_DIR_EXPR.getValue();
+			break;
+		}
+		if(filterPath != null) dirDialog.setFilterPath(filterPath);
+		
+		return dirDialog;
+	}
+}
