Index: trunk/src/v2/org/pathvisio/R/RController.java
===================================================================
--- trunk/src/v2/org/pathvisio/R/RController.java	(revision 960)
+++ trunk/src/v2/org/pathvisio/R/RController.java	(revision 961)
@@ -33,8 +33,8 @@
 import org.eclipse.jface.dialogs.MessageDialog;
 import org.eclipse.jface.dialogs.ProgressMonitorDialog;
 import org.eclipse.jface.operation.IRunnableWithProgress;
+import org.pathvisio.ApplicationEvent;
 import org.pathvisio.Engine;
-import org.pathvisio.Engine.ApplicationEvent;
 import org.pathvisio.Engine.ApplicationEventListener;
 import org.pathvisio.R.RCommands.RException;
 import org.pathvisio.gui.swt.SwtEngine;
Index: trunk/src/core/org/pathvisio/Engine.java
===================================================================
--- trunk/src/core/org/pathvisio/Engine.java	(revision 960)
+++ trunk/src/core/org/pathvisio/Engine.java	(revision 961)
@@ -1,264 +0,0 @@
-package org.pathvisio;
-
-import java.awt.Color;
-import java.io.File;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.EventObject;
-import java.util.HashMap;
-import java.util.List;
-
-import org.pathvisio.data.DBConnector;
-import org.pathvisio.debug.Logger;
-import org.pathvisio.model.ConverterException;
-import org.pathvisio.model.Pathway;
-import org.pathvisio.model.PathwayElement;
-import org.pathvisio.model.PathwayExporter;
-import org.pathvisio.model.PathwayImporter;
-import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
-import org.pathvisio.util.Utils;
-import org.pathvisio.view.VPathway;
-
-public class Engine {
-	private static Pathway pathway;
-	private static VPathway vPathway;
-		
-	public static final String SVG_FILE_EXTENSION = "svg";
-	public static final String SVG_FILTER_NAME = "Scalable Vector Graphics (*." + SVG_FILE_EXTENSION + ")";
-	public static final String PATHWAY_FILE_EXTENSION = "gpml";
-	public static final String PATHWAY_FILTER_NAME = "PathVisio Pathway (*." + PATHWAY_FILE_EXTENSION + ")";
-	public static final String GENMAPP_FILE_EXTENSION = "mapp";
-	public static final String GENMAPP_FILTER_NAME = "GenMAPP Pathway (*." + GENMAPP_FILE_EXTENSION + ")";
-	
-	/**
-	 * the transparent color used in the icons for visualization of protein/mrna data
-	 */
-	public static final Color TRANSPARENT_COLOR = new Color(255, 0, 255);
-	
-	public final static Logger log = new Logger();
-			
-	/**
-	 * Get the {@link URL} for the resource stored in a jar file in the classpath
-	 * @param name	the filename of the resource
-	 * @return the URL pointing to the resource
-	 */
-	public static URL getResourceURL(String name) {
-		URL url = Engine.class.getClassLoader().getResource(name);
-		if(url == null) log.error("Couldn't load resource '" + name + "'");
-		return url;
-	}
-	
-	/**
-	 * Gets the currently open drawing
-	 */
-	public static VPathway getActiveVPathway() {
-		return vPathway;
-	}
-
-	/**
-	 * Sets the currently active Pathway and its VPathway 
-	 * (Used by SwtEngine, will be removed after finishing Graphics2D transision)
-	 * @param vpw
-	 */
-	@Deprecated
-	public static void setActiveVPathway(Pathway pw, VPathway vpw) {
-		pathway = pw;
-		vPathway = vpw;
-	}
-	
-	/**
-	 * Returns the currently open Pathway
-	 */
-	public static Pathway getActivePathway() {
-		return pathway;
-	}
-	
-	/**
-	 * application global clipboard.
-	 */
-	public static List<PathwayElement> clipboard = null;
-	
-	public static void importPathway(File file) throws ConverterException {
-		String fileName = file.toString();
-		
-		int dot = fileName.lastIndexOf('.');
-		String ext = Engine.PATHWAY_FILE_EXTENSION; //
-		if(dot >= 0) {
-			ext = fileName.substring(dot + 1, fileName.length());
-		}
-		PathwayImporter importer = getPathwayImporter(ext);
-		
-		if(importer == null) throw new ConverterException( "No importer for '" + ext +  "' files" );
-		
-		Pathway _pathway = new Pathway();
-		importer.doImport(file, _pathway);
-		pathway = _pathway;
-		fireApplicationEvent(new ApplicationEvent(pathway, ApplicationEvent.PATHWAY_OPENED));
-	}
-	
-	public static void openPathway(String fileName) throws ConverterException {
-		openPathway(new File(fileName));
-	}
-	
-	/**
-	 * Open a pathway from a gpml file
-	 */
-	public static void openPathway(File pathwayFile) throws ConverterException
-	{
-		Pathway _pathway = null;		
-		String pwf = pathwayFile.toString();
-		
-		// initialize new JDOM gpml representation and read the file
-		_pathway = new Pathway();
-		if (pwf.endsWith(".mapp"))
-		{
-			_pathway.readFromMapp(new File(pwf));
-		}
-		else
-		{
-			_pathway.readFromXml(new File(pwf), true);
-		}
-		if(_pathway != null) //Only continue if the data is correctly loaded
-		{
-			pathway = _pathway;
-			fireApplicationEvent(new ApplicationEvent(pathway, ApplicationEvent.PATHWAY_OPENED));
-		}
-		
-	}
-	
-	public static void savePathway() throws ConverterException {
-		savePathway(pathway.getSourceFile());
-	}
-	
-	public static void savePathway(File toFile) throws ConverterException {
-		pathway.writeToXml(toFile, true);
-	}
-	
-	private static void createVPathway(Pathway p) {
-		vPathway.fromGmmlData(pathway);
-		fireApplicationEvent(new ApplicationEvent(vPathway, ApplicationEvent.VPATHWAY_CREATED));
-	}
-		
-	/**
-	 * Create a new pathway and view (Pathay and VPathway)
-	 */
-	public static void newPathway() {
-		pathway = new Pathway();
-		pathway.initMappInfo();
-		
-		fireApplicationEvent(new ApplicationEvent(vPathway, ApplicationEvent.PATHWAY_NEW));
-	}
-	
-	public static void newVPathway(Pathway pathway) {
-		vPathway.fromGmmlData(pathway);
-	}
-	
-	/**
-	 * Find out whether a drawing is currently open or not
-	 * @return true if a drawing is open, false if not
-	 */
-	public static boolean isDrawingOpen() { return vPathway != null; }
-
-
-	private static HashMap<String, PathwayExporter> exporters = new HashMap<String, PathwayExporter>();
-	private static HashMap<String, PathwayImporter> importers = new HashMap<String, PathwayImporter>();
-	/**
-	 * Add a {@link PathwayExporter} that handles export of GPML to another file format
-	 * @param export
-	 */
-	public static void addPathwayExporter(PathwayExporter export) {
-		for(String ext : export.getExtensions()) {
-			exporters.put(ext, export);
-		}
-	}
-
-	/**
-	 * Add a {@link PathwayImporter} that handles imoprt of GPML to another file format
-	 * @param export
-	 */
-	public static void addPathwayImporter(PathwayImporter importer) {
-		for(String ext : importer.getExtensions()) {
-			importers.put(ext, importer);
-		}
-	}
-	
-	public static PathwayExporter getPathwayExporter(String ext) {
-		return exporters.get(ext);
-	}
-
-	public static PathwayImporter getPathwayImporter(String ext) {
-		return importers.get(ext);
-	}
-	
-	public static HashMap<String, PathwayExporter> getPathwayExporters() {
-		return exporters;
-	}
-		
-	public static HashMap<String, PathwayImporter> getPathwayImporters() {
-		return importers;
-	}
-	
-	public static DBConnector getDbConnector(int type) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
-		DBConnector connector = null;
-		String className = null;
-		switch(type) {
-		case DBConnector.TYPE_GDB:
-			className = SwtPreference.SWT_DB_ENGINE_GDB.getValue();
-			break;
-		case DBConnector.TYPE_GEX:
-			className = SwtPreference.SWT_DB_ENGINE_GDB.getValue();
-			break;
-		}
-		if(className == null) return null;
-		
-		Class dbc = Class.forName(className);
-		
-		if(Utils.isSubClass(dbc, DBConnector.class)) {
-			connector = (DBConnector)dbc.newInstance();
-			connector.setDbType(type);
-		}
-	
-		return connector;
-	}
-		
-	private static List<ApplicationEventListener> applicationEventListeners  = new ArrayList<ApplicationEventListener>();
-	
-	/**
-	 * Add an {@link ApplicationEventListener}, that will be notified if a
-	 * property changes that has an effect throughout the program (e.g. opening a pathway)
-	 * @param l The {@link ApplicationEventListener} to add
-	 */
-	public static void addApplicationEventListener(ApplicationEventListener l) {
-		applicationEventListeners.add(l);
-	}
-	
-	/**
-	 * Fire a {@link ApplicationEvent} to notify all {@link ApplicationEventListener}s registered
-	 * to this class
-	 * @param e
-	 */
-	public static void fireApplicationEvent(ApplicationEvent e) {
-		for(ApplicationEventListener l : applicationEventListeners) l.applicationEvent(e);
-	}
-	
-	public interface ApplicationEventListener {
-		public void applicationEvent(ApplicationEvent e);
-	}
-	
-	public static class ApplicationEvent extends EventObject {
-		private static final long serialVersionUID = 1L;
-		public static final int PATHWAY_OPENED = 1;
-		public static final int PATHWAY_NEW = 2;
-		public static final int APPLICATION_CLOSE = 3;
-		public static final int VPATHWAY_CREATED = 4;
-
-		public Object source;
-		public int type;
-		
-		public ApplicationEvent(Object source, int type) {
-			super(source);
-			this.source = source;
-			this.type = type;
-		}
-	}
-}
\ No newline at end of file
Index: trunk/src/core/org/pathvisio/gui/swt/SwtEngine.java
===================================================================
--- trunk/src/core/org/pathvisio/gui/swt/SwtEngine.java	(revision 960)
+++ trunk/src/core/org/pathvisio/gui/swt/SwtEngine.java	(revision 961)
@@ -1,443 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.gui.swt;
-
-import java.io.File;
-import java.lang.reflect.InvocationTargetException;
-import java.net.URL;
-import java.util.List;
-
-import org.eclipse.core.runtime.IProgressMonitor;
-import org.eclipse.jface.dialogs.IDialogConstants;
-import org.eclipse.jface.dialogs.MessageDialog;
-import org.eclipse.jface.dialogs.ProgressMonitorDialog;
-import org.eclipse.jface.resource.ImageRegistry;
-import org.eclipse.jface.window.ApplicationWindow;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.graphics.DeviceData;
-import org.eclipse.swt.widgets.Display;
-import org.eclipse.swt.widgets.FileDialog;
-import org.eclipse.swt.widgets.Shell;
-import org.pathvisio.Engine;
-import org.pathvisio.Globals;
-import org.pathvisio.Engine.ApplicationEvent;
-import org.pathvisio.debug.Sleak;
-import org.pathvisio.model.ConverterException;
-import org.pathvisio.model.Pathway;
-import org.pathvisio.model.PathwayElement;
-import org.pathvisio.preferences.PreferenceCollection;
-import org.pathvisio.preferences.swt.SwtPreferences;
-import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
-import org.pathvisio.util.SwtUtils.SimpleRunnableWithProgress;
-import org.pathvisio.view.VPathway;
-
-import edu.stanford.ejalbert.BrowserLauncher;
-import edu.stanford.ejalbert.exception.BrowserLaunchingExecutionException;
-import edu.stanford.ejalbert.exception.BrowserLaunchingInitializingException;
-import edu.stanford.ejalbert.exception.UnsupportedOperatingSystemException;
-
-/**
- This class contains the essential parts of the program: the window, drawing and gpml data
- It takes care of some basic Document handling facilities such as:
- - creating a new document
- - load / save / save as
- - asking if a changed file should be saved before closing
- */
-public class SwtEngine {
-	/**
-	 * {@link Pathway} object containing JDOM representation of the gpml pathway 
-	 * and handle gpml related actions
-	 */
-	
-	private static MainWindow window;
-	
-	private static ImageRegistry imageRegistry;
-	private static PreferenceCollection preferences;
-	
-	private static File DIR_APPLICATION;
-	private static File DIR_DATA;
-	static boolean USE_R;
-		
-	/**
-	 * application global clipboard.
-	 */
-	public static List<PathwayElement> clipboard = null;
-
-	/**
-	   Checks if the current pathway has changes, and if so, pops up a dialog
-	   offering to save.
-	   This should always be called before you change pathway
-
-	   @return returns false if the user pressed cancel. 
-	   
-	   TODO: Currently always asks, even if there were no changes since last save.
-	 */
-	static public boolean canDiscardPathway()
-	{
-		// checking not necessary if there is no pathway.
-		if (Engine.getActivePathway() == null) return true;
-		String[] opts =
-		{
-			IDialogConstants.YES_LABEL,
-			IDialogConstants.NO_LABEL,
-			IDialogConstants.CANCEL_LABEL
-		};
-		MessageDialog msgDlg = new MessageDialog (
-			window.getShell(),
-			"Save changes?",
-			null,
-			"Your pathway may have changed. Do you want to save?",
-			MessageDialog.QUESTION,
-			opts,
-			0);
-		int result = msgDlg.open();
-		if (result == 2) // cancel
-		{
-			return false;
-		}
-		else if (result == 0) // yes
-		{
-			// return false if save is cancelled.
-			return (savePathway());
-		}
-		// no
-		return true;
-	}
-	
-	public static void doOpenWebPage(String url) throws BrowserLaunchingInitializingException, BrowserLaunchingExecutionException, UnsupportedOperatingSystemException {
-		BrowserLauncher bl = new BrowserLauncher(null);
-		bl.openURLinBrowser(url);
-	}
-	
-	/**
-	 * Get the working directory of this application
-	 */
-	public static File getApplicationDir() {
-		if(DIR_APPLICATION == null) {
-			DIR_APPLICATION = new File(System.getProperty("user.home"), "." + Globals.APPLICATION_NAME);
-			if(!DIR_APPLICATION.exists()) DIR_APPLICATION.mkdir();
-		}
-		return DIR_APPLICATION;
-	}
-	
-	public static File getDataDir() {
-		if(DIR_DATA == null) {
-			DIR_DATA = new File(System.getProperty("user.home"), Globals.APPLICATION_NAME + "-Data");
-			if(!DIR_DATA.exists()) DIR_DATA.mkdir();
-		}
-		return DIR_DATA;
-	}
-		
-	/**
-	 * Get the {@link ImageRegistry} containing commonly used images
-	 */
-	public static ImageRegistry getImageRegistry() { 
-		if(imageRegistry == null) imageRegistry = new ImageRegistry();
-		return imageRegistry; 
-	}
-	
-	/**
-	 * Get the {@link SwtPreferences} containing the user preferences
-	 */
-	public static PreferenceCollection getPreferences() { 
-		if(preferences == null) preferences = new SwtPreferences();
-		return preferences; 
-	}
-	
-	/**
-	 * Get the {@link URL} for the resource stored in a jar file in the classpath
-	 * @param name	the filename of the resource
-	 * @return the URL pointing to the resource
-	 */
-	public static URL getResourceURL(String name) {
-		URL url = SwtEngine.class.getClassLoader().getResource(name);
-		if(url == null) Engine.log.error("Couldn't load resource '" + name + "'");
-		return url;
-	}
-		
-	/**
-	 * Initiates an instance of {@link MainWindow} that is monitored by Sleak.java,
-	 * to monitor what handles (to OS device context) are in use. For debug purposes only 
-	 * (to check for undisposed widgets)
-	 * @return The {@link MainWindow} monitored by Sleak.java
-	 */
-	public static MainWindow getSleakWindow() {
-		//<DEBUG to find undisposed system resources>
-		DeviceData data = new DeviceData();
-		data.tracking = true;
-		Display display = new Display(data);
-		Sleak sleak = new Sleak();
-		sleak.open();
-		
-		Shell shell = new Shell(display);
-		window = new MainWindow(shell);
-		return window;
-		//</DEBUG>
-	}
-	
-	/**
-	 * Get the {@link ApplicationWindow}, the UI of the program
-	 */
-	public static MainWindow getWindow() {
-		if(window == null) window = new MainWindow();
-		return window;
-	}
-	
-	public static boolean isUseR() { return USE_R; }
-
-	/**
-	 Create a new pathway (drawing + gpml data)
-	 Asks to discard an existing pathway
-	 */
-	public static void newPathway()
-	{
-		if (canDiscardPathway())
-		{
-			Pathway pathway = new Pathway();
-			pathway.initMappInfo();
-			VPathway vPathway = getWindow().createNewDrawing();
-			vPathway.fromGmmlData(pathway);
-			Engine.setActiveVPathway(pathway, vPathway);
-			Engine.fireApplicationEvent(new ApplicationEvent(vPathway, ApplicationEvent.PATHWAY_OPENED));
-			updateTitle();
-		}
-	}
-
-	/**
-	 Open a pathway from a gpml file
-	 Asks the user if the old pathway should be discarded, if necessary
-	 */
-	public static void openPathway(String pwf)
-	{
-		if (canDiscardPathway())
-		{
-			Pathway _gmmlData = null;
-			VPathway _drawing = getWindow().createNewDrawing();
-			
-			// initialize new JDOM gpml representation and read the file
-			try { 
-				Engine.openPathway(pwf);
-			} catch(ConverterException e) {		
-				if (e.getMessage().contains("Cannot find the declaration of element 'Pathway'"))
-				{
-					MessageDialog.openError(getWindow().getShell(), 
-						"Unable to open Gpml file", 
-						"Unable to open Gpml file.\n\n" +
-						"The most likely cause for this error is that you are trying to open an old Gpml file. " +
-						"Please note that the Gpml format has changed as of March 2007. " +
-						"The standard pathway set can be re-downloaded from http://pathvisio.org " +
-						"Non-standard pathways need to be recreated or upgraded. " +
-						"Please contact the authors at martijn.vaniersel@bigcat.unimaas.nl if you need help with this.\n" +
-						"\nSee error log for details");
-					Engine.log.error("Unable to open Gpml file", e);
-				}
-				else
-				{
-					MessageDialog.openError(getWindow().getShell(), 
-											"Unable to open Gpml file", e.getClass() + e.getMessage());
-					Engine.log.error("Unable to open Gpml file", e);
-				}
-			}
-			
-			if(_gmmlData != null) //Only continue if the data is correctly loaded
-			{
-				_drawing.fromGmmlData(_gmmlData);
-				Engine.setActiveVPathway(_gmmlData, _drawing);
-				updateTitle();
-				Engine.fireApplicationEvent(new ApplicationEvent(_drawing, ApplicationEvent.PATHWAY_OPENED));
-			}
-		}
-	}
-	
-	/**
-	   Opens a URL in the default webbrowser.  Uses a progress dialog
-	   if it takes a long time.  Shows an error message and returns
-	   false if it somehow failed to open the web page.
-	*/
-	public static boolean openWebPage(String url, String progressMsg, String errMsg) {
-		Shell shell = getWindow().getShell();
-		if(shell == null || shell.isDisposed()) return false;
-		
-		SimpleRunnableWithProgress rwp = new SimpleRunnableWithProgress(
-				Engine.class, "doOpenWebPage", new Class[] { String.class }, new Object[] { url }, null);
-		SimpleRunnableWithProgress.setMonitorInfo(progressMsg, IProgressMonitor.UNKNOWN);
-		ProgressMonitorDialog dialog = new ProgressMonitorDialog(shell);
-		try {
-			dialog.run(true, true, rwp);
-			return true;
-		} catch (InvocationTargetException e) {
-			Throwable cause = e.getCause();
-			String msg = cause == null ? null : cause.getMessage();
-			MessageDialog.openError(shell, "Error",
-			"Unable to open web browser" +
-			(msg == null ? "" : ": " + msg) +
-			"\n" + errMsg);
-			return false;
-		} catch (InterruptedException ignore) { return false; }
-	}
-	
-	/**
-	   save the current pathway
-	   returns false if the action was cancelled by the user
-	   
-	   Calls savePathwayAs if the filename of the current pathway is unknown,
-	   so that the user can set a location for this pathway
-	*/
-		public static boolean savePathway()
-		{
-			Pathway pathway = Engine.getActivePathway();
-			VPathway vPathway = Engine.getActiveVPathway();
-			
-			boolean result = true;
-			
-			double usedZoom = vPathway.getPctZoom();
-			// Set zoom to 100%
-			vPathway.setPctZoom(100);			
-			
-	        // Overwrite the existing xml file.
-			// If the target file is read-only, let the user select a new pathway
-			if (pathway.getSourceFile() != null && pathway.getSourceFile().canWrite())
-			{
-				try
-				{
-					Engine.savePathway();
-				}
-				catch (ConverterException e)
-				{
-					String msg = "While writing xml to " 
-						+ pathway.getSourceFile().getAbsolutePath();					
-					MessageDialog.openError (window.getShell(), "Error", 
-											 "Error: " + msg + "\n\n" + 
-											 "See the error log for details.");
-					Engine.log.error(msg, e);
-				}
-			}
-			else
-			{
-				result = savePathwayAs();
-			}
-			// Set zoom back
-			vPathway.setPctZoom(usedZoom);
-
-			return result;
-		}
-		
-	/**
-	   Opens a file dialog and lets user select a file.
-	   Then the pathways is saved to that file.
-	   returns false if the action was cancelled by the user
-	 */
-	public static boolean savePathwayAs()
-	{
-		Pathway pathway = Engine.getActivePathway();
-		VPathway vPathway = Engine.getActiveVPathway();
-		
-		// Check if a gpml pathway is loaded
-		if (pathway != null)
-		{
-			FileDialog fd = new FileDialog(window.getShell(), SWT.SAVE);
-			fd.setText("Save");
-			fd.setFilterExtensions(new String[] {"*." + Engine.PATHWAY_FILE_EXTENSION, "*.*"});
-			fd.setFilterNames(new String[] {Engine.PATHWAY_FILTER_NAME, "All files (*.*)"});
-			
-			File xmlFile = pathway.getSourceFile();
-			if(xmlFile != null) {
-				fd.setFileName(xmlFile.getName());
-				fd.setFilterPath(xmlFile.getPath());
-			} else {
-					fd.setFilterPath(SwtPreference.SWT_DIR_PWFILES.getValue());
-			}
-			String fileName = fd.open();
-			// Only proceed if user selected a file
-			
-			if(fileName == null) return false;
-			
-			// Append .gpml extension if not already present
-			if(!fileName.endsWith("." + Engine.PATHWAY_FILE_EXTENSION)) 
-				fileName += "." + Engine.PATHWAY_FILE_EXTENSION;
-			
-			File checkFile = new File(fileName);
-			boolean confirmed = true;
-			// If file exists, ask overwrite permission
-			if(checkFile.exists())
-			{
-				confirmed = MessageDialog.openQuestion(window.getShell(),"",
-													   "File already exists, overwrite?");
-			}
-			if(confirmed)
-			{
-				double usedZoom = vPathway.getPctZoom();
-				// Set zoom to 100%
-				vPathway.setPctZoom(100);					
-				// Overwrite the existing xml file
-				try
-				{
-					Engine.savePathway(checkFile);
-					updateTitle();
-					// Set zoom back
-					vPathway.setPctZoom(usedZoom);
-				}
-				catch (ConverterException e)
-				{
-					String msg = "While writing xml to " 
-						+ checkFile.getAbsolutePath();					
-					MessageDialog.openError (window.getShell(), "Error", 
-											 "Error: " + msg + "\n\n" + 
-											 "See the error log for details.");
-					Engine.log.error(msg, e);
-				}
-			}
-		}
-		else
-		{
-			MessageDialog.openError (window.getShell(), "Error", 
-									 "No gpml file loaded! Open or create a new gpml file first");
-		}			
-		return true;
-	}
-	
-	/**
-	 * Set the {@link ImageRegistry} containing commonly used images
-	 */
-	public static void setImageRegistry(ImageRegistry _imageRegistry) {
-		imageRegistry = _imageRegistry;
-	}
-	
-	/**
-	   Updates the title of the main window.
-	   Call at initialization of the program,
-	   whenever the filename of the current document has changed,
-	   or the change status has changed.
-	*/
-	public static void updateTitle()
-	{
-		if (Engine.getActivePathway() == null)
-		{
-			window.getShell().setText(Globals.APPLICATION_VERSION_NAME);
-		}
-		else
-		{
-			// get filename, or (New Pathway) if current pathway hasn't been opened yet
-			String fname = (Engine.getActivePathway().getSourceFile() == null) ? "(New Pathway)" :
-				Engine.getActivePathway().getSourceFile().getName();
-			window.getShell().setText(
-				"*" + fname + " - " +
-				Globals.APPLICATION_VERSION_NAME
-				);
-		}
-	}
-}
\ No newline at end of file
Index: trunk/src/core/org/pathvisio/gui/swt/MainWindowBase.java
===================================================================
--- trunk/src/core/org/pathvisio/gui/swt/MainWindowBase.java	(revision 960)
+++ trunk/src/core/org/pathvisio/gui/swt/MainWindowBase.java	(revision 961)
@@ -1,438 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.gui.swt;
-
-import org.eclipse.jface.action.Action;
-import org.eclipse.jface.action.ActionContributionItem;
-import org.eclipse.jface.action.ControlContribution;
-import org.eclipse.jface.action.IAction;
-import org.eclipse.jface.action.IContributionItem;
-import org.eclipse.jface.action.MenuManager;
-import org.eclipse.jface.action.ToolBarContributionItem;
-import org.eclipse.jface.action.ToolBarManager;
-import org.eclipse.jface.dialogs.MessageDialog;
-import org.eclipse.jface.dialogs.ProgressMonitorDialog;
-import org.eclipse.jface.window.ApplicationWindow;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.custom.SashForm;
-import org.eclipse.swt.custom.ScrolledComposite;
-import org.eclipse.swt.events.SelectionAdapter;
-import org.eclipse.swt.events.SelectionEvent;
-import org.eclipse.swt.widgets.Combo;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Control;
-import org.eclipse.swt.widgets.Shell;
-import org.pathvisio.Engine;
-import org.pathvisio.Engine.ApplicationEvent;
-import org.pathvisio.Engine.ApplicationEventListener;
-import org.pathvisio.data.DBConnector;
-import org.pathvisio.data.Gdb;
-import org.pathvisio.data.Gex;
-import org.pathvisio.data.Gex.ExpressionDataEvent;
-import org.pathvisio.data.Gex.ExpressionDataListener;
-import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
-import org.pathvisio.search.PathwaySearchComposite;
-import org.pathvisio.view.GeneProduct;
-import org.pathvisio.view.VPathway;
-import org.pathvisio.view.VPathwayEvent;
-import org.pathvisio.view.VPathwayListener;
-import org.pathvisio.visualization.LegendPanel;
-
-/**
- * MainWindowBase is an abstract and incomplete Main Window that contains some
- * core functionality. This way we can create different flavours of the main window
- * without having too much duplicate code. Descendants should at least provide
- * a constructor, and override createCoolBarManager and createMenuManager.
- */
-public abstract class MainWindowBase extends ApplicationWindow implements 
-	ApplicationEventListener, ExpressionDataListener, VPathwayListener
-{
-	private static final long serialVersionUID = 1L;
-	static int ZOOM_TO_FIT = -1;
-		
-	protected CommonActions.UndoAction undoAction = new CommonActions.UndoAction(this);	
-	protected CommonActions.NewAction newAction = new CommonActions.NewAction (this);
-	protected CommonActions.OpenAction openAction = new CommonActions.OpenAction (this);	
-	protected CommonActions.ImportAction importAction = new CommonActions.ImportAction (this);	
-	protected CommonActions.SaveAction saveAction = new CommonActions.SaveAction(this);	
-	protected CommonActions.SaveAsAction saveAsAction = new CommonActions.SaveAsAction (this);
-	protected CommonActions.ExportAction exportAction = new CommonActions.ExportAction (this);
-	protected CommonActions.ExitAction exitAction = new CommonActions.ExitAction(this);
-	protected CommonActions.PreferencesAction preferencesAction = new CommonActions.PreferencesAction(this);
-	protected CommonActions.AboutAction aboutAction = new CommonActions.AboutAction(this);
-	protected CommonActions.CopyAction copyAction = new CommonActions.CopyAction(this);
-	protected CommonActions.HelpAction helpAction = new CommonActions.HelpAction(this);	
-	protected CommonActions.PasteAction pasteAction = new CommonActions.PasteAction(this);
-	protected CommonActions.SwitchEditModeAction switchEditModeAction = new CommonActions.SwitchEditModeAction(this);
-	public ShowRightPanelAction showRightPanelAction = new ShowRightPanelAction(this);
-	protected SelectGdbAction selectGdbAction = new SelectGdbAction(this);
-	protected AlignActions.AlignCenterXAction alignCenterXAction = new AlignActions.AlignCenterXAction(this);
-	protected AlignActions.AlignCenterYAction alignCenterYAction = new AlignActions.AlignCenterYAction(this);
-	protected AlignActions.AlignLeftAction alignLeftAction = new AlignActions.AlignLeftAction(this);
-	protected AlignActions.AlignRightAction alignRightAction = new AlignActions.AlignRightAction(this);
-	protected AlignActions.AlignTopAction alignTopAction = new AlignActions.AlignTopAction(this);
-	protected AlignActions.AlignBottomAction alignBottomAction = new AlignActions.AlignBottomAction(this);
-	protected AlignActions.SetCommonWidthAction setCommonWidthAction = new AlignActions.SetCommonWidthAction(this);
-	protected AlignActions.SetCommonHeightAction setCommonHeightAction = new AlignActions.SetCommonHeightAction(this);
-
-	/**
-	 * {@link Action} to select a Gene Database
-	 */
-	private class SelectGdbAction extends Action
-	{
-		MainWindowBase window;
-		public SelectGdbAction(MainWindowBase w)
-		{
-			window = w;
-			setText("Select &Gene Database");
-			setToolTipText("Select Gene Database");
-		}
-		
-		public void run () {			
-			try {
-				DBConnector dbcon = Gdb.getDBConnector();
-				String dbName = dbcon.openChooseDbDialog(getShell());
-				
-				if(dbName == null) return;
-				
-				Gdb.connect(dbName);
-				setStatus("Using Gene Database: '" + SwtPreference.SWT_CURR_GDB + "'");
-				cacheExpressionData();
-			} catch(Exception e) {
-				String msg = "Failed to open Gene Database; " + e.getMessage();
-				MessageDialog.openError (window.getShell(), "Error", 
-						"Error: " + msg + "\n\n" + 
-						"See the error log for details.");
-				Engine.log.error(msg, e);
-			}
-		}
-	}
-
-	/**
-	 * deselect all buttons in the alignActionsCI coolbar
-	 */
-	public void deselectAlignItemActions()
-	{
-		IContributionItem[] items = alignActionsCI.getToolBarManager().getItems();
-		for(int i = 0; i < items.length; i++)
-		{
-			if(items[i] instanceof ActionContributionItem)
-			{
-				((ActionContributionItem)items[i]).getAction().setChecked(false);
-			}
-		}
-		Engine.getActiveVPathway().setNewGraphics(VPathway.NEWNONE);
-	}
-	
-	/**
-	 * {@link Action} to show or hide the right sidepanel
-	 */
-	public class ShowRightPanelAction extends Action
-	{
-		MainWindowBase window;
-		public ShowRightPanelAction (MainWindowBase w)
-		{
-			super("Show &information panel", IAction.AS_CHECK_BOX);
-			window = w;
-			setChecked(true);
-		}
-		
-		public void run() {
-			if(isChecked()) rightPanel.show();
-			else rightPanel.hide();
-		}
-	}
-
-	/**
-	 * Loads expression data for all {@link GeneProduct}s in the loaded pathway
-	 */
-	private void cacheExpressionData()
-	{
-		if(Engine.isDrawingOpen())
-		{
-			VPathway drawing = Engine.getActiveVPathway();
-			//Check for neccesary connections
-			if(Gex.isConnected() && Gdb.isConnected())
-			{
-				ProgressMonitorDialog dialog = new ProgressMonitorDialog(getShell());
-				try {
-					dialog.run(true, true, Gex.createCacheRunnable(drawing.getMappIds(), drawing.getSystemCodes()));
-					drawing.redraw();
-				} catch(Exception e) {
-					String msg = "while caching expression data: " + e.getMessage();					
-					MessageDialog.openError (getShell(), "Error", 
-							"Error: " + msg + "\n\n" + 
-							"See the error log for details.");
-					Engine.log.error(msg, e);
-				}
-			}
-		}
-	}
-
-	/**
-	 * Deselects all {@link NewElementAction}s on the toolbar and sets 
-	 * {@link VPathway}.newGraphics to {@link VPathway}.NEWNONE
-	 */
-	public void deselectNewItemActions()
-	{
-		IContributionItem[] items = editActionsCI.getToolBarManager().getItems();
-		for(int i = 0; i < items.length; i++)
-		{
-			if(items[i] instanceof ActionContributionItem)
-			{
-				((ActionContributionItem)items[i]).getAction().setChecked(false);
-			}
-		}
-		Engine.getActiveVPathway().setNewGraphics(VPathway.NEWNONE);
-	}
-
-	// Elements of the coolbar
-	ToolBarContributionItem commonActionsCI;
-	ToolBarContributionItem editActionsCI;
-	ToolBarContributionItem alignActionsCI;
-	ToolBarContributionItem viewActionsCI;
-	
-	/**
-	 * Creates element of the coolbar containing common actions as new, save etc.
-	 */
-	protected void createCommonActionsCI()
-	{
-		ToolBarManager toolBarManager = new ToolBarManager(SWT.FLAT);
-		toolBarManager.add(newAction);
-		toolBarManager.add(openAction);
-		toolBarManager.add(saveAction);
-		commonActionsCI = new ToolBarContributionItem(toolBarManager, "CommonActions");
-	}
-
-	/**
-	 * Creates element of the coolbar only shown in edit mode (new element actions)
-	 */
-	protected void createEditActionsCI()
-	{
-		ToolBarManager toolBarManager = new ToolBarManager(SWT.FLAT);		
-		toolBarManager.add(new NewElementAction(VPathway.NEWGENEPRODUCT));
-		toolBarManager.add(new NewElementAction(VPathway.NEWLABEL));
-		toolBarManager.add(new NewElementAction(VPathway.NEWLINEMENU));
-		toolBarManager.add(new NewElementAction(VPathway.NEWRECTANGLE));
-		toolBarManager.add(new NewElementAction(VPathway.NEWOVAL));
-		toolBarManager.add(new NewElementAction(VPathway.NEWARC));
-		toolBarManager.add(new NewElementAction(VPathway.NEWBRACE));
-		toolBarManager.add(new NewElementAction(VPathway.NEWTBAR));
-		toolBarManager.add(new NewElementAction(VPathway.NEWLINESHAPEMENU));
-
-		editActionsCI = new ToolBarContributionItem(toolBarManager, "EditModeActions");
-	}
-	
-	/**
-	 * Creates element of the coolbar containing controls related to viewing a pathway
-	 */
-	protected void createViewActionsCI()
-	{
-		final MainWindowBase window = this;
-		ToolBarManager toolBarManager = new ToolBarManager(SWT.FLAT);
-		//Add zoomCombo
-		toolBarManager.add(new ControlContribution("ZoomCombo") {
-			protected Control createControl(Composite parent) {
-				final Combo zoomCombo = new Combo(parent, SWT.DROP_DOWN);
-				zoomCombo.setItems(new String[] { "200%", "100%", "75%", "50%", "Zoom to fit" });
-				zoomCombo.setText("100%");
-				zoomCombo.addSelectionListener(new SelectionAdapter() {
-					public void widgetSelected(SelectionEvent e) {
-						int pctZoom = 100;
-						String zoomText = zoomCombo.getText().replace("%", "");
-						try {
-							pctZoom = Integer.parseInt(zoomText);
-						} catch (Exception ex) { 
-							if(zoomText.equals("Zoom to fit"))
-									{ pctZoom = ZOOM_TO_FIT; } else { return; }
-						}
-						new CommonActions.ZoomAction(window, pctZoom).run();
-					}
-					public void widgetDefaultSelected(SelectionEvent e) { widgetSelected(e); }
-				});
-				return zoomCombo;
-			}
-		});
-		//Add swich to editmode
-		toolBarManager.add(switchEditModeAction);
-		
-		viewActionsCI =  new ToolBarContributionItem(toolBarManager, "SwitchActions");
-	}
-		
-	/**
-	 * Shows or hides the editActionsCI
-	 * @param show	true/false for either show or hide
-	 */
-	public void showEditActionsCI(boolean show)
-	{
-		if(show) {
-			getCoolBarManager().insertAfter(viewActionsCI.getId(), editActionsCI);
-		}
-		else {
-			getCoolBarManager().remove(editActionsCI);
-		}
-//		showVisualizationCI(!show); //Visualizations can show up in edit mode...
-		getCoolBarManager().update(true);
-	}
-
-	/**
-	   Shows or hides the alignActionsCI.
-	   @param show	true/false for either show or hide
-	*/
-	public void showAlignActionsCI(boolean show)
-	{
-		if(show) {
-			getCoolBarManager().insertAfter(editActionsCI.getId(), alignActionsCI);
-		}
-		else {
-			getCoolBarManager().remove(alignActionsCI);
-		}
-//		showVisualizationCI(!show); //Visualizations can show up in edit mode...
-		getCoolBarManager().update(true);
-	}
-	
-	//	KH 20070514 begin
-	/**
-	 * set up the alignActions coolbar
-	 */
-	protected void createAlignActionsCI()
-	{
-		ToolBarManager toolBarManager = new ToolBarManager(SWT.FLAT);
-		toolBarManager.add(alignCenterXAction);
-		toolBarManager.add(alignCenterYAction);
-		toolBarManager.add(alignLeftAction);
-		toolBarManager.add(alignRightAction);
-		toolBarManager.add(alignTopAction);
-		toolBarManager.add(alignBottomAction);
-		toolBarManager.add(setCommonWidthAction);
-		toolBarManager.add(setCommonHeightAction);
-	
-		alignActionsCI = new ToolBarContributionItem(toolBarManager, "AlignActions");
-	}
-	
-//	KH end
-	/**
-	   Invoked when user tries to close window.
-	   We'll ask the user if he wants to save the pathway
-	*/
-	protected boolean canHandleShellCloseEvent()
-	{
-		return SwtEngine.canDiscardPathway();
-	}
-	
-	protected MenuManager menuManager = null;
-	/**
-	 * can be accessed by plugins etc. 
-	 * to add menu items and even complete menus.
-	 * 
-	 * (plugin API)
-	 */
-	public MenuManager getMenuManager()
-	{
-		return menuManager;
-	}
-		
-	public boolean close() {
-		Engine.fireApplicationEvent(
-				new ApplicationEvent(this, ApplicationEvent.APPLICATION_CLOSE));
-		return super.close();
-	}
-	
-	public ScrolledComposite sc;
-	public BackpagePanel bpBrowser; //Browser for showing backpage information
-	public PropertyPanel propertyTable;	//Table showing properties of Graphics objects
-	SashForm sashForm; //SashForm containing the drawing area and sidebar
-	TabbedSidePanel rightPanel; //side panel containing backbage browser and property editor
-	PathwaySearchComposite pwSearchComposite; //Composite that handles pathway searches and displays results
-	LegendPanel legend; //Legend to display colorset information
-	
-	public TabbedSidePanel getSidePanel() { return rightPanel; }
-	
-	public LegendPanel getLegend() { return legend; }
-	
-	public void showLegend(boolean show) {	
-		if(show && Gex.isConnected()) {
-			if(rightPanel.isVisible("Legend")) return; //Legend already visible, only refresh
-			rightPanel.unhideTab("Legend", 0);
-			rightPanel.selectTab("Legend");
-		}
-		
-		else rightPanel.hideTab("Legend");
-	}
-	
-	/**
-	 * Creates a new empty drawing canvas
-	 * @return the empty {@link VPathway}
-	 */
-	public VPathway createNewDrawing()
-	{		
-		return new VPathway(sc, SWT.NO_BACKGROUND);
-	}
-				
-	public void applicationEvent(ApplicationEvent e) {
-		switch(e.type) {
-		case ApplicationEvent.PATHWAY_OPENED:
-			if(Gex.isConnected()) cacheExpressionData();
-			break;
-		}
-		switch(e.type) {
-		case ApplicationEvent.PATHWAY_NEW:
-		case ApplicationEvent.PATHWAY_OPENED:
-			Engine.getActiveVPathway().addVPathwayListener(this);
-		}
-	}
-
-	public void expressionDataEvent(ExpressionDataEvent e) {
-		switch(e.type) {
-		case ExpressionDataEvent.CONNECTION_CLOSED:
-			getShell().getDisplay().syncExec(new Runnable() {
-				public void run() {
-					showLegend(false);
-				}
-			});
-			break;
-		case ExpressionDataEvent.CONNECTION_OPENED:
-			getShell().getDisplay().syncExec(new Runnable() {
-				public void run() {
-					cacheExpressionData();
-					showLegend(true);
-				}
-			});
-			break;
-		}
-	}
-	
-	public void vPathwayEvent(VPathwayEvent e) {
-		switch(e.getType()) {
-		case VPathwayEvent.EDIT_MODE_OFF:
-			showLegend(true);
-			break;
-		case VPathwayEvent.EDIT_MODE_ON:
-			showLegend(false);
-			break;
-		case VPathwayEvent.NEW_ELEMENT_ADDED:
-			deselectNewItemActions();
-			break;
-		}
-	}
-	
-	public MainWindowBase(Shell shell)
-	{
-		super(shell);
-	}
-
-}
Index: trunk/src/core/org/pathvisio/gui/swt/CommonActions.java
===================================================================
--- trunk/src/core/org/pathvisio/gui/swt/CommonActions.java	(revision 960)
+++ trunk/src/core/org/pathvisio/gui/swt/CommonActions.java	(revision 961)
@@ -29,9 +29,9 @@
 import org.eclipse.jface.resource.ImageDescriptor;
 import org.eclipse.swt.SWT;
 import org.eclipse.swt.widgets.FileDialog;
+import org.pathvisio.ApplicationEvent;
 import org.pathvisio.Engine;
 import org.pathvisio.Globals;
-import org.pathvisio.Engine.ApplicationEvent;
 import org.pathvisio.Engine.ApplicationEventListener;
 import org.pathvisio.biopax.gui.BiopaxDialog;
 import org.pathvisio.model.ConverterException;
@@ -614,10 +614,10 @@
 		}
 
 		public void applicationEvent(ApplicationEvent e) {
-			if(e.type == ApplicationEvent.PATHWAY_OPENED) {
+			if(e.type == ApplicationEvent.VPATHWAY_OPENED) {
 				Engine.getActiveVPathway().setEditMode(isChecked());
 			}
-			else if(e.type == ApplicationEvent.PATHWAY_NEW) {
+			else if(e.type == ApplicationEvent.VPATHWAY_NEW) {
 				switchEditMode(true);
 			}
 		}
Index: trunk/src/core/org/pathvisio/search/SearchResultTable.java
===================================================================
--- trunk/src/core/org/pathvisio/search/SearchResultTable.java	(revision 960)
+++ trunk/src/core/org/pathvisio/search/SearchResultTable.java	(revision 961)
@@ -28,8 +28,8 @@
 import org.eclipse.swt.widgets.Button;
 import org.eclipse.swt.widgets.Composite;
 import org.eclipse.swt.widgets.Label;
+import org.pathvisio.ApplicationEvent;
 import org.pathvisio.Engine;
-import org.pathvisio.Engine.ApplicationEvent;
 import org.pathvisio.Engine.ApplicationEventListener;
 import org.pathvisio.util.tableviewer.PathwayTable;
 import org.pathvisio.util.tableviewer.TableData.Row;
Index: trunk/src/core/org/pathvisio/data/Gex.java
===================================================================
--- trunk/src/core/org/pathvisio/data/Gex.java	(revision 960)
+++ trunk/src/core/org/pathvisio/data/Gex.java	(revision 961)
@@ -48,8 +48,8 @@
 import org.jdom.input.SAXBuilder;
 import org.jdom.output.Format;
 import org.jdom.output.XMLOutputter;
+import org.pathvisio.ApplicationEvent;
 import org.pathvisio.Engine;
-import org.pathvisio.Engine.ApplicationEvent;
 import org.pathvisio.Engine.ApplicationEventListener;
 import org.pathvisio.data.CachedData.Data;
 import org.pathvisio.data.Gdb.IdCodePair;
Index: trunk/src/core/org/pathvisio/view/VPoint.java
===================================================================
--- trunk/src/core/org/pathvisio/view/VPoint.java	(revision 960)
+++ trunk/src/core/org/pathvisio/view/VPoint.java	(revision 961)
@@ -1,147 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.view;
-
-import java.awt.Shape;
-import java.util.HashSet;
-import java.util.Set;
-
-import org.eclipse.swt.events.PaintEvent;
-import org.eclipse.swt.graphics.GC;
-import org.pathvisio.model.PathwayElement.MPoint;
-
-public class VPoint extends VPathwayElement {
-	Handle handle;
-	Set<Line> lines;
-	Set<MPoint> mPoints;
-	
-	VPoint(VPathway canvas) {
-		super(canvas);
-		mPoints = new HashSet<MPoint>();
-		lines = new HashSet<Line>();
-		handle = new Handle(Handle.DIRECTION_FREE, this, canvas);
-	}
-	
-	public int getDrawingOrder() {
-		return VPathway.DRAW_ORDER_LINE;
-	}
-	
-	protected void addMPoint(MPoint p) {
-		mPoints.add(p);
-	}
-	
-	protected void removeMPoint(MPoint p) {
-		mPoints.remove(p);
-	}
-	
-	protected void addLine(Line l) {
-		lines.add(l);
-	}
-	
-	protected void removeLine(Line l) {
-		lines.remove(l);
-		//Remove this VPoint when it links to no lines no more
-		if(lines.size() == 0) {
-			destroy();
-		}
-	}
-	
-	protected Set<Line> getLines() { return lines; }
-	
-	protected void link(Graphics g) {
-		if(lines.contains(g)) return; //Prevent linking to self
-		String id = g.getGmmlData().getGraphId();
-		if(id == null) id = g.getGmmlData().setGeneratedGraphId();
-		for(MPoint p : mPoints) p.setGraphRef(id);
-	}
-	
-	protected void link(VPoint p) {
-		if(p == this) return; //Already linked
-		for(MPoint mp : p.mPoints) {
-			mPoints.add(mp);
-		}
-		for(Line l : p.lines) {
-			l.swapPoint(p, this);
-			addLine(l);
-		}
-		p.lines.clear();
-		p.destroy();
-	}
-	
-	protected double getVX() { return vFromM(getMPoint().getX()); }
-	protected double getVY() { return vFromM(getMPoint().getY()); }
-	
-	protected void setVLocation(double vx, double vy) {
-		for(MPoint p : mPoints) {
-			p.setX(mFromV(vx));
-			p.setY(mFromV(vy));
-		}
-	}
-	
-	protected void vMoveBy(double dx, double dy) {
-		for(MPoint p : mPoints) {
-			p.moveBy(mFromV(dx), mFromV(dy));
-		}
-	}
-	
-	protected void setHandleLocation() {
-		MPoint mp = getMPoint();
-		handle.setMLocation(mp.getX(), mp.getY());
-	}
-	
-	private MPoint getMPoint() {
-		for(MPoint p : mPoints) return p;
-		return null;
-	}
-	
-	protected void adjustToHandle(Handle h) {
-		double mcx = h.mCenterx;
-		double mcy = h.mCentery;
-		for(MPoint p : mPoints) {
-			p.setX(mcx);
-			p.setY(mcy);
-		}
-	}
-	
-	protected Handle getHandle() {
-		return handle;
-	}
-	
-	protected Handle[] getHandles() {
-		return new Handle[] { handle };
-	}
-	
-	protected void draw(PaintEvent e) {
-		// TODO Auto-generated method stub
-	}
-
-	public void draw(PaintEvent e, GC buffer) {
-		// TODO Auto-generated method stub
-	}
-
-	protected Shape getVOutline() {
-		return handle.getVOutline();
-	}
-
-	protected void destroy() {
-		//Check if we can legally destroy this point
-		if(lines.size() > 0) 
-			throw new RuntimeException("VPoint cannot be destroyed: still linked to " + lines);
-
-		super.destroy();
-	}
-}
Index: trunk/src/g2d_swt/org/pathvisio/visualization/VisualizationManager.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/visualization/VisualizationManager.java	(revision 960)
+++ trunk/src/g2d_swt/org/pathvisio/visualization/VisualizationManager.java	(revision 961)
@@ -43,8 +43,8 @@
 import org.jdom.input.SAXBuilder;
 import org.jdom.output.Format;
 import org.jdom.output.XMLOutputter;
+import org.pathvisio.ApplicationEvent;
 import org.pathvisio.Engine;
-import org.pathvisio.Engine.ApplicationEvent;
 import org.pathvisio.Engine.ApplicationEventListener;
 import org.pathvisio.data.Gex;
 import org.pathvisio.data.Gex.ExpressionDataEvent;
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/AboutDlg.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/AboutDlg.java	(revision 960)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/AboutDlg.java	(revision 961)
@@ -1,96 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.gui.swt;
-
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.layout.GridData;
-import org.eclipse.swt.layout.GridLayout;
-import org.eclipse.swt.widgets.Button;
-import org.eclipse.swt.widgets.Dialog;
-import org.eclipse.swt.widgets.Display;
-import org.eclipse.swt.widgets.Event;
-import org.eclipse.swt.widgets.Label;
-import org.eclipse.swt.widgets.Listener;
-import org.eclipse.swt.widgets.Shell;
-import org.pathvisio.Globals;
-import org.pathvisio.Revision;
-
-/**
- * 
- * A simple dialog box that shows about information
- */
-public class AboutDlg extends Dialog
-{
-	private static final long serialVersionUID = 1L;
-
-	public AboutDlg(Shell parent) 
-	{
-		super (parent);
-	}
-
-	public AboutDlg(Shell parent, int style) 
-	{
-		super (parent, style);
-	}
-	
-	public void open()
-	{
-		Shell parent = getParent();
-		final Shell shell = new Shell (parent, SWT.TITLE | SWT.BORDER | SWT.APPLICATION_MODAL);
-
-		shell.setText ("About " + Globals.APPLICATION_VERSION_NAME);		
-		GridLayout ly = new GridLayout();
-		ly.numColumns = 2;
-		shell.setLayout (ly);
-		
-		Label lbl = new Label (shell, SWT.NULL);
-		lbl.setText (Globals.APPLICATION_VERSION_NAME + "\nRevision: " + Revision.REVISION);
-		GridData gd = new GridData (GridData.HORIZONTAL_ALIGN_CENTER);
-		gd.horizontalSpan = 2;		
-		lbl.setLayoutData (gd);
-		
-		lbl = new Label (shell, SWT.NULL);
-		lbl.setImage (SwtEngine.getImageRegistry().get("about.logo"));
-
-		lbl = new Label (shell, SWT.NULL);
-		lbl.setText ("R.M.H. Besseling\nS.P.M.Crijns\nI.Kaashoek\nM.M.Palm\n" +
-				"E.D Pelgrim\nT.A.J. Kelder\nM.P. van Iersel\n\nBiGCaT");
-		
-		final Button btnOk = new Button (shell, SWT.PUSH);
-		btnOk.setText ("OK");
-		gd = new GridData (GridData.HORIZONTAL_ALIGN_CENTER);
-		gd.horizontalSpan = 2;
-		gd.widthHint = 60;
-		btnOk.setLayoutData (gd);
-		
-		btnOk.addListener(SWT.Selection, new Listener() {
-			public void handleEvent (Event event) {
-					shell.dispose();
-			}
-		});
-			
-		shell.pack();
-		shell.open();
-		
-		Display display = parent.getDisplay();
-		while (!shell.isDisposed())
-		{
-			if (!display.readAndDispatch())
-				display.sleep();			
-		}
-	}
-}
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/NewElementAction.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/NewElementAction.java	(revision 960)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/NewElementAction.java	(revision 961)
@@ -1,225 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-
-package org.pathvisio.gui.swt;
-
-import java.net.URL;
-import java.util.Vector;
-
-import org.eclipse.jface.action.Action;
-import org.eclipse.jface.action.ActionContributionItem;
-import org.eclipse.jface.action.IMenuCreator;
-import org.eclipse.jface.resource.ImageDescriptor;
-import org.eclipse.swt.widgets.Control;
-import org.eclipse.swt.widgets.Menu;
-import org.pathvisio.Engine;
-import org.pathvisio.view.VPathway;
-
-/**
- * {@link Action} to add a new element to the gpml pathway
- */
-public class NewElementAction extends Action
-{
-	MainWindow window;
-	int element;
-		
-	/**
-	 * Constructor for this class
-	 * @param e	type of element this action adds; a {@link VPathway} field constant
-	 */
-	public NewElementAction (int e)
-	{
-		// TODO: this should be moved to CommonActions, since it is both in v1 and v2
-		element = e;
-		
-		String toolTipText;
-		URL imageURL = null;
-		toolTipText = null;
-		switch(element) {
-		case VPathway.NEWLINE: 
-			toolTipText = "Draw new line";
-			imageURL = Engine.getResourceURL("icons/newline.gif");
-			setChecked(false);
-			break;
-		case VPathway.NEWLINEARROW:
-			toolTipText = "Draw new arrow";
-			imageURL = Engine.getResourceURL("icons/newarrow.gif");
-			setChecked(false);
-			break;
-		case VPathway.NEWLINEDASHED:
-			toolTipText = "Draw new dashed line";
-			imageURL = Engine.getResourceURL("icons/newdashedline.gif");
-			setChecked(false);
-			break;
-		case VPathway.NEWLINEDASHEDARROW:
-			toolTipText = "Draw new dashed arrow";
-			imageURL = Engine.getResourceURL("icons/newdashedarrow.gif");
-			setChecked(false);
-			break;
-		case VPathway.NEWLABEL:
-			toolTipText = "Draw new label";
-			imageURL = Engine.getResourceURL("icons/newlabel.gif");
-			setChecked(false);
-			break;
-		case VPathway.NEWARC:
-			toolTipText = "Draw new arc";
-			imageURL = Engine.getResourceURL("icons/newarc.gif");
-			setChecked(false);
-			break;
-		case VPathway.NEWBRACE:
-			toolTipText = "Draw new brace";
-			imageURL = Engine.getResourceURL("icons/newbrace.gif");
-			setChecked(false);
-			break;
-		case VPathway.NEWGENEPRODUCT:
-			toolTipText = "Draw new geneproduct";
-			imageURL = Engine.getResourceURL("icons/newgeneproduct.gif");
-			setChecked(false);
-			break;
-		case VPathway.NEWRECTANGLE:
-			imageURL = Engine.getResourceURL("icons/newrectangle.gif");
-			setChecked(false);
-			break;
-		case VPathway.NEWOVAL:
-			toolTipText = "Draw new oval";
-			imageURL = Engine.getResourceURL("icons/newoval.gif");
-			setChecked(false);
-			break;
-		case VPathway.NEWTBAR:
-			toolTipText = "Draw new TBar";
-			imageURL = Engine.getResourceURL("icons/newtbar.gif");
-			setChecked(false);
-			break;
-		case VPathway.NEWRECEPTORROUND:
-			toolTipText = "Draw new round receptor";
-			imageURL = Engine.getResourceURL("icons/newreceptorround.gif");
-			setChecked(false);
-			break;
-		case VPathway.NEWRECEPTORSQUARE:
-			toolTipText = "Draw new square receptor";
-			imageURL = Engine.getResourceURL("icons/newreceptorsquare.gif");
-			setChecked(false);
-			break;
-		case VPathway.NEWLIGANDROUND:
-			toolTipText = "Draw new round ligand";
-			imageURL = Engine.getResourceURL("icons/newligandround.gif");
-			setChecked(false);
-			break;
-		case VPathway.NEWLIGANDSQUARE:
-			toolTipText = "Draw new square ligand";
-			imageURL = Engine.getResourceURL("icons/newligandsquare.gif");
-			setChecked(false);
-			break;
-		case VPathway.NEWLINEMENU:
-			setMenuCreator(new NewItemMenuCreator(VPathway.NEWLINEMENU));
-			imageURL = Engine.getResourceURL("icons/newlinemenu.gif");
-			toolTipText = "Draw new line or arrow";
-			break;
-		case VPathway.NEWLINESHAPEMENU:
-			setMenuCreator(new NewItemMenuCreator(VPathway.NEWLINESHAPEMENU));
-			imageURL = Engine.getResourceURL("icons/newlineshapemenu.gif");
-			toolTipText = "Draw new ligand or receptor";
-			break;
-		}
-		setToolTipText(toolTipText);
-		setId("newItemAction");
-		if(imageURL != null) setImageDescriptor(ImageDescriptor.createFromURL(imageURL));
-	}
-				
-	public void run () {
-		if(isChecked())
-		{
-			SwtEngine.getWindow().deselectNewItemActions();
-			setChecked(true);
-			Engine.getActiveVPathway().setNewGraphics(element);
-		}
-		else
-		{	
-			Engine.getActiveVPathway().setNewGraphics(VPathway.NEWNONE);
-		}
-	}
-
-	/**
-	 * {@link IMenuCreator} that creates the drop down menus for 
-	 * adding new line-type and -shape elements
-	 */
-	private class NewItemMenuCreator implements IMenuCreator
-	{
-		private Menu menu;
-		int element;
-		
-		/**
-		 * Constructor for this class
-		 * @param e	type of menu to create; one of {@link VPathway}.NEWLINEMENU
-		 * , {@link VPathway}.NEWLINESHAPEMENU
-		 */
-		public NewItemMenuCreator(int e) 
-		{
-			element = e;
-		}
-		
-		public Menu getMenu(Menu parent)
-		{
-			return null;
-		}
-
-		public Menu getMenu(Control parent)
-		{
-			if (menu != null)
-				menu.dispose();
-			
-			menu = new Menu(parent);
-			Vector<Action> actions = new Vector<Action>();
-			switch(element)
-			{
-			case VPathway.NEWLINEMENU:
-				actions.add(new NewElementAction(VPathway.NEWLINE));
-				actions.add(new NewElementAction(VPathway.NEWLINEARROW));
-				actions.add(new NewElementAction(VPathway.NEWLINEDASHED));
-				actions.add(new NewElementAction(VPathway.NEWLINEDASHEDARROW));
-				break;
-			case VPathway.NEWLINESHAPEMENU:
-				actions.add(new NewElementAction(VPathway.NEWLIGANDROUND));
-				actions.add(new NewElementAction(VPathway.NEWRECEPTORROUND));
-				actions.add(new NewElementAction(VPathway.NEWLIGANDSQUARE));
-				actions.add(new NewElementAction(VPathway.NEWRECEPTORSQUARE));
-			}
-			
-			for (Action act : actions)
-			{			
-				addActionToMenu(menu, act);
-			}
-
-			return menu;
-		}
-		
-		protected void addActionToMenu(Menu parent, Action a)
-		{
-			ActionContributionItem item = new ActionContributionItem(a);
-			item.fill(parent, -1);
-		}
-		
-		public void dispose() 
-		{
-			if (menu != null)  {
-				menu.dispose();
-				menu = null;
-			}
-		}
-	}
-
-}
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/ButtonCellEditor.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/ButtonCellEditor.java	(revision 960)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/ButtonCellEditor.java	(revision 961)
@@ -1,36 +0,0 @@
-package org.pathvisio.gui.swt;
-
-import org.eclipse.jface.viewers.CellEditor;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.widgets.Button;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Control;
-
-public abstract class ButtonCellEditor extends CellEditor {
-	public static int buttonStyle = SWT.PUSH;
-	private Button button;
-		
-	public ButtonCellEditor(Composite parent, String label) {
-		super(parent);
-		button.setText(label);
-	}
-		
-	protected Control createControl(Composite parent) {
-		//Composite comp = new Composite(parent, SWT.NULL);
-		//comp.setLayout(new FillLayout());
-		button = new Button(parent, buttonStyle);
-		setSelectionListeners(button);
-		return button;
-	}
-	
-	protected Button getButton() {
-		return button;
-	}
-	
-	protected abstract void setSelectionListeners(Button b);
-	
-	protected void doSetFocus() {
-		if(button != null && !button.isDisposed()) 
-			button.setFocus();
-	}
-}
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/GdbCellEditor.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/GdbCellEditor.java	(revision 960)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/GdbCellEditor.java	(revision 961)
@@ -1,262 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.gui.swt;
-
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.sql.Statement;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.events.FocusAdapter;
-import org.eclipse.swt.events.FocusEvent;
-import org.eclipse.swt.events.SelectionAdapter;
-import org.eclipse.swt.events.SelectionEvent;
-import org.eclipse.swt.graphics.Point;
-import org.eclipse.swt.graphics.Rectangle;
-import org.eclipse.swt.widgets.Button;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Control;
-import org.eclipse.swt.widgets.Layout;
-import org.pathvisio.Engine;
-import org.pathvisio.data.DataSources;
-import org.pathvisio.data.Gdb;
-import org.pathvisio.gui.swt.PropertyPanel.AutoFillData;
-import org.pathvisio.model.PathwayElement;
-import org.pathvisio.model.PropertyType;
-import org.pathvisio.util.SuggestCellEditor;
-import org.pathvisio.util.SuggestCombo;
-import org.pathvisio.util.SuggestCombo.SuggestionListener;
-import org.pathvisio.util.SuggestCombo.SuggestionProvider;
-
-public class GdbCellEditor extends SuggestCellEditor implements SuggestionProvider, SuggestionListener {
-	public static final int TYPE_IDENTIFIER = 0;
-	public static final int TYPE_SYMBOL = 1;
-	int type;
-	
-	public static final int NO_LIMIT = 0;
-	public static final int NO_TIMEOUT = 0;
-	public static int query_timeout = 5; //seconds
-	
-	HashMap<String, PropertyPanel.AutoFillData> suggested;
-	
-	Button button;
-	
-	GdbCellEditor(Composite parent, int type) {
-		super();
-		this.type = type;
-		create(parent); //Set type before creating contol
-		suggestCombo.addSuggetsionListener(this);
-		suggested = new HashMap<String, PropertyPanel.AutoFillData>();
-	}
-		
-	protected Control createControl(Composite parent) {
-		if(type == TYPE_IDENTIFIER) {
-			Composite comp = new Composite(parent, SWT.NULL);
-			super.createControl(comp);
-			button = new Button(comp, SWT.PUSH);
-			button.setText("Set Label");
-			button.setToolTipText("Set the Label property by looking up the gene symbol in the synonym database");
-			button.addSelectionListener(new SelectionAdapter() {
-				public void widgetSelected(SelectionEvent e) {
-					Object value = doGetValue();
-					if(value instanceof AutoFillData) {
-						AutoFillData afd = (AutoFillData) value;
-						afd.setDoGuessData(true);
-						fireApplyEditorValue();
-						afd.setDoGuessData(false);
-					}
-				}
-			});
-			comp.setLayout(new CellLayout());
-			return comp;
-		} else {
-			return super.createControl(parent);
-		}
-	}
-	
-	protected void setFocusListeners() {
-        suggestCombo.getControl().addFocusListener(new FocusAdapter() {
-            public void focusLost(FocusEvent e) {
-            	if(!suggestCombo.isSuggestFocus() &&
-            		(button != null && !button.isFocusControl())) { //Also check focus on button
-            		GdbCellEditor.this.focusLost();
-            	}
-            }
-        });
-	}
-	
-    private class CellLayout extends Layout {
-    	//Adapted from DialogCellEditor
-        public void layout(Composite editor, boolean force) {
-            Rectangle bounds = editor.getClientArea();
-            Point size = button.computeSize(SWT.DEFAULT, SWT.DEFAULT, force);
-			suggestCombo.setBounds(0, 0, bounds.width - size.x, bounds.height);
-            button.setBounds(bounds.width - size.x, 0, size.x, bounds.height);
-        }
-
-        public Point computeSize(Composite editor, int wHint, int hHint,
-                boolean force) {
-            if (wHint != SWT.DEFAULT && hHint != SWT.DEFAULT) {
-				return new Point(wHint, hHint);
-			}
-            Point contentsSize = suggestCombo.computeSize(SWT.DEFAULT, SWT.DEFAULT,
-                    force);
-            Point buttonSize = button.computeSize(SWT.DEFAULT, SWT.DEFAULT,
-            		force);
-            Point result = new Point(buttonSize.x, Math.max(contentsSize.y,
-            		buttonSize.y));
-            return result;
-        }
-    }
-
-    public String getLabel(AutoFillData adf) {
-    	String iddb = adf.getProperty(PropertyType.GENEID) + " (" +
-    	adf.getProperty(PropertyType.SYSTEMCODE) + ")";
-    	switch(type) {
-    	case TYPE_IDENTIFIER:
-    		return 	iddb;
-    	case TYPE_SYMBOL:
-    	default:
-    		return adf.getProperty(PropertyType.TEXTLABEL) + ": " + iddb;
-    	}
-				
-	}
-	
-	public SuggestionProvider getSuggestionProvider() {
-		return this;
-	}
-
-	public void suggestionSelected(String suggestion) {
-		suggestCombo.setText(suggestion);
-		fireApplyEditorValue();
-	}
-	
-	protected Object doGetValue() {
-		String text = suggestCombo.getText();
-		AutoFillData suggestion = suggested.get(text);
-		if(suggestion == null) {
-			suggested.put(text, suggestion = new GdbAutoFillData(getMainPropertyType(), text));
-		}
-		return suggestion;
-	}
-	
-	protected PropertyType getMainPropertyType() {
-		switch(type) {
-		case TYPE_IDENTIFIER:
-			return PropertyType.GENEID;
-		case TYPE_SYMBOL:
-		default:
-			return PropertyType.TEXTLABEL;
-		}
-	}
-	
-	public String[] getSuggestions(String text, SuggestCombo suggestCombo) {
-		int limit = getLimit();
-		
-		List<String> sugg = new ArrayList<String>();
-		try {
-			Statement s = Gdb.getCon().createStatement();
-			
-			s.setQueryTimeout(query_timeout);
-			if(limit > NO_LIMIT) s.setMaxRows(limit);
-			
-			String query = "";
-			switch(type) {
-			case TYPE_IDENTIFIER:
-				query =
-						"SELECT id, code FROM gene WHERE " +
-						"id LIKE '" + text + "%'";
-				break;
-			case TYPE_SYMBOL:
-			default:
-				query =
-						"SELECT id, code, backpageText FROM gene WHERE " +
-						"backpageText LIKE '%<TH>Gene Name:<TH>" + text + "%'";
-			}
-			
-			ResultSet r = s.executeQuery(query);
-	
-			while(r.next()) {
-				String sysCode = r.getString("code");
-				String sysName = DataSources.sysCode2Name.get(sysCode);
-				
-				AutoFillData adf = null;
-				switch(type) {
-				case TYPE_IDENTIFIER:
-					adf = new GdbAutoFillData(PropertyType.GENEID, r.getString("id"));
-					adf.setProperty(PropertyType.SYSTEMCODE, sysName);
-					break;
-				case TYPE_SYMBOL:
-				default:
-					String symbol = Gdb.parseGeneSymbol(r.getString("backpageText"));
-					adf = new GdbAutoFillData(PropertyType.TEXTLABEL, symbol);
-					adf.setProperty(PropertyType.SYSTEMCODE, sysName);
-					adf.setProperty(PropertyType.GENEID, r.getString("id"));
-					
-				}
-				
-				String label = getLabel(adf);
-				suggested.put(label, adf);
-				sugg.add(label);
-			}
-		} catch (SQLException e) {
-			Engine.log.error("Unable to query suggestions", e);
-		}
-		if(limit > NO_LIMIT && sugg.size() == limit) sugg.add("...results limited to " + limit);
-		return sugg.toArray(new String[sugg.size()]);
-	}
-
-	int getLimit() {
-		switch(type) {
-		case TYPE_IDENTIFIER:
-			return 100;
-		case TYPE_SYMBOL:
-		default:
-			return 100;
-		}
-	}
-
-	class GdbAutoFillData extends AutoFillData {
-		public GdbAutoFillData(PropertyType mainProperty, String mainValue) {
-			super(mainProperty, mainValue);
-		}
-		
-		protected void guessData(PathwayElement o) {
-			//Fetch info from self
-			String id = getProperty(PropertyType.GENEID);
-			String sysName = getProperty(PropertyType.SYSTEMCODE);
-			
-			//If null, fetch from dataobject
-			if(id == null) id = (String)o.getProperty(PropertyType.GENEID);
-			if(sysName == null) sysName = (String)o.getProperty(PropertyType.SYSTEMCODE);
-			
-			String code = sysName == null ? null : DataSources.sysName2Code.get(sysName);
-			
-			//Guess symbol
-			if(id != null && code != null) {
-				String symbol = Gdb.getGeneSymbol(id, code);
-				if(symbol != null) {
-					setProperty(PropertyType.TEXTLABEL, symbol);
-				}
-			}
-		}
-	}
-
-}
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/PropertyPanel.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/PropertyPanel.java	(revision 960)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/PropertyPanel.java	(revision 961)
@@ -1,657 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.gui.swt;
-
-import java.awt.Color;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Set;
-
-import org.eclipse.jface.viewers.ArrayContentProvider;
-import org.eclipse.jface.viewers.CellEditor;
-import org.eclipse.jface.viewers.ColorCellEditor;
-import org.eclipse.jface.viewers.ComboBoxCellEditor;
-import org.eclipse.jface.viewers.ICellModifier;
-import org.eclipse.jface.viewers.ILabelProviderListener;
-import org.eclipse.jface.viewers.IStructuredContentProvider;
-import org.eclipse.jface.viewers.ITableLabelProvider;
-import org.eclipse.jface.viewers.TableViewer;
-import org.eclipse.jface.viewers.TextCellEditor;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.graphics.Image;
-import org.eclipse.swt.graphics.RGB;
-import org.eclipse.swt.layout.FillLayout;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Table;
-import org.eclipse.swt.widgets.TableColumn;
-import org.eclipse.swt.widgets.TableItem;
-import org.pathvisio.Engine;
-import org.pathvisio.biopax.gui.BiopaxCellEditor;
-import org.pathvisio.data.DataSources;
-import org.pathvisio.model.DataNodeType;
-import org.pathvisio.model.LineStyle;
-import org.pathvisio.model.LineType;
-import org.pathvisio.model.MappFormat;
-import org.pathvisio.model.ObjectType;
-import org.pathvisio.model.OrientationType;
-import org.pathvisio.model.PathwayElement;
-import org.pathvisio.model.PathwayEvent;
-import org.pathvisio.model.PathwayListener;
-import org.pathvisio.model.PropertyClass;
-import org.pathvisio.model.PropertyType;
-import org.pathvisio.model.ShapeType;
-import org.pathvisio.preferences.GlobalPreference;
-import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
-import org.pathvisio.util.ColorConverter;
-import org.pathvisio.util.SuggestCellEditor;
-import org.pathvisio.util.TableColumnResizer;
-import org.pathvisio.view.Graphics;
-import org.pathvisio.view.SelectionBox;
-import org.pathvisio.view.SelectionBox.SelectionEvent;
-import org.pathvisio.view.SelectionBox.SelectionListener;
-
-/**
- * This class implements the sidepanel where you can edit graphical properties
- * of each object on the pathway.
- */
-public class PropertyPanel extends Composite implements PathwayListener, SelectionListener {
-	public TableViewer tableViewer;
-	CellEditor[] cellEditors = new CellEditor[2];
-	TextCellEditor textEditor;
-	ColorCellEditor colorEditor;
-	ComboBoxCellEditor comboBoxEditor;
-	SuggestCellEditor identifierSuggestEditor;
-	SuggestCellEditor symbolSuggestEditor;
-	BiopaxCellEditor biopaxEditor;
-	
-	private List<PathwayElement> dataObjects;
-	
-	private List<PropertyType> attributes;
-	
-	final static int TYPES_DIFF = ObjectType.MIN_VALID -1;
-	final static Object VALUE_DIFF = new Object() {
-		public boolean equals(Object o) { return false; }
-		public String toString() { return "different values"; }
-	};
-
-	/**
-	 * Add a {@link PathwayElement} to the list of objects of which 
-	 * the properties are displayed
-	 * @param o
-	 */
-	public void addGmmlDataObject(PathwayElement o) {
-		if(!dataObjects.contains(o)) {
-			if(dataObjects.add(o)) {
-				o.addListener(this);
-				refresh();
-			}
-		}
-	}
-	
-	/**
-	 * Remove a {@link PathwayElement} from the list of objects of which 
-	 * the properties are displayed
-	 * @param o
-	 */
-	public void removeGmmlDataObject(PathwayElement o) {
-		if(dataObjects.remove(o)) {
-			o.removeListener(this);
-			refresh();
-		}
-	}
-	
-	/**
-	 * Clear the list of objects of which the properties are displayed
-	 */
-	public void clearGmmlDataObjects() {
-		for(PathwayElement o : dataObjects) o.removeListener(this);
-		dataObjects.clear();
-		refresh();
-	}
-	
-	/**
-	 * Refresh the table and attributes to display
-	 */
-	void refresh() {
-		setAttributes();
-		tableViewer.refresh();
-	}
-	
-	int getAggregateType() {
-		int type = TYPES_DIFF;
-		for(int i = 0; i < dataObjects.size(); i++) {
-			PathwayElement g = dataObjects.get(i);
-			
-			if(i != 0 && type != g.getObjectType()) return TYPES_DIFF;
-			
-			type = g.getObjectType();
-		}
-		return type;
-	}
-	
-	Object getAggregateValue(PropertyType key) {
-		Object value = VALUE_DIFF;
-		for(int i = 0; i < dataObjects.size(); i++) {
-			PathwayElement g = dataObjects.get(i);
-			Object o = g.getProperty(key);
-			if(i != 0 && (o == null || !o.equals(value))) return VALUE_DIFF;
-
-			value = o;
-		}
-		return value;
-	}
-		
-	/**
-	 * Sets the attributes for the selected objects
-	 * Only attributes that are present in all objects in the selection will be
-	 * added to the attributes list and shown in the property table
-	 */
-	public void setAttributes ()
-	{
-		HashMap<PropertyType, Integer> master = new HashMap<PropertyType, Integer>();
-		for (PathwayElement o : dataObjects)
-		{
-			// get attributes. Only get advanced attributes if the preferences say so.
-			for (PropertyType attr : o.getAttributes(
-					 GlobalPreference.getValueBoolean(SwtPreference.SWT_SHOW_ADVANCED_ATTR)))
-			{
-				if (master.containsKey(attr))
-				{
-					// increment
-					master.put(attr, master.get(attr) + 1);
-				}
-				else
-				{
-					// set to 1
-					master.put(attr, 1);
-				}
-			}
-		}
-		attributes.clear();
-		for (PropertyType attr : master.keySet())
-		{
-			if (master.get(attr) == dataObjects.size())
-			{
-				attributes.add(attr);
-			}
-		}
-		// sortAttributes();
-		Collections.sort (attributes);		
-	}
-	
-//	void sortAttributes() {
-//		Collections.sort(attributes, new Comparator() {
-//			public int compare(Object o1, Object o2) {
-//				return o1.ordinal() - o2.ordinal();
-//			}
-//		});
-//	}
-
-	final static String[] colNames = new String[] {"Property", "Value"};
-				
-	PropertyPanel(Composite parent, int style)
-	{
-		super(parent, style);
-		setLayout(new FillLayout());
-		Table t = new Table(this, style);
-		TableColumn tcName = new TableColumn(t, SWT.LEFT);
-		TableColumn tcValue = new TableColumn(t, SWT.LEFT);
-		tcName.setText(colNames[0]);
-		tcValue.setText(colNames[1]);
-		tcName.setWidth(80);
-		tcValue.setWidth(70);
-		tableViewer = new TableViewer(t);
-		tableViewer.getTable().setLinesVisible(true);
-		tableViewer.getTable().setHeaderVisible(true);
-		tableViewer.setContentProvider(tableContentProvider);
-		tableViewer.setLabelProvider(tableLabelProvider);
-		
-		cellEditors[1] = cellEditors[0] = textEditor = new TextCellEditor(tableViewer.getTable());
-		colorEditor = new ColorCellEditor(tableViewer.getTable());
-		comboBoxEditor = new ComboBoxCellEditor(tableViewer.getTable(), new String[] {""});
-		identifierSuggestEditor = new GdbCellEditor(tableViewer.getTable(), GdbCellEditor.TYPE_IDENTIFIER);
-		symbolSuggestEditor = new GdbCellEditor(tableViewer.getTable(), GdbCellEditor.TYPE_SYMBOL);
-		biopaxEditor = new BiopaxCellEditor(tableViewer.getTable(), "...");
-		
-		tableViewer.setCellEditors(cellEditors);
-		tableViewer.setColumnProperties(colNames);
-		tableViewer.setCellModifier(cellModifier);
-		
-		t.addControlListener(new TableColumnResizer(t, t.getParent()));
-		
-		dataObjects = new ArrayList<PathwayElement>();
-		attributes = new ArrayList<PropertyType>();
-		tableViewer.setInput(attributes);
-		
-		SelectionBox.addListener(this);
-	}
-	
-	/**
-	 * return the right cell editor for a certain object. Will return
-	 * one of existing editors. In the case of a list of possible values, 
-	 * a comboboxeditor will be set up with the proper values for
-	 * the drop down list.
-	 */
-	final static String[] orientation_names = OrientationType.getNames();
-	final static String[] linestyle_names = LineStyle.getNames();
-	final static String[] boolean_names = {"false", "true"};
-	final static String[] shape_names = ShapeType.getNames();
-	final static String[] linetype_names = LineType.getNames(); 
-	final static String[] genetype_names = DataNodeType.getNames();
-	
-	private CellEditor getCellEditor(Object element)
-	{
-		PropertyType key = (PropertyType)element;
-		PropertyClass type = key.type();
-		switch(type)
-		{
-			case FONT:				
-			case STRING:
-			case DOUBLE:
-			case ANGLE:
-			case INTEGER: 	return textEditor;
-			case COLOR: 	return colorEditor;
-			case LINETYPE:
-				comboBoxEditor.setItems(linetype_names);
-				return comboBoxEditor;
-			case SHAPETYPE:
-				comboBoxEditor.setItems(shape_names);
-				return comboBoxEditor;
-			case DATASOURCE:			
-				comboBoxEditor.setItems(DataSources.dataSources);
-				return comboBoxEditor;
-			case ORIENTATION:
-				comboBoxEditor.setItems(orientation_names);
-				return comboBoxEditor;
-			case LINESTYLE:
-				comboBoxEditor.setItems(linestyle_names);
-				return comboBoxEditor;
-			case BOOLEAN:
-				comboBoxEditor.setItems(boolean_names);
-				return comboBoxEditor;
-			case ORGANISM:
-				comboBoxEditor.setItems(MappFormat.organism_latin_name);
-				return comboBoxEditor;
-			case GENETYPE:
-				comboBoxEditor.setItems(genetype_names);
-				return comboBoxEditor;
-			case DB_ID:
-				return identifierSuggestEditor;
-			case DB_SYMBOL:
-				return textEditor;
-			case BIOPAXREF:
-				return biopaxEditor;
-				
-		}
-		return textEditor;
-	}
-	
-	private ICellModifier cellModifier = new ICellModifier()
-	{
-		public boolean canModify(Object element, String property) {
-			if (!colNames[1].equals(property))
-			{
-				return false;
-			}
-			
-			cellEditors[1] = getCellEditor(element);
-			return true;
-		}
-
-		/**
-		 * Getvalue is the value that is passed to the Cell Editor when it is 
-		 * activated.
-		 * It should return an Integer object for ComboboxCellEditors.
-		 */
-		public Object getValue(Object element, String property) 
-		{
-			PropertyType key = (PropertyType)element;
-			Object value = getAggregateValue(key);
-			if(value == VALUE_DIFF) {
-				return VALUE_DIFF.toString();
-			}
-			switch(key.type())
-			{
-				case ANGLE:
-				{
-					Double x = Math.round((Double)(value) * 1800.0 / Math.PI) / 10.0;
-					return x.toString();
-				}
-				case DOUBLE:
-				{
-					Double x = Math.round((Double)(value) * 100.0) / 100.0;
-					return x.toString();
-				}
-				case INTEGER: 
-					return value.toString();
-				case ORGANISM:
-					return Arrays.asList(MappFormat.organism_latin_name).indexOf((String)value);
-				case GENETYPE:
-					return Arrays.asList(genetype_names).indexOf((String)value);
-				case STRING:
-				case FONT:
-					return value == null ? "" : (String)value;
-				case DATASOURCE:
-					return DataSources.lDataSources.indexOf((String)value);				
-				// for all combobox types:
-				case BOOLEAN:
-					return ((Boolean)value) ? 1 : 0;
-				case SHAPETYPE:
-					return (((ShapeType)value).ordinal());
-				case LINETYPE:
-					return (((LineType)value).ordinal());
-				case COLOR:
-					if(value instanceof Color)
-						value = ColorConverter.toRGB((Color)value);
-					return (RGB)value;
-				case ORIENTATION:
-				case LINESTYLE:
-				{
-//					try 
-//					{
-						return (Integer)value;
-//					}
-//					catch (ClassCastException e)
-//					{
-//						MessageDialog.openWarning(getShell(), "warning", "Can't cast " + value + " to Integer!");
-//					}
-				}
-				case DB_ID:
-				case DB_SYMBOL:
-					if(value instanceof String) return (String)value;
-					if(value instanceof PropertyPanel.AutoFillData) 
-						return ((PropertyPanel.AutoFillData)value).getMainValue();
-				case BIOPAXREF:
-					return value;
-					
-			}
-			return null;
-		}
-		
-		public void modify(Object element, String property, Object value) {
-			PropertyType key = (PropertyType)((TableItem)element).getData();
-			
-			if(value == VALUE_DIFF || value == VALUE_DIFF.toString()) {
-				return;
-			}
-			/*
-			 * Here, we transform the output of the cell editor
-			 * to a value understood by PathwayElement.SetProperty().
-			 * 
-			 * The output of a comboboxCellEditor is Integer.
-			 * The output of a textCellEditor is String.
-			 * 
-			 * For linetype and shapetype we go from Integer to Integer. easy
-			 * For boolean, we go from Integer to Boolean
-			 * For Double / Integer, we go from String to Double
-			 * For Datasource, we go from Integer to String.
-			 */
-			switch(key.type())
-			{
-			case ANGLE: 	
-				try 
-				{ 
-					// convert degrees (property editor) to radians (model)
-					value = Double.parseDouble((String)value) * Math.PI / 180;					
-					break;
-				} 
-				catch(Exception e) 
-				{
-					// invalid input, ignore
-					return; 
-				}
-			case DOUBLE: 	
-				try 
-				{ 
-					value = Double.parseDouble((String)value); 
-					break; 
-				} 
-				catch(Exception e) 
-				{
-					// invalid input, ignore
-					return; 
-				}
-			case INTEGER: 	
-				try 
-				{ 
-					value = Integer.parseInt((String)value); 
-					break; 
-				}
-				catch(Exception e) 
-				{ 
-					// invalid input, ignore 
-					return; 
-				}
-			case DATASOURCE:
-				if((Integer)value == -1) return; //Nothing selected
-				value = DataSources.lDataSources.get((Integer)value);
-				break;
-			case BOOLEAN:
-				if ((Integer)value == 0)
-				{
-					value = new Boolean (false);
-				}
-				else
-				{
-					value = new Boolean (true);
-				}
-				break;
-			case ORGANISM:
-				if((Integer)value == -1) return; //Nothing selected
-				value = MappFormat.organism_latin_name[(Integer)value];
-				break;
-			case GENETYPE:
-				if((Integer)value == -1) return; //Nothing selected
-				value = genetype_names[(Integer)value];
-				break;
-			case COLOR:
-				value = ColorConverter.fromRGB((RGB)value);
-			case DB_SYMBOL:
-			case DB_ID:
-				if(value instanceof PropertyPanel.AutoFillData) {
-					PropertyPanel.AutoFillData adf = (PropertyPanel.AutoFillData)value;
-					for(PathwayElement o : dataObjects) {
-						if(o.getObjectType() == ObjectType.DATANODE) {
-							adf.fillData(o);
-						}
-					}
-					value = adf.getMainValue();
-				}
-				break;
-			}
-			for(PathwayElement o : dataObjects) {
-				o.setProperty(key, value);
-			}
-			tableViewer.refresh();
-			Engine.getActiveVPathway().redrawDirtyRect();
-		}
-	};
-	
-	private IStructuredContentProvider tableContentProvider = new ArrayContentProvider();
-	
-	private ITableLabelProvider tableLabelProvider = new ITableLabelProvider() {
-		public Image getColumnImage(Object element, int columnIndex) {
-			return null;
-		}
-		public String getColumnText(Object element, int columnIndex) {
-			PropertyType key = (PropertyType)element;
-			switch(columnIndex) {
-				case 0:
-					return key.desc();					
-				case 1:
-					//TODO: prettier labels for different value types
-					if(attributes.contains(key))
-					{
-						Object value = getAggregateValue(key);
-						if (value == null)
-						{
-							return null;
-						}
-						else 
-						{
-							switch (key.type())
-							{
-								case ANGLE:
-								{
-									if (value instanceof Double)
-									{
-										Double x = Math.round((Double)(value) * 1800.0 / Math.PI) / 10.0;
-										return x.toString();
-									}
-									else
-										return value.toString();
-								}
-								case DOUBLE:								
-									if (value instanceof Double)
-									{
-										Double x = Math.round((Double)(value) * 10.0) / 10.0;
-										return x.toString();
-									}
-									else
-										return value.toString();
-										
-								case BOOLEAN:
-								{
-									if (value instanceof Boolean)
-									{
-										return (Boolean)(value) ? "true" : "false";
-									}
-									else
-										return value.toString();
-								}
-								case LINETYPE:
-								{
-									if (value instanceof Integer)
-										return linetype_names[(Integer)(value)];
-									else
-										return value.toString();
-								}
-								case LINESTYLE:
-								{
-									if (value instanceof Integer)
-										return linestyle_names[(Integer)(value)];
-									else
-										return value.toString();
-								}
-								case ORIENTATION:
-								{
-									if (value instanceof Integer)
-										return orientation_names[(Integer)(value)];
-									else
-										return value.toString();									
-								}
-								case SHAPETYPE:
-								{
-									if (value instanceof Integer)
-										return shape_names[(Integer)(value)];
-									else
-										return value.toString();
-								}
-								case COLOR:
-									if(value instanceof Color) {
-										return ColorConverter.toRGB((Color)value).toString();
-									}
-								default:
-									return value.toString();
-							}
-						}
-					}
-			}
-			return null;
-			}
-		
-		public void addListener(ILabelProviderListener listener) { }
-		public void dispose() {}
-		public boolean isLabelProperty(Object element, String property) {
-			return false;
-		}
-		public void removeListener(ILabelProviderListener listener) { }
-	};
-
-	public void gmmlObjectModified(PathwayEvent e) {
-		tableViewer.refresh();
-	}
-
-	//TODO: implement all attribute types as subclasses of MyType.
-//	class MyType {
-//		abstract String getColumnText(Object value);
-//		abstract Object adjustedValue(Object value);
-//		abstract CellEditor getCellEditor()
-//	}
-	
-	public void drawingEvent(SelectionEvent e) {
-		switch(e.type) {
-		case SelectionEvent.OBJECT_ADDED:
-			if(e.affectedObject instanceof Graphics)
-				addGmmlDataObject(((Graphics)e.affectedObject).getGmmlData());
-			break;
-		case SelectionEvent.OBJECT_REMOVED:
-			if(e.affectedObject instanceof Graphics)
-				removeGmmlDataObject(((Graphics)e.affectedObject).getGmmlData());
-			break;
-		case SelectionEvent.SELECTION_CLEARED:
-			 clearGmmlDataObjects();
-			break;
-		}
-		
-	}
-
-	static class AutoFillData {
-		PropertyType mProp;
-		Object mValue;
-		HashMap<PropertyType, String> values;
-		
-		private boolean doGuess = false;
-		
-		public AutoFillData(PropertyType mainProperty, String mainValue) {
-			values = new HashMap<PropertyType, String>();
-			mProp = mainProperty;
-			mValue = mainValue;
-			setProperty(mainProperty, mainValue);
-		}
-		
-		public void setProperty(PropertyType property, String value) {
-			values.put(property, value);
-		}
-		
-		public PropertyType getMainProperty() { return mProp; }
-		public Object getMainValue() { return mValue; }
-		
-		public String getProperty(PropertyType property) { return values.get(property); }
-		
-		public Set<PropertyType> getProperties() { return values.keySet(); }
-		
-		public void fillData(PathwayElement o) {
-			if(doGuess) guessData(o);
-			for(PropertyType p : getProperties()) {
-				Object vNew = getProperty(p);
-				o.setProperty(p, vNew);
-			}
-		}
-		
-		public void setDoGuessData(boolean doGuessData) {
-			doGuess = doGuessData;
-		}
-		
-		protected void guessData(PathwayElement o) {
-		}
-	}
-}
-
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/SidePanel.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/SidePanel.java	(revision 960)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/SidePanel.java	(revision 961)
@@ -1,212 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.gui.swt;
-
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.custom.SashForm;
-import org.eclipse.swt.custom.StackLayout;
-import org.eclipse.swt.events.SelectionAdapter;
-import org.eclipse.swt.events.SelectionEvent;
-import org.eclipse.swt.layout.FillLayout;
-import org.eclipse.swt.layout.GridData;
-import org.eclipse.swt.layout.GridLayout;
-import org.eclipse.swt.widgets.Button;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Control;
-import org.eclipse.swt.widgets.Sash;
-import org.pathvisio.preferences.GlobalPreference;
-import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
-
-/**
- * This class can be extended to create a sidepanel with minimize button
- * for use as component of a {@link SashForm}
- */
-public class SidePanel extends Composite {
-	private SashForm parentSash;
-	private Composite contentComposite;
-	
-	/**
-	 * Constructor for this class
-	 * @param parent	The parent composite (needs to be an {@link SashForm} for the
-	 * minimize button to work
-	 * @param style
-	 */
-	public SidePanel(Composite parent, int style) {
-		super(parent, style);
-		if(parent instanceof SashForm) //Minimize button only works if parent is sashform
-			parentSash = (SashForm)parent;
-		createControls();
-	}
-
-	public Composite getContentComposite() { return contentComposite; }
-	
-	Composite buttonBar;
-	Composite stackComposite;
-	Composite emptyComposite;
-	StackLayout stackLayout;
-	Button minButton;
-	/**
-	 * Creates the button controls to minimize the sidepanel and a {@link Composite} for the contents
-	 */
-	public void createControls() {
-		GridLayout topLayout = new GridLayout();
-		topLayout.verticalSpacing = topLayout.marginTop = topLayout.marginWidth = 0;
-		setLayout(topLayout);
-		
-		if(parentSash != null) {
-			//Create minimize control on top of content
-			buttonBar = new Composite(this, SWT.NULL);
-			GridLayout barLayout = new GridLayout(2, true);
-			barLayout.marginBottom = barLayout.marginHeight = barLayout.marginWidth = 1;
-			buttonBar.setLayout(barLayout);
-						
-			minButton = new Button(buttonBar, SWT.TOGGLE);
-			minButton.setToolTipText("Minimize this sidepanel");
-			minButton.addSelectionListener(new SelectionAdapter() {
-				public void widgetSelected(SelectionEvent e) {
-					if(minButton.getSelection()) {
-						minimize();
-						minButton.setToolTipText("Restore this sidepanel");
-					}
-					else {
-						restore();
-						minButton.setToolTipText("Minimize this sidepanel");
-					}
-				}
-			});
-			minButton.setImage(SwtEngine.getImageRegistry().get("sidepanel.minimize"));
-			final Button hideButton = new Button(buttonBar, SWT.PUSH);
-			hideButton.setToolTipText("Close this sidepanel (use view menu to open again)");
-			hideButton.addSelectionListener(new SelectionAdapter() {
-				public void widgetSelected(SelectionEvent e) {
-					hide();
-					SwtEngine.getWindow().showRightPanelAction.setChecked(false);
-				}
-			});
-			hideButton.setImage(SwtEngine.getImageRegistry().get("sidepanel.hide"));
-			
-			GridData buttonGrid = new GridData();
-			buttonGrid.widthHint = 12;
-			buttonGrid.heightHint =  12;
-			hideButton.setLayoutData(buttonGrid);
-			minButton.setLayoutData(buttonGrid);
-			
-			buttonBar.pack();
-		}
-		stackComposite = new Composite(this, SWT.NULL);
-		stackComposite.setLayoutData(new GridData(GridData.FILL_BOTH));
-		stackLayout = new StackLayout();
-		stackComposite.setLayout(stackLayout);
-		emptyComposite = new Composite(stackComposite, SWT.NULL);
-		emptyComposite.setLayout(new FillLayout());
-		contentComposite = new Composite(stackComposite, SWT.NULL);
-		contentComposite.setLayout(new FillLayout());
-		
-		stackLayout.topControl = contentComposite;
-	}
-	
-	/**
-	 * Minimizes this panel, while the minimize button will still be visible
-	 */
-	public void minimize() {
-		parentSash.setWeights(calculateWeights(WEIGHTS_MINIMIZE));
-		stackLayout.topControl = emptyComposite;
-		stackComposite.layout();
-	}
-	
-	/**
-	 * Hides this panel, the minimize button will not be visible anymore
-	 */
-	public void hide() {
-		parentSash.setWeights(calculateWeights(WEIGHTS_HIDE));
-	}
-	
-	public void show() {
-		int sidePanelSize = GlobalPreference.getValueInt(SwtPreference.SWT_SIDEPANEL_SIZE);
-		if(sidePanelSize == 0) sidePanelSize = 10; //Force show if initial size = 0
-		parentSash.setWeights(calculateWeights(sidePanelSize));
-	}
-	
-	/**
-	 * Restores the size of the panel to its previous size
-	 */
-	public void restore() {
-		if(oldWeights == null) return;
-		parentSash.setWeights(oldWeights);
-		stackLayout.topControl = contentComposite;
-		stackComposite.layout();
-	}
-	
-	private int[] oldWeights;
-	private static final int WEIGHTS_HIDE = -1;
-	private static final int WEIGHTS_MINIMIZE = -2;
-	/**
-	 * Calculates weights that have to be passed to the parent {@link SashForm#setWeights(int[])}
-	 * to resize, minimize or hide this panel
-	 * @param percent percentage of total size for this panel or 
-	 * one of WEIGHTS_HIDE or WEIGHTS_MINIMIZE, in the first case the panel is hidden,
-	 * so its weight is set to zero, in the second case the panel is miminized in a way the minimize 
-	 * button is still visible
-	 * @return
-	 */
-	private int[] calculateWeights(int percent) {
-		Control[] controls = parentSash.getChildren();
-		int[] weights = parentSash.getWeights();
-		oldWeights = weights.clone();
-		//Get the index of this control in the sashform
-		int thisIndex = 0;
-		for(int i = 0; i < controls.length; i++) {
-			if(controls[i] == this) break;
-			if(!(controls[i] instanceof Sash)) thisIndex++; //Don't count sash controls
-		}
-		
-		int thisWeight = weights[thisIndex];
-		
-		//Get the index of the neighbouring composite
-		int neighbourIndex = -1;
-		if(thisIndex == weights.length - 1) neighbourIndex = thisIndex - 1;
-		else neighbourIndex = thisIndex + 1;
-		
-		//Calculate widths needed to calculate new weight 
-		int newWidth;
-		switch(percent) {
-		case WEIGHTS_MINIMIZE: newWidth = minButton.getSize().x; break;
-		case WEIGHTS_HIDE: newWidth = 0; break;
-		default:
-			//Calculate new weights
-			int percentLeft = 100 - percent;
-			int sum = 0;
-			for(int i = 0; i < weights.length; i++) {
-				sum += weights[i];
-				if(i == thisIndex) continue;
-				weights[i] = (int)(((double)weights[i] / 100) * percentLeft);
-			}
-			weights[thisIndex] = (int)(((double)percent / 100) * sum);
-			return weights;
-			}
-		
-		int thisWidth = getSize().x;
-		
-		//Calculate new weights
-		int newWeight = (int)(((double)newWidth / thisWidth) * thisWeight);
-		//Adjust the weight of this and the next control
-		weights[thisIndex] = newWeight;
-		weights[neighbourIndex] += thisWeight - newWeight;
-		return weights;
-	}
-
-}
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/TabbedSidePanel.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/TabbedSidePanel.java	(revision 960)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/TabbedSidePanel.java	(revision 961)
@@ -1,175 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.gui.swt;
-
-import java.util.HashMap;
-
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.custom.CTabFolder;
-import org.eclipse.swt.custom.CTabItem;
-import org.eclipse.swt.custom.SashForm;
-import org.eclipse.swt.events.DisposeEvent;
-import org.eclipse.swt.events.DisposeListener;
-import org.eclipse.swt.widgets.Composite;
-import org.eclipse.swt.widgets.Control;
-import org.eclipse.swt.widgets.TabFolder;
-import org.eclipse.swt.widgets.TabItem;
-
-/**
- * This class represents a side panel with contents placed in different
- * tabitems. Components to add needs to be children of the {@link TabFolder}
- * returned by {@link #getTabFolder()}
- */
-public class TabbedSidePanel extends SidePanel {
-	private CTabFolder tabFolder;
-	HashMap<String, Control> controls;
-	HashMap<String, CTabItem> tabItems;
-	
-	/**
-	 * Returns the {@link TabFolder} containing the different
-	 * tabItems of this sidepanel
-	 */
-	public CTabFolder getTabFolder() { return tabFolder; }
-	
-	public HashMap<String, CTabItem> getTabItemHash() { return tabItems; }
-	
-	/**
-	 * Constructor for this class
-	 * @param parent	The parent composite (needs to be an {@link SashForm} for the
-	 * minimize button to work
-	 * @param style		
-	 */
-	public TabbedSidePanel(Composite parent, int style) {
-		super(parent, style);
-		controls = new HashMap<String, Control>();
-		tabItems = new HashMap<String, CTabItem>();
-		
-		tabFolder = new CTabFolder(getContentComposite(), SWT.BORDER);
-		tabFolder.setSimple(false);
-	}
-	
-	/**
-	 * Add a TabItem containing the given Control.
-	 * @param content	{@link Control} that needs to be a child of the
-	 * TabFolder returned by {@link #getTabFolder()}
-	 * @param title		The title for the TabItem
-	 */
-	public void addTab(Control content, String title)
-	{		
-		createTabItem(content, title, false);
-		controls.put(title, content);
-	}
-	
-	public void addTab(Control content, String title, boolean close)
-	{		
-		createTabItem(content, title, close);
-		controls.put(title, content);
-	}
-	
-	/**
-	 * Creates an {@link TabItem} with the given control and title
-	 * @param content
-	 * @param title
-	 * @param close
-	 * @returns
-	 */
-	private CTabItem createTabItem(Control content, String title, boolean close)
-	{
-		return createTabItem(content, title, tabFolder.getItemCount(), close);
-	}
-	
-	/**
-	 * Creates an {@link TabItem} with the given control and title at the given index.
-	 * If the index is lower than the number of tabitems, the new tabitem is placed before the first,
-	 * otherwise it is placed after the last.
-	 * @param content
-	 * @param title
-	 * @returns
-	 * @param index
-	 * @return
-	 */
-	private CTabItem createTabItem(Control content, String title, int index, boolean close) {
-		int nrTabs = tabFolder.getItemCount();
-		
-		if(index > nrTabs) index = nrTabs; //If index is invalid, choose first or last tab
-		else if(index < 0) index = 0;
-		
-		final CTabItem ti = new CTabItem(tabFolder, close ? SWT.CLOSE : SWT.NULL, index);
-		ti.setText(title);
-		ti.setControl(content);
-		ti.addDisposeListener(new DisposeListener() {
-			public void widgetDisposed(DisposeEvent e) {
-				tabItems.remove(ti.getText());
-			}
-		});
-		tabItems.put(title, ti);
-		return ti;
-	}
-	
-	/**
-	 * Hides a tab (without disposing the containing {@link Control})
-	 * @param title The title of the tab
-	 */
-	public void hideTab(String title) {
-		if(!tabItems.containsKey(title)) return;
-		tabItems.get(title).dispose();
-		tabItems.remove(title);
-	}
-	
-	/**
-	 * Shows a tab if a control with the given title exists
-	 * @param title	The title of the tabitem, also serves to find the {@link Control} for the tabItem
-	 * @return true if the tab is added, false if not ({@link Control} not found)
-	 */
-	public boolean unhideTab(String title) {
-		return unhideTab(title, tabFolder.getItemCount());
-	}
-	
-	/**
-	 * Shows a tab if a control with the given title exists
-	 * @param title	The title of the tabitem, also serves to find the {@link Control} for the tabItem
-	 * @param position The index of the position to add the tab
-	 * @return true if the tab is added, false if not ({@link Control} not found)
-	 */
-	public boolean unhideTab(String title, int position) {
-		if(controls.containsKey(title)) {
-			createTabItem(controls.get(title), title, position, false);
-			return true;
-		}
-		return false;
-	}
-	
-	public void selectTab(String title) {
-		if(tabItems.containsKey(title)) 
-			tabFolder.setSelection(tabItems.get(title));
-	}
-	
-	/**
-	 * Checks whether a tabitem is visible
-	 */
-	public boolean isVisible(String title) {
-		return tabItems.containsKey(title) && controls.containsKey(title);
-	}
-	
-	/**
-	 * Check whether a tabitem with the given title exists
-	 * @param title
-	 */
-	public boolean hasTab(String title) {
-		return tabItems.containsKey(title);
-	}
-}
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/CommonActions.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/CommonActions.java	(revision 960)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/CommonActions.java	(revision 961)
@@ -1,625 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.gui.swt;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-
-import org.eclipse.jface.action.Action;
-import org.eclipse.jface.action.IAction;
-import org.eclipse.jface.dialogs.MessageDialog;
-import org.eclipse.jface.preference.PreferenceDialog;
-import org.eclipse.jface.preference.PreferenceManager;
-import org.eclipse.jface.resource.ImageDescriptor;
-import org.eclipse.swt.SWT;
-import org.eclipse.swt.widgets.FileDialog;
-import org.pathvisio.Engine;
-import org.pathvisio.Globals;
-import org.pathvisio.Engine.ApplicationEvent;
-import org.pathvisio.Engine.ApplicationEventListener;
-import org.pathvisio.biopax.gui.BiopaxDialog;
-import org.pathvisio.model.ConverterException;
-import org.pathvisio.model.Pathway;
-import org.pathvisio.model.PathwayExporter;
-import org.pathvisio.preferences.swt.PreferenceDlg;
-import org.pathvisio.preferences.swt.SwtPreferences;
-import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
-import org.pathvisio.view.VPathway;
-
-/**
-   This class contains a large number of JFace Actions that are both in V1 and V2.
-*/   
-public class CommonActions
-{
-	static class UndoAction extends Action
-	{
-		MainWindowBase window;
-		public UndoAction (MainWindowBase w)
-		{
-			window = w;
-			setText ("&Undo@Ctrl+Z");
-			setToolTipText ("Undo last action");
-		}
-		public void run() 
-		{
-			if (Engine.getActivePathway() != null)
-			{
-				Engine.getActivePathway().undo();
-			}
-		}
-	}
-	
-	/**
-	 * {@link Action} to create a new gpml pathway
-	 */
-	static class NewAction extends Action 
-	{
-		MainWindowBase window;
-		public NewAction (MainWindowBase w)
-		{
-			window = w;
-			setText ("&New pathway@Ctrl+N");
-			setToolTipText ("Create new pathway");
-			setImageDescriptor(ImageDescriptor.createFromURL(
-					Engine.getResourceURL("icons/new.gif")));
-		}
-		public void run ()
-		{			
-			SwtEngine.newPathway();
-		}	
-	}
-	
-	/**
-	 * {@link Action} to create a new gpml pathway
-	 */
-	static class SvgExportAction extends Action 
-	{
-		MainWindowBase window;
-		public SvgExportAction (MainWindowBase w)
-		{
-			window = w;
-			setText ("Export to SVG");
-			setToolTipText ("Export to Scalable Vector Graphics (SVG) " +
-					"for publication-quality images");
-		}
-		public void run () 
-		{
-			//TODO: move to engine, merge with "save"
-			VPathway drawing = Engine.getActiveVPathway();
-			Pathway gmmlData = Engine.getActivePathway();
-			// Check if a gpml pathway is loaded
-			if (drawing != null)
-			{
-				FileDialog fd = new FileDialog(window.getShell(), SWT.SAVE);
-				fd.setText("Save");
-				fd.setFilterExtensions(new String[] {"*." + Engine.SVG_FILE_EXTENSION, "*.*"});
-				fd.setFilterNames(new String[] {Engine.SVG_FILTER_NAME, "All files (*.*)"});
-				
-				File xmlFile = gmmlData.getSourceFile();
-				if(xmlFile != null) {
-					String name = xmlFile.getName();
-					if (name.endsWith("." + Engine.PATHWAY_FILE_EXTENSION))
-					{
-						name = name.substring(0, name.length() - 
-							Engine.PATHWAY_FILE_EXTENSION.length()) +
-							Engine.SVG_FILE_EXTENSION;
-					}
-					fd.setFileName(name);
-					fd.setFilterPath(xmlFile.getPath());
-				} else {
-					fd.setFileName(SwtPreference.SWT_DIR_PWFILES.getValue());
-				}
-				String fileName = fd.open();
-				// Only proceed if user selected a file
-				
-				if(fileName == null) return;
-				
-				// Append .svg extension if not already present
-				if(!fileName.endsWith("." + Engine.SVG_FILE_EXTENSION)) 
-					fileName += "." + Engine.SVG_FILE_EXTENSION;
-				
-				File checkFile = new File(fileName);
-				boolean confirmed = true;
-				// If file exists, ask overwrite permission
-				if(checkFile.exists())
-				{
-					confirmed = MessageDialog.openQuestion(window.getShell(),"",
-					"File already exists, overwrite?");
-				}
-				if(confirmed)
-				{
-					try
-					{
-						gmmlData.writeToSvg(checkFile);
-					}
-					catch (ConverterException e)
-					{
-						String msg = "While writing svg to " 
-							+ checkFile.getAbsolutePath();					
-						MessageDialog.openError (window.getShell(), "Error", 
-								"Error: " + msg + "\n\n" + 
-								"See the error log for details.");
-						Engine.log.error(msg, e);
-					}
-				}
-			}
-			else
-			{
-				MessageDialog.openError (window.getShell(), "Error", 
-					"No pathway to save! Open or create a new pathway first");
-			}			
-		}
-	}
-
-	/**
-	 * {@link Action} to open an gpml pathway
-	 */
-	static class OpenAction extends Action 
-	{
-		MainWindowBase window;
-		public OpenAction (MainWindowBase w)
-		{
-			window = w;
-			setText ("&Open pathway@Ctrl+O");
-			setToolTipText ("Open pathway");
-			setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/open.gif")));
-		}
-		public void run () 
-		{
-			FileDialog fd = new FileDialog(window.getShell(), SWT.OPEN);
-			fd.setText("Open");
-			String pwpath = SwtPreference.SWT_DIR_PWFILES.getValue();
-			fd.setFilterPath(pwpath);
-			fd.setFilterExtensions(new String[] {"*." + Engine.PATHWAY_FILE_EXTENSION, "*.*"});
-			fd.setFilterNames(new String[] {Engine.PATHWAY_FILTER_NAME, "All files (*.*)"});
-	        String fnMapp = fd.open();
-	        // Only open pathway if user selected a file
-	        
-	        if(fnMapp != null) { 
-	        	SwtEngine.openPathway(fnMapp); 
-	        }
-		}
-	}
-
-	/**
-	 * {@link Action} to open an gpml pathway
-	 */
-	static class ImportAction extends Action 
-	{
-		MainWindowBase window;
-		public ImportAction (MainWindowBase w)
-		{
-			window = w;
-			setText ("&Import");
-			setToolTipText ("Import Pathway in GenMAPP format");
-		}
-		public void run () 
-		{
-			if(SwtEngine.canDiscardPathway())
-			{
-				FileDialog fd = new FileDialog(window.getShell(), SWT.OPEN);
-				fd.setText("Open");
-				fd.setFilterPath(SwtPreference.SWT_DIR_PWFILES.getValue());
-				fd.setFilterExtensions(new String[] {"*." + Engine.GENMAPP_FILE_EXTENSION, "*.*"});
-				fd.setFilterNames(new String[] {Engine.GENMAPP_FILTER_NAME, "All files (*.*)"});
-	        	String fnMapp = fd.open();
-	        	// Only open pathway if user selected a file
-	        	
-	        	if(fnMapp != null) { 
-	        		SwtEngine.openPathway(fnMapp); 
-	        	}
-	        }
-		}
-	}
-
-	/**
-	 * {@link Action} to save a gpml pathway to a file specified by the user
-	 */
-	static class SaveAsAction extends Action 
-	{
-		MainWindowBase window;
-		public SaveAsAction (MainWindowBase w)
-		{
-			window = w;
-			setText ("Save pathway &As");
-			setToolTipText ("Save pathway with new file name");
-		}
-		
-		public void run () 
-		{
-			SwtEngine.savePathwayAs();
-		}
-	}
-
-	
-	/**
-	 * {@link Action} to save a gpml pathway to a file specified by the user
-	 */
-	static class ExportAction extends Action 
-	{
-		MainWindowBase window;
-		public ExportAction (MainWindowBase w)
-		{
-			window = w;
-			setText ("&Export");
-			setToolTipText ("Export Pathway to GenMAPP format");
-		}
-		public void run () {
-			//TODO: move to engine, merge with "save" or "saveAs"
-			VPathway drawing = Engine.getActiveVPathway();
-			Pathway gmmlData = Engine.getActivePathway();
-			// Check if a gpml pathway is loaded
-			if (drawing != null)
-			{
-				FileDialog fd = new FileDialog(window.getShell(), SWT.SAVE);
-				fd.setText("Export");
-				
-				class FileType implements Comparable<FileType> {
-					final String name;
-					final String ext;
-					public FileType(String n, String e) { name = n; ext = e; }
-					public int compareTo(FileType o) {
-						return name.compareTo(o.name);
-					}
-				}
-				
-				ArrayList<FileType> fts = new ArrayList<FileType>();
-				HashMap<String, PathwayExporter> exporters = Engine.getPathwayExporters();
-								
-				for(String ext : exporters.keySet()) {
-					fts.add(new FileType(
-								exporters.get(ext).getName() + " (*." + ext + ")",
-								"*." + ext));
-				}
-				Collections.sort(fts);
-				String[] exts = new String[fts.size()];
-				String[] nms = new String[fts.size()];
-				for(int i = 0; i < fts.size(); i++) {
-					FileType ft = fts.get(i);
-					exts[i] = ft.ext;
-					nms[i] = ft.name;
-				}
-				fd.setFilterExtensions(exts);
-				fd.setFilterNames(nms);
-								
-				File xmlFile = gmmlData.getSourceFile();
-				if(xmlFile != null) {
-					String name = xmlFile.getName();
-					if (name.endsWith("." + Engine.PATHWAY_FILE_EXTENSION))
-					{
-						name = name.substring(0, name.length() - 
-							Engine.PATHWAY_FILE_EXTENSION.length() - 1);
-					}
-					fd.setFileName(name);
-					fd.setFilterPath(xmlFile.getPath());
-				} else {
-					fd.setFileName(SwtPreference.SWT_DIR_PWFILES.getValue());
-				}
-				String fileName = fd.open();
-				// Only proceed if user selected a file
-				if(fileName == null) return;
-				
-				int dot = fileName.lastIndexOf('.');
-				String ext = Engine.GENMAPP_FILE_EXTENSION;
-				if(dot >= 0) {
-					ext = fileName.substring(dot + 1, fileName.length());
-				}
-				PathwayExporter exporter = Engine.getPathwayExporter(ext);
-				
-				if(exporter == null) 
-					MessageDialog.openError (window.getShell(), "Error", 
-					"No exporter for '" + ext +  "' files");
-								
-				File checkFile = new File(fileName);
-				boolean confirmed = true;
-				// If file exists, ask overwrite permission
-				if(checkFile.exists())
-				{
-					confirmed = MessageDialog.openQuestion(window.getShell(),"",
-					"File already exists, overwrite?");
-				}
-				if(confirmed)
-				{
-					try
-					{
-						//gmmlData.writeToMapp(checkFile);
-						exporter.doExport(checkFile, gmmlData);
-					}
-					catch (ConverterException e)
-					{
-						String msg = "While exporting to " 
-							+ checkFile.getAbsolutePath();					
-						MessageDialog.openError (window.getShell(), "Error", 
-								"Error: " + msg + "\n\n" + 
-								"See the error log for details.");
-						Engine.log.error(msg, e);
-					}
-				}
-			}
-			else
-			{
-				MessageDialog.openError (window.getShell(), "Error", 
-					"No pathway to save! Open or create a new pathway first");
-			}			
-		}
-	}
-
-	/**
-	 * {@link Action} to exit the application
-	 */
-	static class ExitAction extends Action 
-	{
-		MainWindowBase window;
-		public ExitAction (MainWindowBase w)
-		{
-			window = w;
-			setText ("E&xit@Ctrl+X");
-			setToolTipText ("Exit Application");
-		}
-		public void run () 
-		{
-			if (SwtEngine.canDiscardPathway())
-			{
-				window.close();
-			}
-		}
-	}
-	
-	static class PreferencesAction extends Action
-	{
-		MainWindowBase window;
-		public PreferencesAction (MainWindowBase w)
-		{
-			window = w;
-			setText("&Preferences");
-			setToolTipText("Edit preferences");
-		}
-		public void run () {
-			PreferenceManager pg = new PreferenceDlg();
-			PreferenceDialog pd = new PreferenceDialog(window.getShell(), pg);
-			pd.setPreferenceStore((SwtPreferences)SwtEngine.getPreferences());
-			pd.open();
-		}
-	}
-
-	/**
-	 * {@link Action} that zooms a mapp to the specified zoomfactor
-	 */
-	static class ZoomAction extends Action 
-	{
-		MainWindowBase window;
-		int pctZoomFactor;
-		
-		/**
-		 * Constructor for this class
-		 * @param w {@link MainWindow} window this action belongs to
-		 * @param newPctZoomFactor the zoom factor as percentage of original
-		 */
-		public ZoomAction (MainWindowBase w, int newPctZoomFactor)
-		{
-			window = w;
-			pctZoomFactor = newPctZoomFactor;
-			if(pctZoomFactor == MainWindowBase.ZOOM_TO_FIT) 
-			{
-				setText ("Zoom to fit");
-				setToolTipText("Zoom mapp to fit window");
-			}
-			else
-			{
-				setText (pctZoomFactor + " %");
-				setToolTipText ("Zoom mapp to " + pctZoomFactor + " %");
-			}
-		}
-		public void run () {
-			VPathway drawing = Engine.getActiveVPathway();
-			if (drawing != null)
-			{
-				drawing.setPctZoom(pctZoomFactor);
-			}
-			else
-			{
-				MessageDialog.openError (window.getShell(), "Error", 
-					"No gpml file loaded! Open or create a new gpml file first");
-			}
-		}
-	}
-
-	/**
-	 * {@link Action} to open a {@link AboutDlg} window
-	 */
-	static class AboutAction extends Action 
-	{
-		MainWindowBase window;
-		public AboutAction (MainWindowBase w)
-		{
-			window = w;
-			setText ("&About");
-			setToolTipText ("About " + Globals.APPLICATION_VERSION_NAME);
-		}
-		public void run () {
-			AboutDlg gmmlAboutBox = new AboutDlg(window.getShell(), SWT.NONE);
-			gmmlAboutBox.open();
-		}
-	}
-	
-	/**
-	 * {@link Action} to open a Help window
-	 */
-	static class HelpAction extends Action 
-	{
-		MainWindowBase window;
-		public HelpAction (MainWindowBase w)
-		{
-			window = w;
-			setText ("&Help@F1");
-			setToolTipText ("Opens " + Globals.APPLICATION_VERSION_NAME + " help in your web browser");
-		}
-		public void run ()
-		{
-			SwtEngine.openWebPage(Globals.HELP_URL, "Opening help page in broswer",
-						"Unable to open web browser" +
-						"\nYou can open the help page manually:\n" +
-						Globals.HELP_URL);
-		}
-	}
-
-	static class CopyAction extends Action
-	{
-		MainWindowBase window;
-		public CopyAction (MainWindowBase w)
-		{
-			window = w;
-			setText ("Copy@Ctrl+C");
-			setToolTipText ("Copy selected objects to clipboard");
-		}
-		public void run()
-		{
-			Engine.getActiveVPathway().copyToClipboard();
-		}
-	}
-
-	static class PasteAction extends Action
-	{
-		MainWindowBase window;
-		public PasteAction (MainWindowBase w)
-		{
-			window = w;
-			setText ("Paste@Ctrl+V");
-			setToolTipText ("Paste contents of clipboard");
-		}
-		public void run()
-		{
-			Engine.getActiveVPathway().pasteFromClipboad();
-		}
-	}
-	
-	/**
-	 * {@link Action} to save a gpml pathway
-	 */
-	static class SaveAction extends Action 
-	{
-		MainWindowBase window;
-		public SaveAction (MainWindowBase w)
-		{
-			window = w;
-			setText ("&Save pathway@Ctrl+S");
-			setToolTipText ("Save pathway");
-			setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/save.gif")));
-		}
-		
-		public void run ()
-		{
-			SwtEngine.savePathway();
-		}
-	}
-	
-	static class BiopaxAction extends Action 
-	{
-		MainWindowBase window;
-		public BiopaxAction (MainWindowBase w)
-		{
-			window = w;
-			setText ("Edit &BioPAX code");
-			setToolTipText ("Edit BioPAX code");
-		}
-		
-		public void run () {
-			BiopaxDialog d = new BiopaxDialog(window.getShell());
-			d.setPathway(Engine.getActivePathway());
-			d.open();
-		}
-	}
-	
-	/**
-	 * {@link Action} to switch between edit and view mode
-	 */
-	static class SwitchEditModeAction extends Action implements ApplicationEventListener
-	{
-		final String ttChecked = "Exit edit mode";
-		final String ttUnChecked = "Switch to edit mode to edit the pathway content";
-		MainWindowBase window;
-		public SwitchEditModeAction (MainWindowBase w)
-		{
-			super("&Edit mode", IAction.AS_CHECK_BOX);
-			setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/edit.gif")));
-			setToolTipText(ttUnChecked);
-			window = w;
-			
-			Engine.addApplicationEventListener(this);
-		}
-
-		public void run ()
-		{
-			if(Engine.isDrawingOpen())
-			{
-				VPathway drawing = Engine.getActiveVPathway();
-				Pathway pathway = Engine.getActivePathway();
-				if(isChecked())
-				{
-					// give a warning that this can't be edited.
-					if (pathway.getSourceFile() != null && !pathway.getSourceFile().canWrite())
-					{
-						MessageDialog.openWarning(
-								window.getShell(), "Read-only Warning",
-								"You're trying to edit a Read-only file.\n" +
-						"When you want to save your changes, you have to save to a different file.");
-					}
-					//Switch to edit mode: show edit toolbar, show property table in sidebar
-					drawing.setEditMode(true);
-					window.showEditActionsCI(true);
-					window.showAlignActionsCI(true);
-					window.rightPanel.getTabFolder().setSelection(1);
-				}
-				else
-				{
-					//Switch to view mode: hide edit toolbar, show backpage browser in sidebar
-					drawing.setEditMode(false);
-					window.showEditActionsCI(false);
-					window.showAlignActionsCI(false);
-					window.rightPanel.getTabFolder().setSelection(0);
-				}
-			}
-			else //No gpml pathway loaded, deselect action and do nothing
-			{
-				setChecked(false);
-			}
-			window.getCoolBarManager().update(true);
-		}
-		
-		public void setChecked(boolean check) {
-			super.setChecked(check);
-			setToolTipText(check ? ttChecked : ttUnChecked);
-		}
-
-		public void switchEditMode(boolean edit) {
-			setChecked(edit);
-			run();
-
-		}
-
-		public void applicationEvent(ApplicationEvent e) {
-			if(e.type == ApplicationEvent.PATHWAY_OPENED) {
-				Engine.getActiveVPathway().setEditMode(isChecked());
-			}
-			else if(e.type == ApplicationEvent.PATHWAY_NEW) {
-				switchEditMode(true);
-			}
-		}
-	}
-}
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/GuiMain.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/GuiMain.java	(revision 960)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/GuiMain.java	(revision 961)
@@ -1,206 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.gui.swt;
-
-import java.io.File;
-import java.io.PrintStream;
-
-import org.eclipse.jface.resource.ImageDescriptor;
-import org.eclipse.jface.resource.ImageRegistry;
-import org.eclipse.swt.graphics.Image;
-import org.eclipse.swt.graphics.ImageData;
-import org.eclipse.swt.widgets.Display;
-import org.pathvisio.Engine;
-import org.pathvisio.data.Gdb;
-import org.pathvisio.data.Gex;
-import org.pathvisio.model.ImageExporter;
-import org.pathvisio.model.MappFormat;
-import org.pathvisio.model.Pathway;
-import org.pathvisio.model.SvgFormat;
-import org.pathvisio.preferences.GlobalPreference;
-import org.pathvisio.preferences.Preference;
-import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
-import org.pathvisio.util.SwtUtils;
-import org.pathvisio.visualization.VisualizationManager;
-import org.pathvisio.visualization.plugins.PluginManager;
-
-/**
- * This class contains the main method and is responsible for initiating 
- * the application by setting up the user interface and creating all necessary objects
- */
-public class GuiMain {
-	
-	/**
-	 * Main method which will be carried out when running the program
-	 */
-	public static void main(String[] args)
-	{
-		boolean debugHandles = false;
-		for(String a : args) {
-			if(		a.equalsIgnoreCase("--MonitorHandles") ||
-					a.equalsIgnoreCase("-mh")) {
-				debugHandles = true;
-			}
-			else if(a.equalsIgnoreCase("--UseR") ||
-					a.equalsIgnoreCase("-ur")) {
-				SwtEngine.USE_R = true;
-			}
-		}
-		
-		//Setup the application window
-		MainWindow window = null;
-		if(debugHandles)	window = SwtEngine.getSleakWindow();
-		else				window = SwtEngine.getWindow();
-		
-		initiate();
-		
-		window.setBlockOnOpen(true);
-		window.open();
-		
-		//Perform exit operations
-		//TODO: implement PropertyChangeListener and fire exit property when closing
-		// make classes themself responsible for closing when exit property is changed
-		Gex.close();
-		Gdb.close();
-		//Close log stream
-		Engine.log.getStream().close();
-		
-		Display.getCurrent().dispose();
-	}
-	
-	/**
-	 * Initiates some objects used by the program
-	 */
-	public static void initiate() {
-		//initiate logger
-		try { 
-			GlobalPreference.FILE_LOG.setDefault(new File(SwtEngine.getApplicationDir(), ".PathVisioLog").toString());
-			Engine.log.setStream(new PrintStream(GlobalPreference.FILE_LOG.getValue())); 
-		} catch(Exception e) {}
-		Engine.log.setLogLevel(true, true, true, true, true, true);//Modify this to adjust log level
-		Pathway.setLogger(Engine.log);
-		
-		//load the preferences
-		loadPreferences();
-		
-		//initiate Gene database (to load previously used gdb)
-		Gdb.init();
-		
-		//load visualizations and plugins
-		loadVisualizations();
-		
-		//create data directories if they don't exist yet
-		createDataDirectories();
-		
-		//register listeners for static classes
-		registerListeners();
-				
-		registerExporters();
-		
-		//NOTE: ImageRegistry will be initiated in "createContents" of MainWindow,
-		//since the window has to be opened first (need an active Display)
-	}
-	
-	/**
-	 * Creates data directories stored in preferences (if not exist)
-	 */
-	static void createDataDirectories() {
-		Preference[] dirPrefs = new Preference[] {
-				SwtPreference.SWT_DIR_EXPR,
-				SwtPreference.SWT_DIR_GDB,
-				SwtPreference.SWT_DIR_PWFILES,
-				SwtPreference.SWT_DIR_RDATA,
-		};
-		for(Preference p : dirPrefs) {
-			File dir = new File(p.getValue());
-			if(!dir.exists()) dir.mkdir();
-		}
-	}
-	
-			
-	static void registerListeners() {
-		VisualizationManager vmgr = new VisualizationManager();
-		Gex gex = new Gex();
-		
-		Engine.addApplicationEventListener(vmgr);
-		Engine.addApplicationEventListener(gex);
-	}
-	
-	static void registerExporters() {
-		Engine.addPathwayExporter(new MappFormat());
-		Engine.addPathwayExporter(new SvgFormat());
-		Engine.addPathwayExporter(new ImageExporter(ImageExporter.TYPE_PNG));
-		Engine.addPathwayExporter(new ImageExporter(ImageExporter.TYPE_TIFF));
-		Engine.addPathwayExporter(new ImageExporter(ImageExporter.TYPE_PDF));
-	}
-	
-	static void loadVisualizations() {
-		//load visualization plugins
-		try {
-			PluginManager.loadPlugins();
-		} catch (Throwable e) {
-			Engine.log.error("When loading visualization plugins", e);
-		}
-		
-		VisualizationManager.loadGeneric();
-	}
-	
-	static void loadPreferences() {
-		SwtEngine.getPreferences();
-	}
-	
-	/**
-	 * Loads images used throughout the applications into an {@link ImageRegistry}
-	 */
-	static void loadImages(Display display)
-	{
-		ClassLoader cl = GuiMain.class.getClassLoader();
-	
-		ImageRegistry imageRegistry = new ImageRegistry(display);
-		
-		// Labels for color by expressiondata (mRNA and Protein)
-		ImageData img = new ImageData(cl.getResourceAsStream("images/mRNA.bmp"));
-		img.transparentPixel = img.palette.getPixel(SwtUtils.color2rgb(Engine.TRANSPARENT_COLOR));
-		imageRegistry.put("data.mRNA",
-				new Image(display, img));
-		img = new ImageData(cl.getResourceAsStream("images/protein.bmp"));
-		img.transparentPixel = img.palette.getPixel(SwtUtils.color2rgb(Engine.TRANSPARENT_COLOR));
-		imageRegistry.put("data.protein",
-				new Image(display, img));
-		imageRegistry.put("sidepanel.minimize",
-				ImageDescriptor.createFromURL(cl.getResource("icons/minimize.gif")));
-		imageRegistry.put("sidepanel.hide",
-				ImageDescriptor.createFromURL(cl.getResource("icons/close.gif")));
-		imageRegistry.put("shell.icon", 
-				ImageDescriptor.createFromURL(cl.getResource("images/bigcateye.gif")));
-		imageRegistry.put("about.logo",
-				ImageDescriptor.createFromURL(cl.getResource("images/logo.jpg")));
-						imageRegistry.put("checkbox.unchecked",
-				ImageDescriptor.createFromURL(cl.getResource("icons/unchecked.gif")));
-		imageRegistry.put("checkbox.unavailable",
-				ImageDescriptor.createFromURL(cl.getResource("icons/unchecked_unavailable.gif")));
-		imageRegistry.put("checkbox.checked",
-				ImageDescriptor.createFromURL(cl.getResource("icons/checked.gif")));
-		imageRegistry.put("tree.collapsed",
-				ImageDescriptor.createFromURL(cl.getResource("icons/tree_collapsed.gif")));
-		imageRegistry.put("tree.expanded",
-				ImageDescriptor.createFromURL(cl.getResource("icons/tree_expanded.gif")));
-		SwtEngine.setImageRegistry(imageRegistry);
-	}
-	
-}
-
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/AlignActions.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/AlignActions.java	(revision 960)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/AlignActions.java	(revision 961)
@@ -1,177 +0,0 @@
-//	 PathVisio,
-//	 a tool for data visualization and analysis using Biological Pathways
-//	 Copyright 2006-2007 BiGCaT Bioinformatics
-	//
-//	 Licensed under the Apache License, Version 2.0 (the "License"); 
-//	 you may not use this file except in compliance with the License. 
-//	 You may obtain a copy of the License at 
-//	 
-//	 http://www.apache.org/licenses/LICENSE-2.0 
-//	  
-//	 Unless required by applicable law or agreed to in writing, software 
-//	 distributed under the License is distributed on an "AS IS" BASIS, 
-//	 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-//	 See the License for the specific language governing permissions and 
-//	 limitations under the License.
-	//
-
-package org.pathvisio.gui.swt;
-
-import org.eclipse.jface.action.Action;
-import org.eclipse.jface.resource.ImageDescriptor;
-import org.pathvisio.Engine;
-public class AlignActions {
-
-		
-	public static final char CENTERX = 'x';
-	public static final char CENTERY = 'y';
-	public static final char LEFT = 'l';
-	public static final char RIGHT = 'r';
-	public static final char TOP = 't';
-	public static final char BOTTOM = 'b';
-	public static final char WIDTH = 'w';
-	public static final char HEIGHT = 'h';
-	
-	
-		static class AlignCenterXAction extends Action 
-		{
-			MainWindowBase window;
-			public AlignCenterXAction (MainWindowBase w)
-			{
-				window = w;
-				setToolTipText ("Align horizontal centers");
-				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/aligncenterx.gif")));
-				
-			}
-			public void run () 
-			{
-				
-				Engine.getActiveVPathway().alignSelected(CENTERX);
-				
-			}
-		}
-		
-		static class AlignCenterYAction extends Action 
-		{
-			MainWindowBase window;
-			public AlignCenterYAction (MainWindowBase w)
-			{
-				window = w;
-				setToolTipText ("Align vertical centers");
-				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/aligncentery.gif")));
-				
-			}
-			public void run () 
-			{
-				
-				Engine.getActiveVPathway().alignSelected(CENTERY);
-				
-			}
-		}
-		static class AlignLeftAction extends Action 
-		{
-			MainWindowBase window;
-			public AlignLeftAction (MainWindowBase w)
-			{
-				window = w;
-				setToolTipText ("Align left edges");
-				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/alignleft.gif")));
-				
-			}
-			public void run () 
-			{
-				
-				Engine.getActiveVPathway().alignSelected(LEFT);
-				
-			}
-		}
-		static class AlignRightAction extends Action 
-		{
-			MainWindowBase window;
-			public AlignRightAction (MainWindowBase w)
-			{
-				window = w;
-				setToolTipText ("Align right edges");
-				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/alignright.gif")));
-				
-			}
-			public void run () 
-			{
-				
-				Engine.getActiveVPathway().alignSelected(RIGHT);
-				
-			}
-		}
-		static class AlignTopAction extends Action 
-		{
-			MainWindowBase window;
-			public AlignTopAction (MainWindowBase w)
-			{
-				window = w;
-				setToolTipText ("Align top edges");
-				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/aligntop.gif")));
-				
-			}
-			public void run () 
-			{
-				
-				Engine.getActiveVPathway().alignSelected(TOP);
-				
-			}
-		}
-		static class AlignBottomAction extends Action 
-		{
-			MainWindowBase window;
-			public AlignBottomAction (MainWindowBase w)
-			{
-				window = w;
-				setToolTipText ("Align bottom edges");
-				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/alignbottom.gif")));
-				
-			}
-			public void run () 
-			{
-				
-				Engine.getActiveVPathway().alignSelected(BOTTOM);
-				
-			}
-		}
-		static class SetCommonHeightAction extends Action 
-		{
-			MainWindowBase window;
-			public SetCommonHeightAction (MainWindowBase w)
-			{
-				window = w;
-				setToolTipText ("Set common height");
-				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/sizeheight.gif")));
-				
-			}
-			public void run () 
-			{
-				
-				Engine.getActiveVPathway().scaleSelected(HEIGHT);
-				
-			}
-		}
-		static class SetCommonWidthAction extends Action 
-		{
-			MainWindowBase window;
-			public SetCommonWidthAction (MainWindowBase w)
-			{
-				window = w;
-				setToolTipText ("Set common width");
-				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/sizewidth.gif")));
-				
-			}
-			public void run () 
-			{
-				
-				Engine.getActiveVPathway().scaleSelected(WIDTH);
-				
-			}
-		}
-
-
-	}
-
-
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/BackpagePanel.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/BackpagePanel.java	(revision 960)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/BackpagePanel.java	(revision 961)
@@ -1,296 +0,0 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio.gui.swt;
-
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.util.List;
-
-import org.eclipse.swt.browser.Browser;
-import org.eclipse.swt.layout.FillLayout;
-import org.eclipse.swt.widgets.Composite;
-import org.pathvisio.Engine;
-import org.pathvisio.data.DataSources;
-import org.pathvisio.data.Gdb;
-import org.pathvisio.data.Gex;
-import org.pathvisio.data.Gdb.IdCodePair;
-import org.pathvisio.util.Utils;
-import org.pathvisio.view.GeneProduct;
-import org.pathvisio.view.SelectionBox;
-import org.pathvisio.view.VPathwayElement;
-import org.pathvisio.view.SelectionBox.SelectionEvent;
-import org.pathvisio.view.SelectionBox.SelectionListener;
-
-/**
- * Backpage browser - side panel that shows the backpage information when a GeneProduct is double-clicked
- */
-public class BackpagePanel extends Composite implements SelectionListener {
-	/**
-	 * Directory containing HTML files needed to display the backpage information
-	 */
-	final static String BPDIR = "backpage";
-	/**
-	 * Header file, containing style information
-	 */
-	final static String HEADERFILE = "header.html";
-	
-	/**
-	 * Header for the gene information in HTML format
-	 */
-	final static String bpHeader = "<H1>Gene information</H1><P>";
-	/**
-	 * Header for the expression information in HTML format
-	 */
-	final static String gexHeader = "<H1>Expression data</H1><P>";
-	
-	private String bpText;
-	private String gexText;
-	private String header;
-	
-	private Browser bpBrowser;
-	
-	private GeneProduct geneProduct;
-	
-	/**
-	 * Constructor for this class
-	 * @param parent	Parent {@link Composite} for the Browser widget
-	 * @param style		Style for the Browser widget
-	 */
-	public BackpagePanel(Composite parent, int style) {
-		super(parent, style);
-		
-		initializeHeader(); //Load the header including style information
-		setLayout(new FillLayout());
-		bpBrowser = new Browser(this, style); //Set the Browser widget
-		setGeneText(null);
-		setGexText(null);
-		
-		SelectionBox.addListener(this);
-	}
-	
-	public void setGeneProduct(final GeneProduct gp) 
-	{ 
-		if(geneProduct == gp) return;
-		
-		Thread fetchThread = new Thread() {
-			public void run() {
-				geneProduct = gp;
-				if(gp == null) {
-					setGeneText(null);
-					setGexText(null);
-					return;
-				}
-				// Get the backpage text
-				String geneHeader = geneProduct.getGmmlData().getBackpageHead();
-				if (geneHeader == null) geneHeader = "";
-				String geneId = geneProduct.getGmmlData().getGeneID();
-				String systemCode = geneProduct.getGmmlData().getSystemCode();
-				String bpText = geneHeader.equals("") ? geneHeader : "<H2>" + geneHeader + "</H2><P>";
-				String bpInfo = Gdb.getBpInfo(geneId, systemCode);
-				bpText += bpInfo == null ? "<I>No gene information found</I>" : bpInfo;
-				String crossRefText = getCrossRefText(geneId, systemCode);
-				String gexText = Gex.getDataString(new IdCodePair(geneId, systemCode));
-				if (bpText != null) 	setGeneText(bpText);
-				if (gexText != null)	setGexText(gexText + crossRefText);
-				else 					setGexText("<I>No expression data found</I>");
-			}
-		};
-		
-		//Run in seperate thread so that this method can return
-		fetchThread.start();
-	}
-		
-	public String getCrossRefText(String id, String code) {
-		List<IdCodePair> crfs = Gdb.getCrossRefs(id, code);
-		if(crfs.size() == 0) return "";
-		StringBuilder crt = new StringBuilder("<H1>Cross references</H1><P>");
-		for(IdCodePair cr : crfs) {
-			String idtxt = cr.getId();
-			String url = getCrossRefLink(cr);
-			if(url != null) {
-				int os = Utils.getOS();
-				if(os == Utils.OS_WINDOWS) {
-					//In windows: open in new browser window
-					idtxt = "<a href='" + url + "' target='_blank'>" + idtxt + "</a>";
-				} else {
-					//This doesn't work under ubuntu, so no new windoe there
-					idtxt = "<a href='" + url + "'>" + idtxt + "</a>";
-				}
-				
-			}
-			String dbName = DataSources.sysCode2Name.get(cr.getCode());
-			crt.append( idtxt + ", " + (dbName != null ? dbName : cr.getCode()) + "<br>");
-		}
-		return crt.toString();
-	}
-	
-	String getCrossRefLink(IdCodePair idc) {
-		String c = idc.getCode();
-		String id = idc.getId();
-		if(c.equalsIgnoreCase("En"))
-			return "http://www.ensembl.org/Homo_sapiens/searchview?species=all&idx=Gene&q=" + id;
-		if(c.equalsIgnoreCase("P"))
-			return "http://www.expasy.org/uniprot/" + id;
-		if(c.equalsIgnoreCase("Q")) {
-			String pre = "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?";
-			if(id.startsWith("NM")) {
-				return pre + "db=Nucleotide&cmd=Search&term=" + id;
-			} else {
-				return pre + "db=Protein&cmd=search&term=" + id;
-			}
-		}
-		if(c.equalsIgnoreCase("T"))
-			return "http://godatabase.org/cgi-bin/go.cgi?view=details&search_constraint=terms&depth=0&query=" + id;
-		if(c.equalsIgnoreCase("I"))
-			return "http://www.ebi.ac.uk/interpro/IEntry?ac=" + id;
-		if(c.equalsIgnoreCase("Pd"))
-			return "http://bip.weizmann.ac.il/oca-bin/ocashort?id=" + id;
-		if(c.equalsIgnoreCase("X"))
-			return "http://www.ensembl.org/Homo_sapiens/featureview?type=OligoProbe;id=" + id;
-		if(c.equalsIgnoreCase("Em"))
-			return "http://www.ebi.ac.uk/cgi-bin/emblfetch?style=html&id=" + id;
-		if(c.equalsIgnoreCase("L"))
-			return "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=gene&cmd=Retrieve&dopt=full_report&list_uids=" + id;
-		if(c.equalsIgnoreCase("H"))
-			return "http://www.gene.ucl.ac.uk/cgi-bin/nomenclature/get_data.pl?hgnc_id=" + id;
-		if(c.equalsIgnoreCase("I"))
-			return "http://www.ebi.ac.uk/interpro/IEntry?ac=" + id;
-		if(c.equalsIgnoreCase("M"))
-			return "http://www.informatics.jax.org/searches/accession_report.cgi?id=" + id;
-		if(c.equalsIgnoreCase("Om"))
-			return "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=OMIM&cmd=Search&doptcmdl=Detailed&term=?" + id;
-		if(c.equalsIgnoreCase("Pf"))
-			return "http://www.sanger.ac.uk//cgi-bin/Pfam/getacc?" + id;
-		if(c.equalsIgnoreCase("R"))
-			return "http://rgd.mcw.edu/generalSearch/RgdSearch.jsp?quickSearch=1&searchKeyword=" + id;
-		if(c.equalsIgnoreCase("D"))
-			return "http://db.yeastgenome.org/cgi-bin/locus.pl?locus=" + id;
-		if(c.equalsIgnoreCase("S"))
-			return "http://www.expasy.org/uniprot/" + id;
-		if(c.equalsIgnoreCase("U")) {
-			String [] org_nr = id.split("\\.");
-			if(org_nr.length == 2) {
-				return "http://www.ncbi.nlm.nih.gov/UniGene/clust.cgi?ORG=" + 
-				org_nr[0] + "&CID=" + org_nr[1];
-			}
-			else {
-				return null;
-			}
-		}
-		if (c.equalsIgnoreCase("Nw"))
-		{
-			return "http://nugowiki.org/index.php/" + id;
-		}
-		if (c.equalsIgnoreCase("Ca"))
-		{
-			return "http://chem.sis.nlm.nih.gov/chemidplus/direct.jsp?regno=" + id;
-		}
-		if (c.equalsIgnoreCase("Cp"))
-		{
-			return "http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi?cid=" + id;
-		}
-		if (c.equalsIgnoreCase("Ce"))
-		{
-			return "http://www.ebi.ac.uk/chebi/searchId=CHEBI:" + id;
-		}
-		if (c.equalsIgnoreCase("Ch"))
-		{
-			return "http://www.hmdb.ca/scripts/show_card.cgi?METABOCARD=" + id + ".txt";
-		}
-		if (c.equalsIgnoreCase("Ck"))
-		{
-			return "http://www.genome.jp/dbget-bin/www_bget?cpd:" + id;
-		}
-		return null;
-	}
-	
-	/**
-	 * Sets the text for the Gene information part of the browser. Will be prepended by a paragraph
-	 * header as defined in bpHeader
-	 * @param bpText	Text to display in HTML format
-	 */
-	public void setGeneText(String bpText) {
-		if(bpText == null) { //In case no information has to be displayed
-			this.bpText = bpHeader + "<I>No gene selected</I>";
-		} else {
-			this.bpText = bpHeader + bpText;
-		}
-		refresh();
-	}
-	
-	/**
-	 * Sets the text for the expression part of the browser. Will be prepended by a paragraph
-	 * header as defined in gexHeader
-	 * @param gexText	Text to display in HTML format
-	 */
-	public void setGexText(String gexText) {
-		if(gexText != null) { //In case no information has to be displayed
-			this.gexText = gexHeader + gexText;
-		} else {
-			this.gexText = "";
-		}
-		refresh();
-	}
-	
-	/**
-	 * Refreshes the text displayed in the browser
-	 */
-	public void refresh() {
-		getDisplay().asyncExec(new Runnable() {
-			public void run() {
-				bpBrowser.setText(header + bpText + gexText);	
-			}
-		});
-	}
-	
-	/**
-	 * Reads the header of the HTML content displayed in the browser. This header is displayed in the
-	 * file specified in the {@link HEADERFILE} field
-	 */
-	private void initializeHeader() {
-		try {
-			BufferedReader input = new BufferedReader(new InputStreamReader(
-						Engine.getResourceURL(BPDIR + "/" + HEADERFILE).openStream()));
-			String line;
-			header = "";
-			while((line = input.readLine()) != null) {
-				header += line.trim();
-			}
-		} catch (Exception e) {
-			Engine.log.error("Unable to read header file for backpage browser: " + e.getMessage(), e);
-		}
-	}
-
-	public void drawingEvent(SelectionEvent e) {
-		switch(e.type) {
-		case SelectionEvent.OBJECT_ADDED:
-			//Just take the first GeneProduct in the selection
-			for(VPathwayElement o : e.selection) {
-				if(o instanceof GeneProduct) {
-					if(geneProduct != o) setGeneProduct((GeneProduct)o);
-					break; //Selects the first, TODO: use setGmmlDataObjects
-				}
-			}
-			break;
-		case SelectionEvent.OBJECT_REMOVED:
-			if(e.selection.size() != 0) break;
-		case SelectionEvent.SELECTION_CLEARED:
-			setGeneProduct(null);
-			break;
-		}
-	}
-}
Index: trunk/src/g2d_swt/org/pathvisio/gui/swt/MainWindowBase.java
===================================================================
--- trunk/src/g2d_swt/org/pathvisio/gui/swt/MainWindowBase.java	(revision 960)
+++ trunk/src/g2d_swt/org/pathvisio/gui/swt/MainWindowBase.java	(revision 961)
@@ -36,8 +36,8 @@
 import org.eclipse.swt.widgets.Composite;
 import org.eclipse.swt.widgets.Control;
 import org.eclipse.swt.widgets.Shell;
+import org.pathvisio.ApplicationEvent;
 import org.pathvisio.Engine;
-import org.pathvisio.Engine.ApplicationEvent;
 import org.pathvisio.Engine.ApplicationEventListener;
 import org.pathvisio.data.DBConnector;
 import org.pathvisio.data.Gdb;
Index: trunk/src/g2d/org/pathvisio/view/VPathwayEvent.java
===================================================================
--- trunk/src/g2d/org/pathvisio/view/VPathwayEvent.java	(revision 960)
+++ trunk/src/g2d/org/pathvisio/view/VPathwayEvent.java	(revision 961)
@@ -1,34 +0,0 @@
-package org.pathvisio.view;
-
-import java.util.EventObject;
-
-public class VPathwayEvent extends EventObject {
-	public static final int NEW_ELEMENT_ADDED = 0;
-	public static final int EDIT_MODE_ON = 1;
-	public static final int EDIT_MODE_OFF = 2;
-	
-	int type;
-	VPathwayElement affectedElement;
-	
-	public VPathwayEvent(VPathway source, int type) {
-		super(source);
-		this.type = type;
-	}
-	
-	public VPathwayEvent(VPathway source, VPathwayElement affectedElement, int type) {
-		this(source, type);
-		this.affectedElement = affectedElement;
-	}
-	
-	public VPathwayElement getAffectedElement() {
-		return affectedElement;
-	}
-	
-	public int getType() {
-		return type;
-	}
-	
-	public VPathway getVPathway() {
-		return (VPathway)getSource();
-	}
-}
Index: trunk/src/g2d/org/pathvisio/view/VPathwayListener.java
===================================================================
--- trunk/src/g2d/org/pathvisio/view/VPathwayListener.java	(revision 960)
+++ trunk/src/g2d/org/pathvisio/view/VPathwayListener.java	(revision 961)
@@ -1,5 +0,0 @@
-package org.pathvisio.view;
-
-public interface VPathwayListener {
-	public void vPathwayEvent(VPathwayEvent e);
-}
Index: trunk/src/g2d_plugins/org/pathvisio/visualization/plugins/VisualizationPlugin.java
===================================================================
--- trunk/src/g2d_plugins/org/pathvisio/visualization/plugins/VisualizationPlugin.java	(revision 0)
+++ trunk/src/g2d_plugins/org/pathvisio/visualization/plugins/VisualizationPlugin.java	(revision 961)
@@ -0,0 +1,355 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.plugins;
+
+import java.awt.Graphics2D;
+import java.util.Collection;
+
+import org.eclipse.jface.window.ApplicationWindow;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Shell;
+import org.jdom.Element;
+import org.pathvisio.view.Graphics;
+import org.pathvisio.visualization.Visualization;
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+
+/**
+ * The VisualizationPlugin class can be extended to create a visualization plugin for
+ * the visualization of experimental data on GPML pathways
+ * @author Thomas
+ */
+public abstract class VisualizationPlugin implements Comparable {
+	public static String XML_ELEMENT = "plugin";
+	public static String XML_ATTR_CLASS = "class";
+	
+	protected static final int SIDEPANEL = 2;
+	protected static final int TOOLTIP = 4;
+	protected static final int DRAWING = 8;
+	
+	private int DISPLAY_OPT; //Where on the display cann this plugin be used (SIDEPANEL | TOOLTIP | DRAWING)
+	private boolean CONFIGURABLE; //Configurable (if true, override createConfigComposite)
+	private boolean GENERIC; //For generic use, or expression dataset specific
+	private boolean USE_PROVIDED_AREA; //Does this plugin use reserved region in GmmlGraphicsObject
+	
+	private boolean isActive;
+		
+	private Visualization visualization;
+	
+	/**
+	 * Constructor for this class. Create an instance of this {@link VisualizationPlugin}
+	 * @param v The {@link Visualization} the instance is part of
+	 */
+	public VisualizationPlugin(Visualization v) {
+		visualization = v;
+	}
+	
+	/**
+	 * Get the {@link Visualization} this instance belongs to
+	 * @return The {@link Visualization} this plugin belongs to
+	 */
+	protected final Visualization getVisualization() { return visualization; }
+	
+	/**
+	 * Gets the name of this visualization plugin class
+	 * @return the name of this visualization plugin class
+	 */
+	public abstract String getName();
+	
+	/**
+	 * Gets the description of this visualization plugin class
+	 * @return the description of this visualization plugin class
+	 */
+	public abstract String getDescription();
+	
+	//TODO: Update javadoc
+	/**
+	 * Create a visualization on the pathway drawing for the given {@link Graphics} object.
+	 * This method will only be called when the plugin display options contains {@link VisualizationPlugin#DRAWING}.
+	 * @param g	The {@link Graphics} object on which the visualization applies
+	 * @param e	{@link PaintEvent} containing information about the paint
+	 * @param gc Graphical context on which drawing operations can be performed
+	 * @see <a href=http://www.eclipse.org/articles/Article-SWT-graphics/SWT_graphics.html>
+	 * Introduction in SWT graphics</a>
+	 */
+	public abstract void visualizeOnDrawing(Graphics g, Graphics2D g2d);
+	
+	/**
+	 * Create a visualization on the side panel for the given {@link Graphics} objects
+	 * This method will only be called when the plugin display options contains {@link VisualizationPlugin#SIDEPANEL}.
+	 * @param objects List of {@link Graphics} objects to create the visualization for
+	 */
+	public abstract void visualizeOnSidePanel(Collection<Graphics> objects);
+	
+	/**
+	 * Create a visualization on the Tool Tip for the given {@link Graphics} object.
+	 * This method will only be called when the plugin display options contains {@link VisualizationPlugin#TOOLTIP}.
+	 * @param parent The parent of the {@link Composite} that will be displayed on the Tool Tip
+	 * @param g The {@link Graphics} object to create the visualization for
+	 * @return A {@link Composite} that will be displayed in the Tool Tip
+	 */
+	public abstract Composite visualizeOnToolTip(Composite parent, Graphics g);
+	
+	/**
+	 * Initialize a Composite for visualization on the side panel
+	 * This method will only be called when the plugin display options contains {@link VisualizationPlugin#SIDEPANEL}.
+	 * @param parent The parent of the new {@link Composite}
+	 */
+	public abstract void initSidePanel(Composite parent);
+	
+	/**
+	 * Create a {@link Composite} that is displayed in the legend for every plug-in that is
+	 * activated on the pathway drawing.
+	 * This method may be overridden if the plug-in needs to show a legend item when it is
+	 * active on the pathway drawing.
+	 * @param parent The parent of the new {@link Composite} to return
+	 * @return A {@link Composite} that displays the legend information for this plug-in
+	 */
+	public Composite createLegendComposite(Composite parent) {
+		return null;
+	}
+	
+	/**
+	 * Create a {@link Composite} that can be used to configure this visualization plugin
+	 * Override this method when the visualization plugin can be configured by the user
+	 * @see  VisualizationPlugin#isConfigurable() VisualizationPlugin#openConfigDialog(Shell)
+	 * @param parent The parent of the {@link Composite} to create
+	 * @return A {@link Composite} that will be displayed when the user wants to configure the plugin
+	 */
+	protected Composite createConfigComposite(Composite parent) {
+		return new Composite(parent, SWT.NULL); //Empty composite
+	}
+	
+	/**
+	 * Opens the configuration dialog (only when isConfigurable returnst true) that
+	 * will display the {@link Composite} created in {@link VisualizationPlugin#createConfigComposite(Composite)}.
+	 * @param shell The parent {@link Shell} of the dialog to open
+	 */
+	public final void openConfigDialog(Shell shell) {
+		if(!CONFIGURABLE) return; //Not configurable, so don't open config dialog
+		ApplicationWindow d = new ConfigurationDialog(shell);
+		d.open();
+	}
+	
+	
+	/**
+	 * Save the configuration of the current instance of this class to an XML element.<br>
+	 * Override this method to save custom configuration settings:<br>
+	 * <code>
+	 * public Element toXML() {								<br>
+	 * &nbsp;Element elm = super.toXML();					<br>
+	 * &nbsp;//Add custom attributes and elements to elm, e.g.:	<br>
+	 * &nbsp;elm.setAttribute("fontsize", fontsize)			<br>
+	 * <br>
+	 * &nbsp;return elm;									<br>
+	 * }
+	 * </code>
+	 */
+	public Element toXML() {
+		Element elm = new Element(XML_ELEMENT);
+		elm.setAttribute(XML_ATTR_CLASS, getClass().getCanonicalName());
+		return elm;
+	}
+	
+	/**
+	 * Load the configuration of the current instance of this class from an XML element.<br>
+	 * Override this method to load custom configuration settings:<br>
+	 * <code>
+	 * public Element loadXML(Element xml) {				<br>
+	 * &nbsp;super.loadXML(xml)								<br>
+	 * &nbsp;//Load custom attributes and elements to elm, e.g.:	<br>
+	 * &nbsp;fontSize = xml.getAttributeValue("fontsize")			<br>
+	 * }
+	 * </code>
+	 * @param xml The {@link Element} that contains the configuration for this plugin
+	 */
+	public void loadXML(Element xml) { }
+	
+	/**
+	 * Returns whether the current instance of this visualization plugin is activated or not
+	 * @return true if this instance is activated, false otherwise
+	 */
+	public final boolean isActive() { return isActive; }
+	
+	/**
+	 * Set the activation state of this instance. If set to active, the visualization methods
+	 * of this plugin will be called from the {@link Visualization} this instance belongs to.
+	 * @param active true to activate this instance, false to de-activate
+	 */
+	public final void setActive(boolean active) { 
+		if(isActive != active) {
+			isActive = active;
+			fireModifiedEvent();
+		}	
+	}
+	
+	/**
+	 * Returns whether this plugin can be displayed in the side panel
+	 * @return true when this plugin can be displayed in the side panel, false otherwise
+	 */
+	public final boolean canSidePanel() { return (DISPLAY_OPT & SIDEPANEL) != 0; }
+	
+	/**
+	 * Returns whether this plugin can be displayed in the Tool Tip
+	 * @return true when this plugin can be displayed in the Tool Tip, false otherwise
+	 */
+	public final boolean canToolTip() { return (DISPLAY_OPT & TOOLTIP) != 0; }
+	
+	/**
+	 * Returns whether this plugin can be displayed in the pathway drawing
+	 * @return true when this plugin can be displayed in the pathway drawing, false otherwise
+	 */
+	public final boolean canDrawing() { return (DISPLAY_OPT & DRAWING) != 0; }
+	
+	/**
+	 * Specify where this plugin can be displayed.
+	 * One of:<BR><UL>
+	 * <LI><CODE>DRAWING</CODE>: this plugin implements visualization on drawing objects
+	 * <LI><CODE>TOOLTIP</CODE>: this plugins implements visualization in the tooltip showed
+	 * when hovering over GeneProducts
+	 * <LI><CODE>SIDEPANEL</CODE>: this plugin implements visualization to be displayed in the side panel
+	 * </UL><BR>
+	 * When multiple visualization options are implemented, 
+	 * use bitwise OR (e.g. <CODE>SIDEPANEL | DRAWING</CODE>)
+	 * @param options
+	 */
+	protected void setDisplayOptions(int options) {
+		DISPLAY_OPT = options;
+	}
+	
+	/**
+	 * Specify whether the parent {@link Visualization} needs to provide an area on the 
+	 * {@link Graphics} objects.
+	 * When multiple visualization plugins apply visualizations on the same {@link Graphics}
+	 * object, the available space will be divided over the plugins for which this method is called
+	 * with true as argument.
+	 * The provided area can be obtained by calling {@link Visualization#provideDrawArea(VisualizationPlugin, Graphics)}
+	 * @param use	true if this plugin uses the provided area, false if not
+	 * @see Visualization#provideDrawArea(VisualizationPlugin, Graphics)
+	 */
+	protected void setUseProvidedArea(boolean use) {
+		USE_PROVIDED_AREA = use;
+	}
+	
+	/**
+	 * Specify whether this visualization plugin is configurable or not.
+	 * When the plugin is set to be configurable, override {@link VisualizationPlugin#createConfigComposite(Composite)}.
+	 * @param configurable
+	 * @see VisualizationPlugin#createConfigComposite(Composite)
+	 */
+	protected void setIsConfigurable(boolean configurable) {
+		CONFIGURABLE = configurable;
+	}
+	
+	/**
+	 * Specify whether this visualization plugin is generic or not.
+	 * Generic plugins are independent of expression data. Non-generic plugin configurations
+	 * depend on an expression dataset and will be loaded/saved together with this expression dataset.
+	 * @param generic true if this plugin is generic, false otherwise
+	 */
+	protected void setIsGeneric(boolean generic) {
+		GENERIC = generic;
+	}
+	
+	/**
+	 * Returns whether this visualiazation plugin is generic or not
+	 * Generic plugins are independent of expression data. Non-generic plugin configurations
+	 * depend on an expression dataset and will be loaded/saved together with this expression dataset.
+	 * @see VisualizationPlugin#setIsGeneric(boolean)
+	 * @return true if this plugin is generic, false otherwise
+	 */
+	public final boolean isGeneric() { return GENERIC; }
+	
+	/**
+	 * Returns whether this visualization plugin is configurable or not
+	 * @see VisualizationPlugin#setIsConfigurable(boolean)
+	 * @return true if this plugin is configurable, false otherwise
+	 */
+	public final boolean isConfigurable() { return CONFIGURABLE; }
+	
+	/**
+	 * Returns whether this visualization plugin uses the area provided by
+	 * the {@link Visualization} it belongs to.
+	 * @see VisualizationPlugin#setUseProvidedArea(boolean)
+	 * @return true if this plugin uses the provided area, false otherwise
+	 */
+	public final boolean isUseProvidedArea() { 
+		return USE_PROVIDED_AREA; 
+	}
+		
+	/**
+	 * Fire a {@link VisualizationEvent} with type {@link VisualizationEvent#PLUGIN_MODIFIED}
+	 */
+	protected final void fireModifiedEvent() {
+		VisualizationManager.fireVisualizationEvent(
+				new VisualizationEvent(this, VisualizationEvent.PLUGIN_MODIFIED));
+	}
+	
+	/**
+	 * The configuration dialog that displays the configuration settings for a 
+	 * visualization plugin
+	 * @author Thomas
+	 */
+	private class ConfigurationDialog extends ApplicationWindow {
+		public ConfigurationDialog(Shell shell) {
+			super(shell);
+			setBlockOnOpen(true);
+		}
+		
+		public Control createContents(Composite parent) {
+			Composite contents = new Composite(parent, SWT.NULL);
+			contents.setLayout(new GridLayout());
+			
+			Composite config = createConfigComposite(contents);
+			config.setLayoutData(new GridData(GridData.FILL_BOTH));
+			
+			Composite buttonComp = createButtonComposite(contents);
+			buttonComp.setLayoutData(new GridData(GridData.HORIZONTAL_ALIGN_END));
+			
+			return contents;
+		}
+		
+		public Composite createButtonComposite(Composite parent) {
+			Composite comp = new Composite(parent, SWT.NULL);
+			comp.setLayout(new GridLayout(2, false));
+			
+			Button ok = new Button(comp, SWT.PUSH);
+			ok.setText(" Ok ");
+			ok.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent arg0) {
+					close();
+				}
+			});
+			
+			return comp;
+		}
+	}
+	
+	public int compareTo(Object o) {
+		if(o instanceof VisualizationPlugin)
+			return getName().compareTo(((VisualizationPlugin)o).getName());
+		return -1;
+	}
+}

Property changes on: trunk/src/g2d_plugins/org/pathvisio/visualization/plugins/VisualizationPlugin.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/g2d_plugins/org/pathvisio/visualization/plugins/PluginManager.java
===================================================================
--- trunk/src/g2d_plugins/org/pathvisio/visualization/plugins/PluginManager.java	(revision 0)
+++ trunk/src/g2d_plugins/org/pathvisio/visualization/plugins/PluginManager.java	(revision 961)
@@ -0,0 +1,326 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.plugins;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.FilenameFilter;
+import java.io.IOException;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Modifier;
+import java.net.JarURLConnection;
+import java.net.URL;
+import java.net.URLDecoder;
+import java.util.Enumeration;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.jar.JarFile;
+import java.util.zip.ZipEntry;
+
+import org.jdom.Document;
+import org.jdom.Element;
+import org.jdom.input.SAXBuilder;
+import org.jdom.output.Format;
+import org.jdom.output.XMLOutputter;
+import org.pathvisio.Engine;
+import org.pathvisio.data.Gex;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.util.Utils;
+import org.pathvisio.visualization.Visualization;
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+
+public abstract class PluginManager {
+	//static final String PLUGIN_PKG = "org.pathvisio.visualization.plugins";
+	//static final String PKG_DIR = PLUGIN_PKG.replace('.', '/');
+	static final String FILE_ADD_PLUGINS = "visplugins.xml";
+	static final String XML_ELEMENT = "additional-plugins";
+	static final String XML_ELM_PLUGIN = "plugin";
+	static final String XML_ATTR_URL = "url";
+	
+	static Document addDoc;
+	static final Set<Class> plugins = new LinkedHashSet<Class>();
+	
+	public static VisualizationPlugin getInstance(Class pluginClass, Visualization v) throws Throwable {
+		Constructor c = pluginClass.getConstructor(new Class[] { Visualization.class });
+		return (VisualizationPlugin)c.newInstance(new Object[] { v });
+	}
+		
+	public static VisualizationPlugin instanceFromXML(Element xml, Visualization v) throws Throwable {
+		String className = xml.getAttributeValue(VisualizationPlugin.XML_ATTR_CLASS);
+		
+		if(className == null) throw new IllegalArgumentException(
+				"Element has no '" + VisualizationPlugin.XML_ATTR_CLASS + "' attribute");
+		
+		Class pluginClass = Class.forName(className);
+		VisualizationPlugin p = getInstance(pluginClass, v);
+		p.loadXML(xml);
+		return p;
+	}
+	
+	public static Class[] getPlugins() {
+		return Gex.isConnected() ?
+				plugins.toArray(new Class[plugins.size()]) :
+				getGenericPlugins();
+	}
+	
+	public static Class[] getGenericPlugins() {
+		Set<Class> generic = new LinkedHashSet<Class>();
+		for(Class pc : plugins) {
+			if(isGeneric(pc)) generic.add(pc);
+		}
+		return generic.toArray(new Class[generic.size()]);
+	}
+	
+	public static boolean isGeneric(Class pluginClass) {
+		try {
+			return getInstance(pluginClass, null).isGeneric();
+		} catch(Throwable e) { 
+			e.printStackTrace();
+			Engine.log.error("Unable to determine if plugin is generic", e);
+			return false; 
+		}
+	}
+	
+	public static String[] getPluginNames() {
+		String[] names = new String[plugins.size()];
+		int i = 0;
+		for(Class p : plugins) {
+			names[i++] = getPluginName(p);
+		}
+		return names;
+	}
+	
+	public static String getPluginName(Class pluginClass) {
+		try {
+			VisualizationPlugin p = getInstance(pluginClass, null);
+			return p.getName();
+		} catch(Throwable e) {
+			Engine.log.error("Unable to get plugin name for " + pluginClass, e);
+			return pluginClass.getName();
+		}
+	}
+
+	public static void loadPlugins() throws Throwable {	
+		Engine.log.trace("> Loading visualization plugins");
+		Enumeration<URL> resources = 
+			SwtEngine.class.getClassLoader().getResources(".");
+        while (resources.hasMoreElements()) {
+        	URL url = resources.nextElement();
+        	Engine.log.trace("visualization.plugins package found in: " + url);
+        	try {
+        		loadPlugin(url);
+        	} catch(Throwable e) {
+        		Engine.log.error("Error when loading plugins from " + url, e);
+        	}
+        }
+        loadAdditional();
+  	}
+	    
+	static void loadPlugin(File f) throws Throwable {
+			loadPlugin(f.toURL());
+	}
+	
+	public static void loadAdditionalPlugin(File file) throws Throwable {
+		loadPlugin(file);
+		saveAdditional(file.toURL());
+		VisualizationManager.fireVisualizationEvent(
+				new VisualizationEvent(PluginManager.class, VisualizationEvent.PLUGIN_ADDED));
+	}
+		
+	static void loadPlugin(URL url) throws Throwable {
+    	if(url.getProtocol().equals("jar")) {
+    		loadFromJar(url);
+    	} else if(url.getProtocol().equals("file")) {
+    		File f = new File(url.getFile());
+    		if(f.getName().endsWith(".jar")) 
+    			loadFromJar(url);
+    		else loadFromDir(url);
+    	}
+		else Engine.log.error("Unable to load additional plugin", new Exception("Unsupported URL protocol"));
+	}
+	
+	static Document getAdditionalXML() {
+		if(addDoc == null) {
+			File f = new File(SwtEngine.getApplicationDir(), FILE_ADD_PLUGINS);
+			if(!f.exists()) {
+				return createXML();
+			} else {
+				SAXBuilder parser = new SAXBuilder();
+				try {
+					Document doc = parser.build(f);
+					return doc;
+				} catch(Exception e) {
+					Engine.log.error("Unable to load additional plugins file", e);
+					return createXML();
+				}
+			}
+		} else return addDoc;
+		
+	}
+	
+	static Document createXML() {
+		Document doc = new Document();
+		doc.setRootElement(new Element(XML_ELEMENT));
+		return doc;
+	}
+
+	static void loadAdditional() {
+		Document doc = getAdditionalXML();
+		Element root = doc.getRootElement();
+		for(Object o : root.getChildren(XML_ELM_PLUGIN)) {
+			URL url = null;
+			try {
+				url = new URL(((Element)o).getAttributeValue(XML_ATTR_URL));
+				loadPlugin(new File(url.getFile()));
+			} catch(Throwable ex) {
+				Engine.log.error("Unable to load additional plugin", ex);
+				if(url != null) removeAdditional(url);
+			}
+		}
+	}
+	
+	static void saveAdditional(URL url) {
+		Document doc = getAdditionalXML();
+		Element root = doc.getRootElement();
+		
+		if(containsElement(root, url)) return;
+		
+		Element elm = new Element(XML_ELM_PLUGIN);
+		elm.setAttribute(XML_ATTR_URL, url.toString());
+		root.addContent(elm);
+		saveXML(doc);
+	}
+	
+	static void removeAdditional(URL url) {
+		Document doc = getAdditionalXML();
+		Element root = doc.getRootElement();
+		
+		Element toRemove = null;
+		for(Object o : root.getChildren(XML_ELM_PLUGIN)) {
+			Element e = (Element) o;
+			String url1 = e.getAttributeValue(XML_ATTR_URL);
+			if(url1.equals(url.toString())) {
+				toRemove = e;
+				break;
+			}
+		}
+		root.removeContent(toRemove);
+		saveXML(doc);
+	}
+	
+	static void saveXML(Document doc) {
+		XMLOutputter out = new XMLOutputter(Format.getPrettyFormat());
+		try {
+			FileWriter fw = new FileWriter(new File(SwtEngine.getApplicationDir(), FILE_ADD_PLUGINS));
+			out.output(doc, fw);
+			fw.close();
+		} catch(IOException e) {
+			Engine.log.error("Unable to save additional plugins", e);
+		}
+	}
+	
+	static boolean containsElement(Element root, URL url) {
+		for(Object o : root.getChildren(XML_ELM_PLUGIN)) {
+			String url1 = ((Element)o).getAttributeValue(XML_ATTR_URL);
+			if(url1.equals(url.toString())) return true;
+		}
+		return false;
+	}
+	
+	static void loadFromDir(URL url) throws Throwable {
+		Engine.log.trace("\tLoading from directory " + url);
+		File directory = new File(URLDecoder.decode(url.getPath(), "UTF-8"));
+		if (directory.exists()) {
+           processFile(directory, directory.toString());
+        }
+	}
+	
+	static private void processFile(File f, String base) throws Throwable {
+		if(f.isDirectory()) {
+			File[] files = f.listFiles();
+            for (File file : files)
+            	processFile(file, base);
+		} else {
+			String fn = f.toString();
+			if(fn.endsWith(".class") && !fn.contains("$")) { //Ignore inner classes for now
+				String cn = fn.substring(base.length() + 1);
+				cn = removeClassExt(cn.replace('/', '.'));
+				addPlugin(Class.forName(cn, false, SwtEngine.class.getClassLoader()));
+			}
+		}
+	}
+	static void loadFromJar(URL url) throws Throwable {
+		Engine.log.trace("\tLoading from jar connection " + url);
+		JarFile f = null;
+		if(url.getProtocol().equals("jar")) {
+			JarURLConnection conn = (JarURLConnection)url.openConnection();
+			f = conn.getJarFile();
+		} else {
+			f = new JarFile(url.getFile());
+		}
+		loadFromJar(f);
+	}
+		
+	static void loadFromJar(JarFile jfile) throws Throwable {
+		Throwable error = null;
+		Engine.log.trace("\tLoading from jar file " + jfile);
+		Enumeration e = jfile.entries();
+		while (e.hasMoreElements()) {
+			ZipEntry entry = (ZipEntry)e.nextElement();
+			Engine.log.trace("Checking " + entry);
+			String entryname = entry.getName();
+			if(entryname.endsWith(".class")) {
+				try {
+					String cn = removeClassExt(entryname.replace('/', '.').replace('$', '.'));
+					Class pluginClass = Class.forName(cn);
+					addPlugin(pluginClass);
+				} catch(Throwable ex) {
+					Engine.log.error("Unable to load plugin", ex);
+					error = ex;
+				}
+			}
+		}
+		if(error != null) throw error;
+	}
+	
+	static String removeClassExt(String fn) {
+		return fn.substring(0, fn.length() - 6);
+	}
+	
+	static void addPlugin(Class c) {
+		Engine.log.trace("\t\tTrying to add " + c);
+		if(isPlugin(c)) {
+			Engine.log.trace("\t\t\t!> Adding " + c);
+			plugins.add(c);
+		}
+	}
+	
+	static boolean isPlugin(Class c) {
+		if(Modifier.isAbstract(c.getModifiers())) {
+			Engine.log.trace("\t\t> Class " + c + " is not a visualization plugin (is abstract)");
+			return false;
+		}
+		return Utils.isSubClass(c, VisualizationPlugin.class);
+	}
+			
+	static  FilenameFilter classFilter = new FilenameFilter() {
+		public boolean accept(File f, String name) {
+			return name.endsWith(".class");
+		}
+    };
+}

Property changes on: trunk/src/g2d_plugins/org/pathvisio/visualization/plugins/PluginManager.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/visualization/Visualization.java
===================================================================
--- trunk/src/swt/org/pathvisio/visualization/Visualization.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/visualization/Visualization.java	(revision 961)
@@ -0,0 +1,612 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.events.ShellAdapter;
+import org.eclipse.swt.events.ShellEvent;
+import org.eclipse.swt.graphics.GC;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.graphics.Region;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.layout.RowLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.Group;
+import org.eclipse.swt.widgets.Listener;
+import org.eclipse.swt.widgets.Shell;
+import org.jdom.Element;
+import org.pathvisio.Engine;
+import org.pathvisio.data.Gex;
+import org.pathvisio.data.Gex.ExpressionDataEvent;
+import org.pathvisio.data.Gex.ExpressionDataListener;
+import org.pathvisio.util.Utils;
+import org.pathvisio.view.Graphics;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+import org.pathvisio.visualization.VisualizationManager.VisualizationListener;
+import org.pathvisio.visualization.plugins.PluginManager;
+import org.pathvisio.visualization.plugins.VisualizationPlugin;
+
+/**
+ * Represents a set of configured visualization plugins
+ * @author thomas
+ */
+public class Visualization implements ExpressionDataListener, VisualizationListener {
+	public static final String XML_ELEMENT = "visualization";
+	public static final String XML_ATTR_NAME = "name";
+	
+	String name;
+	HashMap<Class, PluginSet> plugins;
+	List<PluginSet> pluginPlacement;
+	
+	Composite sidePanel;
+	
+	/**
+	 * Constructor for this class. Creates an instance of {@link Visualization} with the
+	 * given name
+	 * @param name The name of this {@link Visualization}
+	 */
+	public Visualization(String name) {
+		initPlugins();
+		this.name = name;
+		Gex.addListener(this);
+		VisualizationManager.addListener(this);
+	}
+	
+	/**
+	 * Create initial instances of {@link PluginSet} for each visualization
+	 * plugin class
+	 */
+	void initPlugins() {
+		plugins = new HashMap<Class, PluginSet>();
+		pluginPlacement = new ArrayList<PluginSet>();
+		for(Class c : PluginManager.getPlugins()) {
+			addPluginClass(c);
+		}
+	}
+	
+	/**
+	 * Refresh the available subclasses of {@link VisualizationPlugin}.
+	 */
+	void refreshPluginClasses() {
+		for(Class c : PluginManager.getPlugins()) {
+			if(!plugins.containsKey(c)) {
+				addPluginClass(c);
+			}
+		}
+	}
+	
+	/**
+	 * Add a subclass of {@link VisualizationPlugin} to the available
+	 * visualization plugin classes
+	 * @param c	The class of the visualization plugin to add
+	 */
+	void addPluginClass(Class c) {
+		try {
+			PluginSet pr = new PluginSet(c, this);
+			plugins.put(c, pr);
+			pluginPlacement.add(pr);
+		} catch(Throwable e) {
+			Engine.log.error("Unable to create instance of plugin " + c, e);
+		}
+	}
+
+	/**
+	 * Get the name of this {@link Visualization}
+	 * @return the name
+	 */
+	public String getName() { return name; }
+	
+	/**
+	 * Set the name of this {@link Visualization}
+	 * @param name the name for this visualization
+	 */
+	public void setName(String name) { 
+		this.name = name;
+		fireVisualizationEvent(VisualizationEvent.VISUALIZATION_MODIFIED);
+	}
+	
+	/**
+	 * Fire an {@link VisualizationEvent} for this visualization and the given type
+	 * @param type The type of the {@link VisualizationEvent} to fire
+	 */
+	private final void fireVisualizationEvent(int type) {
+		VisualizationManager.fireVisualizationEvent(
+				new VisualizationEvent(this, type));
+	}
+	
+	/**
+	 * Returnts whether this visualization is generic or not. A visualization is
+	 * generic only if all of its active plugins are generic.
+	 * @see VisualizationPlugin#isGeneric()
+	 * @return true if this visualization is generic, false otherwise
+	 */
+	public boolean isGeneric() {
+		for(PluginSet pr : getPluginSets())
+			if(pr.isActive() && !pr.isGeneric()) return false; //One or more active non-generic plugins, so not generic
+		return true;
+	}
+	
+	/**
+	 * Get the {@link PluginSet}s of this visualization
+	 * @return An ordered list of {@link PluginSet}s
+	 */
+	public List<PluginSet> getPluginSets() {
+		return pluginPlacement;
+	}
+	
+	/**
+	 * Get the {@link PluginSet} for the given plugin class
+	 */
+	public PluginSet getPluginSet(Class c) {
+		return plugins.get(c);
+	}
+	
+	/**
+	 * Set the {@link PluginSet} for the given subclass of {@link VisualizationPlugin}
+	 * @param pluginClass	The class to set the given {@link PluginSet} for
+	 * @param ps			The {@link PluginSet} to set
+	 */
+	private void setPluginSet(Class pluginClass, PluginSet ps) {
+		pluginPlacement.remove(ps);
+		plugins.put(pluginClass, ps);
+		pluginPlacement.add(ps);
+		fireVisualizationEvent(VisualizationEvent.VISUALIZATION_MODIFIED);
+	}
+	
+	/**
+	 * Draw this visualization to the pathway drawing for the given {@link Graphics} object.
+	 * @see VisualizationPlugin#visualizeOnDrawing(Graphics, PaintEvent, GC)
+	 * @param g	The {@link Graphics} object the visualization applies to
+	 * @param e	{@link PaintEvent} containing information about the paint
+	 * @param gc Graphical context on which drawing operations can be performed
+	 */
+	public void visualizeDrawing(Graphics g, PaintEvent e, GC gc) {
+		for(PluginSet pr : getPluginSetsDrawingOrder()) {
+			if(pr.isDrawing()) pr.getDrawingPlugin().visualizeOnDrawing(g, e, gc);
+		}
+	}
+	
+	/**
+	 * Provide an drawing area on the given Graphics for the given VisualizationPlugin (only
+	 * when {@link VisualizationPlugin#isUseProvidedArea()})
+	 * @param p the VisualizationPlugin to provide the area for
+	 * @param g the Graphics on which the area is created
+	 * @return An {@link Region} object that contains the area in which the
+	 * VisualizationPlugin can draw its visualization
+	 */
+	public Region provideDrawArea(VisualizationPlugin p, Graphics g) {
+		if(!p.isUseProvidedArea()) 
+			throw new IllegalArgumentException("useProvidedArea set to false for this plug-in");
+		
+		//Determine number of active plugins that to reserve a region
+		int nrRes = 0;
+		int index = 0;
+		for(PluginSet pr : getPluginSetsDrawingOrder()) {
+			if(pr.getDrawingPlugin() == p) index = nrRes;
+			nrRes += (pr.getDrawingPlugin().isActive() && pr.getDrawingPlugin().isUseProvidedArea()) ? 1 : 0;
+		}
+		
+		Region region = g.createVisualizationRegion();
+		//Distribute space over plugins
+		Rectangle bounds = region.getBounds();
+		
+		//Adjust width so we can divide into equal rectangles
+		bounds.width += bounds.width % nrRes;
+		int w = bounds.width / nrRes;
+		bounds.x += w * index;
+		bounds.width = w;
+		
+		
+		region.intersect(bounds);
+		return region;
+	}
+	
+	/**
+	 * Set the display order of the given plugin-set. {@link Utils#ORDER_FIRST} makes the
+	 * plug-in to be drawn last (so displayed on top of the visualization).
+	 * @param pr The plugin-set to set the drawing order for
+	 * @param order The order constant (as specified in {@link Utils#changeOrder(List, Object, int)}
+	 * @see Utils#changeOrder(List, Object, int)
+	 */
+	public void setDisplayOrder(PluginSet pr, int order) {
+		Utils.changeOrder(pluginPlacement, pr, order);
+		fireVisualizationEvent(VisualizationEvent.VISUALIZATION_MODIFIED);
+	}
+	
+	/**
+	 * Get the plugin-sets in the order of which they are to be drawn
+	 * @return a list of plugin-sets in the order of which they are to be drawn
+	 */
+	public List<PluginSet> getPluginSetsDrawingOrder() {
+		List<PluginSet> sorted = new ArrayList<PluginSet>(pluginPlacement);
+		Collections.reverse(sorted);
+		return sorted;
+	}
+	
+	/**
+	 * Update the side-panel for all plug-ins that are activated
+	 * in the side-panel to visualize the given pathway elements
+	 * @param objects The pathway elements to visualize
+	 */
+	void visualizeSidePanel(Collection<Graphics> objects) {
+		for(PluginSet pr : getPluginSetsDrawingOrder()) {
+			if(pr.isSidePanel())
+				pr.getSidePanelPlugin().visualizeOnSidePanel(objects);
+		}
+	}
+	
+	/**
+	 * Create the side-panel composite for plug-ins that are activated
+	 * in the side-panel.
+	 * @param parent The parent Composite to create the new Composite on
+	 * @return A Composite that displays the side-panel visualization for the plug-ins
+	 * that are activated in the side-panel
+	 */
+	Composite createSideSidePanel(Composite parent) {
+		sidePanel = new Composite(parent, SWT.NULL);
+		sidePanel.setLayout(new FillLayout(SWT.VERTICAL));
+		
+		for(PluginSet pr : getPluginSetsDrawingOrder()) {
+			if(pr.isSidePanel()) {
+				Group group = new Group(sidePanel, SWT.NULL);
+				group.setBackground(group.getDisplay().getSystemColor(SWT.COLOR_WHITE));
+				group.setLayout(new FillLayout());
+				group.setText(pr.getSidePanelPlugin().getName());
+				pr.getSidePanelPlugin().initSidePanel(group);
+			}
+		}
+		return sidePanel;
+	}
+	
+	/**
+	 * Disposes the side-panel composite created with {@link #createSideSidePanel(Composite)}
+	 */
+	void disposeSidePanel() {
+		if(sidePanel != null && !sidePanel.isDisposed())
+			sidePanel.dispose();
+	}
+	
+	/**
+	 * Checks whether this visualization has one or more plug-ins activated on
+	 * the tool-tip
+	 * @return true if one or more plug-ins are activated on the tool-tip, false if not
+	 */
+	public boolean usesToolTip() {
+		for(PluginSet pr : pluginPlacement) {
+			if(pr.isToolTip()) return true;
+		}
+		return false;
+	}
+	
+	/**
+	 * Create a tool-tip for the given pathway element
+	 * @param parent The parent shell
+	 * @param control The control on which the tool-tip is created
+	 * @param g The pathway element to create the tool-tip for
+	 * @return A tool-tip that displays visualizations for the given gene-product 
+	 * by the plug-ins activated on the tool-tip
+	 */
+	public Shell visualizeToolTip(Shell parent, Control control, Graphics g) {
+		final Shell tip = new Shell(parent, SWT.ON_TOP | SWT.TOOL);  
+		tip.setBackground(parent.getDisplay().getSystemColor(SWT.COLOR_INFO_BACKGROUND));
+		tip.setLayout(new RowLayout(SWT.VERTICAL));
+		
+		Listener hideListener = new Listener() {
+			public void handleEvent(Event event) {
+	 			switch (event.type) {
+	 			case SWT.MouseDown:
+	 			case SWT.MouseExit:
+	 			case SWT.MouseMove:
+	 			case SWT.FocusOut:
+	 				tip.dispose();
+	 			}
+			}
+		};
+		
+		tip.addListener(SWT.MouseDown, hideListener);
+		tip.addListener(SWT.MouseExit, hideListener);
+		control.addListener(SWT.MouseMove, hideListener);
+		parent.addShellListener(new ShellAdapter() {
+			public void shellClosed(ShellEvent e) {
+				tip.dispose();	
+			}
+			public void shellDeactivated(ShellEvent e) {
+				tip.dispose();
+			}
+		});
+				
+		boolean hasOne = false;
+		for(PluginSet pr : getPluginSetsDrawingOrder()) {
+			if(pr.isToolTip()) {
+				Composite ttc = pr.getToolTipPlugin().visualizeOnToolTip(tip, g);
+				if(ttc != null) hasOne = true;
+			}
+		}
+		tip.pack();
+		return hasOne ? tip : null;
+	}
+	
+	/**
+	 * Save the information to re-build this visualization to an
+	 * XML element
+	 * @return The XML element containing the information to re-build this visualization
+	 */
+	public Element toXML() {
+		Element vis = new Element(XML_ELEMENT);
+		vis.setAttribute(XML_ATTR_NAME, getName());
+		for(PluginSet pr : pluginPlacement)
+			if(pr.isActive()) 
+				vis.addContent(pr.toXML());
+		return vis;
+	}
+	
+	/**
+	 * Re-build a visualization based on the information in the given XML element
+	 * @param xml The XML element that contains the information to re-build the visualization
+	 * @return The visualization that is re-build based on the information in the XML element
+	 */
+	public static Visualization fromXML(Element xml) {
+		String name = xml.getAttributeValue(XML_ATTR_NAME);
+		if(name == null) name = VisualizationManager.getNewName();
+		
+		Visualization v = new Visualization(name);
+		for(Object o : xml.getChildren(PluginSet.XML_ELEMENT)) {
+			try {
+				PluginSet pr = PluginSet.fromXML((Element)o, v);
+				v.setPluginSet(pr.getClass(), pr);
+			} catch(Throwable e) {
+				Engine.log.error("Unable to load plugin", e);
+			}
+		}		
+		return v;
+	}
+	
+	public boolean equals(Object o) {
+		if(o instanceof Visualization) return ((Visualization)o).getName().equals(name);
+		return false;
+	}
+
+	public void expressionDataEvent(ExpressionDataEvent e) {
+		switch(e.type) {
+		case ExpressionDataEvent.CONNECTION_OPENED:
+			refreshPluginClasses();
+		}
+		
+	}
+
+	public void visualizationEvent(VisualizationEvent e) {
+		switch(e.type) {
+		case VisualizationEvent.PLUGIN_ADDED: 
+			refreshPluginClasses();
+			break;
+		}
+	}
+	
+	/**
+	 * Set of instances from subclass of {@link VisualizationPlugin} (all instances
+	 * have the same class).
+	 * The set contains one instance for each display option (drawing, side panel, tool tip)
+	 * @author Thomas
+	 */
+	public static class PluginSet {
+		static final int NR = 3; //Number of display options
+		static final int TOOLTIP = 0;
+		static final int DRAWING = 1;
+		static final int SIDEPANEL = 2;
+		
+		Visualization vis;
+		Class pluginClass;
+		VisualizationPlugin[] reps;
+		
+		private PluginSet(Visualization v) {
+			vis = v;
+			reps = new VisualizationPlugin[NR];
+		}
+		
+		/**
+		 * Constructor for this class
+		 * @param pluginClass The class of the plug-in this set will contain
+		 * @param v The visualization this plugin-set belongs to
+		 * @throws Throwable
+		 */
+		public PluginSet(Class pluginClass, Visualization v) throws Throwable {
+			this(v);
+			this.pluginClass = pluginClass;
+			for(int i = 0; i < NR; i++) {
+				reps[i] = PluginManager.getInstance(pluginClass, v);
+			}
+		}
+		
+		void setPluginClass(Class pluginClass) throws Throwable {
+			this.pluginClass = pluginClass;
+			for(int i = 0; i < reps.length; i++) {
+				if(reps[i] == null || !pluginClass.isInstance(reps[i]))
+					reps[i] = PluginManager.getInstance(pluginClass, vis);
+			}
+		}
+		
+		void setPlugin(VisualizationPlugin p, int representation) throws Throwable {
+			p.setActive(true);
+			reps[representation] = p;
+			if(pluginClass == null || !pluginClass.equals(p.getClass())) 
+				setPluginClass(p.getClass());
+		}
+		
+		void checkIndex(int index) {
+			if(index < 0 || index > reps.length) 
+				throw new IllegalArgumentException("invalid representation index");
+		}
+		
+		/**
+		 * Get the plug-in instance that will be used for visualization on the pahtway drawing
+		 * @return The plug-in instance for visualization on the drawing
+		 */
+		public VisualizationPlugin getDrawingPlugin() { return reps[DRAWING]; }
+		/**
+		 * Get the plug-in instance that will be used for visualization on the pahtway tool-tip
+		 * @return The plug-in instance for visualization on the tool-tip
+		 */
+		public VisualizationPlugin getToolTipPlugin() { return reps[TOOLTIP]; }
+		/**
+		 * Get the plug-in instance that will be used for visualization on the pahtway side-panel
+		 * @return The plug-in instance for visualization on the side-panel
+		 */
+		public VisualizationPlugin getSidePanelPlugin() { return reps[SIDEPANEL]; }
+		
+		/**
+		 * Get the plug-in instance for the given representation
+		 * @param representation one of {@link #TOOLTIP}, {@link #SIDEPANEL}, {@link #DRAWING})
+		 * @return The instance of the plug-in for the given representation
+		 */
+		public VisualizationPlugin getPlugin(int representation) { 
+			checkIndex(representation);
+			return reps[representation]; 
+		}
+		
+		/**
+		 * Get an instance of the plugin-class this plugin-set contains.
+		 * Convenience method to query information about the plug-in, don't use
+		 * the instance for visualization!
+		 * @return An instance of the plugin-class
+		 */
+		VisualizationPlugin getInstance() { return reps[0]; }
+		
+		/**
+		 * Check whether one or more of the plug-ins in this set are activated
+		 * @return true if one or more of the plug-ins are activated, false if not
+		 * @see VisualizationPlugin#isActive()
+		 */
+		public boolean isActive() {
+			for(VisualizationPlugin p : reps) 
+				if(p.isActive()) return true;
+			return false;
+		}
+		
+		/**
+		 * Check whether all plug-ins in this set are generic
+		 * @return true if all plug-ins in this set are generic, false if not
+		 * @see VisualizationPlugin#isGeneric()
+		 */
+		public boolean isGeneric() {
+			for(VisualizationPlugin p : reps) 
+				if(!p.isGeneric()) return false;
+			return true;
+		}
+		
+		/**
+		 * Check whether the pathway drawing representation in this set is activated
+		 * @return true if the drawing representation is active, false if not
+		 */
+		public boolean isDrawing() { return getDrawingPlugin().isActive(); }
+		/**
+		 * Check whether the side-panel representation in this set is activated
+		 * @return true if the sice-panel representation is active, false if not
+		 */
+		public boolean isSidePanel() { return getSidePanelPlugin().isActive(); }
+		/**
+		 * Check whether the tool-tip representation in this set is activated
+		 * @return true if the tool-tip representation is active, false if not
+		 */
+		public boolean isToolTip() { return getToolTipPlugin().isActive(); }
+
+		/**
+		 * Set the activation state of the instance of the plug-in for the given representaion
+		 * @param representation The representation (one of {@link #DRAWING}, {@link #SIDEPANEL}, {@link #TOOLTIP})
+		 * @param active true to activate, false to de-activate
+		 */
+		public void setActive(int representation, boolean active) {
+			checkIndex(representation);
+			reps[representation].setActive(active);
+			if(representation == SIDEPANEL) VisualizationManager.fireVisualizationEvent(
+					new VisualizationEvent(this, VisualizationEvent.PLUGIN_SIDEPANEL_ACTIVATED));
+		}
+		
+		static final String XML_ELEMENT = "plugin-representations";
+		static final String XML_ATTR_CLASS = "class";
+		static final String XML_ELM_DRAWING = "drawing";
+		static final String XML_ELM_TOOLTIP = "tooltip";
+		static final String XML_ELM_SIDEPANEL = "sidepanel";
+		
+		/**
+		 * Save the information to re-build this plugin-ste to an
+		 * XML element
+		 * @return The XML element containing the information to re-build this plugin-set
+		 */
+		public Element toXML() {
+			Element e = new Element(XML_ELEMENT);
+			e.setAttribute(XML_ATTR_CLASS, pluginClass.getCanonicalName());		 
+			
+			if(reps[DRAWING].isActive()) {
+				Element dr = new Element(XML_ELM_DRAWING);
+				dr.addContent(reps[DRAWING].toXML());
+				e.addContent(dr);
+			}
+			if(reps[SIDEPANEL].isActive()) {
+				Element sp = new Element(XML_ELM_SIDEPANEL);
+				sp.addContent(reps[SIDEPANEL].toXML());
+				e.addContent(sp);
+			}
+			if(reps[TOOLTIP].isActive()) { 
+				Element tt = new Element(XML_ELM_TOOLTIP);
+				tt.addContent(reps[TOOLTIP].toXML());
+				e.addContent(tt);
+			}
+			return e;
+		}
+		
+		/**
+		 * Re-build a plugin-set based on the information in the given XML element
+		 * @param xml The XML element that contains the information to re-build the plugin-set
+		 * @return The plugin-set that is re-build based on the information in the XML element
+		 */
+		public static PluginSet fromXML(Element xml, Visualization v) throws Throwable {
+			PluginSet pr = new PluginSet(v);
+			
+			Element drawing = xml.getChild(XML_ELM_DRAWING);
+			Element tooltip = xml.getChild(XML_ELM_TOOLTIP);
+			Element sidepanel = xml.getChild(XML_ELM_SIDEPANEL);
+			if(drawing != null) 
+				pr.setPlugin(PluginManager.instanceFromXML(
+						drawing.getChild(VisualizationPlugin.XML_ELEMENT), v), DRAWING);
+			if(tooltip != null)
+				pr.setPlugin(PluginManager.instanceFromXML(
+						tooltip.getChild(VisualizationPlugin.XML_ELEMENT), v), TOOLTIP);
+			if(sidepanel != null)
+				pr.setPlugin(PluginManager.instanceFromXML(
+						sidepanel.getChild(VisualizationPlugin.XML_ELEMENT), v), SIDEPANEL);
+			return pr;
+		}
+		
+		public int hashCode() {
+			return pluginClass.hashCode();
+		}
+		public boolean equals(Object obj) {
+			if(obj instanceof PluginSet) 
+				return pluginClass.equals(((PluginSet)obj).pluginClass);
+			return false;
+		}
+	}
+}

Property changes on: trunk/src/swt/org/pathvisio/visualization/Visualization.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/visualization/VisualizationDialog.java
===================================================================
--- trunk/src/swt/org/pathvisio/visualization/VisualizationDialog.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/visualization/VisualizationDialog.java	(revision 961)
@@ -0,0 +1,664 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization;
+
+import java.io.File;
+import java.util.List;
+
+import org.eclipse.jface.dialogs.IInputValidator;
+import org.eclipse.jface.dialogs.InputDialog;
+import org.eclipse.jface.dialogs.MessageDialog;
+import org.eclipse.jface.viewers.CellEditor;
+import org.eclipse.jface.viewers.CheckboxCellEditor;
+import org.eclipse.jface.viewers.ICellModifier;
+import org.eclipse.jface.viewers.ILabelProviderListener;
+import org.eclipse.jface.viewers.ISelectionChangedListener;
+import org.eclipse.jface.viewers.IStructuredContentProvider;
+import org.eclipse.jface.viewers.IStructuredSelection;
+import org.eclipse.jface.viewers.ITableLabelProvider;
+import org.eclipse.jface.viewers.LabelProvider;
+import org.eclipse.jface.viewers.ListViewer;
+import org.eclipse.jface.viewers.SelectionChangedEvent;
+import org.eclipse.jface.viewers.StructuredSelection;
+import org.eclipse.jface.viewers.TableViewer;
+import org.eclipse.jface.viewers.Viewer;
+import org.eclipse.jface.window.ApplicationWindow;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.CTabFolder;
+import org.eclipse.swt.custom.CTabItem;
+import org.eclipse.swt.custom.StackLayout;
+import org.eclipse.swt.events.ModifyEvent;
+import org.eclipse.swt.events.ModifyListener;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.events.SelectionListener;
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.layout.RowLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.FileDialog;
+import org.eclipse.swt.widgets.Group;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Shell;
+import org.eclipse.swt.widgets.Table;
+import org.eclipse.swt.widgets.TableColumn;
+import org.eclipse.swt.widgets.TableItem;
+import org.eclipse.swt.widgets.Text;
+import org.pathvisio.Engine;
+import org.pathvisio.data.Gex;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.util.TableColumnResizer;
+import org.pathvisio.util.Utils;
+import org.pathvisio.visualization.Visualization.PluginSet;
+import org.pathvisio.visualization.colorset.ColorSetComposite;
+import org.pathvisio.visualization.plugins.PluginManager;
+
+/**
+ * Dialog to configure visualizations
+ * @author thomas
+ *
+ */
+public class VisualizationDialog extends ApplicationWindow {
+	VisualizationSettings settingsComp;
+	Composite noneSelectedComp;
+	
+	StackLayout settingsStack;
+	ListViewer visList;
+	
+	Color nonGenericColor;
+	Color genericColor;
+	
+	int tabItemOnOpen = 0;
+	
+	public static final int TABITEM_VISUALIZATIONS = 0;
+	public static final int TABITEM_COLORSETS = 1;
+	final String[] tabItemNames = new String[] {
+		"Visualizations", "Color sets"	
+	};
+	final String[] columnNames = new String[] {
+			"Name", "Drawing", "Side panel", "Tooltip"
+	};
+	final String[] columnTips = new String[] {
+			"Plugin name",
+			"Show this plugin on drawing", "Show this plugin in side panel", 
+			"Show this plugin in tooltip"
+	};
+	
+	public VisualizationDialog(Shell shell) {
+		super(shell);
+		setBlockOnOpen(true);
+	}
+	
+	public boolean close() {
+		Gex.saveXML();
+		return super.close();
+	}
+	
+	public void setTabItemOnOpen(int index) {
+		tabItemOnOpen = index;
+	}
+	
+	public Control createContents(Composite parent) {
+		Shell shell = getShell();
+		shell.setSize(700, 600);
+		
+		Composite content = new Composite(parent, SWT.NULL);
+		content.setLayout(new GridLayout());
+		
+		CTabFolder tabs = new CTabFolder(content, SWT.BORDER);
+		tabs.setSimple(false);
+		tabs.setSelectionBackground(new Color[] {
+				tabs.getSelectionBackground(),
+				tabs.getDisplay().getSystemColor(SWT.COLOR_WIDGET_BACKGROUND) }, 
+				new int[] { 100 }, true);
+		CTabItem visTab = new CTabItem(tabs, SWT.NULL);
+		visTab.setControl(createVisualizationComp(tabs));
+		visTab.setText(tabItemNames[0]);
+
+		if(Gex.isConnected()) {
+			CTabItem colorTab = new CTabItem(tabs, SWT.NULL);
+			colorTab.setControl(new ColorSetComposite(tabs, SWT.NULL));
+			colorTab.setText(tabItemNames[1]);
+		}
+
+		tabs.setLayoutData(new GridData(GridData.FILL_BOTH));
+		
+		final Button ok = new Button(content, SWT.NULL);
+		ok.setText("  Ok  ");
+		ok.addSelectionListener(new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				close();
+			}
+		});
+		ok.setLayoutData(new GridData(GridData.HORIZONTAL_ALIGN_END));
+		
+		Visualization v = VisualizationManager.getCurrent();
+		if(v != null) visList.setSelection(new StructuredSelection(v));
+		
+		tabs.setSelection(tabItemOnOpen);
+		content.setFocus();
+		return tabs;
+	}
+
+	Composite createVisualizationComp(Composite parent) {
+		Composite content = new Composite(parent, SWT.NULL);
+		content.setLayout(new GridLayout(2, false));
+		
+		createVisualizationsList(content);
+		Composite rightComp = new Composite(content, SWT.NULL);
+		rightComp.setLayoutData(new GridData(GridData.FILL_BOTH));
+		
+		settingsStack = new StackLayout();
+		rightComp.setLayout(settingsStack);
+		createNoneSelectedComp(rightComp);
+		settingsComp = new VisualizationSettings(rightComp, SWT.NULL);
+		settingsStack.topControl = noneSelectedComp;
+		
+		return content;
+	}
+	
+	private void createNoneSelectedComp(Composite parent) {
+		noneSelectedComp = new Composite(parent, SWT.NULL);
+		RowLayout layout = new RowLayout(SWT.VERTICAL);
+		layout.justify = true;
+		layout.marginLeft = 30;
+		noneSelectedComp.setLayout(layout);
+		Label l = new Label(noneSelectedComp, SWT.CENTER | SWT.WRAP);
+		l.setText("No visualization selected, click 'Add' to add a visualization or select " +
+				"one from the list to configure");
+	}
+	
+	private void createVisualizationsList(Composite parent) {
+		Composite comp = new Composite(parent, SWT.NULL);
+		comp.setLayoutData(new GridData(GridData.FILL_VERTICAL));
+		comp.setLayout(new GridLayout());
+		
+		Label label = new Label(comp, SWT.CENTER);
+		label.setText("Visualizations");
+		
+		visList = new ListViewer(comp, SWT.SINGLE | SWT.BORDER);
+		visList.getList().setLayoutData(new GridData(GridData.FILL_BOTH));
+		setListProviders();
+		setListListeners();
+				
+		Composite bComp = new Composite(comp, SWT.NULL);
+		bComp.setLayout(new RowLayout(SWT.HORIZONTAL));
+		final Button add = new Button(bComp, SWT.PUSH);
+		add.setText("Add");
+		add.addSelectionListener(new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				newVisualization();
+			}
+		});
+		final Button remove = new Button(bComp, SWT.PUSH);
+		remove.setText("Remove");
+		remove.addSelectionListener(new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				removeVisualization(visList.getList().getSelectionIndex());
+			}
+		});
+		bComp.pack();
+	}
+	
+	private void setListProviders() {
+		visList.setLabelProvider(new LabelProvider() {
+			public String getText(Object element) {
+				return ((Visualization)element).getName();
+			}
+		});
+		visList.setContentProvider(new IStructuredContentProvider() {
+			public Object[] getElements(Object input) {
+				return ((List)input).toArray();
+			}
+			public void dispose() {}
+			public void inputChanged(Viewer v, Object oldInput, Object newInput) {}
+			
+		});
+		visList.setInput(VisualizationManager.getVisualizations()); 
+	}
+	
+	private void setListListeners() {
+		visList.addSelectionChangedListener(new ISelectionChangedListener() {
+			public void selectionChanged(SelectionChangedEvent e) {
+				Visualization v = getSelectedVisualization();
+				VisualizationManager.setCurrent(v);
+				showVisualizationSettings(v);
+			}
+		});
+	}
+	
+	private void showVisualizationSettings(Visualization v) {
+		if(v == null) hideVisualizationSettings();
+		settingsStack.topControl = settingsComp;
+		((Composite)settingsComp.getParent()).layout();
+		settingsComp.setInput(v);
+	}
+	
+	private void hideVisualizationSettings() {
+		settingsStack.topControl = noneSelectedComp;
+		((Composite)noneSelectedComp.getParent()).layout();
+	}
+	
+	private void newVisualization() {
+		InputDialog d = new InputDialog(getShell(), 
+				"New visualization", "Name: ",
+				VisualizationManager.getNewName(), new IInputValidator() {
+					public String isValid(String name) {
+						return VisualizationManager.nameExists(name) ? "Name already exists" : null;
+					}
+		});
+		if(d.open() == InputDialog.OK) {
+			Visualization v = new Visualization(d.getValue());
+			VisualizationManager.addVisualization(v);
+			visList.refresh();
+			visList.setSelection(new StructuredSelection(v));
+		}
+	}
+	
+	private void removeVisualization(int index) {
+		VisualizationManager.removeVisualization(index);
+		visList.refresh();
+	}
+		
+	private Visualization getSelectedVisualization() {
+		return (Visualization)
+		((IStructuredSelection)visList.getSelection()).getFirstElement();
+	}
+	
+	TableViewer pluginTable;
+	class VisualizationSettings extends Composite {		
+		Visualization input;
+		Text nameText;
+		Label description;
+		Button ttConfig, drConfig, spConfig, firstButton, upButton, downButton, lastButton;
+		
+		VisualizationSettings(Composite parent, int style) {
+			super(parent, style);
+			createContents();
+		}
+		
+		void createContents() {
+			setLayoutData(new GridData(GridData.FILL_BOTH));
+			setLayout(new GridLayout());
+			
+			createNameComposite(this);
+			Group pluginGroup = new Group(this, SWT.NULL);
+			pluginGroup.setLayout(new FillLayout());
+			pluginGroup.setLayoutData(new GridData(GridData.FILL_BOTH));
+			pluginGroup.setText("Visualization plugins");
+			createPluginComp(pluginGroup);
+		}
+		
+		void createNameComposite(Composite parent) {
+			Composite comp = new Composite(parent, SWT.NULL);
+			comp.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+			comp.setLayout(new GridLayout(2, false));
+			Label l = new Label(comp, SWT.NULL);
+			l.setText("Name: ");
+			nameText = new Text(comp, SWT.SINGLE | SWT.BORDER);
+			nameText.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+			nameText.addModifyListener(new ModifyListener() {
+				public void modifyText(ModifyEvent e) {
+					if(input != null) {
+						input.setName(nameText.getText());
+						visList.update(input, null);
+					}
+				}
+			});
+		}
+		
+		void createPluginComp(Composite parent) {
+			Composite comp = new Composite(parent, SWT.NULL);
+			comp.setLayout(new GridLayout(2, false));
+			
+			pluginTable = new TableViewer(createPluginTable(comp));
+			pluginTable.setContentProvider(new IStructuredContentProvider() {
+				public Object[] getElements(Object input) {
+					return ((Visualization)input).getPluginSets().toArray();
+				}
+				public void dispose() {}
+				public void inputChanged(Viewer arg0, Object arg1, Object arg2) {}
+			});
+			pluginTable.setLabelProvider(new PluginTableLabelProvider());
+			pluginTable.setCellModifier(new PluginTableModifier());
+			CellEditor[] editors = new CellEditor[columnNames.length];
+			editors[0] = null;
+			editors[1] = editors[2] = editors[3] = new CheckboxCellEditor();
+			pluginTable.setCellEditors(editors);
+			pluginTable.setColumnProperties(columnNames);
+			
+			pluginTable.addSelectionChangedListener(new ISelectionChangedListener() {
+				public void selectionChanged(SelectionChangedEvent event) {
+					PluginSet p = getSelectedPluginSet();
+					description.setText(p == null ? "" : p.getInstance().getDescription());
+					layout(true, true);
+					setPluginButtonsEnabled(true);
+				}
+			});
+			
+			createPluginButtonComp(comp);
+			
+			Composite descrComp = createDescriptionComp(comp);
+			GridData span = new GridData(GridData.FILL_HORIZONTAL);
+			span.horizontalSpan= 2;
+			descrComp.setLayoutData(span);
+
+			Button loadJar = new Button(comp, SWT.NULL);
+			loadJar.setText("Load plugin");
+			loadJar.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					loadPluginJar();
+				}
+			});
+		}
+		
+		Composite createDescriptionComp(Composite parent) {
+			Group group = new Group(parent, SWT.NULL);
+			group.setLayout(new FillLayout());
+			group.setText("Plugin description");
+			description = new Label(group, SWT.NULL);
+			return group;
+		}
+		
+		Composite createPluginButtonComp(Composite parent) {
+			Composite comp = new Composite(parent, SWT.NULL);
+			comp.setLayout(new RowLayout(SWT.VERTICAL));
+			
+			createPluginConfigGroup(comp);
+			
+			Group group = new Group(comp, SWT.NULL);
+			group.setText("Drawing order");
+			RowLayout rl = new RowLayout(SWT.VERTICAL);
+			rl.fill = true;
+			group.setLayout(rl);
+			firstButton = new Button(group, SWT.PUSH);
+			firstButton.setText("First");
+			firstButton.addSelectionListener(getDrawingOrderListener());
+			upButton = new Button(group, SWT.PUSH);
+			upButton.setText("Up");
+			upButton.addSelectionListener(getDrawingOrderListener());
+			downButton = new Button(group, SWT.PUSH);
+			downButton.setText("Down");
+			downButton.addSelectionListener(getDrawingOrderListener());
+			lastButton = new Button(group, SWT.PUSH);
+			lastButton.setText("Last");
+			lastButton.addSelectionListener(getDrawingOrderListener());
+			
+			setPluginButtonsEnabled(false);
+			return comp;
+		}
+		
+		Composite createPluginConfigGroup(Composite parent) {
+			Group configGroup = new Group(parent, SWT.NULL);
+			configGroup.setText("Selected plugin configuration");
+			RowLayout rl = new RowLayout(SWT.VERTICAL);
+			rl.fill = true;
+			configGroup.setLayout(rl);
+			
+			drConfig = new Button(configGroup, SWT.PUSH);
+			drConfig.setText("Drawing object...");
+			ttConfig = new Button(configGroup, SWT.PUSH);
+			ttConfig.setText("Tool tip...");
+			spConfig = new Button(configGroup, SWT.PUSH);
+			spConfig.setText("Side panel...");
+			
+			SelectionAdapter sa = new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					if		(e.widget == drConfig) 
+						openPluginConfiguration(PluginSet.DRAWING);
+					else if	(e.widget == ttConfig) 
+						openPluginConfiguration(PluginSet.TOOLTIP);
+					else if	(e.widget == spConfig) 
+						openPluginConfiguration(PluginSet.SIDEPANEL);
+					pluginTable.refresh();
+				}
+			};
+			
+			drConfig.addSelectionListener(sa);
+			ttConfig.addSelectionListener(sa);
+			spConfig.addSelectionListener(sa);
+			return configGroup;
+		}
+		
+		SelectionListener getDrawingOrderListener() {
+			return new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					Visualization v = getSelectedVisualization();
+					PluginSet ps = getSelectedPluginSet();
+					if(ps == null || v == null) return; //Shouldn't happen
+					
+					int order = 0;
+					if		(e.widget == firstButton)
+						order = Utils.ORDER_FIRST;
+					else if (e.widget == lastButton)
+						order = Utils.ORDER_LAST;
+					else if (e.widget == upButton) 
+						order = Utils.ORDER_UP;
+					else if (e.widget == downButton) 
+						order = Utils.ORDER_DOWN;
+					v.setDisplayOrder(ps, order);
+					pluginTable.refresh();
+					colorPluginTable();
+				}
+			};
+		}
+				
+		void loadPluginJar() {
+			FileDialog fd = new FileDialog(getShell());
+			fd.setFilterExtensions(new String[] { "*.jar" });
+			fd.setFilterNames(new String[] { "jar file" });
+			String jar = fd.open();
+			if(jar != null) {
+				try {
+					PluginManager.loadAdditionalPlugin(new File(jar));
+					pluginTable.refresh();
+				} catch(Throwable e) {
+					MessageDialog.openError(getShell(), "Unable to load plugin", e.toString() + "\n" + e.getMessage());
+					Engine.log.error("Unable to load plugin", e);
+				}
+			}
+		}
+		
+		void setPluginButtonsEnabled(boolean enable) {
+			
+			PluginSet ps = getSelectedPluginSet();
+		
+			setConfigButtonsEnabled(enable, ps);
+			setOrderButtonsEnabled(enable);
+		}
+		
+		void setConfigButtonsEnabled(boolean doEnable, PluginSet ps) {
+			if(ps == null) {
+				drConfig.setEnabled(false);
+				ttConfig.setEnabled(false);
+				spConfig.setEnabled(false);
+			} else {
+				doEnable = doEnable && ps.getInstance().isConfigurable();
+				drConfig.setEnabled(doEnable && ps.isDrawing());
+				ttConfig.setEnabled(doEnable && ps.isToolTip());
+				spConfig.setEnabled(doEnable && ps.isSidePanel());
+			}
+		}
+		
+		void setOrderButtonsEnabled(boolean enable) {
+			firstButton.setEnabled(enable);
+			upButton.setEnabled(enable);
+			downButton.setEnabled(enable);
+			lastButton.setEnabled(enable);
+		}
+		
+		PluginSet getSelectedPluginSet() {
+			return (PluginSet)
+				((IStructuredSelection)pluginTable.getSelection()).getFirstElement();
+		}
+		
+		void openPluginConfiguration(int representation) {
+			PluginSet ps = getSelectedPluginSet();
+			if(ps.isActive()) 
+				ps.getPlugin(representation).openConfigDialog(getShell());
+		}
+		
+		Table createPluginTable(Composite parent) {
+			Composite tableComp = new Composite(parent, SWT.NULL);
+			tableComp.setLayoutData(new GridData(GridData.FILL_BOTH));
+			tableComp.setLayout(new FillLayout());
+			Table t = new Table(tableComp, SWT.BORDER | SWT.FULL_SELECTION);
+			t.setHeaderVisible(true);
+				
+			int[] alignment = new int[] { 
+					SWT.LEFT, SWT.CENTER,
+					SWT.CENTER, SWT.CENTER, SWT.CENTER };
+			boolean[] resizable = new boolean[] { 
+					true, false,
+					false, false, false };
+			int[] width = new int[] {
+					50, 60, 60, 78, 60
+			};
+			for(int i = 0; i < columnNames.length; i++) {
+				TableColumn tc = new TableColumn(t, alignment[i]);
+				tc.setText(columnNames[i]);
+				tc.setToolTipText(columnTips[i]);
+				tc.setWidth(width[i]);
+				tc.setResizable(resizable[i]);
+			}
+				
+			t.addControlListener(new TableColumnResizer(t, tableComp));
+			return t;
+		}
+		
+		void setInput(Visualization v) { 
+			input = v;
+			refresh();
+		}
+		
+		void refresh() {
+			if(input != null) {
+				nameText.setText(input.getName());
+				pluginTable.setInput(input);
+				colorPluginTable();
+			} else {
+				nameText.setText("");
+				pluginTable.setInput(null);
+				hideVisualizationSettings();
+			}
+		}
+		
+	}
+	
+	void colorPluginTable() {
+		if(genericColor == null) 
+			genericColor = pluginTable.getTable().getBackground();
+		if(nonGenericColor == null) 
+			nonGenericColor = pluginTable.getTable().getDisplay().getSystemColor(
+					SWT.COLOR_INFO_BACKGROUND);
+		for(TableItem ti : pluginTable.getTable().getItems()) {			
+			PluginSet ps = (PluginSet)ti.getData();
+			ti.setBackground(ps.isGeneric() ? genericColor : nonGenericColor);
+		}
+	}
+	
+	class PluginTableLabelProvider implements ITableLabelProvider {
+		final Image checkTrue = SwtEngine.getImageRegistry().get("checkbox.checked");
+		final Image checkFalse = SwtEngine.getImageRegistry().get("checkbox.unchecked");
+		final Image checkUnavailable = SwtEngine.getImageRegistry().get("checkbox.unavailable");
+		
+		public String getColumnText(Object element, int columnIndex) {
+			PluginSet ps = (PluginSet)element;
+			
+			if(columnIndex == 0) return ps.getInstance().getName();
+			return null;
+		}
+
+		public Image getColumnImage(Object element, int columnIndex) {
+			PluginSet ps = (PluginSet)element;
+			
+			switch(columnIndex) {
+			case 1: 
+				if(ps.getInstance().canDrawing())
+					return ps.isDrawing() ? checkTrue : checkFalse;
+				else return checkUnavailable;
+			case 2: 
+				if(ps.getInstance().canSidePanel()) 
+					return ps.isSidePanel() ? checkTrue : checkFalse;
+				else return checkUnavailable;
+			case 3: 
+				if(ps.getInstance().canToolTip())
+					return ps.isToolTip() ? checkTrue : checkFalse;
+				else return checkUnavailable;
+			default: return null; 
+			}
+		}
+		
+		public void addListener(ILabelProviderListener arg0) { }
+		
+		public void dispose() {	}
+		public boolean isLabelProperty(Object arg0, String arg1) { return false; }
+		public void removeListener(ILabelProviderListener arg0) { }		
+	}
+	
+	class PluginTableModifier implements ICellModifier {
+		public boolean canModify(Object element, String property) {
+			PluginSet ps = (PluginSet)element;
+			int index = getColumnIndex(property);
+			switch(index) {
+			case 0: return false;
+			case 1: return ps.getInstance().canDrawing();
+			case 2: return ps.getInstance().canSidePanel();
+			case 3: return ps.getInstance().canToolTip();
+			default: return false;
+			}
+		}
+
+		public Object getValue(Object element, String property) {
+			PluginSet ps = (PluginSet)element;
+			int index = getColumnIndex(property);
+			switch(index) {
+			case 0: return ps.getInstance().getName();
+			case 1: return ps.isDrawing();
+			case 2: return ps.isSidePanel();
+			case 3: return ps.isToolTip();
+			default: return null; //Shouldn't happen
+			}
+		}
+
+		public void modify(Object element, String property, Object value) {
+			int index = getColumnIndex(property);
+			TableItem ti = (TableItem) element;
+			PluginSet ps = (PluginSet) ti.getData();
+
+			switch(index) {
+			case 1: ps.setActive(PluginSet.DRAWING, (Boolean)value); break;
+			case 2: ps.setActive(PluginSet.SIDEPANEL, (Boolean)value); break;
+			case 3: ps.setActive(PluginSet.TOOLTIP, (Boolean)value); break;
+			}
+			
+			pluginTable.refresh();
+		}
+	}
+	
+	int getColumnIndex(String property) {
+		for(int i = 0; i < columnNames.length; i++) 
+			if(columnNames[i].equals(property)) return i;
+		return -1;
+	}
+
+}

Property changes on: trunk/src/swt/org/pathvisio/visualization/VisualizationDialog.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/visualization/plugins/VisualizationPlugin.java
===================================================================
--- trunk/src/swt/org/pathvisio/visualization/plugins/VisualizationPlugin.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/visualization/plugins/VisualizationPlugin.java	(revision 961)
@@ -0,0 +1,355 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.plugins;
+
+import java.util.Collection;
+
+import org.eclipse.jface.window.ApplicationWindow;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.graphics.GC;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Shell;
+import org.jdom.Element;
+
+import org.pathvisio.view.Graphics;
+import org.pathvisio.visualization.Visualization;
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+
+/**
+ * The VisualizationPlugin class can be extended to create a visualization plugin for
+ * the visualization of experimental data on GPML pathways
+ * @author Thomas
+ */
+public abstract class VisualizationPlugin implements Comparable {
+	public static String XML_ELEMENT = "plugin";
+	public static String XML_ATTR_CLASS = "class";
+	
+	protected static final int SIDEPANEL = 2;
+	protected static final int TOOLTIP = 4;
+	protected static final int DRAWING = 8;
+	
+	private int DISPLAY_OPT; //Where on the display cann this plugin be used (SIDEPANEL | TOOLTIP | DRAWING)
+	private boolean CONFIGURABLE; //Configurable (if true, override createConfigComposite)
+	private boolean GENERIC; //For generic use, or expression dataset specific
+	private boolean USE_PROVIDED_AREA; //Does this plugin use reserved region in GmmlGraphicsObject
+	
+	private boolean isActive;
+		
+	private Visualization visualization;
+	
+	/**
+	 * Constructor for this class. Create an instance of this {@link VisualizationPlugin}
+	 * @param v The {@link Visualization} the instance is part of
+	 */
+	public VisualizationPlugin(Visualization v) {
+		visualization = v;
+	}
+	
+	/**
+	 * Get the {@link Visualization} this instance belongs to
+	 * @return The {@link Visualization} this plugin belongs to
+	 */
+	protected final Visualization getVisualization() { return visualization; }
+	
+	/**
+	 * Gets the name of this visualization plugin class
+	 * @return the name of this visualization plugin class
+	 */
+	public abstract String getName();
+	
+	/**
+	 * Gets the description of this visualization plugin class
+	 * @return the description of this visualization plugin class
+	 */
+	public abstract String getDescription();
+	
+	/**
+	 * Create a visualization on the pathway drawing for the given {@link Graphics} object.
+	 * This method will only be called when the plugin display options contains {@link VisualizationPlugin#DRAWING}.
+	 * @param g	The {@link Graphics} object on which the visualization applies
+	 * @param e	{@link PaintEvent} containing information about the paint
+	 * @param gc Graphical context on which drawing operations can be performed
+	 * @see <a href=http://www.eclipse.org/articles/Article-SWT-graphics/SWT_graphics.html>
+	 * Introduction in SWT graphics</a>
+	 */
+	public abstract void visualizeOnDrawing(Graphics g, PaintEvent e, GC gc);
+	
+	/**
+	 * Create a visualization on the side panel for the given {@link Graphics} objects
+	 * This method will only be called when the plugin display options contains {@link VisualizationPlugin#SIDEPANEL}.
+	 * @param objects List of {@link Graphics} objects to create the visualization for
+	 */
+	public abstract void visualizeOnSidePanel(Collection<Graphics> objects);
+	
+	/**
+	 * Create a visualization on the Tool Tip for the given {@link Graphics} object.
+	 * This method will only be called when the plugin display options contains {@link VisualizationPlugin#TOOLTIP}.
+	 * @param parent The parent of the {@link Composite} that will be displayed on the Tool Tip
+	 * @param g The {@link Graphics} object to create the visualization for
+	 * @return A {@link Composite} that will be displayed in the Tool Tip
+	 */
+	public abstract Composite visualizeOnToolTip(Composite parent, Graphics g);
+	
+	/**
+	 * Initialize a Composite for visualization on the side panel
+	 * This method will only be called when the plugin display options contains {@link VisualizationPlugin#SIDEPANEL}.
+	 * @param parent The parent of the new {@link Composite}
+	 */
+	public abstract void initSidePanel(Composite parent);
+	
+	/**
+	 * Create a {@link Composite} that is displayed in the legend for every plug-in that is
+	 * activated on the pathway drawing.
+	 * This method may be overridden if the plug-in needs to show a legend item when it is
+	 * active on the pathway drawing.
+	 * @param parent The parent of the new {@link Composite} to return
+	 * @return A {@link Composite} that displays the legend information for this plug-in
+	 */
+	public Composite createLegendComposite(Composite parent) {
+		return null;
+	}
+	
+	/**
+	 * Create a {@link Composite} that can be used to configure this visualization plugin
+	 * Override this method when the visualization plugin can be configured by the user
+	 * @see  VisualizationPlugin#isConfigurable() VisualizationPlugin#openConfigDialog(Shell)
+	 * @param parent The parent of the {@link Composite} to create
+	 * @return A {@link Composite} that will be displayed when the user wants to configure the plugin
+	 */
+	protected Composite createConfigComposite(Composite parent) {
+		return new Composite(parent, SWT.NULL); //Empty composite
+	}
+	
+	/**
+	 * Opens the configuration dialog (only when isConfigurable returnst true) that
+	 * will display the {@link Composite} created in {@link VisualizationPlugin#createConfigComposite(Composite)}.
+	 * @param shell The parent {@link Shell} of the dialog to open
+	 */
+	public final void openConfigDialog(Shell shell) {
+		if(!CONFIGURABLE) return; //Not configurable, so don't open config dialog
+		ApplicationWindow d = new ConfigurationDialog(shell);
+		d.open();
+	}
+	
+	
+	/**
+	 * Save the configuration of the current instance of this class to an XML element.<br>
+	 * Override this method to save custom configuration settings:<br>
+	 * <code>
+	 * public Element toXML() {								<br>
+	 * &nbsp;Element elm = super.toXML();					<br>
+	 * &nbsp;//Add custom attributes and elements to elm, e.g.:	<br>
+	 * &nbsp;elm.setAttribute("fontsize", fontsize)			<br>
+	 * <br>
+	 * &nbsp;return elm;									<br>
+	 * }
+	 * </code>
+	 */
+	public Element toXML() {
+		Element elm = new Element(XML_ELEMENT);
+		elm.setAttribute(XML_ATTR_CLASS, getClass().getCanonicalName());
+		return elm;
+	}
+	
+	/**
+	 * Load the configuration of the current instance of this class from an XML element.<br>
+	 * Override this method to load custom configuration settings:<br>
+	 * <code>
+	 * public Element loadXML(Element xml) {				<br>
+	 * &nbsp;super.loadXML(xml)								<br>
+	 * &nbsp;//Load custom attributes and elements to elm, e.g.:	<br>
+	 * &nbsp;fontSize = xml.getAttributeValue("fontsize")			<br>
+	 * }
+	 * </code>
+	 * @param xml The {@link Element} that contains the configuration for this plugin
+	 */
+	public void loadXML(Element xml) { }
+	
+	/**
+	 * Returns whether the current instance of this visualization plugin is activated or not
+	 * @return true if this instance is activated, false otherwise
+	 */
+	public final boolean isActive() { return isActive; }
+	
+	/**
+	 * Set the activation state of this instance. If set to active, the visualization methods
+	 * of this plugin will be called from the {@link Visualization} this instance belongs to.
+	 * @param active true to activate this instance, false to de-activate
+	 */
+	public final void setActive(boolean active) { 
+		if(isActive != active) {
+			isActive = active;
+			fireModifiedEvent();
+		}	
+	}
+	
+	/**
+	 * Returns whether this plugin can be displayed in the side panel
+	 * @return true when this plugin can be displayed in the side panel, false otherwise
+	 */
+	public final boolean canSidePanel() { return (DISPLAY_OPT & SIDEPANEL) != 0; }
+	
+	/**
+	 * Returns whether this plugin can be displayed in the Tool Tip
+	 * @return true when this plugin can be displayed in the Tool Tip, false otherwise
+	 */
+	public final boolean canToolTip() { return (DISPLAY_OPT & TOOLTIP) != 0; }
+	
+	/**
+	 * Returns whether this plugin can be displayed in the pathway drawing
+	 * @return true when this plugin can be displayed in the pathway drawing, false otherwise
+	 */
+	public final boolean canDrawing() { return (DISPLAY_OPT & DRAWING) != 0; }
+	
+	/**
+	 * Specify where this plugin can be displayed.
+	 * One of:<BR><UL>
+	 * <LI><CODE>DRAWING</CODE>: this plugin implements visualization on drawing objects
+	 * <LI><CODE>TOOLTIP</CODE>: this plugins implements visualization in the tooltip showed
+	 * when hovering over GeneProducts
+	 * <LI><CODE>SIDEPANEL</CODE>: this plugin implements visualization to be displayed in the side panel
+	 * </UL><BR>
+	 * When multiple visualization options are implemented, 
+	 * use bitwise OR (e.g. <CODE>SIDEPANEL | DRAWING</CODE>)
+	 * @param options
+	 */
+	protected void setDisplayOptions(int options) {
+		DISPLAY_OPT = options;
+	}
+	
+	/**
+	 * Specify whether the parent {@link Visualization} needs to provide an area on the 
+	 * {@link Graphics} objects.
+	 * When multiple visualization plugins apply visualizations on the same {@link Graphics}
+	 * object, the available space will be divided over the plugins for which this method is called
+	 * with true as argument.
+	 * The provided area can be obtained by calling {@link Visualization#provideDrawArea(VisualizationPlugin, Graphics)}
+	 * @param use	true if this plugin uses the provided area, false if not
+	 * @see Visualization#provideDrawArea(VisualizationPlugin, Graphics)
+	 */
+	protected void setUseProvidedArea(boolean use) {
+		USE_PROVIDED_AREA = use;
+	}
+	
+	/**
+	 * Specify whether this visualization plugin is configurable or not.
+	 * When the plugin is set to be configurable, override {@link VisualizationPlugin#createConfigComposite(Composite)}.
+	 * @param configurable
+	 * @see VisualizationPlugin#createConfigComposite(Composite)
+	 */
+	protected void setIsConfigurable(boolean configurable) {
+		CONFIGURABLE = configurable;
+	}
+	
+	/**
+	 * Specify whether this visualization plugin is generic or not.
+	 * Generic plugins are independent of expression data. Non-generic plugin configurations
+	 * depend on an expression dataset and will be loaded/saved together with this expression dataset.
+	 * @param generic true if this plugin is generic, false otherwise
+	 */
+	protected void setIsGeneric(boolean generic) {
+		GENERIC = generic;
+	}
+	
+	/**
+	 * Returns whether this visualiazation plugin is generic or not
+	 * Generic plugins are independent of expression data. Non-generic plugin configurations
+	 * depend on an expression dataset and will be loaded/saved together with this expression dataset.
+	 * @see VisualizationPlugin#setIsGeneric(boolean)
+	 * @return true if this plugin is generic, false otherwise
+	 */
+	public final boolean isGeneric() { return GENERIC; }
+	
+	/**
+	 * Returns whether this visualization plugin is configurable or not
+	 * @see VisualizationPlugin#setIsConfigurable(boolean)
+	 * @return true if this plugin is configurable, false otherwise
+	 */
+	public final boolean isConfigurable() { return CONFIGURABLE; }
+	
+	/**
+	 * Returns whether this visualization plugin uses the area provided by
+	 * the {@link Visualization} it belongs to.
+	 * @see VisualizationPlugin#setUseProvidedArea(boolean)
+	 * @return true if this plugin uses the provided area, false otherwise
+	 */
+	public final boolean isUseProvidedArea() { 
+		return USE_PROVIDED_AREA; 
+	}
+		
+	/**
+	 * Fire a {@link VisualizationEvent} with type {@link VisualizationEvent#PLUGIN_MODIFIED}
+	 */
+	protected final void fireModifiedEvent() {
+		VisualizationManager.fireVisualizationEvent(
+				new VisualizationEvent(this, VisualizationEvent.PLUGIN_MODIFIED));
+	}
+	
+	/**
+	 * The configuration dialog that displays the configuration settings for a 
+	 * visualization plugin
+	 * @author Thomas
+	 */
+	private class ConfigurationDialog extends ApplicationWindow {
+		public ConfigurationDialog(Shell shell) {
+			super(shell);
+			setBlockOnOpen(true);
+		}
+		
+		public Control createContents(Composite parent) {
+			Composite contents = new Composite(parent, SWT.NULL);
+			contents.setLayout(new GridLayout());
+			
+			Composite config = createConfigComposite(contents);
+			config.setLayoutData(new GridData(GridData.FILL_BOTH));
+			
+			Composite buttonComp = createButtonComposite(contents);
+			buttonComp.setLayoutData(new GridData(GridData.HORIZONTAL_ALIGN_END));
+			
+			return contents;
+		}
+		
+		public Composite createButtonComposite(Composite parent) {
+			Composite comp = new Composite(parent, SWT.NULL);
+			comp.setLayout(new GridLayout(2, false));
+			
+			Button ok = new Button(comp, SWT.PUSH);
+			ok.setText(" Ok ");
+			ok.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent arg0) {
+					close();
+				}
+			});
+			
+			return comp;
+		}
+	}
+	
+	public int compareTo(Object o) {
+		if(o instanceof VisualizationPlugin)
+			return getName().compareTo(((VisualizationPlugin)o).getName());
+		return -1;
+	}
+}

Property changes on: trunk/src/swt/org/pathvisio/visualization/plugins/VisualizationPlugin.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/visualization/plugins/PluginManager.java
===================================================================
--- trunk/src/swt/org/pathvisio/visualization/plugins/PluginManager.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/visualization/plugins/PluginManager.java	(revision 961)
@@ -0,0 +1,314 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.plugins;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.FilenameFilter;
+import java.io.IOException;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Modifier;
+import java.net.JarURLConnection;
+import java.net.URL;
+import java.net.URLDecoder;
+import java.util.Enumeration;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.jar.JarFile;
+import java.util.zip.ZipEntry;
+
+import org.jdom.Document;
+import org.jdom.Element;
+import org.jdom.input.SAXBuilder;
+import org.jdom.output.Format;
+import org.jdom.output.XMLOutputter;
+import org.pathvisio.Engine;
+import org.pathvisio.data.Gex;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.util.Utils;
+import org.pathvisio.visualization.Visualization;
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+
+public abstract class PluginManager {
+	static final String PLUGIN_PKG = "org.pathvisio.visualization.plugins";
+	static final String PKG_DIR = PLUGIN_PKG.replace('.', '/');
+	static final String FILE_ADD_PLUGINS = "visplugins.xml";
+	static final String XML_ELEMENT = "additional-plugins";
+	static final String XML_ELM_PLUGIN = "plugin";
+	static final String XML_ATTR_URL = "url";
+	
+	static Document addDoc;
+	static final Set<Class> plugins = new LinkedHashSet<Class>();
+	
+	public static VisualizationPlugin getInstance(Class pluginClass, Visualization v) throws Throwable {
+		Constructor c = pluginClass.getConstructor(new Class[] { Visualization.class });
+		return (VisualizationPlugin)c.newInstance(new Object[] { v });
+	}
+		
+	public static VisualizationPlugin instanceFromXML(Element xml, Visualization v) throws Throwable {
+		String className = xml.getAttributeValue(VisualizationPlugin.XML_ATTR_CLASS);
+		
+		if(className == null) throw new IllegalArgumentException(
+				"Element has no '" + VisualizationPlugin.XML_ATTR_CLASS + "' attribute");
+		
+		Class pluginClass = Class.forName(className);
+		VisualizationPlugin p = getInstance(pluginClass, v);
+		p.loadXML(xml);
+		return p;
+	}
+	
+	public static Class[] getPlugins() {
+		return Gex.isConnected() ?
+				plugins.toArray(new Class[plugins.size()]) :
+				getGenericPlugins();
+	}
+	
+	public static Class[] getGenericPlugins() {
+		Set<Class> generic = new LinkedHashSet<Class>();
+		for(Class pc : plugins) {
+			if(isGeneric(pc)) generic.add(pc);
+		}
+		return generic.toArray(new Class[generic.size()]);
+	}
+	
+	public static boolean isGeneric(Class pluginClass) {
+		try {
+			return getInstance(pluginClass, null).isGeneric();
+		} catch(Throwable e) { 
+			e.printStackTrace();
+			Engine.log.error("Unable to determine if plugin is generic", e);
+			return false; 
+		}
+	}
+	
+	public static String[] getPluginNames() {
+		String[] names = new String[plugins.size()];
+		int i = 0;
+		for(Class p : plugins) {
+			names[i++] = getPluginName(p);
+		}
+		return names;
+	}
+	
+	public static String getPluginName(Class pluginClass) {
+		try {
+			VisualizationPlugin p = getInstance(pluginClass, null);
+			return p.getName();
+		} catch(Throwable e) {
+			Engine.log.error("Unable to get plugin name for " + pluginClass, e);
+			return pluginClass.getName();
+		}
+	}
+
+	public static void loadPlugins() throws Throwable {	
+		Engine.log.trace("> Loading visualization plugins");
+		Enumeration<URL> resources = 
+			Engine.class.getClassLoader().getResources(PLUGIN_PKG.replace('.', '/'));
+        while (resources.hasMoreElements()) {
+        	URL url = resources.nextElement();
+        	Engine.log.trace("visualization.plugins package found in: " + url);
+        	try {
+        		loadPlugin(url);
+        	} catch(Throwable e) {
+        		Engine.log.error("Error when loading plugins from " + url, e);
+        	}
+        }
+        loadAdditional();
+  	}
+	    
+	static void loadPlugin(File f) throws Throwable {
+			loadPlugin(f.toURL());
+	}
+	
+	public static void loadAdditionalPlugin(File file) throws Throwable {
+		loadPlugin(file);
+		saveAdditional(file.toURL());
+		VisualizationManager.fireVisualizationEvent(
+				new VisualizationEvent(PluginManager.class, VisualizationEvent.PLUGIN_ADDED));
+	}
+		
+	static void loadPlugin(URL url) throws Throwable {
+    	if(url.getProtocol().equals("jar")) {
+    		loadFromJar(url);
+    	} else if(url.getProtocol().equals("file")) {
+    		File f = new File(url.getFile());
+    		if(f.getName().endsWith(".jar")) 
+    			loadFromJar(url);
+    		else loadFromDir(url);
+    	}
+		else Engine.log.error("Unable to load additional plugin", new Exception("Unsupported URL protocol"));
+	}
+	
+	static Document getAdditionalXML() {
+		if(addDoc == null) {
+			File f = new File(SwtEngine.getApplicationDir(), FILE_ADD_PLUGINS);
+			if(!f.exists()) {
+				return createXML();
+			} else {
+				SAXBuilder parser = new SAXBuilder();
+				try {
+					Document doc = parser.build(f);
+					return doc;
+				} catch(Exception e) {
+					Engine.log.error("Unable to load additional plugins file", e);
+					return createXML();
+				}
+			}
+		} else return addDoc;
+		
+	}
+	
+	static Document createXML() {
+		Document doc = new Document();
+		doc.setRootElement(new Element(XML_ELEMENT));
+		return doc;
+	}
+
+	static void loadAdditional() {
+		Document doc = getAdditionalXML();
+		Element root = doc.getRootElement();
+		for(Object o : root.getChildren(XML_ELM_PLUGIN)) {
+			URL url = null;
+			try {
+				url = new URL(((Element)o).getAttributeValue(XML_ATTR_URL));
+				loadPlugin(new File(url.getFile()));
+			} catch(Throwable ex) {
+				Engine.log.error("Unable to load additional plugin", ex);
+				if(url != null) removeAdditional(url);
+			}
+		}
+	}
+	
+	static void saveAdditional(URL url) {
+		Document doc = getAdditionalXML();
+		Element root = doc.getRootElement();
+		
+		if(containsElement(root, url)) return;
+		
+		Element elm = new Element(XML_ELM_PLUGIN);
+		elm.setAttribute(XML_ATTR_URL, url.toString());
+		root.addContent(elm);
+		saveXML(doc);
+	}
+	
+	static void removeAdditional(URL url) {
+		Document doc = getAdditionalXML();
+		Element root = doc.getRootElement();
+		
+		Element toRemove = null;
+		for(Object o : root.getChildren(XML_ELM_PLUGIN)) {
+			Element e = (Element) o;
+			String url1 = e.getAttributeValue(XML_ATTR_URL);
+			if(url1.equals(url.toString())) {
+				toRemove = e;
+				break;
+			}
+		}
+		root.removeContent(toRemove);
+		saveXML(doc);
+	}
+	
+	static void saveXML(Document doc) {
+		XMLOutputter out = new XMLOutputter(Format.getPrettyFormat());
+		try {
+			FileWriter fw = new FileWriter(new File(SwtEngine.getApplicationDir(), FILE_ADD_PLUGINS));
+			out.output(doc, fw);
+			fw.close();
+		} catch(IOException e) {
+			Engine.log.error("Unable to save additional plugins", e);
+		}
+	}
+	
+	static boolean containsElement(Element root, URL url) {
+		for(Object o : root.getChildren(XML_ELM_PLUGIN)) {
+			String url1 = ((Element)o).getAttributeValue(XML_ATTR_URL);
+			if(url1.equals(url.toString())) return true;
+		}
+		return false;
+	}
+	
+	static void loadFromDir(URL url) throws Throwable {
+		Engine.log.trace("\tLoading from directory " + url);
+		File directory = new File(URLDecoder.decode(url.getPath(), "UTF-8"));
+		if (directory.exists()) {
+            String[] files = directory.list(classFilter);
+            for (String file : files)
+            	addPlugin(Class.forName(PLUGIN_PKG + '.' + removeClassExt(file)));
+        }
+	}
+	
+	static void loadFromJar(URL url) throws Throwable {
+		Engine.log.trace("\tLoading from jar connection " + url);
+		JarFile f = null;
+		if(url.getProtocol().equals("jar")) {
+			JarURLConnection conn = (JarURLConnection)url.openConnection();
+			f = conn.getJarFile();
+		} else {
+			f = new JarFile(url.getFile());
+		}
+		loadFromJar(f);
+	}
+		
+	static void loadFromJar(JarFile jfile) throws Throwable {
+		Throwable error = null;
+		Engine.log.trace("\tLoading from jar file " + jfile);
+		Enumeration e = jfile.entries();
+		while (e.hasMoreElements()) {
+			ZipEntry entry = (ZipEntry)e.nextElement();
+			Engine.log.trace("Checking " + entry);
+			String entryname = entry.getName();
+			if(entryname.startsWith(PKG_DIR) && entryname.endsWith(".class")) {
+				try {
+					String cn = removeClassExt(entryname.replace('/', '.').replace('$', '.'));
+					Class pluginClass = Class.forName(cn);
+					addPlugin(pluginClass);
+				} catch(Throwable ex) {
+					Engine.log.error("Unable to load plugin", ex);
+					error = ex;
+				}
+			}
+		}
+		if(error != null) throw error;
+	}
+	
+	static String removeClassExt(String fn) {
+		return fn.substring(0, fn.length() - 6);
+	}
+	
+	static void addPlugin(Class c) {
+		Engine.log.trace("\t\tTrying to add " + c);
+		if(isPlugin(c)) {
+			Engine.log.trace("\t\t\t!> Adding " + c);
+			plugins.add(c);
+		}
+	}
+	
+	static boolean isPlugin(Class c) {
+		if(Modifier.isAbstract(c.getModifiers())) {
+			Engine.log.trace("\t\t> Class " + c + " is not a visualization plugin (is abstract)");
+			return false;
+		}
+		return Utils.isSubClass(c, VisualizationPlugin.class);
+	}
+			
+	static  FilenameFilter classFilter = new FilenameFilter() {
+		public boolean accept(File f, String name) {
+			return name.endsWith(".class");
+		}
+    };
+}

Property changes on: trunk/src/swt/org/pathvisio/visualization/plugins/PluginManager.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/visualization/colorset/ColorSetObject.java
===================================================================
--- trunk/src/swt/org/pathvisio/visualization/colorset/ColorSetObject.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/visualization/colorset/ColorSetObject.java	(revision 961)
@@ -0,0 +1,166 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.colorset;
+import java.util.HashMap;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.ModifyEvent;
+import org.eclipse.swt.events.ModifyListener;
+import org.eclipse.swt.graphics.RGB;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Text;
+import org.jdom.Element;
+
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+
+/**
+ * This class represent any object that can be present in a colorset
+ * e.g. a gradient or boolean expression.
+ */
+public abstract class ColorSetObject {
+	
+	/**
+	 * The parent colorset, that this colorSetObject is a part of.
+	 */
+	private ColorSet parent;
+	
+	/**
+	 * The display name of this colorSetObject
+	 */
+	private String name;
+	
+	/**
+	 * getter for name, the name of this colorSetObject
+	 */
+	public void setName(String _name) 
+	{
+		this.name = _name; 
+	}
+	
+	/**
+	 * setter for name, the name of this colorSetObject
+	 */
+	public String getName() { return name; }
+	
+	public ColorSet getColorSet() { return parent; }
+	
+	/**
+	 * Constructor for this class
+	 * @param parent 		colorset this gradient belongs to
+	 * @param name 			name of the gradient
+	 */
+	public ColorSetObject(ColorSet parent, String name) 
+	{	
+		this.parent = parent;
+		this.name = name;
+	}
+	
+	public ColorSetObject(ColorSet parent, Element xml) {
+		this.parent = parent;
+		loadXML(xml);
+	}
+				
+	/**
+	 * get the color defined by the colorset object for the given data
+	 * @param data {@link HashMap}<Integer, Object> containing data (String or double) for every sampleId 
+	 * @param sample id of the sample that is visualized using this color
+	 * @return {@link RGB} with the color returned by the colorset object after evaluating the input data,
+	 * null if the input data doesn't result in a valid color
+	 * @throws Exception 
+	 */
+	abstract RGB getColor(HashMap<Integer, Object> data, int idSample) throws Exception;
+	
+	/**
+	 * Returns the parent colorset
+	 */
+	public ColorSet getParent()
+	{
+		return parent;
+	}
+
+	protected void fireModifiedEvent() {
+		VisualizationManager.fireVisualizationEvent(
+				new VisualizationEvent(this, VisualizationEvent.COLORSET_MODIFIED));
+	}
+	
+	abstract String getXmlElementName();
+	
+	static final String XML_ATTR_NAME = "name";
+	
+	public Element toXML() {
+		Element elm = new Element(getXmlElementName());
+		elm.setAttribute(XML_ATTR_NAME, name);
+		return elm;
+	}
+	
+	protected void loadXML(Element xml) {
+		name = xml.getAttributeValue(XML_ATTR_NAME);
+	}
+				
+	public static abstract class ConfigComposite extends Composite {
+		final int colorLabelSize = 15;
+		ColorSetObject input;
+		Text nameText;
+		
+		public ConfigComposite(Composite parent, int style) {
+			super(parent, style);
+			createContents();
+		}
+		
+		public void setInput(ColorSetObject input) {
+			this.input = input;
+			refresh();
+		}
+		
+		public boolean save() {
+			return true;
+		}
+		
+		void refresh() {
+			String nm = "";
+			if(input != null) nm = input.getName();
+			nameText.setText(nm);
+		}
+				
+		void changeName(String name) {
+			input.setName(name);
+		}
+		
+		abstract void createContents();
+		
+		protected Composite createNameComposite(Composite parent) {
+			Composite comp = new Composite(parent, SWT.NULL);
+			comp.setLayout(new GridLayout(2, false));
+			
+			Label nameLabel = new Label(comp, SWT.CENTER);
+			nameLabel.setText("Name:");
+		
+			nameText = new Text(comp, SWT.SINGLE | SWT.BORDER);
+			nameText.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+		    nameText.addModifyListener(new ModifyListener() {
+		    	public void modifyText(ModifyEvent e) {
+		    		changeName(nameText.getText());
+		    	}
+		    });
+		    return comp;
+		}
+	}
+}

Property changes on: trunk/src/swt/org/pathvisio/visualization/colorset/ColorSetObject.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/visualization/colorset/CriterionComposite.java
===================================================================
--- trunk/src/swt/org/pathvisio/visualization/colorset/CriterionComposite.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/visualization/colorset/CriterionComposite.java	(revision 961)
@@ -0,0 +1,171 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.colorset;
+
+import java.sql.Types;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.ModifyEvent;
+import org.eclipse.swt.events.ModifyListener;
+import org.eclipse.swt.events.MouseAdapter;
+import org.eclipse.swt.events.MouseEvent;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.layout.RowLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Group;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.List;
+import org.eclipse.swt.widgets.Text;
+
+import org.pathvisio.data.Gex;
+
+public class CriterionComposite extends Composite {
+	ErrorArea errorArea;
+	Criterion criterion;
+	List symbolList;
+	Text exprText;
+	
+	public CriterionComposite(Composite parent, Criterion criterion) {
+		super(parent, SWT.NULL);
+		this.criterion = criterion;
+		createContents();
+	}
+	
+	public void setAvailableSymbols(String[] symbols) {
+		symbolList.setItems(symbols);
+	}
+	
+	public void fetchSymbolsFromGex() {
+		if(Gex.isConnected()) {
+			java.util.List<String> numSmp = Gex.getSampleNames(Types.REAL);
+			symbolList.setItems(numSmp.toArray(new String[numSmp.size()]));	
+		} else {
+			symbolList.setItems(new String[] {});
+		}
+	}
+	
+	void setExpression(String expression) {
+		if(criterion != null) {
+			criterion.setExpression(expression, symbolList.getItems());
+			Exception e = criterion.getParseException();
+			if(e == null) {
+				errorArea.setErrorMessage(null);
+			} else if(expression.equals("")) {
+				errorArea.setWarningMessage("Please specify a boolean expression");
+			} else {
+				errorArea.setErrorMessage(
+						"Invalid boolean expression: " + e.getMessage());
+				e.printStackTrace();
+			}
+		}
+	}
+	
+	public void setInput(Criterion input) {
+		criterion = input;
+		refresh();
+	}
+	
+	public Criterion getCriterion() { return criterion; }
+	
+	public void refresh() {
+		if(criterion == null) exprText.setText("");
+		else exprText.setText(criterion.getExpression());
+	}
+	
+	protected void createContents() {
+		setLayout(new GridLayout());
+		
+		errorArea = new ErrorArea(this, SWT.NULL);
+		
+		Group criterionGroup = new Group(this, SWT.SHADOW_IN);
+		criterionGroup.setLayoutData(new GridData(GridData.FILL_BOTH));
+	    criterionGroup.setLayout(new GridLayout(2, false));
+	    
+	    Label expressionLabel = new Label(criterionGroup, SWT.CENTER);
+	    expressionLabel.setText("Boolean expression:");
+	    exprText = new Text(criterionGroup, SWT.SINGLE | SWT.BORDER);
+	    exprText.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+
+	    Label opsLabel = new Label(criterionGroup, SWT.CENTER);
+	    opsLabel.setText("Operators:");
+	    Label sampleLabel = new Label(criterionGroup, SWT.CENTER);
+	    sampleLabel.setText("Samples:");
+
+	    final List opsList = new List
+		(criterionGroup, SWT.SINGLE | SWT.BORDER | SWT.V_SCROLL | SWT.H_SCROLL);
+	    opsList.setLayoutData(new GridData(GridData.FILL_VERTICAL));
+	    opsList.setItems(Criterion.tokens);
+	    opsList.addMouseListener(new MouseAdapter() {
+	    	public void mouseDoubleClick(MouseEvent e) {
+	    		String[] selection = opsList.getSelection();
+	    		if(selection != null && selection.length > 0) exprText.insert(" " + selection[0] + " ");
+	    	}
+	    });
+	    
+	    symbolList = new List
+	    	(criterionGroup, SWT.SINGLE | SWT.BORDER | SWT.V_SCROLL | SWT.H_SCROLL);
+	    symbolList.setLayoutData(new GridData(GridData.FILL_BOTH));
+	    symbolList.addMouseListener(new MouseAdapter() {
+	    	public void mouseDoubleClick(MouseEvent e) {
+	    		String[] selection = symbolList.getSelection();
+	    		if(selection != null && selection.length > 0)
+	    			exprText.insert(" [" + selection[0] + "] ");
+	    	}
+	    });
+	    	    
+	    exprText.addModifyListener(new ModifyListener() {
+			public void modifyText(ModifyEvent e) {
+				setExpression(exprText.getText());
+			}
+	    });
+	}
+	
+	class ErrorArea extends Composite {
+		Label errorImage;
+		Label errorText;
+		
+		public ErrorArea(Composite parent, int style) {
+			super(parent, style);
+			setLayout(new RowLayout());
+			errorImage = new Label(this, SWT.NULL);
+			errorText = new Label(this, SWT.WRAP | SWT.CENTER);
+		}
+		
+		public void setErrorMessage(String error) {
+			if(error == null) {
+				errorImage.setImage(null);
+				errorText.setText("");
+			} else {
+				errorImage.setImage(getDisplay().getSystemImage(SWT.ICON_ERROR));
+				errorText.setText(error);
+			}
+			getParent().layout(true, true);
+		}
+		
+		public void setWarningMessage(String warning) {
+			if(warning == null) {
+				errorImage.setImage(null);
+				errorText.setText("");
+			} else {
+				errorImage.setImage(getDisplay().getSystemImage(SWT.ICON_WARNING));
+				errorText.setText(warning);
+			}
+			getParent().layout(true, true);
+		}
+	}
+}

Property changes on: trunk/src/swt/org/pathvisio/visualization/colorset/CriterionComposite.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/visualization/colorset/ColorSetManager.java
===================================================================
--- trunk/src/swt/org/pathvisio/visualization/colorset/ColorSetManager.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/visualization/colorset/ColorSetManager.java	(revision 961)
@@ -0,0 +1,140 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.colorset;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.jdom.Document;
+import org.jdom.Element;
+import org.jdom.JDOMException;
+import org.jdom.input.SAXBuilder;
+
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+
+public class ColorSetManager {
+	public final static String XML_ELEMENT = "color-sets";
+
+	private static List<ColorSet> colorSets = new ArrayList<ColorSet>();
+
+	/**
+	 * Gets the {@link ColorSet}s used for the currently loaded Expression data
+	 */
+	public static List<ColorSet> getColorSets() { return colorSets; }
+
+	public static boolean nameExists(String name) {
+		for(ColorSet cs : colorSets) 
+			if(cs.getName().equalsIgnoreCase(name)) return true;
+		return false;
+	}
+
+	public static String getNewName() {
+		String prefix = "color set";
+		int i = 1;
+		String name = prefix;
+		while(nameExists(name)) name = prefix + "-" + i++;
+		return name;
+	}
+
+	public static void newColorSet(String name) {
+		if(name == null) name = getNewName();
+		addColorSet(new ColorSet(name));
+		
+	}
+	
+	public static void addColorSet(ColorSet cs) {
+		colorSets.add(cs);
+		VisualizationManager.fireVisualizationEvent(
+				new VisualizationEvent(null, VisualizationEvent.COLORSET_ADDED));
+	}
+
+	/**
+	 * Removes this {@link ColorSet}
+	 * @param cs Colorset to remove
+	 */
+	public static void removeColorSet(ColorSet cs) {
+		if(colorSets.contains(cs)) {
+			colorSets.remove(cs);
+			VisualizationManager.fireVisualizationEvent(
+					new VisualizationEvent(null, VisualizationEvent.COLORSET_REMOVED));
+		}
+	}
+	
+	/**
+	 * Clears all color-set information
+	 */
+	public static void clearColorSets() {
+		colorSets.clear();
+		VisualizationManager.fireVisualizationEvent(
+				new VisualizationEvent(null, VisualizationEvent.COLORSET_REMOVED));
+	}
+	
+	public static ColorSet getColorSet(int index) {
+		if(index >= 0 && index < colorSets.size())
+			return colorSets.get(index);
+		else return null;
+	}
+
+	/**
+	 * Removes this {@link ColorSet}
+	 * @param i index of ColorSet to remove
+	 */
+	public static void removeColorSet(int i) {
+		if(i > -1 && i < colorSets.size()) {
+			removeColorSet(colorSets.get(i));
+		}
+	}
+
+	/**
+	 * Gets the names of all {@link ColorSet}s used 
+	 */
+	public static String[] getColorSetNames()
+	{
+		String[] colorSetNames = new String[colorSets.size()];
+		for(int i = 0; i < colorSetNames.length; i++)
+		{
+			colorSetNames[i] = ((ColorSet)colorSets.get(i)).getName();
+		}
+		return colorSetNames;
+	}
+
+	public static Element getXML() {
+		Element cse = new Element(XML_ELEMENT);
+				
+		for(ColorSet cs : colorSets) cse.addContent(cs.toXML());
+		
+		return cse;
+	}
+
+	public static void fromXML(Element xml) {
+		clearColorSets();
+		
+		if(xml == null) return;
+
+		for(Object o : xml.getChildren(ColorSet.XML_ELEMENT)) {
+			addColorSet(ColorSet.fromXML((Element) o));				
+		}
+	}
+
+	static Document parseInput(InputStream in) throws JDOMException, IOException {
+		SAXBuilder parser = new SAXBuilder();
+		return parser.build(in);
+	}
+}

Property changes on: trunk/src/swt/org/pathvisio/visualization/colorset/ColorSetManager.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/visualization/colorset/ColorSet.java
===================================================================
--- trunk/src/swt/org/pathvisio/visualization/colorset/ColorSet.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/visualization/colorset/ColorSet.java	(revision 961)
@@ -0,0 +1,224 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.colorset;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+
+import org.eclipse.jface.dialogs.MessageDialog;
+import org.eclipse.swt.graphics.RGB;
+import org.jdom.Element;
+import org.pathvisio.Engine;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.util.ColorConverter;
+import org.pathvisio.util.SwtUtils;
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+
+/**
+ * This class represents a colorset, a set of criteria that can be evaluated and 
+ * results in a color given a collection of data
+ */
+public class ColorSet {	
+	public static final int ID_COLOR_NO_CRITERIA_MET = 1;
+	public static final int ID_COLOR_NO_GENE_FOUND = 2;
+	public static final int ID_COLOR_NO_DATA_FOUND = 3;
+	
+	RGB color_no_criteria_met = SwtUtils.color2rgb(GlobalPreference.getValueColor(GlobalPreference.COLOR_NO_CRIT_MET));
+	RGB color_no_gene_found = SwtUtils.color2rgb(GlobalPreference.getValueColor(GlobalPreference.COLOR_NO_GENE_FOUND));
+	RGB color_no_data_found = SwtUtils.color2rgb(GlobalPreference.getValueColor(GlobalPreference.COLOR_NO_DATA_FOUND));
+		
+	String name;
+	
+	public List<ColorSetObject> colorSetObjects;
+		
+	/**
+	 * Constructor of this class
+	 * @param name		name of the colorset
+	 */
+	public ColorSet(String name)
+	{
+		this.name = name;
+		colorSetObjects = new ArrayList<ColorSetObject>();
+	}
+		
+	public String getName() { return name; }
+	
+	public void setName(String n) { 
+		name = n;
+		fireModifiedEvent();
+	}
+	
+	public void setColor(int id, RGB rgb) {
+		switch(id) {
+		case ID_COLOR_NO_CRITERIA_MET:
+			color_no_criteria_met = rgb;
+			break;
+		case ID_COLOR_NO_DATA_FOUND:
+			color_no_data_found = rgb;
+			break;
+		case ID_COLOR_NO_GENE_FOUND:
+			color_no_gene_found = rgb;
+			break;
+		}
+		fireModifiedEvent();
+	}
+	
+	public RGB getColor(int id) {
+		switch(id) {
+		case ID_COLOR_NO_CRITERIA_MET:
+			return color_no_criteria_met;
+		case ID_COLOR_NO_DATA_FOUND:
+			return color_no_data_found;
+		case ID_COLOR_NO_GENE_FOUND:
+			return color_no_gene_found;
+		default: return null;
+		}
+	}
+	
+	/**
+	 * Adds a new {@link ColorSetObject} to this colorset
+	 * @param o the {@link ColorSetObject} to add
+	 */
+	public void addObject(ColorSetObject o)
+	{
+		colorSetObjects.add(o);
+		fireModifiedEvent();
+	}
+	
+	public void removeObject(ColorSetObject o) {
+		colorSetObjects.remove(o);
+		fireModifiedEvent();
+	}
+	
+	public List<ColorSetObject> getObjects() {
+		return colorSetObjects;
+	}
+	
+	/**
+	 * Checks whether this color-set contains one or more color gradients
+	 * (instances of class {@link ColorGradient}
+	 * @return true if one or more of the objects of this color-set is an instance of
+	 * {@link ColorGradient}
+	 */
+	public boolean hasColorGradient() {
+		for(ColorSetObject o : colorSetObjects) {
+			if(o instanceof ColorGradient) return true;
+		}
+		return false;
+	}
+
+	public boolean nameExists(String name) {
+		for(ColorSetObject o : colorSetObjects) 
+			if(o.getName().equalsIgnoreCase(name)) return true;
+		return false;
+	}
+	
+	public String getNewName(String prefix) {
+		int i = 1;
+		String name = prefix;
+		while(nameExists(name)) name = prefix + "-" + i++;
+		return name;
+	}
+		
+	/**
+	 * Get the color for the given expression data by evaluating all colorset objects
+	 * @param data		the expression data to get the color for
+	 * @param sampleId	the id of the sample that will be visualized
+	 * @return	an {@link RGB} object representing the color for the given data
+	 */
+	public RGB getColor(HashMap<Integer, Object> data, int sampleId)
+	{
+		if(data == null) return color_no_data_found;
+		Object value = data.get(sampleId);
+		if(value == null || value.equals(Double.NaN)) return color_no_data_found;
+		
+		RGB rgb = color_no_criteria_met; //The color to return
+		Iterator it = colorSetObjects.iterator();
+		//Evaluate all colorset objects, return when a valid color is found
+		while(it.hasNext())
+		{
+			ColorSetObject gc = (ColorSetObject)it.next();
+			try{ 
+				RGB gcRgb = gc.getColor(data, sampleId);
+				if(gcRgb != null) {
+					return gcRgb;
+				}
+			} catch(Exception e) {
+				Engine.log.error("ColorSetObject " + gc + " could not evaluate data: " + e.getMessage());
+			}
+		}
+		return rgb;
+	}
+	
+	final static String XML_ELEMENT = "ColorSet";
+	final static String XML_ATTR_NAME = "name";
+	final static String XML_ELM_COLOR_NCM = "no-criteria-met";
+	final static String XML_ELM_COLOR_NGF = "no-gene-found";
+	final static String XML_ELM_COLOR_NDF = "no-data-found";
+	
+	public Element toXML() {
+		Element elm = new Element(XML_ELEMENT);
+		elm.setAttribute(XML_ATTR_NAME, name);
+		
+		elm.addContent(ColorConverter.createColorElement(XML_ELM_COLOR_NCM, SwtUtils.rgb2color(color_no_criteria_met)));
+		elm.addContent(ColorConverter.createColorElement(XML_ELM_COLOR_NGF, SwtUtils.rgb2color(color_no_gene_found)));
+		elm.addContent(ColorConverter.createColorElement(XML_ELM_COLOR_NDF, SwtUtils.rgb2color(color_no_data_found)));
+		
+		for(ColorSetObject cso : colorSetObjects)
+			elm.addContent(cso.toXML());
+		return elm;
+	}
+	
+	public static ColorSet fromXML(Element e) {
+		ColorSet cs = new ColorSet(e.getAttributeValue(XML_ATTR_NAME));
+		for(Object o : e.getChildren()) {
+			try {
+				Element elm = (Element) o;
+				String name = elm.getName();
+				if(name.equals(ColorGradient.XML_ELEMENT_NAME))
+					cs.addObject(new ColorGradient(cs, elm));
+				else if(name.equals(ColorCriterion.XML_ELEMENT_NAME))
+					cs.addObject(new ColorCriterion(cs, elm));
+				else if(name.equals(XML_ELM_COLOR_NCM))
+					cs.setColor(ID_COLOR_NO_CRITERIA_MET, SwtUtils.color2rgb(ColorConverter.parseColorElement(elm)));
+				else if(name.equals(XML_ELM_COLOR_NGF))
+					cs.setColor(ID_COLOR_NO_GENE_FOUND, SwtUtils.color2rgb(ColorConverter.parseColorElement(elm)));
+				else if(name.equals(XML_ELM_COLOR_NDF))
+					cs.setColor(ID_COLOR_NO_DATA_FOUND, SwtUtils.color2rgb(ColorConverter.parseColorElement(elm)));
+			} catch(Exception ex) {
+				Engine.log.error("Unable to parse colorset xml", ex);
+			}
+		}
+		return cs;
+	}
+			
+	static void printParseError(String criterion, Exception e) {
+		Engine.log.error("Unable to parse colorset data stored in " +
+				"expression database: " + criterion, e);
+		MessageDialog.openWarning(SwtEngine.getWindow().getShell(), 
+					"Warning", "Unable to parse the colorset data in this expression dataset");
+	}
+	
+	void fireModifiedEvent() {
+		VisualizationManager.fireVisualizationEvent(
+				new VisualizationEvent(this, VisualizationEvent.COLORSET_MODIFIED));
+	}
+}

Property changes on: trunk/src/swt/org/pathvisio/visualization/colorset/ColorSet.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/visualization/colorset/ColorGradient.java
===================================================================
--- trunk/src/swt/org/pathvisio/visualization/colorset/ColorGradient.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/visualization/colorset/ColorGradient.java	(revision 961)
@@ -0,0 +1,413 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.colorset;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+
+import org.eclipse.jface.viewers.CellEditor;
+import org.eclipse.jface.viewers.ColorCellEditor;
+import org.eclipse.jface.viewers.ICellModifier;
+import org.eclipse.jface.viewers.ILabelProviderListener;
+import org.eclipse.jface.viewers.IStructuredContentProvider;
+import org.eclipse.jface.viewers.IStructuredSelection;
+import org.eclipse.jface.viewers.ITableLabelProvider;
+import org.eclipse.jface.viewers.TableViewer;
+import org.eclipse.jface.viewers.TextCellEditor;
+import org.eclipse.jface.viewers.Viewer;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.events.SelectionListener;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.graphics.RGB;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.layout.RowLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Table;
+import org.eclipse.swt.widgets.TableColumn;
+import org.eclipse.swt.widgets.TableItem;
+import org.jdom.Element;
+import org.pathvisio.Engine;
+import org.pathvisio.util.ColorConverter;
+import org.pathvisio.util.SwtUtils;
+import org.pathvisio.util.TableColumnResizer;
+
+/**
+ * This class represent a color gradient used for data visualization
+ */
+public class ColorGradient extends ColorSetObject {
+	public static final String XML_ELEMENT_NAME = "ColorGradient";
+
+	private ArrayList<ColorValuePair> colorValuePairs;
+	
+	/**
+	 * Constructor for this class
+	 * @param parent 		colorset this gradient belongs to
+	 * @param name 			name of the gradient
+	 */
+	public ColorGradient(ColorSet parent, String name)
+	{
+		super(parent, name);
+		getColorValuePairs();
+	}
+		
+	public ColorGradient(ColorSet parent, Element xml) {
+		super(parent, xml);
+	}
+	
+	/**
+	 * Get the the colors and corresponding values used in this gradient as {@link ColorValuePair}
+	 * @return ArrayList containing the ColorValuePairs
+	 */
+	public ArrayList<ColorValuePair> getColorValuePairs() 
+	{ 
+		if(colorValuePairs == null) {//Not initialized yet, use defaults
+			colorValuePairs = new ArrayList<ColorValuePair>();
+			colorValuePairs.add(new ColorValuePair(new RGB(0,255,0), -1));
+			colorValuePairs.add(new ColorValuePair(new RGB(255,255,0), 0));
+			colorValuePairs.add(new ColorValuePair(new RGB(255,0,0), 1));
+		}
+		return colorValuePairs;
+	}
+	/**
+	 * Add a {@link ColorValuePair} to this gradient
+	 */
+	public void addColorValuePair(ColorValuePair cvp)
+	{
+		if(colorValuePairs == null) { 
+			colorValuePairs = new ArrayList<ColorValuePair>();
+		}
+		colorValuePairs.add(cvp);
+		fireModifiedEvent();
+	}
+	/**
+	 * Remove a {@link ColorValuePair} from this gradient
+	 */
+	public void removeColorValuePair(ColorValuePair cvp)
+	{
+		if(colorValuePairs == null || !colorValuePairs.contains(cvp)) return;
+		colorValuePairs.remove(cvp);
+		fireModifiedEvent();
+	}
+			
+	/**
+	 * get the color of the gradient for this value
+	 * @param value
+	 * @return	{@link RGB} containing the color information for the corresponding value
+	 * or null if the value does not have a valid color for this gradient
+	 */
+	public RGB getColor(double value)
+	{
+		double[] minmax = getMinMax(); //Get the minimum and maximum values of the gradient
+		double valueStart = 0;
+		double valueEnd = 0;
+		RGB colorStart = null;
+		RGB colorEnd = null;
+		Collections.sort(colorValuePairs);
+		//If value is larger/smaller than max/min then set the value to max/min
+		//TODO: make this optional
+		if(value < minmax[0]) value = minmax[0]; else if(value > minmax[1]) value = minmax[1];
+		
+		//Find what colors the value is in between
+		for(int i = 0; i < colorValuePairs.size() - 1; i++)
+		{
+			ColorValuePair cvp = colorValuePairs.get(i);
+			ColorValuePair cvpNext = colorValuePairs.get(i + 1);
+			if(value >= cvp.value && value <= cvpNext.value)
+			{
+				valueStart = cvp.getValue();
+				colorStart = cvp.getColor();
+				valueEnd = cvpNext.getValue();
+				colorEnd = cvpNext.getColor();
+			}
+		}
+		if(colorStart == null || colorEnd == null) return null; //Check if the values/colors are found
+		// Interpolate to find the color belonging to the given value
+		double alpha = (value - valueStart) / (valueEnd - valueStart);
+		double red = colorStart.red + alpha*(colorEnd.red - colorStart.red);
+		double green = colorStart.green + alpha*(colorEnd.green - colorStart.green);
+		double blue = colorStart.blue + alpha*(colorEnd.blue - colorStart.blue);
+		RGB rgb = null;
+		
+		//Try to create an RGB, if the color values are not valid (outside 0 to 255)
+		//This method returns null
+		try {
+			rgb = new RGB((int)red, (int)green, (int)blue);
+		} catch (Exception e) { 
+			Engine.log.error("GmmlColorGradient:getColor: " + 
+					red + "," + green + "," +blue + ", for value " + value, e);
+		}
+		return rgb;
+	}
+	
+	public RGB getColor(HashMap<Integer, Object> data, int idSample) throws NumberFormatException
+	{
+		double value = (Double)data.get(idSample);
+		return getColor(value);
+	}
+	
+	String getXmlElementName() {
+		return XML_ELEMENT_NAME;
+	}
+	
+	public Element toXML() {
+		Element elm = super.toXML();
+		for(ColorValuePair cvp : colorValuePairs)
+			elm.addContent(cvp.toXML());
+		return elm;
+	}
+	
+	protected void loadXML(Element xml) {
+		super.loadXML(xml);
+		colorValuePairs = new ArrayList<ColorValuePair>();
+		for(Object o : xml.getChildren(ColorValuePair.XML_ELEMENT))
+			colorValuePairs.add(new ColorValuePair((Element) o));
+	}
+	
+	/**
+	 * Find the minimum and maximum values used in this gradient
+	 * @return a double[] of length 2 with respecively the minimum and maximum values
+	 */
+	public double[] getMinMax()
+	{
+		double[] minmax = new double[] { Double.MAX_VALUE, Double.MIN_VALUE };
+		for(ColorValuePair cvp : colorValuePairs)
+		{
+			minmax[0] = Math.min(cvp.value, minmax[0]);
+			minmax[1] = Math.max(cvp.value, minmax[1]);
+		}
+		return minmax;
+	}
+	
+	/**
+	 * This class contains a color and its corresponding value used for the {@link ColorGradient}
+	 */
+	public class ColorValuePair implements Comparable<ColorValuePair> {
+		static final String XML_ELEMENT = "color-value";
+		static final String XML_ATTR_VALUE = "value";
+		static final String XML_ELM_COLOR = "color";
+		private RGB color;
+		private double value;
+		
+		public ColorValuePair(RGB color, double value)
+		{
+			this.color = color;
+			this.value = value;
+		}
+		
+		public ColorValuePair(Element xml) {
+			Object o = xml.getChildren(XML_ELM_COLOR).get(0);
+			color = SwtUtils.color2rgb(ColorConverter.parseColorElement((Element)o));
+			value = Double.parseDouble(xml.getAttributeValue(XML_ATTR_VALUE));
+		}
+		
+		public RGB getColor() { return color; }
+		public void setColor(RGB rgb) {
+			color = rgb;
+			fireModifiedEvent();
+		}
+		
+		public double getValue() { return value; }
+		public void setValue(double v) {
+			value = v;
+			fireModifiedEvent();
+		}
+		
+		public int compareTo(ColorValuePair o)
+		{
+			return (int)(value - o.value);
+		}
+		
+		public Element toXML() {
+			Element elm = new Element(XML_ELEMENT);
+			elm.setAttribute(XML_ATTR_VALUE, Double.toString(value));
+			elm.addContent(ColorConverter.createColorElement(XML_ELM_COLOR, SwtUtils.rgb2color(color)));
+			return elm;
+		}
+	}
+	
+	public static class ColorGradientComposite extends ConfigComposite {	
+		static final String[] tableColumns = new String[] {"Color", "Value"};
+		TableViewer colorTable;
+		
+		public ColorGradientComposite(Composite parent, int style) {
+			super(parent, style);
+		}
+		
+		ColorGradient getInput() {
+			return (ColorGradient)input;
+		}
+		
+		public void setInput(ColorSetObject o) {
+			super.setInput(o);
+			colorTable.setInput(o);
+		}
+				
+		void addColor() {
+			getInput().addColorValuePair(getInput().new ColorValuePair(new RGB(255, 0, 0), 0));
+    		colorTable.refresh();
+		}
+		
+		void removeColor() {
+    		ColorValuePair cvp = (ColorValuePair)
+    		((IStructuredSelection)colorTable.getSelection()).getFirstElement();
+    		getInput().removeColorValuePair(cvp);
+    		colorTable.refresh();
+		}
+		
+		void createContents() {
+			setLayout(new GridLayout());
+			Composite nameComp = createNameComposite(this);
+			nameComp.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+			
+			Composite buttonComp = createButtonComp(this);
+
+			Composite tableComp = createColorTable(this);
+			tableComp.setLayoutData(new GridData(GridData.FILL_BOTH));
+		}
+		
+		Composite createButtonComp(Composite parent) {
+			Composite comp = new Composite(parent, SWT.NULL);
+			comp.setLayout(new RowLayout(SWT.HORIZONTAL));
+			
+			
+			final Button addColor = new Button(comp, SWT.PUSH);
+			addColor.setText("Add color");
+		    final Button removeColor = new Button(comp, SWT.PUSH);
+		    removeColor.setText("Remove color");
+		    
+			SelectionListener buttonAdapter = new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					if(e.widget == addColor) addColor();
+					else removeColor();
+				}
+			};
+			addColor.addSelectionListener(buttonAdapter);
+		    removeColor.addSelectionListener(buttonAdapter);
+		    return comp;
+		}
+
+		Composite createColorTable(Composite parent) {
+			Composite tableComp = new Composite(parent, SWT.NULL);
+			tableComp.setLayout(new GridLayout());
+					    			
+		    Table table = new Table(tableComp, SWT.BORDER | SWT.SINGLE | SWT.FULL_SELECTION);
+		    
+		    table.setHeaderVisible(true);
+		    TableColumn colorCol = new TableColumn(table, SWT.LEFT);
+		    TableColumn valueCol = new TableColumn(table, SWT.LEFT);
+		    valueCol.setText(tableColumns[1]);
+		    colorCol.setText(tableColumns[0]);
+
+		    colorCol.setWidth(45);
+		    colorCol.setResizable(false);
+		    
+		    table.addControlListener(
+		    		new TableColumnResizer(table, tableComp, new int[] { 0, 100 }));
+		    
+		    colorTable = new TableViewer(table);
+		    colorTable.setColumnProperties(tableColumns);
+		    
+		    colorTable.setLabelProvider(createLabelProvider());
+		    colorTable.setContentProvider(createContentProvider());
+		    colorTable.setCellModifier(createCellModifier());
+		    
+		    CellEditor[] cellEditors = new CellEditor[2];
+		    cellEditors[1] = new TextCellEditor(table);
+		    cellEditors[0] = new ColorCellEditor(table);
+		    colorTable.setCellEditors(cellEditors);
+		    
+		    return tableComp;
+		}
+		
+		IStructuredContentProvider createContentProvider() {
+			return new IStructuredContentProvider() {
+				public Object[] getElements(Object inputElement) {
+					return ((ColorGradient)inputElement).getColorValuePairs().toArray();
+				}
+				public void dispose() {	}
+				public void inputChanged(Viewer viewer, Object oldInput, Object newInput) { }
+			};
+		}
+		
+		ITableLabelProvider createLabelProvider() {
+			return new ITableLabelProvider() {
+				private Image colorImage;
+				
+				public void dispose() {
+					if(colorImage != null) colorImage.dispose();
+				}
+				
+				public Image getColumnImage(Object element, int columnIndex) { 
+					if(columnIndex == 0) {
+						RGB rgb = ((ColorValuePair)element).color;
+						colorImage = new Image(null, ColorSetComposite.createColorImage(rgb));
+						return colorImage;
+					}
+					return null;
+				}
+				
+				public String getColumnText(Object element, int columnIndex) {
+					if(columnIndex == 1) {
+						return Double.toString(((ColorValuePair)element).getValue());
+					}
+					return null;
+				}
+
+				public void addListener(ILabelProviderListener listener) {}
+				public boolean isLabelProperty(Object element, String property) {
+					return false;
+				}
+				public void removeListener(ILabelProviderListener listener) {}
+			};
+		}
+
+		ICellModifier createCellModifier() {
+			return new ICellModifier() {
+				public boolean canModify(Object element, String property) {
+					return true;
+				}
+
+				public Object getValue(Object element, String property) {
+					ColorValuePair cvp = (ColorValuePair)element;
+					if(property.equals(tableColumns[0])) {
+						return cvp.getColor();
+					} else {
+						return Double.toString(cvp.getValue());
+					}
+				}
+
+				public void modify(Object element, String property, Object value) {
+					if(element instanceof TableItem) {
+						element = ((TableItem)element).getData();
+					}
+					ColorValuePair cvp = (ColorValuePair)element;
+					if(property.equals(tableColumns[0])) {
+						cvp.setColor((RGB)value);
+					} else {
+						cvp.setValue(Double.parseDouble((String)value));
+					}
+					colorTable.refresh();
+				}
+			};
+		}
+	}
+}

Property changes on: trunk/src/swt/org/pathvisio/visualization/colorset/ColorGradient.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/visualization/colorset/ColorCriterion.java
===================================================================
--- trunk/src/swt/org/pathvisio/visualization/colorset/ColorCriterion.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/visualization/colorset/ColorCriterion.java	(revision 961)
@@ -0,0 +1,204 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.colorset;
+
+import java.util.HashMap;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.CLabel;
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.RGB;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.ColorDialog;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Listener;
+import org.eclipse.swt.widgets.Text;
+import org.jdom.Element;
+import org.pathvisio.Engine;
+import org.pathvisio.util.ColorConverter;
+import org.pathvisio.util.SwtUtils;
+
+public class ColorCriterion extends ColorSetObject {	
+	public static final String XML_ELEMENT_NAME = "ColorCriterion";
+	
+	Criterion criterion;
+	
+	public static final RGB INITIAL_COLOR = new RGB(255, 255, 255);
+	private RGB color;
+	public void setColor(RGB color) { 
+		this.color = color;
+		fireModifiedEvent();
+	}
+	
+	public RGB getColor() { return color == null ? INITIAL_COLOR : color; }
+	
+	public Criterion getCriterion() { return criterion; }
+	
+	public ColorCriterion(ColorSet parent, String name) {
+		super(parent, name);
+		criterion = new Criterion();
+	}
+
+	public ColorCriterion(ColorSet parent, Element xml) {
+		super(parent, xml);
+	}
+	
+	RGB getColor(HashMap<Integer, Object> data, int idSample) throws Exception {
+		if(criterion.evaluate(data, idSample)) return color;
+		return null;
+	}
+	
+	public String getXmlElementName() {
+		return XML_ELEMENT_NAME;
+	}
+	
+	protected void loadXML(Element xml) {
+		super.loadXML(xml);
+		try {
+			String expression = xml.getAttributeValue(XML_ATTR_EXPRESSION);
+			criterion = new Criterion();
+			criterion.setExpression(expression);
+			Element ce = xml.getChild(XML_ELM_COLOR);
+			if(ce != null) color = SwtUtils.color2rgb(ColorConverter.parseColorElement(ce));
+		} catch(Exception e) {
+			Engine.log.error("Unable to load ColorCriterion", e);
+		}
+	}
+	
+	static final String XML_ELM_COLOR = "color";
+	static final String XML_ATTR_EXPRESSION = "expression";
+	public Element toXML() {
+		Element elm = super.toXML();
+		Element ce = ColorConverter.createColorElement(XML_ELM_COLOR, SwtUtils.rgb2color(getColor()));
+		elm.addContent(ce);
+		elm.setAttribute(XML_ATTR_EXPRESSION, criterion.getExpression());
+		
+		return elm;
+	}
+		
+	public static class ColorCriterionComposite extends ConfigComposite {
+		final int colorLabelSize = 15;
+		CriterionComposite critComp;
+		Text exprText;
+		CLabel colorLabel;
+		Color color;
+		
+		public ColorCriterionComposite(Composite parent, int style) {
+			super(parent, style);
+		}
+		
+		void refresh() {
+			super.refresh();
+			critComp.refresh();
+			changeColorLabel(getInput() == null ? null : getInput().getColor());
+		}
+		
+		ColorCriterion getInput() {
+			return (ColorCriterion)input;
+		}
+		
+//		public boolean save() {
+//			if(input != null) try {
+//				critComp.saveToCriterion();
+//			} catch(Exception e) {
+//				return false;
+//			}
+//			return true;
+//		}
+			
+		public void setInput(ColorSetObject o) {
+			super.setInput(o);
+			if(o == null) critComp.setInput(null);
+			else critComp.setInput(((ColorCriterion)o).getCriterion());
+			refresh();
+		}
+		
+		RGB askColor() {
+			ColorDialog dg = new ColorDialog(getShell());
+			dg.setRGB(getInput().getColor());
+			return dg.open();
+		}
+		
+		void changeColor(RGB rgb) {
+			if(rgb != null) {
+				ColorCriterion c = getInput();
+				if(c != null) c.setColor(rgb);
+				changeColorLabel(rgb);
+			}
+		}
+		
+		void changeColorLabel(RGB rgb) {
+			if(rgb != null) {
+				color = SwtUtils.changeColor(color, rgb, colorLabel.getDisplay());
+				colorLabel.setBackground(color);
+			}
+		}
+		
+				void createContents() {
+			setLayout(new GridLayout());
+			
+			Composite superComp = super.createNameComposite(this);
+			superComp.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+			
+			Composite colorComp = createColorComp(this);
+			colorComp.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+					    
+		    critComp = new CriterionComposite(this, null);
+		    critComp.setLayoutData(new GridData(GridData.FILL_BOTH));
+		    critComp.fetchSymbolsFromGex();
+		}
+		
+		Composite createColorComp(Composite parent) {
+			Composite colorComp = new Composite(parent, SWT.NULL);
+			colorComp.setLayout(new GridLayout(3, false));
+			
+			final GridData colorLabelGrid = new GridData(GridData.HORIZONTAL_ALIGN_BEGINNING);
+			colorLabelGrid.widthHint = colorLabelGrid.heightHint = colorLabelSize;
+			
+			Label label = new Label(colorComp, SWT.CENTER);
+			label.setText("Color:");
+
+			colorLabel = new CLabel(colorComp, SWT.SHADOW_IN);
+			colorLabel.setLayoutData(colorLabelGrid);
+			colorLabel.setBackground(getDisplay().getSystemColor(SWT.COLOR_BLACK));
+
+			Button colorButton = new Button(colorComp, SWT.PUSH);
+			colorButton.addListener(SWT.Selection | SWT.Dispose, new Listener() {
+				public void handleEvent(Event e) {
+					switch(e.type) {
+					case SWT.Selection:
+						RGB rgb = askColor();
+						changeColor(rgb);
+					break;
+					case SWT.Dispose:
+						color.dispose();
+					break;
+					}
+				}
+			});
+			
+			colorButton.setLayoutData(colorLabelGrid);
+			colorButton.setText("...");
+			
+			return colorComp;
+		}
+	}
+}

Property changes on: trunk/src/swt/org/pathvisio/visualization/colorset/ColorCriterion.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/visualization/colorset/ColorSetComposite.java
===================================================================
--- trunk/src/swt/org/pathvisio/visualization/colorset/ColorSetComposite.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/visualization/colorset/ColorSetComposite.java	(revision 961)
@@ -0,0 +1,628 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.colorset;
+
+import java.util.HashMap;
+
+import org.eclipse.jface.dialogs.Dialog;
+import org.eclipse.jface.viewers.ILabelProviderListener;
+import org.eclipse.jface.viewers.ISelectionChangedListener;
+import org.eclipse.jface.viewers.IStructuredContentProvider;
+import org.eclipse.jface.viewers.IStructuredSelection;
+import org.eclipse.jface.viewers.ITableLabelProvider;
+import org.eclipse.jface.viewers.SelectionChangedEvent;
+import org.eclipse.jface.viewers.StructuredSelection;
+import org.eclipse.jface.viewers.TableViewer;
+import org.eclipse.jface.viewers.Viewer;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.CLabel;
+import org.eclipse.swt.custom.StackLayout;
+import org.eclipse.swt.dnd.DND;
+import org.eclipse.swt.dnd.DragSource;
+import org.eclipse.swt.dnd.DragSourceAdapter;
+import org.eclipse.swt.dnd.DragSourceEvent;
+import org.eclipse.swt.dnd.DropTarget;
+import org.eclipse.swt.dnd.DropTargetAdapter;
+import org.eclipse.swt.dnd.DropTargetEvent;
+import org.eclipse.swt.dnd.TextTransfer;
+import org.eclipse.swt.dnd.Transfer;
+import org.eclipse.swt.events.ModifyEvent;
+import org.eclipse.swt.events.ModifyListener;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.events.SelectionListener;
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.graphics.ImageData;
+import org.eclipse.swt.graphics.PaletteData;
+import org.eclipse.swt.graphics.RGB;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.layout.RowLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.ColorDialog;
+import org.eclipse.swt.widgets.Combo;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Group;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Table;
+import org.eclipse.swt.widgets.TableColumn;
+import org.eclipse.swt.widgets.TableItem;
+import org.eclipse.swt.widgets.Text;
+
+import org.pathvisio.util.SwtUtils;
+import org.pathvisio.util.TableColumnResizer;
+import org.pathvisio.util.Utils;
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+import org.pathvisio.visualization.VisualizationManager.VisualizationListener;
+import org.pathvisio.visualization.colorset.ColorCriterion.ColorCriterionComposite;
+import org.pathvisio.visualization.colorset.ColorGradient.ColorGradientComposite;
+
+public class ColorSetComposite extends Composite implements VisualizationListener {
+	final int colorLabelSize = 15;
+	ColorSet colorSet;
+	
+	TableViewer objectsTable;
+	
+	Composite colorButtons;
+	Group objectsGroup;
+	ObjectSettingsComposite objectSettings;
+	Color colorNCM, colorNGF, colorNDF;
+	CLabel labelColorNCM, labelColorNGF, labelColorNDF;
+	Combo colorSetCombo;
+	Text nameText;
+	
+	public ColorSetComposite(Composite parent, int style) {
+		super(parent, style);
+		createContents();
+		VisualizationManager.addListener(this);
+	}
+	
+	public void dispose() {
+		colorNCM.dispose();
+		colorNGF.dispose();
+		colorNDF.dispose();
+		super.dispose();
+	}
+	
+	public void setInput(ColorSet cs) {
+		colorSet = cs;
+		if(colorSet == null) {
+			setObjectsGroupEnabled(false);
+		} else {
+			setObjectsGroupEnabled(true);
+			initColorLabels();
+			initName();
+			objectsTable.setInput(colorSet);
+			objectsTable.getTable().select(0);
+		}
+	}
+		
+	void setObjectsGroupEnabled(boolean enable) {
+		SwtUtils.setCompositeAndChildrenEnabled(objectsGroup, enable);
+	}
+		
+	void initName() {
+		nameText.setText(colorSet.getName());
+	}
+	
+	void initColorLabels() {
+		changeColorLabel(labelColorNCM, colorSet.getColor(ColorSet.ID_COLOR_NO_CRITERIA_MET));
+		changeColorLabel(labelColorNGF, colorSet.getColor(ColorSet.ID_COLOR_NO_GENE_FOUND));
+		changeColorLabel(labelColorNDF, colorSet.getColor(ColorSet.ID_COLOR_NO_DATA_FOUND));
+	}
+		
+	public void refreshCombo() {
+		colorSetCombo.setItems(ColorSetManager.getColorSetNames());
+		colorSetCombo.layout();
+		colorSetCombo.select(0);
+	}
+
+	void createContents() {
+		setLayout(new GridLayout());
+		Composite colorSetComp = createColorSetComposite(this);
+		colorSetComp.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+		
+		objectsGroup = new Group(this, SWT.NULL);
+		objectsGroup.setText("Criteria");
+		objectsGroup.setLayoutData(new GridData(GridData.FILL_BOTH));
+		objectsGroup.setLayout(new GridLayout(2, false));
+		
+		Composite listComp = createObjectList(objectsGroup);
+		listComp.setLayoutData(new GridData(GridData.FILL_VERTICAL));
+		
+		objectSettings = new ObjectSettingsComposite(objectsGroup, SWT.NONE);
+		objectSettings.setLayoutData(new GridData(GridData.FILL_BOTH));
+
+		refreshCombo();
+		
+		colorSetCombo.select(0);
+	}
+
+	Composite createObjectList(Composite parent) {
+		Composite listComp = new Composite(parent, SWT.NULL);
+		listComp.setLayout(new GridLayout());
+		
+		Composite tableComp = new Composite(listComp, SWT.NULL);
+		tableComp.setLayoutData(new GridData(GridData.FILL_BOTH));
+		tableComp.setLayout(new FillLayout());
+		Table table = new Table(tableComp, SWT.BORDER | SWT.SINGLE);
+		TableColumn coCol = new TableColumn(table, SWT.LEFT);
+		coCol.setText("Name");
+		table.addControlListener(new TableColumnResizer(table, listComp));
+		
+		objectsTable = new TableViewer(table);
+		objectsTable.setContentProvider(new IStructuredContentProvider() {
+			public Object[] getElements(Object inputElement) {
+				return ((ColorSet)inputElement).getObjects().toArray();
+			}
+			
+			public void dispose() { }
+			public void inputChanged(Viewer viewer, Object oldInput, Object newInput) { }
+		});
+		objectsTable.setLabelProvider(new ITableLabelProvider() {			
+			private HashMap<Object, Image> images = new HashMap<Object, Image>();
+											
+			public void dispose() {
+				for(Image img : images.values()) disposeImage(img);
+			}
+			
+			void disposeImage(Image img) { if(img != null && !img.isDisposed()) img.dispose(); }
+			
+			public Image getColumnImage(Object element, int columnIndex) {
+				Image img = images.get(element);
+				if(element instanceof ColorGradient) {
+					disposeImage(img);
+					img = new Image(null, createGradientImage((ColorGradient)element));
+					images.put(element, img);
+					return img;
+				}
+				if(element instanceof ColorCriterion) {
+					disposeImage(img);
+					img = new Image(null, createColorImage(
+							((ColorCriterion)element).getColor()));
+					images.put(element, img);
+					return img;
+				}
+				return null;
+			}
+			
+			public String getColumnText(Object element, int columnIndex) {
+				if(element instanceof ColorSetObject)
+					return ((ColorSetObject)element).getName();
+				return "";
+			}
+			
+			public boolean isLabelProperty(Object element, String property) {
+				return false;
+			}
+			public void removeListener(ILabelProviderListener listener) {}
+			public void addListener(ILabelProviderListener listener) {}
+		});
+		
+		objectsTable.addSelectionChangedListener(new ISelectionChangedListener() {
+			boolean ignore;
+			ColorSetObject previous = null;
+			public void selectionChanged(SelectionChangedEvent event) {
+				if(ignore) {
+					ignore = false;
+					return;
+				}
+				boolean save = true;
+				if(previous != null && colorSet.getObjects().contains(previous))
+					save = objectSettings.save();
+				if(save) {
+					previous = getSelectedObject();
+					objectSettings.setInput(previous);
+				} else {
+					ignore = true;
+					objectsTable.setSelection(new StructuredSelection(previous));
+				}
+			}
+		});
+		
+		//Drag & Drop support
+		DragSource ds = new DragSource(objectsTable.getTable(), DND.DROP_MOVE);
+		ds.addDragListener(new ColorSetObjectDragAdapter());
+		ds.setTransfer(new Transfer[] { TextTransfer.getInstance() });
+		DropTarget dt = new DropTarget(objectsTable.getTable(), DND.DROP_MOVE);
+		dt.addDropListener(new ColorSetObjectDropAdapter());
+		dt.setTransfer(new Transfer[] { TextTransfer.getInstance() });
+		
+		Composite buttons = new Composite(listComp, SWT.NULL);
+		buttons.setLayout(new RowLayout(SWT.HORIZONTAL));
+		final Button add = new Button(buttons, SWT.PUSH);
+		add.setText("Add");
+		final Button remove = new Button(buttons, SWT.PUSH);
+		remove.setText("Remove");
+		
+		SelectionListener buttonAdapter = new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				if(e.widget == add) addColorSetObject();
+				else removeColorSetObject();
+			}
+		};
+		
+		add.addSelectionListener(buttonAdapter);
+		remove.addSelectionListener(buttonAdapter);
+		
+		return  listComp;
+	}
+		
+	RGB askColor(RGB current) {
+		ColorDialog cd = new ColorDialog(getShell());
+		cd.setRGB(current);
+		return cd.open();
+	}
+	
+	void changeColor(CLabel label) {
+		ColorDialog cd = new ColorDialog(getShell());
+		cd.setRGB(label.getBackground().getRGB());
+		changeColor(label, cd.open());
+	}
+	
+	void changeColor(CLabel label, RGB rgb) {
+		int id = -1;
+		if(label == labelColorNCM)
+			id = ColorSet.ID_COLOR_NO_CRITERIA_MET;
+		else if	(label == labelColorNDF)
+			id = ColorSet.ID_COLOR_NO_DATA_FOUND;
+		else if (label == labelColorNGF)
+			id = ColorSet.ID_COLOR_NO_GENE_FOUND;
+
+		if(id >= 0) {
+			if(rgb != null) {
+				colorSet.setColor(id, rgb);
+				changeColorLabel(label, rgb);
+			}
+		}
+	}
+	
+	void changeColorLabel(CLabel label, RGB rgb) {
+		Color c = null;
+		if(label == labelColorNCM)
+			c = colorNCM = SwtUtils.changeColor(colorNCM, rgb, getDisplay());
+		else if	(label == labelColorNDF)
+			c = colorNDF = SwtUtils.changeColor(colorNDF, rgb, getDisplay());
+		else if (label == labelColorNGF)
+			c = colorNGF = SwtUtils.changeColor(colorNGF, rgb, getDisplay());
+		
+		if(c != null) label.setBackground(c);
+	}
+	
+	void addColorSet() {
+		ColorSetManager.newColorSet(null);
+		refreshCombo();
+		colorSetCombo.select(ColorSetManager.getColorSets().size() - 1);
+	}
+	
+	void removeColorSet() {
+		ColorSetManager.removeColorSet(colorSetCombo.getSelectionIndex());
+		refreshCombo();
+	}
+	
+	void addColorSetObject() {
+		final int NEW_GRADIENT = 10;
+		final int NEW_EXPRESSION = 11;
+		Dialog dialog = new Dialog(getShell()) {
+			int newObject = NEW_GRADIENT;
+			public int open() {
+				int open = super.open();
+				return open == CANCEL ? CANCEL : newObject;
+			}
+			protected Control createDialogArea(Composite parent) {
+				setBlockOnOpen(true);
+				Composite contents = new Composite(parent, SWT.NULL);
+				contents.setLayout(new RowLayout(SWT.VERTICAL));
+				final Button gradient = new Button(contents, SWT.RADIO);
+				gradient.setText("Color by gradient");
+				final Button expression = new Button(contents, SWT.RADIO);
+				expression.setText("Color by boolean expression");
+				
+				SelectionListener lst = new SelectionAdapter() {
+					public void widgetSelected(SelectionEvent e) {
+						if(e.widget == gradient) newObject =  NEW_GRADIENT;
+						else newObject = NEW_EXPRESSION;
+					}
+				};
+				
+				gradient.addSelectionListener(lst);
+				expression.addSelectionListener(lst);
+				gradient.setSelection(true);
+				return contents;
+			}
+		};
+		
+		int type = dialog.open();
+		if(type == Dialog.CANCEL) return;
+		ColorSetObject newCso = null;
+		switch(type) {
+		case NEW_GRADIENT:
+			newCso = new ColorGradient(colorSet, colorSet.getNewName("New gradient"));
+			break;
+		case NEW_EXPRESSION:
+			newCso = new ColorCriterion(colorSet, colorSet.getNewName("New expression"));
+			break;
+		}
+		if(newCso != null) {
+			colorSet.addObject(newCso);
+			objectsTable.refresh();
+			objectsTable.setSelection(new StructuredSelection(newCso));
+		}
+		
+	}
+	
+	void removeColorSetObject() {
+		colorSet.removeObject(getSelectedObject());
+		objectsTable.refresh();
+	}
+	
+	ColorSetObject getSelectedObject() {
+		return (ColorSetObject)
+			((IStructuredSelection)objectsTable.getSelection()).getFirstElement();
+	}
+	void modifyName(String newName) {
+		if(!newName.equals("")) colorSet.setName(newName);
+	}
+	
+	void colorSetSelected() {
+		int index = colorSetCombo.getSelectionIndex();
+		if(index == -1)
+			setInput(null);
+		else
+			setInput(ColorSetManager.getColorSets().get(index));
+	}
+	
+	Composite createColorSetComposite(Composite parent) {
+		Composite csComp = new Composite(parent, SWT.NULL);
+		csComp.setLayout(new GridLayout(2, false));
+		
+		//Combo + buttons
+		Composite comboComp = new Composite(csComp, SWT.NULL);
+		comboComp.setLayout(new GridLayout());
+		
+		Label comboLabel = new Label(comboComp, SWT.NULL);
+		comboLabel.setText("Color set:");
+		colorSetCombo = new Combo(comboComp, SWT.SINGLE | SWT.READ_ONLY);
+		colorSetCombo.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+		colorSetCombo.addModifyListener(new ModifyListener() {
+			public void modifyText(ModifyEvent e) {
+				colorSetSelected();
+				enableSettings(colorSet != null);
+			}
+			
+			void enableSettings(boolean enable) {
+				nameText.setEnabled(enable);
+				SwtUtils.setCompositeAndChildrenEnabled(colorButtons, enable);
+			}
+		});
+		
+		Composite buttons = new Composite(comboComp, SWT.NULL);
+		buttons.setLayout(new RowLayout(SWT.HORIZONTAL));
+		final Button add = new Button(buttons, SWT.PUSH);
+		add.setText("Add");
+		final Button remove = new Button(buttons, SWT.PUSH);
+		remove.setText("Remove");
+		
+		SelectionListener buttonAdapter = new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				if(e.widget == add) addColorSet();
+				else removeColorSet();
+			}
+		};
+		
+		add.addSelectionListener(buttonAdapter);
+		remove.addSelectionListener(buttonAdapter);
+		
+		//Name + colors
+		Composite csSettings = new Composite(csComp, SWT.NULL);
+		csSettings.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+		csSettings.setLayout(new GridLayout(2, false));
+		
+		Label nameLabel = new Label(csSettings, SWT.NULL);
+		nameLabel.setText("Name: ");
+		
+		nameText = new Text(csSettings, SWT.SINGLE | SWT.BORDER);
+		nameText.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+		nameText.addModifyListener(new ModifyListener() {
+			public void modifyText(ModifyEvent e) {
+				modifyName(nameText.getText());
+			}
+		});
+		
+				
+		colorButtons = createFixedColors(csSettings);
+		GridData span2cols = new GridData(GridData.FILL_HORIZONTAL);
+		span2cols.horizontalSpan = 2;
+		colorButtons.setLayoutData(span2cols);
+		
+		nameText.setEnabled(false);
+		SwtUtils.setCompositeAndChildrenEnabled(colorButtons, false);
+		return csComp;
+	}
+	
+	Composite createFixedColors(Composite parent) {		
+		Group buttonGroup = new Group(parent, SWT.NULL);
+		buttonGroup.setLayout(new GridLayout(3, false));
+		buttonGroup.setText("Colors");
+		
+		CLabel[] colorLabels = new CLabel[3];
+		String[] names = new String[] {
+				"No criteria met", "Gene not found", "No data found"
+		};
+		for(int i = 0; i < colorLabels.length; i++) {
+			Composite comp = new Composite(buttonGroup, SWT.NULL);
+			comp.setLayout(new GridLayout(3, false));
+			final CLabel clabel = new CLabel(comp, SWT.SHADOW_IN);
+			clabel.setLayoutData(SwtUtils.getColorLabelGrid());
+			Button b = new Button(comp, SWT.PUSH);
+			b.setLayoutData(SwtUtils.getColorLabelGrid());
+			b.setText("...");
+			b.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) { 
+					changeColor(clabel);
+				}
+			});
+			Label label = new Label(comp, SWT.NULL);
+			label.setText(names[i]);
+			colorLabels[i] = clabel;
+		}
+		labelColorNCM = colorLabels[0];
+		labelColorNGF = colorLabels[1];
+		labelColorNDF = colorLabels[2];
+				
+		return buttonGroup;
+	}
+	
+	class ObjectSettingsComposite extends Composite {
+		StackLayout stack;
+		ColorSetObject input;
+		ColorGradientComposite gradientComp;
+		ColorCriterionComposite criterionComp;
+		Composite nothing;
+		
+		public ObjectSettingsComposite(Composite parent, int style) {
+			super(parent, style);
+			createContents();
+		}
+		
+		public void setInput(ColorSetObject cso) {
+			input = cso;
+			refresh();
+		}
+		
+		public boolean save() {
+			if(input instanceof ColorGradient) return gradientComp.save();
+			else if (input instanceof ColorCriterion) return criterionComp.save();
+			else return true;
+		}
+		
+		public void refresh() {
+			if(input == null) stack.topControl = nothing;
+			else {
+				if(input instanceof ColorGradient) {
+					stack.topControl = gradientComp;
+					gradientComp.setInput(getSelectedObject());
+				} else {
+					stack.topControl = criterionComp;
+					criterionComp.setInput(getSelectedObject());
+				}
+			}
+			layout();
+		}
+		
+		void createContents() {
+			stack = new StackLayout();
+			setLayout(stack);
+						
+			//Gradient
+			gradientComp = new ColorGradientComposite(this, SWT.NULL);
+			//Criterion
+			criterionComp = new ColorCriterionComposite(this, SWT.NULL);
+			//Nothing
+			new Composite(this, SWT.NULL);
+		}		
+	}
+	
+	/**
+	 * creates an 16x16 image filled with the given color
+	 * @param rgb the color to fill the image with
+	 * @return imagedata of a 16x16 image filled with the given color
+	 */
+	static ImageData createColorImage(RGB rgb) {
+		PaletteData colors = new PaletteData(new RGB[] { rgb, new RGB(0,0,0) });
+		ImageData data = new ImageData(16, 16, 1, colors);
+		for(int i = 0; i < 16; i++)
+		{
+			for(int j = 0; j < 16; j++)
+			{
+				if(j == 0 || j == 15 || i == 0 || i == 15) //Black border
+					data.setPixel(i, j, 1);
+				else
+					data.setPixel(i, j, 0);
+			}
+		}
+		return data;
+	}
+	
+	/**
+	 * creates a 16x16 image representing the given {@link GmmlColorGradient}
+	 * @param cg the gradient to create the image from
+	 * @return imagedata representing the gradient
+	 */
+	static ImageData createGradientImage(ColorGradient cg)
+	{
+		PaletteData colors = new PaletteData(0xFF0000, 0x00FF00, 0x0000FF);
+		ImageData data = new ImageData(16, 16, 24, colors);
+		double[] minmax = cg.getMinMax();
+		for(int i = 0; i < 16; i++)
+		{
+			RGB rgb = cg.getColor(minmax[0] + (i * (minmax[1]- minmax[0])) / 16 );
+			if(rgb == null)
+				rgb = new RGB(255,255,255);
+			for(int j = 0; j < 16; j++)
+			{
+				if(j == 0 || j == 15 || i == 0 || i == 15) //Black border
+					data.setPixel(i, j, colors.getPixel(new RGB(0,0,0)));
+				else
+					data.setPixel(i, j, colors.getPixel(rgb));
+			}
+		}
+		return data;
+	}
+
+
+	public void visualizationEvent(VisualizationEvent e) {
+		switch(e.type) {
+		case(VisualizationEvent.COLORSET_MODIFIED):
+			if(objectsTable != null && !objectsTable.getTable().isDisposed())
+				objectsTable.refresh();
+		}
+		
+	}
+	
+    private class ColorSetObjectDragAdapter extends DragSourceAdapter {
+    	public void dragStart(DragSourceEvent e) {
+    		e.doit = getSelectedObject() == null ? false : true;
+    	}
+    	
+    	public void dragSetData(DragSourceEvent e) {
+    		ColorSetObject selected = getSelectedObject();
+    		int csoIndex = colorSet.colorSetObjects.indexOf(selected);
+    		e.data = Integer.toString(csoIndex);
+    	}
+    }
+    
+    private class ColorSetObjectDropAdapter extends DropTargetAdapter {
+    	public void drop(DropTargetEvent e) {
+    		TableItem item = (TableItem)e.item;
+    		if(item != null)
+    		{
+    			Object selected = item.getData();
+    			int index = Integer.parseInt((String)e.data);
+    			if(index >= 0) {
+    				ColorSetObject cso = colorSet.getObjects().get(index);
+    				Utils.moveElement(colorSet.getObjects(), cso, colorSet.getObjects().indexOf(selected));
+    				objectsTable.refresh();
+    			}
+    		}
+    	}
+    }
+}

Property changes on: trunk/src/swt/org/pathvisio/visualization/colorset/ColorSetComposite.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/visualization/colorset/Criterion.java
===================================================================
--- trunk/src/swt/org/pathvisio/visualization/colorset/Criterion.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/visualization/colorset/Criterion.java	(revision 961)
@@ -0,0 +1,574 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization.colorset;
+
+import java.util.HashMap;
+
+import org.eclipse.swt.widgets.Composite;
+import org.pathvisio.Engine;
+import org.pathvisio.data.Gex;
+import org.pathvisio.data.Gex.Sample;
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+
+public class Criterion {
+	static final String displaySample = "|Displayed sample|";
+	public static final String[] tokens = {"AND", "OR", "=", "<", ">", "<=", ">="};
+	private HashMap<String, Double> symTab;
+
+	private String expression;
+		
+	private Exception parseException;
+	
+	CriterionComposite configComp;
+		
+	public String getExpression() {  
+		return expression == null ? "" : expression; 
+	}
+	
+	public boolean setExpression(String expression) {
+		this.expression = expression;
+		fireModifiedEvent();
+		return testExpression(expression);
+	}
+	
+	public boolean setExpression(String expression, String[] symbols) {
+		//Evaluate with dummy data:
+		this.expression = expression;
+		fireModifiedEvent();
+		return testExpression(expression, symbols);
+	}
+	
+	public boolean testExpression(String expression) {
+		try {
+			evaluate(expression);
+			parseException = null;
+			return true;
+		} catch(Exception e) { 
+			parseException = e;
+			return false;
+		}
+	}
+	
+	public boolean testExpression(String expression, String[] symbols) {
+		for(String s : symbols) {
+			addSymbol(s, 1.0);
+		}
+		return testExpression(expression);
+	}
+	
+	public Exception getParseException() { 
+		return parseException;
+	}
+
+	void setSampleData(HashMap<Integer, Object> data) {
+		// Add current sample values to symTab if they are of type Double
+		HashMap<Integer, Sample> samples = Gex.getSamples();
+		clearSymbols();
+		for(Sample s : samples.values()) {
+			Object value = data.get(s.getId());
+			if(value instanceof Double) addSymbol(s.getName(), (Double)value);
+		}
+	}
+	
+	public boolean evaluate(HashMap<Integer, Object> data, int displaySampleId) throws Exception {
+		setSampleData(data);
+		Object value = data.get(displaySampleId);
+		if(value instanceof Double) addSymbol(displaySample, (Double)value);
+
+		return evaluate(expression);
+	}
+	
+	public boolean evaluate(HashMap<Integer, Object> data) throws Exception {
+		setSampleData(data);
+		return evaluate(expression);
+	}
+	
+	public boolean evaluate(String[] symbols, double[] values) throws Exception {
+		clearSymbols();
+		for(int i = 0; i < symbols.length; i++) {
+			symTab.put(symbols[i], values[i]);
+		}
+		return evaluate(expression);
+	}
+
+	public void addSymbol(String sym, Double val)
+	{
+		if(symTab == null) symTab = new HashMap<String, Double>();
+		symTab.put(sym, val);
+	}
+
+	void clearSymbols()
+	{
+		if(symTab == null) return;
+		symTab.clear();
+	}
+		
+	public CriterionComposite getConfigComposite() {
+		return configComp;
+	}
+	
+	public CriterionComposite createConfigComposite(Composite parent) {
+		if(configComp != null && !configComp.isDisposed()) return configComp;
+		configComp = new CriterionComposite(parent, this);
+		return configComp;
+	}
+	
+	void fireModifiedEvent() {
+		VisualizationManager.fireVisualizationEvent(
+				new VisualizationEvent(this, VisualizationEvent.COLORSET_MODIFIED));
+	}
+	//Boolean expression parser by Martijn
+	String input;
+	int charNr;
+	boolean evaluate (String expr) throws Exception
+	{
+		Token e = parse(expr);
+		return e.evaluateAsBool();
+	}
+
+	Token parse(String expr) throws Exception {
+		charNr = 0;
+		input = expr;
+
+		Token e = expression();
+		Token t = getToken();
+		if (t.type != Token.TOKEN_END)
+		{
+			nextToken = null;
+			throw new Exception("Multiple expressions found, second expression " +
+					"starts at position " + charNr);
+		}
+		return e;
+	}
+	
+	char eatChar()
+	{
+		if (input.length() == 0)
+		{
+			return '\0';
+		}
+		else
+		{
+			charNr++;
+			char result = input.charAt(0);
+			input = input.substring(1);
+			return result;
+		}
+	}
+
+	void putBack(char ch)
+	{
+		if (input.length() == 0 && ch == '\0')
+		{
+		}
+		else
+		{
+			input = ch + input;
+		}
+	}
+
+	Token nextToken = null;
+
+	Token getLookAhead() throws Exception
+	{
+		nextToken = getToken();
+		return nextToken;
+	}
+
+	// note: token is taken away from input!
+	Token getToken() throws Exception
+	{      
+		Token token = null;
+		if (nextToken != null)
+		{
+			token = nextToken;
+			nextToken = null;
+			return token;
+		}
+
+		// eat whitespace
+		char ch = eatChar();
+
+		while (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r')
+		{
+			ch = eatChar();
+		}
+
+		// read token
+		switch (ch)
+		{
+		case '-':
+		case '0': case '1': case '2': case '3': case '4':
+		case '5': case '6': case '7': case '8': case '9':
+		case '.': {
+			String value = "" + ch;
+			ch = eatChar();
+			while ((ch >= '0' && ch <= '9') || ch == '.')
+			{
+				value += ch;
+				ch = eatChar();
+			}
+			putBack (ch);									
+			token = new Token(Token.TOKEN_NUMBER, Double.parseDouble(value)); }                            
+		break;
+		case '<':
+			ch = eatChar();
+			if (ch == '=')
+				token = new Token(Token.TOKEN_LE);	
+			else
+			{
+				token = new Token(Token.TOKEN_LT);
+				putBack (ch);
+			}
+			break;
+		case '>':
+			ch = eatChar();
+			if (ch == '=')
+				token = new Token(Token.TOKEN_GE);	
+			else
+			{
+				token = new Token(Token.TOKEN_GT);
+				putBack (ch);
+			}
+			break;
+		case '=': 
+			token = new Token(Token.TOKEN_EQ);
+			break;
+		case '(': 
+			token = new Token(Token.TOKEN_LPAREN);
+			break;
+		case ')': 
+			token = new Token(Token.TOKEN_RPAREN);
+			break;
+		case '[': {
+			ch = eatChar();
+			String value = "";
+			while (ch != ']' && ch != '\0')
+			{
+				value += ch;
+				ch = eatChar();
+			}
+			token = new Token(Token.TOKEN_ID, value);                 
+		} break;
+		case 'A':	
+
+			if (eatChar() == 'N' && eatChar() == 'D')
+			{
+				token = new Token (Token.TOKEN_AND);
+			}
+			else
+			{
+				throw new Exception("Invalid character 'A' at position " + (charNr - 2) + 
+				"\n- Expected start of 'AND'");
+			}
+			break;
+		case 'O':
+			ch = eatChar();
+			if (ch == 'R')
+			{
+				token = new Token (Token.TOKEN_OR);
+			}
+			else
+			{
+				throw new Exception("Invalid character 'O' at position " + (charNr - 1) + 
+				"\n- Expected start of 'OR'");
+			}
+			break;
+		case '\0':
+			token = new Token (Token.TOKEN_END);
+			break;
+		default:
+			throw new Exception("Unexpected end of expression at position " + charNr);
+		}
+		//~ System.out.print (token.type + ", ");
+		return token;
+	}
+
+	/*
+		eats a factor
+			forms:
+			- number
+			- identifier
+			- "(" expression ")"
+	 */
+	Token factor() throws Exception
+	{
+		Token result;
+		Token t = getLookAhead();
+		if (t.type == Token.TOKEN_NUMBER)
+		{
+			getToken();
+			result = t;
+		}
+		else if (t.type == Token.TOKEN_ID)
+		{
+			getToken();
+			result = t;
+		}
+		else if (t.type == Token.TOKEN_LPAREN)
+		{
+			getToken();
+			result = expression();
+			t = getToken();			
+			if (t.type != Token.TOKEN_RPAREN)
+			{
+				nextToken = null;
+				throw new Exception("Number of opening and closing brackets does not match");
+			}			
+		}
+		else
+		{
+			nextToken = null;
+			throw new Exception("Wrong token at position " + charNr);
+		}
+		return result;
+	}
+
+
+	/*
+		eats a subterm
+			forms:
+			subterm -> factor morefactors
+			morefactors -> "<=|=|>=|>|<" factor morefactors
+						| empty
+	 */
+	Token subterm() throws Exception
+	{
+		Token result;
+		result = factor();
+		while (true)
+		{
+			Token t = getLookAhead();
+			if (t.type == Token.TOKEN_EQ || t.type == Token.TOKEN_GE ||
+					t.type == Token.TOKEN_LE || t.type == Token.TOKEN_GT ||
+					t.type == Token.TOKEN_LT)
+			{
+				getToken();
+				t.left = result;
+				t.right = subterm();
+				result = t;
+			}
+			else
+			{
+				return result;
+			}
+		}		
+	}
+
+	/*
+		eats a term
+			forms:
+			term -> subterm moresubterms
+			moresubterms -> "AND" subterm moresubterms
+						| empty
+	 */
+	Token term() throws Exception
+	{
+		Token result;
+		result = subterm();
+		while (true)
+		{
+			Token t = getLookAhead();
+			if (t.type == Token.TOKEN_AND)
+			{
+				getToken();
+				t.left = result;
+				t.right = term();
+				result = t;
+			}
+			else
+			{
+				return result;
+			}
+		}
+	}
+
+
+	/* eats an expression
+			forms:
+			expression -> term moreterms
+			moreterms -> "OR" term moreterms
+				| empty
+	 */
+	Token expression() throws Exception
+	{
+		Token result;
+		result = term();
+		while (true)
+		{
+			Token t = getLookAhead();
+			if (t.type == Token.TOKEN_OR)
+			{
+				getToken();
+				t.left = result;			
+				t.right = expression();
+				result = t;
+			}
+			else
+			{
+				return result;
+			}				
+		}
+	}
+
+	/**
+	 * This class represents a single token of an expression
+	 */
+	class Token {
+		public int type;
+		public static final int TOKEN_NONE = -2;
+		public static final int TOKEN_END = -1;
+		public static final int TOKEN_NUMBER = 0;
+		public static final int TOKEN_ID = 1;
+		public static final int TOKEN_EQ = 2;
+		public static final int TOKEN_GT = 3;
+		public static final int TOKEN_LT = 4;
+		public static final int TOKEN_GE = 5;
+		public static final int TOKEN_LE = 6;
+		public static final int TOKEN_AND = 7;
+		public static final int TOKEN_OR = 8;
+		public static final int TOKEN_LPAREN = 9;
+		public static final int TOKEN_RPAREN = 10;
+
+		public double numberValue; // in case it is a number...
+		public String symbolValue; // in case it is a symbol
+
+		Token left = null;
+		Token right = null;
+
+		void printMe (int level)
+		{
+			for (int i = 0; i < level; ++i)
+			{
+				Engine.log.trace ("--- ");
+			}
+			switch (type)
+			{
+			case Token.TOKEN_AND:
+				Engine.log.trace("AND");
+				left.printMe(level + 1);
+				right.printMe(level + 1);
+				break;
+			case Token.TOKEN_OR:
+				Engine.log.trace("OR");
+				left.printMe(level + 1);
+				right.printMe(level + 1);
+				break;
+			case Token.TOKEN_LE:
+				Engine.log.trace("<=");
+				left.printMe(level + 1);
+				right.printMe(level + 1);
+				break;
+			case Token.TOKEN_LT:
+				Engine.log.trace("<");
+				left.printMe(level + 1);
+				right.printMe(level + 1);
+				break;
+			case Token.TOKEN_GT:
+				Engine.log.trace(">");
+				left.printMe(level + 1);
+				right.printMe(level + 1);
+				break;
+			case Token.TOKEN_GE:
+				Engine.log.trace(">=");
+				left.printMe(level + 1);
+				right.printMe(level + 1);
+				break;
+			case Token.TOKEN_EQ:
+				Engine.log.trace("=");
+				left.printMe(level + 1);
+				right.printMe(level + 1);
+				break;
+			case Token.TOKEN_ID:
+				Engine.log.trace("ID: " + symbolValue);
+				break;
+			case Token.TOKEN_NUMBER:
+				Engine.log.trace("NUMBER: " + numberValue);
+				break;
+			}
+		}
+
+		boolean evaluateAsBool() throws Exception
+		{
+			switch (type)
+			{
+			case Token.TOKEN_AND:
+				if (left.evaluateAsBool() && right.evaluateAsBool())
+					return true;
+				else
+					return false;
+			case Token.TOKEN_OR:
+				if (left.evaluateAsBool() || right.evaluateAsBool())
+					return true;
+				else
+					return false;
+			case Token.TOKEN_EQ:
+				if (left.evaluateAsDouble() == right.evaluateAsDouble())
+					return true;
+				else
+					return false;
+			case Token.TOKEN_GE:
+				if (left.evaluateAsDouble() >= right.evaluateAsDouble())
+					return true;
+				else
+					return false;
+			case Token.TOKEN_LE:
+				if (left.evaluateAsDouble() <= right.evaluateAsDouble())
+					return true;
+				else
+					return false;
+			case Token.TOKEN_GT:
+				if (left.evaluateAsDouble() > right.evaluateAsDouble())
+					return true;
+				else
+					return false;
+			case Token.TOKEN_LT:
+				if (left.evaluateAsDouble() < right.evaluateAsDouble())
+					return true;
+				else
+					return false;
+			}
+			throw new Exception("Can't evaluate this expression as boolean");
+		}
+
+		double evaluateAsDouble() throws Exception
+		{
+			String error = "";
+			switch (type)
+			{
+			case Token.TOKEN_ID:
+				if(!symTab.containsKey(symbolValue)) {//symbol has no value
+					error = "Sample '[" + symbolValue + "]' has no value";
+					break;
+				}
+				return (Double)symTab.get(symbolValue);
+			case Token.TOKEN_NUMBER:
+				return numberValue;
+			default:
+				error = "Can't evaluate this expression as numeric";
+			}
+			throw new Exception(error);
+		}
+
+		Token (int _type) { type = _type; numberValue = 0; symbolValue = ""; }
+		Token (int _type, double _numberValue) { type = _type; numberValue = _numberValue; symbolValue = ""; }
+		Token (int _type, String _symbolValue) { type = _type; numberValue = 0; symbolValue = _symbolValue; }
+	}
+}
+
+

Property changes on: trunk/src/swt/org/pathvisio/visualization/colorset/Criterion.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/visualization/VisualizationManager.java
===================================================================
--- trunk/src/swt/org/pathvisio/visualization/VisualizationManager.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/visualization/VisualizationManager.java	(revision 961)
@@ -0,0 +1,429 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.EventObject;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.eclipse.jface.action.ContributionItem;
+import org.eclipse.jface.action.ControlContribution;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.ScrolledComposite;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Combo;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Label;
+import org.jdom.Document;
+import org.jdom.Element;
+import org.jdom.input.SAXBuilder;
+import org.jdom.output.Format;
+import org.jdom.output.XMLOutputter;
+import org.pathvisio.Engine;
+import org.pathvisio.Engine.ApplicationEvent;
+import org.pathvisio.Engine.ApplicationEventListener;
+import org.pathvisio.data.Gex;
+import org.pathvisio.data.Gex.ExpressionDataEvent;
+import org.pathvisio.data.Gex.ExpressionDataListener;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.view.Graphics;
+import org.pathvisio.view.SelectionBox;
+import org.pathvisio.view.SelectionBox.SelectionListener;
+
+/**
+ * Manages visualizations
+ * @author thomas
+ *
+ */
+public class VisualizationManager implements ApplicationEventListener, ExpressionDataListener {	
+	static {
+		VisualizationManager vm = new VisualizationManager();
+		Engine.addApplicationEventListener(vm);
+		Gex.addListener(vm);
+	}
+	
+	public static final String XML_ELEMENT = "visualizations";
+		
+	static final String FILENAME_GENERIC = "visualizations.xml";
+	
+	static final int CURRENT_NONE = -1;
+	
+	static List<Visualization> visualizations = new ArrayList<Visualization>();
+	static int current = -1;
+		
+	public static Visualization getCurrent() {
+		if(current < 0 || current >= visualizations.size()) return null;
+		return visualizations.get(current);
+	}
+	
+	public static void setCurrent(int index) {
+		current = index;
+		fireVisualizationEvent(
+				new VisualizationEvent(null, VisualizationEvent.VISUALIZATION_SELECTED));
+	}
+	
+	public static void setCurrent(Visualization v) {
+		int index = getVisualizations().indexOf(v);
+		if(index > -1) setCurrent(index);
+	}
+	
+	public static List<Visualization> getVisualizations() {
+		return visualizations;
+	}
+	
+	public static List<Visualization> getGeneric() {
+		List<Visualization> generic = new ArrayList<Visualization>();
+		for(Visualization v : visualizations) if(v.isGeneric()) generic.add(v);
+		return generic;
+	}
+	
+	public static List<Visualization> getNonGeneric() {
+		List<Visualization> nongeneric = new ArrayList<Visualization>();
+		for(Visualization v : visualizations) if(!v.isGeneric()) nongeneric.add(v);
+		return nongeneric;
+	}
+	
+	public static String[] getNames() {
+		String[] names = new String[visualizations.size()];
+		for(int i = 0; i < names.length; i++) 
+			names[i] = visualizations.get(i).getName();
+		return names;
+	}
+	
+	public static void addVisualization(Visualization v) {
+		visualizations.add(v);
+		fireVisualizationEvent(
+				new VisualizationEvent(null, VisualizationEvent.VISUALIZATION_ADDED));
+	}
+	
+	public static void removeVisualization(int index) {
+		if(index < 0 || index >= visualizations.size()) return; //Ignore wrong index
+		visualizations.remove(index);
+		fireVisualizationEvent(
+				new VisualizationEvent(null, VisualizationEvent.VISUALIZATION_REMOVED));
+	}
+	
+	public static void removeVisualization(Visualization v) {
+		removeVisualization(visualizations.indexOf(v));
+	}
+	
+	public static String getNewName() {
+		String prefix = "visualization";
+		int i = 1;
+		String name = prefix;
+		while(nameExists(name)) name = prefix + "-" + i++;
+		return name;
+	}
+	
+	public static boolean nameExists(String name) {
+		for(Visualization v : visualizations) 
+			if(v.getName().equalsIgnoreCase(name)) return true;
+		return false;
+	}
+	
+	public void saveGeneric() {
+		Document xmlDoc = new Document();
+		Element root = new Element(XML_ELEMENT);
+
+		for(Visualization v : visualizations) {
+			if(v.isGeneric()) root.addContent(v.toXML());
+		}
+		xmlDoc.addContent(root);
+		
+		XMLOutputter out = new XMLOutputter(Format.getPrettyFormat());
+		try {
+			FileWriter fw = new FileWriter(getGenericFile());
+			out.output(xmlDoc, fw);
+			fw.close();
+		} catch(IOException e) {
+			Engine.log.error("Unable to save visualization settings", e);
+		}
+	}
+	
+	public static void loadGeneric() {
+		if(!getGenericFile().exists()) return; //No generic visualizations saved yet
+		SAXBuilder parser = new SAXBuilder();
+		try {
+			Document doc = parser.build(getGenericFile());
+			Element root = doc.getRootElement();
+			for(Object o : root.getChildren(Visualization.XML_ELEMENT)) {
+				visualizations.add(Visualization.fromXML((Element) o));				
+			}
+		} catch(Exception e) {
+			Engine.log.error("Unable to load visualization settinsg", e);
+		}
+	}
+	
+	public static Element getNonGenericXML() {
+		Element xml = new Element(XML_ELEMENT);
+		
+		for(Visualization v : getNonGeneric()) xml.addContent(v.toXML());
+		
+		return xml;
+	}
+	
+	public static void loadNonGenericXML(Element xml) {		
+		if(xml == null) return;
+		
+		for(Object o : xml.getChildren(Visualization.XML_ELEMENT)) {
+			Visualization vis = Visualization.fromXML((Element) o);
+			if(!visualizations.contains(vis)) addVisualization(vis);				
+		}
+	}
+	
+	static void removeNonGeneric() {
+		List<Visualization> toRemove = new ArrayList<Visualization>();
+		for(Visualization v : getVisualizations()) {
+			if(!v.isGeneric()) toRemove.add(v);
+		}
+		for(Visualization v : toRemove) removeVisualization(v);
+	}
+	
+	static File getGenericFile() {
+		return new File(SwtEngine.getApplicationDir(), FILENAME_GENERIC);
+	}
+	
+	static VisComboItem visComboItem = new VisComboItem("VisualizationCombo");
+	public static ContributionItem getComboItem() {
+		return visComboItem;
+	}
+	
+	static VisualizationPanel sidePanel;
+		
+	public static Composite getSidePanel() {
+		return sidePanel;
+	}
+	public static Composite createSidePanel(Composite parent) {
+		if(sidePanel != null && !sidePanel.isDisposed()) sidePanel.dispose();
+		sidePanel = new VisualizationPanel(parent, SWT.NULL);
+		return sidePanel;
+	}
+	
+	static class VisComboItem extends ControlContribution implements VisualizationListener {
+		final String NONE = "no visualization";
+		Combo visCombo;
+		
+		public VisComboItem(String id) {
+			super(id);
+			addListener(this);
+		}
+
+		protected Control createControl(Composite parent) {
+			Composite control = new Composite(parent, SWT.NULL);
+			GridLayout layout = new GridLayout(2, false);
+			layout.marginHeight = layout.marginWidth = 1;
+			control.setLayout(layout);
+			
+			Label label = new Label(control, SWT.CENTER);
+			label.setText("Visualization: ");
+			visCombo = new Combo(control, SWT.DROP_DOWN | SWT.READ_ONLY);
+			visCombo.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+			visCombo.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					setCurrent(visCombo.getSelectionIndex() - 1);
+				}
+			});
+			visCombo.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					setCurrent(visCombo.getSelectionIndex() - 1);
+				}
+			});
+			update();
+			return control;
+		}
+		
+		public void update() {
+			if(visCombo == null) return;
+			
+			String[] visnames = getNames();
+			String[] items = new String[visnames.length + 1];
+			items[0] = NONE;
+			for(int i = 1; i < items.length; i++) items[i] = visnames[i-1];
+			visCombo.setItems(items);
+			visCombo.select(current + 1);
+		}
+
+		public void visualizationEvent(VisualizationEvent e) {
+			switch(e.type) {
+			case(VisualizationEvent.VISUALIZATION_ADDED):
+			case(VisualizationEvent.VISUALIZATION_REMOVED):
+			case(VisualizationEvent.VISUALIZATION_MODIFIED):
+				visCombo.getDisplay().syncExec(new Runnable() {
+					public void run() {
+						update();
+					}
+				});
+			}
+			
+		}
+	}
+	
+	static class VisualizationPanel extends ScrolledComposite implements SelectionListener, VisualizationListener {
+		Visualization vis;
+		Composite contents;
+		Set<Graphics> input;
+		
+		public VisualizationPanel(Composite parent, int style) {
+			super(parent, style);
+			createContents();
+			SelectionBox.addListener(this);
+			VisualizationManager.addListener(this);
+			input = new LinkedHashSet<Graphics>();
+		}
+		
+		void createContents() {
+			contents = new Composite(this, SWT.NULL);
+			contents.setBackground(getDisplay().getSystemColor(SWT.COLOR_WHITE));
+			setContent(contents);
+			setExpandHorizontal(true);
+			setExpandVertical(true);
+			contents.setLayout(new FillLayout());
+			setMinSize(contents.computeSize(SWT.DEFAULT, SWT.DEFAULT));
+		}
+		
+		void fillContents() {
+			if(vis != null) {
+				vis.disposeSidePanel();
+				vis.createSideSidePanel(contents);
+			}
+		}
+		
+		public void setVisualization(Visualization v) {
+			if(vis != null) vis.disposeSidePanel();
+			vis = v;
+			fillContents();
+		}
+		
+		void addInput(Graphics g) {
+			input.add(g);
+			refresh();
+		}
+		
+		void removeInput(Graphics g) {
+			input.remove(g);
+			refresh();
+		}
+		
+		void clearInput() {
+			input.clear();
+			refresh();
+		}
+		
+		void refresh() {
+			if(vis != null) vis.visualizeSidePanel(input);
+			layout(true, true);
+		}
+
+		public void drawingEvent(SelectionBox.SelectionEvent e) {
+			switch(e.type) {
+			case SelectionBox.SelectionEvent.OBJECT_ADDED:
+				if(e.affectedObject instanceof Graphics) 
+					addInput((Graphics)e.affectedObject);
+				break;
+			case SelectionBox.SelectionEvent.OBJECT_REMOVED:
+				if(e.affectedObject instanceof Graphics) 
+					removeInput((Graphics)e.affectedObject);
+				break;
+			case SelectionBox.SelectionEvent.SELECTION_CLEARED:
+				clearInput();
+			}
+		}
+
+		public void visualizationEvent(VisualizationEvent e) {
+			switch(e.type) {
+			case VisualizationEvent.VISUALIZATION_SELECTED:
+				setVisualization(getCurrent());
+			case VisualizationEvent.PLUGIN_SIDEPANEL_ACTIVATED:
+				fillContents();
+			}
+			
+		}		
+	}
+	
+	public void applicationEvent(ApplicationEvent e) {
+		if(e.type == ApplicationEvent.APPLICATION_CLOSE) {
+			saveGeneric();
+		}		
+	}
+	
+	static List<VisualizationListener> listeners;
+
+	/**
+	 * Add a {@link ExpressionDataListener}, that will be notified if an
+	 * event related to visualizations occurs
+	 * @param l The {@link ExpressionDataListener} to add
+	 */
+	public static void addListener(VisualizationListener l) {
+		if(listeners == null)
+			listeners = new ArrayList<VisualizationListener>();
+		listeners.add(l);
+	}
+
+	/**
+	 * Fire a {@link VisualizationEvent} to notify all {@link VisualizationListener}s registered
+	 * to this class
+	 * @param e
+	 */
+	public static void fireVisualizationEvent(VisualizationEvent e) {
+		for(VisualizationListener l : listeners) {
+			l.visualizationEvent(e);
+		}
+	}
+
+	public interface VisualizationListener {
+		public void visualizationEvent(VisualizationEvent e);
+	}
+
+	public static class VisualizationEvent extends EventObject {
+		private static final long serialVersionUID = 1L;
+		public static final int COLORSET_ADDED = 0;
+		public static final int COLORSET_REMOVED = 1;
+		public static final int COLORSET_MODIFIED = 2;
+		public static final int VISUALIZATION_ADDED = 3;
+		public static final int VISUALIZATION_REMOVED = 4;
+		public static final int VISUALIZATION_MODIFIED = 5;
+		public static final int VISUALIZATION_SELECTED = 6;
+		public static final int PLUGIN_MODIFIED = 7;
+		public static final int PLUGIN_ADDED = 8;
+		public static final int PLUGIN_SIDEPANEL_ACTIVATED = 9;
+
+		public Object source;
+		public int type;
+
+		public VisualizationEvent(Object source, int type) {
+			super(source == null ? VisualizationManager.class : source);
+			this.source = source;
+			this.type = type;
+		}
+	}
+
+	public void expressionDataEvent(ExpressionDataEvent e) {
+		if(e.type == ExpressionDataEvent.CONNECTION_CLOSED) {
+			removeNonGeneric();
+		}
+	}
+}

Property changes on: trunk/src/swt/org/pathvisio/visualization/VisualizationManager.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/visualization/LegendPanel.java
===================================================================
--- trunk/src/swt/org/pathvisio/visualization/LegendPanel.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/visualization/LegendPanel.java	(revision 961)
@@ -0,0 +1,786 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.visualization;
+
+import java.util.ArrayList;
+import java.util.EventObject;
+import java.util.List;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.CLabel;
+import org.eclipse.swt.custom.ScrolledComposite;
+import org.eclipse.swt.custom.StackLayout;
+import org.eclipse.swt.events.MouseAdapter;
+import org.eclipse.swt.events.MouseEvent;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.events.PaintListener;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.Font;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.RGB;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Canvas;
+import org.eclipse.swt.widgets.Combo;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Group;
+import org.eclipse.swt.widgets.Label;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.util.SwtUtils;
+import org.pathvisio.visualization.LegendPanel.CollapseGroup.CollapseListener;
+import org.pathvisio.visualization.Visualization.PluginSet;
+import org.pathvisio.visualization.VisualizationManager.VisualizationEvent;
+import org.pathvisio.visualization.VisualizationManager.VisualizationListener;
+import org.pathvisio.visualization.colorset.ColorCriterion;
+import org.pathvisio.visualization.colorset.ColorGradient;
+import org.pathvisio.visualization.colorset.ColorSet;
+import org.pathvisio.visualization.colorset.ColorSetManager;
+import org.pathvisio.visualization.colorset.ColorSetObject;
+import org.pathvisio.visualization.colorset.ColorGradient.ColorValuePair;
+import org.pathvisio.visualization.plugins.VisualizationPlugin;
+
+/**
+ * This class shows a legend for the currently loaded visualization and color-sets.
+ * @author Thomas
+ *
+ */
+public class LegendPanel extends ScrolledComposite implements VisualizationListener {
+	static final String FONT = "arial narrow";
+	static final int FONTSIZE = 8;
+
+	Button combine; //Checkbutton to show all colorsets or not
+	Boolean doCombine = true;	//true: all colorsets are shown, false: only colorSetCombo selection
+	
+	ColorSet colorSet; //Currently selected color-set
+
+	ColorSetComposite colorSets;
+	PluginComposite plugins;
+	
+	CollapseGroup colorSetGroup;
+	CollapseGroup pluginGroup;
+
+	Combo colorSetCombo;
+
+	public LegendPanel(Composite parent, int style)
+	{
+		super(parent, style);
+
+		createContents();
+		rebuildContent();
+		VisualizationManager.addListener(this);
+	}
+
+	/**
+	 * Set the color-set to show in the legend (ignored if doCombine)
+	 * @param input The color-set to show in the legend
+	 */
+	public void setInput(ColorSet input) {
+		colorSet = input;
+		refreshContent();
+	}
+
+	/**
+	 * Rebuild the contents of the legend (refresh the names
+	 * in colorSetCombo and refresh the content)
+	 */
+	public void rebuildContent() {
+		combine.setSelection(true);
+		
+		String[] names = ColorSetManager.getColorSetNames();
+		colorSetCombo.setItems(names);
+		if(names.length == 0) {
+			colorSetCombo.setEnabled(false);
+		}
+		else {
+			colorSetCombo.setEnabled(!doCombine);
+			colorSetCombo.select(0);
+		}
+		
+		refreshContent();
+	}
+	
+	/**
+	 * Set whether the legend has to show all color-sets or only the one
+	 * selected in colorSetCombo
+	 * @param comb if true all color-sets are shown, if false only the one selected
+	 * in colorSetCombo is shown
+	 */
+	void setCombine(boolean comb) {
+		doCombine = comb;
+		colorSetCombo.setEnabled(!doCombine);
+		setInput(ColorSetManager.getColorSets().get(colorSetCombo.getSelectionIndex()));
+	}
+	
+	/**
+	 * Refresh the content of the legend
+	 */
+	void refreshContent() {		
+		if(!isDisposed()) {
+			colorSets.refresh();
+			plugins.refresh();
+			rearrange();
+		}
+	}
+
+	/**
+	 * Rearrange the elements of the legend:
+	 * re-layout the elements and compute the minimum size
+	 * for the scrollbars
+	 */
+	void rearrange() {
+		layout();
+		colorSetGroup.rearrange();
+		pluginGroup.rearrange();
+		setMinSize(getContent().computeSize(SWT.DEFAULT, SWT.DEFAULT));
+	}
+	
+	/**
+	 * Create the contents of the legend
+	 */
+	void createContents() {	
+		Composite contents = new Composite(this, SWT.NULL);
+		setContent(contents);
+		setExpandHorizontal(true);
+		setExpandVertical(true);
+		contents.setLayout(new GridLayout());
+
+		Composite comboComp = createColorSetCombo(contents);
+		comboComp.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+
+		Composite legendComp = createLegendComp(contents);
+		legendComp.setLayoutData(new GridData(GridData.FILL_BOTH));
+
+		setChildrenBackground(contents);
+	}
+
+	/**
+	 * Set the background of the given {@link Composite} and all its children
+	 * to background color of the legend (SWT.COLOR_WHITE).
+	 * @param comp the {@link Composite} for which the background has to be set
+	 */
+	void setChildrenBackground(Composite comp) {
+		comp.setBackground(getDisplay().getSystemColor(SWT.COLOR_WHITE));
+		for(Control c : comp.getChildren()) {
+			c.setBackground(getDisplay().getSystemColor(SWT.COLOR_WHITE));
+			if(c instanceof Composite) setChildrenBackground((Composite) c);
+		}
+	}
+
+	/**
+	 * Creates the composite that holds the color-set combo to select
+	 *  the color-set to display
+	 * @param parent The parent composite
+	 * @return The {@link Composite} that displays the color-set combo
+	 */
+	Composite createColorSetCombo(Composite parent) {
+		Composite comboComp = new Composite(parent, SWT.NULL);
+		comboComp.setLayout(new GridLayout(2, false));
+		combine = new Button(parent, SWT.CHECK);
+		GridData span = new GridData(GridData.FILL_HORIZONTAL);
+		span.horizontalSpan = 2;
+		combine.setLayoutData(span);
+		combine.setText("Show all color-sets");
+		combine.addSelectionListener(new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				setCombine(combine.getSelection());
+			}
+		});
+		Label label = new Label(comboComp, SWT.NULL);
+		label.setText("Show color-set:");
+		colorSetCombo = new Combo(comboComp, SWT.READ_ONLY);
+		colorSetCombo.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+		colorSetCombo.addSelectionListener(new SelectionAdapter() {
+			public void widgetSelected(SelectionEvent e) {
+				setInput(ColorSetManager.getColorSets().get(colorSetCombo.getSelectionIndex()));
+			}
+		});
+		return comboComp;
+	}
+
+	/**
+	 * Create the {@link Composite} that holds the legend contents
+	 * @param parent The parent {@link Composite}
+	 * @return The {@link Composite} that holds the legend contents
+	 */
+	Composite createLegendComp(Composite parent) {
+		Composite legendComp = new Composite(parent, SWT.NULL);
+		GridLayout legendGrid = new GridLayout();
+		legendGrid.marginWidth = legendGrid.marginLeft = legendGrid.marginRight = 0;
+		legendComp.setLayout(legendGrid);
+
+		colorSetGroup = new CollapseGroup(legendComp, SWT.NULL);
+		pluginGroup = new CollapseGroup(legendComp, SWT.NULL);
+
+		colorSets = new ColorSetComposite(colorSetGroup.getGroup(), SWT.NONE);
+		plugins = new PluginComposite(pluginGroup.getGroup(), SWT.NONE);
+
+		colorSetGroup.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+		pluginGroup.setLayoutData(new GridData(GridData.FILL_BOTH));
+		
+		colorSetGroup.setText("Color-sets");
+		pluginGroup.setText("Plug-ins");
+
+		colorSetGroup.getGroup().setLayout(new FillLayout());
+		pluginGroup.getGroup().setLayout(new FillLayout());
+		
+		CollapseListener cl = new CollapseListener() {
+			public void stateChanged(LegendPanel.CollapseGroup.CollapseEvent e) {
+				rearrange();
+			}
+		};
+		
+		colorSetGroup.addCollapseListener(cl);
+		pluginGroup.addCollapseListener(cl);
+
+		return legendComp;
+	}
+
+	/**
+	 * This class displays a legend for every {@link VisualizaitonPlugin} that is activated
+	 * on the drawing for the currently selected {@link Visualization} 
+	 * and implements the method {@link VisualizationPlugin#createLegendComposite(Composite)}
+	 * @author Thomas
+	 *
+	 */
+	private class PluginComposite extends Composite
+	{
+		public PluginComposite(Composite parent, int style) {
+			super(parent, style);
+			setLayout(new GridLayout());
+			setChildrenBackground(this);
+		}
+		
+		/**
+		 * Refresh the contents. That is, reload the plug-in information
+		 * for the currently selected visualization and re-create their
+		 * legend-composites.
+		 */
+		public void refresh() {
+			for(Control c : getChildren()) c.dispose();
+			
+			Visualization v = VisualizationManager.getCurrent();
+			if(v == null) return;
+			
+			for(PluginSet ps : v.getPluginSetsDrawingOrder()) {
+				if(ps.isDrawing()) {
+					Group g = new Group(this, SWT.NULL);
+					g.setBackground(getBackground());
+					g.setLayoutData(new GridData(GridData.FILL_BOTH));
+					g.setLayout(new FillLayout());
+					g.setText(ps.getInstance().getName());
+					Composite c = ps.getDrawingPlugin().createLegendComposite(g);
+					if(c == null) g.dispose();
+				}
+			}
+			layout();
+		}
+	}
+	
+	/**
+	 * This class displays the legend for the color-sets.
+	 * @author Thomas
+	 */
+	private class ColorSetComposite extends Composite
+	{
+			public ColorSetComposite(Composite parent, int style) {
+				super(parent, style);
+				setLayout(new GridLayout());
+				setChildrenBackground(this);
+			}
+			
+			/**
+			 * Refresh the contents. That is, reload the color-set
+			 * information and re-create the {@link ColorSetGroup}s.
+			 */
+			public void refresh() {
+				for(Control c : getChildren()) c.dispose();
+				
+				if(doCombine) {
+					for(ColorSet cs : ColorSetManager.getColorSets()) {
+						drawColorSet(this, cs);
+					}
+				} else {
+					if(colorSet == null) return;
+					drawColorSet(this, colorSet);
+				}
+				
+				layout();
+			}
+			
+			/**
+			 * Create a {@link ColorSetGroup} for the given colorset
+			 * @param parent The parent {@link Composite} to create the {@link ColorSetGroup} on
+			 * @param cs The color-set to create the {@link ColorSetGroup} for
+			 */
+			void drawColorSet(Composite parent, ColorSet cs) {
+				ColorSetGroup csg = new ColorSetGroup(parent, SWT.NULL);
+				csg.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+				csg.setInput(cs);
+			}
+	}
+
+	/**
+	 * This class displays the legend for a single {@link ColorSet}
+	 * @author Thomas
+	 */
+	private class ColorSetGroup extends Composite
+	{
+		CriteriaComposite criteria;
+		GradientCanvas gradients;
+		Group group;
+		
+		ColorSet colorSet;
+		
+		public ColorSetGroup(Composite parent, int style) {
+			super(parent, style);
+			createContents();
+		}
+		
+		/**
+		 * Set the color-set of which the legend will be displayed
+		 * @param cs The color-set to display the legend of
+		 */
+		void setInput(ColorSet cs) {
+			colorSet = cs;
+			criteria.setInput(cs);
+			gradients.setInput(cs);
+			refresh();
+		}
+
+		void createContents() {
+			setLayout(new FillLayout());
+			group = new Group(this, SWT.NULL);
+			group.setLayout(new GridLayout());
+			criteria = new CriteriaComposite(group, SWT.NULL);
+			criteria.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+			gradients = new GradientCanvas(group, SWT.NULL);
+			gradients.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+			setChildrenBackground(this);
+		}
+		
+		public void refresh() {
+			if(colorSet != null) group.setText(colorSet.getName());
+			criteria.refresh();
+			gradients.refresh();
+		}
+		
+	}
+	
+	/**
+	 * This class shows the legend for all {@link ColorCriterion} in a color-set as well as
+	 * the 'special colors' ({@link ColorSet#COLOR_NO_GENE_FOUND}, {@link COLORSET#COLOR_NO_DATA_FOUND},
+	 * {@link ColorSet#COLOR_NO_CRITERIA_MET})
+	 * @author Thomas
+	 */
+	private class CriteriaComposite extends Composite
+	{
+		ColorSet colorSet; //The currently displayed color-set
+		
+		public CriteriaComposite(Composite parent, int style)
+		{
+			super(parent, style);
+			setChildrenBackground(this);
+		}
+
+		/**
+		 * Set the color-set to display the criteria legend for
+		 * @param cs
+		 */
+		void setInput(ColorSet cs) {
+			colorSet = cs;
+			refresh();
+		}
+		
+		final static int CLABEL_SIZE = 10; //Size of the colored labels
+		
+		public void refresh()
+		{
+			for(Control c : getChildren()) c.dispose();
+
+			if(colorSet == null) return;
+			drawColorSet(this, colorSet);
+		}
+		
+		/**
+		 * Create a {@Composite} that displays the criteria legend
+		 * @param parent The parent Composite
+		 * @param colorSet The color-set to display the legend for
+		 */
+		void drawColorSet(Composite parent, ColorSet colorSet) {			
+			Color c = null;
+			
+			parent.setLayout(new GridLayout(2, false));
+			
+			//Draw label for special criteria ('no gene found', 'no criteria met')
+			String[] specialLabels = {"No criteria met", "Gene not found", "No data found"};
+			RGB[] specialColors = {
+					colorSet.getColor(ColorSet.ID_COLOR_NO_CRITERIA_MET), 
+					colorSet.getColor(ColorSet.ID_COLOR_NO_GENE_FOUND),
+					colorSet.getColor(ColorSet.ID_COLOR_NO_DATA_FOUND) };
+
+			for(int i = 0; i < specialColors.length; i++)
+			{
+				c = SwtUtils.changeColor(c, specialColors[i], getDisplay());
+				createCriterionLabel(parent, specialLabels[i], c);
+			}
+
+			//Draw CLabel for every criterion
+			for(ColorSetObject co : colorSet.getObjects())
+			{
+				if(!(co instanceof ColorCriterion)) continue; //skip objects other than criretia
+				ColorCriterion cc = (ColorCriterion)co;
+				c = SwtUtils.changeColor(c, cc.getColor(), getDisplay());
+				createCriterionLabel(parent, cc.getName() + "\n(" + cc.getCriterion().getExpression() + ")", c);
+			}
+			
+			if(c != null) c.dispose();
+		}
+		
+		private void createCriterionLabel(Composite parent, String text, Color c)
+		{
+			GridData clabelGrid = new GridData(GridData.HORIZONTAL_ALIGN_BEGINNING);
+			clabelGrid.widthHint = CLABEL_SIZE;
+			clabelGrid.heightHint = CLABEL_SIZE;
+
+			CLabel cLabel = new CLabel(parent, SWT.SHADOW_IN);
+			Label label = new Label(parent, SWT.LEFT);
+
+			label.setBackground(getBackground());
+			label.setText(text);
+
+			cLabel.setBackground(c);
+			cLabel.setLayoutData(clabelGrid);
+		}
+	}
+
+	/**
+	 * This class displays the legend information for all {@link ColorGradient}s in
+	 * the given color-set
+	 * @author Thomas
+	 */
+	private class GradientCanvas extends Canvas implements PaintListener
+	{	
+		ColorSet colorSet; //The color-set to display the gradient information for
+		
+		public GradientCanvas(Composite parent, int style)
+		{
+			super(parent, style);
+			addPaintListener(this);
+		}
+
+		/**
+		 * Set the color-set to display the gradient legend for
+		 * @param input
+		 */
+		public void setInput(ColorSet input) {
+			colorSet = input;
+			refresh();
+		}
+		
+		public void refresh() {
+			layout();
+			redraw();
+		}
+
+		int getNrGradients() {
+			int n = 0;
+			for(ColorSetObject co : colorSet.getObjects()) {
+				if(co instanceof ColorGradient) n++;
+			}
+			return n;
+		}
+
+		public void paintControl (PaintEvent e)
+		{
+			if(colorSet == null) return;
+			
+			//Divide canvas in nr-gradients rows
+			Rectangle cla = getClientArea();
+			Point size = new Point(cla.width, cla.height);
+			int n = getNrGradients();
+			int i = 0;
+			for(ColorSetObject co : colorSet.getObjects()) {
+				if(co instanceof ColorGradient) {
+					ColorGradient cg = (ColorGradient)co;
+					Rectangle area = new Rectangle(
+							0, i++ * size.y / n,
+							size.x, size.y / n++);
+					drawColorGradient(e, cg, area);
+				}
+			}
+		}
+
+		public Point computeSize(int wHint, int hHint) {
+			if(colorSet == null) return new Point(0,0);
+						
+			int charw = SwtUtils.getAverageCharWidth(getDisplay());
+			int x = 0;
+			int nr = 0;
+			for(ColorSetObject co : colorSet.getObjects()) {
+				if(co instanceof ColorGradient) {
+					x = Math.max(x, co.getName().length() * charw);
+					nr++;
+				}
+			}
+			int y = nr * (MAX_BAR_HEIGHT + MARGIN_VERTICAL + LABEL_WIDTH);
+			return new Point(x, y);
+		}
+		
+		public Point computeSize(int wHint, int hHint, boolean changed) {
+			return computeSize(wHint, hHint);
+		}
+		
+		final static int LABEL_WIDTH = 20;
+		final static int MAX_BAR_HEIGHT = 10;
+		final static int MARGIN_VERTICAL = 20;
+		final static int MARGIN_HORIZONTAL = 15;
+		final static int MARKER_LENGTH = 4;
+		void drawColorGradient(PaintEvent e, ColorGradient cg, Rectangle r)
+		{
+			Color c = null;
+			RGB oldBackground = getBackground().getRGB();
+
+			double[] minmax = cg.getMinMax();
+			double min = minmax[0];
+			double max = minmax[1];
+
+			if((float)max == (float)min) {
+				return;
+			}
+
+			// Get region to draw
+			int yStart = r.y + MARGIN_VERTICAL;
+			int barHeight = MAX_BAR_HEIGHT;
+			int start = r.x + MARGIN_HORIZONTAL;
+			int end = r.width - MARGIN_HORIZONTAL;
+
+			int n = end - start;
+
+			// Fill squares with color cg.getColor()
+			for(int i = start; i < end; i++) {
+				double colorValue = min + (i-start) * (max - min) / n;
+				RGB rgb = cg.getColor(colorValue);
+				if(rgb != null) {
+					c = SwtUtils.changeColor(c, rgb, e.display);
+					e.gc.setBackground(c);
+					e.gc.fillRectangle(i, yStart, 1, barHeight);
+				}
+			}
+
+			Font f = new Font(e.display, FONT, FONTSIZE, SWT.NONE);
+			e.gc.setFont(f);
+
+			int markerCenter = yStart + barHeight;
+			c = SwtUtils.changeColor(c, oldBackground, e.display);
+			e.gc.setBackground(c);
+			for(ColorValuePair cvp : cg.getColorValuePairs())
+			{
+				int x = (int)(start + (cvp.getValue() - min) / (max - min) * (end - start));
+				e.gc.drawLine(x, markerCenter - MARKER_LENGTH, x, markerCenter + MARKER_LENGTH);
+				Point labelSize = e.gc.textExtent(Double.toString(cvp.getValue()));
+				e.gc.drawString(Double.toString(cvp.getValue()), x - labelSize.x / 2, 
+						markerCenter + labelSize.y / 2, true);
+			}
+			
+			String label = cg.getName();
+			Point labelSize = e.gc.textExtent(label);
+			e.gc.drawString(label, (end - start) / 2 - labelSize.x / 2, 
+					yStart - barHeight - labelSize.y / 2, true);	
+
+			c.dispose();
+			f.dispose();
+		}
+	}
+
+	public void visualizationEvent(final VisualizationEvent e) {
+		getDisplay().asyncExec(new Runnable() {
+			public void run() {
+				switch(e.type) {
+				case VisualizationEvent.COLORSET_ADDED:
+				case VisualizationEvent.COLORSET_REMOVED:
+					rebuildContent();
+					break;
+				default:
+					refreshContent();
+				}
+			}
+		});
+	}
+
+	/**
+	 * This class contains an {@link Group} that can be collapsed and expanded.
+	 * Contents can to the {@link Group} by using {@link #getGroup()}
+	 * @author Thomas
+	 */
+	static class CollapseGroup extends Composite {
+		static final int SWITCH_SIZE = 9; //Size of the switch label
+		Group group;
+		Composite stackComp;
+		StackLayout stackLayout;
+		Label groupLabel;
+		Label switchLabel;
+		
+		boolean expanded = true;
+		
+		public CollapseGroup(Composite parent, int style) {
+			super(parent, style);
+			GridLayout grid = new GridLayout(2, false);
+			grid.horizontalSpacing = 3;
+			grid.marginBottom = grid.marginHeight = 0;
+			grid.marginLeft = grid.marginRight = grid.marginBottom = grid.marginTop = 0;
+			setLayout(grid);
+			createContents();
+		}
+		
+		void createContents() {
+			switchLabel = new Label(this, SWT.NULL);
+			GridData labelGrid = new GridData(	GridData.HORIZONTAL_ALIGN_BEGINNING | 
+												GridData.VERTICAL_ALIGN_BEGINNING);
+			labelGrid.widthHint = labelGrid.heightHint = SWITCH_SIZE;
+			switchLabel.setLayoutData(labelGrid);
+			switchLabel.addMouseListener(new MouseAdapter() {
+				public void mouseUp(MouseEvent e) {
+					if(expanded) collapse();
+					else expand();
+				}
+			});
+			stackComp = new Composite(this, SWT.NULL);
+			stackComp.setLayoutData(new GridData(GridData.FILL_BOTH));
+			stackLayout = new StackLayout();
+			stackComp.setLayout(stackLayout);
+					
+			groupLabel = new Label(stackComp, SWT.NULL);
+			group = new Group(stackComp, SWT.NULL);
+			
+			expand();
+		}
+		
+		/**
+		 * Get the collapsable group (e.g. to add contents or set layout)
+		 * @return The collapsable group
+		 */
+		public Group getGroup() {
+			return group;
+		}
+		
+		/**
+		 * Set the text of the collapsable {@link Group}
+		 * @param text The text to set
+		 */
+		public void setText(String text) {
+			groupLabel.setText(text);
+			group.setText(text);
+		}
+		
+		void collapse() {
+			setExpanded(false);
+		}
+		
+		void expand() {
+			setExpanded(true);
+		}
+
+		public void layout(boolean changed, boolean all) {
+			super.layout(changed, all);
+			getParent().layout(changed, all);
+		}
+		
+		public Point computeSize(int wHint, int hHint, boolean changed) {
+			int x = super.computeSize(wHint, hHint, changed).x;
+			int y = expanded ?
+					group.computeSize(wHint, hHint, changed).y :
+					groupLabel.computeSize(SWT.DEFAULT, SWT.DEFAULT).y;
+			return new Point(x, y);
+		}
+		
+		/**
+		 * Rearrange the contents. That is, reset the size of the group
+		 * and layout
+		 */
+		void rearrange() {
+			stackLayout.topControl = expanded ? group : groupLabel;
+			stackComp.layout();
+			Object ld = getLayoutData();
+			if(ld instanceof GridData) {
+				GridData gd = (GridData) ld;
+				gd.heightHint = computeSize(SWT.DEFAULT, SWT.DEFAULT).y;
+			}
+			layout();
+			switchLabel.setImage(SwtEngine.getImageRegistry().get(
+					expanded ? "tree.expanded" : "tree.collapsed"));
+		}
+		
+		void setExpanded(boolean exp) {
+			expanded = exp;
+			
+			rearrange();
+			
+			for(CollapseListener l : listeners) 
+				l.stateChanged(new CollapseEvent(this, expanded ? CollapseEvent.EXPANDED : CollapseEvent.COLLAPSED));
+		}
+		
+		List<CollapseListener> listeners = new ArrayList<CollapseListener>();
+		
+		/**
+		 * Add a collapse listener that is triggered when the group is collapsed or expanded
+		 * @param l The listener to add
+		 */
+		public void addCollapseListener(CollapseListener l) {
+			listeners.add(l);
+		}
+				
+		/**
+		 * This event is fired when a {@link CollapseGroup} is collapsed or expanded
+		 * @author Thomas
+		 */
+		public static class CollapseEvent extends EventObject {
+			private static final long serialVersionUID = 1L;
+			public static final int COLLAPSED = 0;
+			public static final int EXPANDED = 1;
+			int type;
+			
+			/**
+			 * Constructor for this class
+			 * @param source The source object that is collapsed or expanded
+			 * @param type one of {@link #COLLAPSED} or {@link #EXPANDED}
+			 */
+			public CollapseEvent(Object source, int type) {
+				super(source);
+				this.type = type;
+			}		
+		}
+		
+		/**
+		 * Implement this interface to listen for {@link CollapseEvent}s
+		 * @author Thomas
+		 */
+		public static interface CollapseListener {
+			/**
+			 * This method is triggered when the collapse state of a {@link CollapseGroup} 
+			 * is changed (collapsed or expanded)
+			 * @param e The collapse event contains information of the state change
+			 */
+			public void stateChanged(CollapseEvent e);
+		}
+	}
+}
\ No newline at end of file

Property changes on: trunk/src/swt/org/pathvisio/visualization/LegendPanel.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/Engine.java
===================================================================
--- trunk/src/swt/org/pathvisio/Engine.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/Engine.java	(revision 961)
@@ -0,0 +1,237 @@
+package org.pathvisio;
+
+import java.awt.Color;
+import java.io.File;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+import org.pathvisio.data.DBConnector;
+import org.pathvisio.debug.Logger;
+import org.pathvisio.model.ConverterException;
+import org.pathvisio.model.Pathway;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.PathwayExporter;
+import org.pathvisio.model.PathwayImporter;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.util.Utils;
+import org.pathvisio.view.VPathway;
+
+public class Engine {
+	private static Pathway pathway;
+	private static VPathway vPathway;
+		
+	public static final String SVG_FILE_EXTENSION = "svg";
+	public static final String SVG_FILTER_NAME = "Scalable Vector Graphics (*." + SVG_FILE_EXTENSION + ")";
+	public static final String PATHWAY_FILE_EXTENSION = "gpml";
+	public static final String PATHWAY_FILTER_NAME = "PathVisio Pathway (*." + PATHWAY_FILE_EXTENSION + ")";
+	public static final String GENMAPP_FILE_EXTENSION = "mapp";
+	public static final String GENMAPP_FILTER_NAME = "GenMAPP Pathway (*." + GENMAPP_FILE_EXTENSION + ")";
+	
+	/**
+	 * the transparent color used in the icons for visualization of protein/mrna data
+	 */
+	public static final Color TRANSPARENT_COLOR = new Color(255, 0, 255);
+	
+	public final static Logger log = new Logger();
+			
+	/**
+	 * Get the {@link URL} for the resource stored in a jar file in the classpath
+	 * @param name	the filename of the resource
+	 * @return the URL pointing to the resource
+	 */
+	public static URL getResourceURL(String name) {
+		URL url = Engine.class.getClassLoader().getResource(name);
+		if(url == null) log.error("Couldn't load resource '" + name + "'");
+		return url;
+	}
+	
+	/**
+	 * Gets the currently open drawing
+	 */
+	public static VPathway getActiveVPathway() {
+		return vPathway;
+	}
+
+	/**
+	 * Sets the currently active Pathway and its VPathway 
+	 * (Used by SwtEngine, will be removed after finishing Graphics2D transision)
+	 * @param vpw
+	 */
+	@Deprecated
+	public static void setActiveVPathway(Pathway pw, VPathway vpw) {
+		pathway = pw;
+		vPathway = vpw;
+	}
+	
+	/**
+	 * Returns the currently open Pathway
+	 */
+	public static Pathway getActivePathway() {
+		return pathway;
+	}
+	
+	/**
+	 * application global clipboard.
+	 */
+	public static List<PathwayElement> clipboard = null;
+	
+	public static void importPathway(File file) throws ConverterException {
+		String fileName = file.toString();
+		
+		int dot = fileName.lastIndexOf('.');
+		String ext = Engine.PATHWAY_FILE_EXTENSION; //
+		if(dot >= 0) {
+			ext = fileName.substring(dot + 1, fileName.length());
+		}
+		PathwayImporter importer = getPathwayImporter(ext);
+		
+		if(importer == null) throw new ConverterException( "No importer for '" + ext +  "' files" );
+		
+		Pathway _pathway = new Pathway();
+		importer.doImport(file, _pathway);
+		pathway = _pathway;
+		fireApplicationEvent(new ApplicationEvent(pathway, ApplicationEvent.PATHWAY_OPENED));
+	}
+	
+	public static void openPathway(String fileName) throws ConverterException {
+		openPathway(new File(fileName));
+	}
+	
+	/**
+	 * Open a pathway from a gpml file
+	 */
+	public static void openPathway(File pathwayFile) throws ConverterException
+	{
+		Pathway _pathway = null;		
+		String pwf = pathwayFile.toString();
+		
+		// initialize new JDOM gpml representation and read the file
+		_pathway = new Pathway();
+		if (pwf.endsWith(".mapp"))
+		{
+			_pathway.readFromMapp(new File(pwf));
+		}
+		else
+		{
+			_pathway.readFromXml(new File(pwf), true);
+		}
+		if(_pathway != null) //Only continue if the data is correctly loaded
+		{
+			pathway = _pathway;
+			fireApplicationEvent(new ApplicationEvent(pathway, ApplicationEvent.PATHWAY_OPENED));
+		}
+		
+	}
+	
+	public static void savePathway() throws ConverterException {
+		savePathway(pathway.getSourceFile());
+	}
+	
+	public static void savePathway(File toFile) throws ConverterException {
+		pathway.writeToXml(toFile, true);
+	}
+			
+	/**
+	 * Create a new pathway and view (Pathay and VPathway)
+	 */
+	public static void newPathway() {
+		pathway = new Pathway();
+		pathway.initMappInfo();
+
+		fireApplicationEvent(new ApplicationEvent(vPathway, ApplicationEvent.PATHWAY_NEW));
+	}
+		
+	/**
+	 * Find out whether a drawing is currently open or not
+	 * @return true if a drawing is open, false if not
+	 */
+	public static boolean isDrawingOpen() { return vPathway != null; }
+
+
+	private static HashMap<String, PathwayExporter> exporters = new HashMap<String, PathwayExporter>();
+	private static HashMap<String, PathwayImporter> importers = new HashMap<String, PathwayImporter>();
+	/**
+	 * Add a {@link PathwayExporter} that handles export of GPML to another file format
+	 * @param export
+	 */
+	public static void addPathwayExporter(PathwayExporter export) {
+		for(String ext : export.getExtensions()) {
+			exporters.put(ext, export);
+		}
+	}
+
+	/**
+	 * Add a {@link PathwayImporter} that handles imoprt of GPML to another file format
+	 * @param export
+	 */
+	public static void addPathwayImporter(PathwayImporter importer) {
+		for(String ext : importer.getExtensions()) {
+			importers.put(ext, importer);
+		}
+	}
+	
+	public static PathwayExporter getPathwayExporter(String ext) {
+		return exporters.get(ext);
+	}
+
+	public static PathwayImporter getPathwayImporter(String ext) {
+		return importers.get(ext);
+	}
+	
+	public static HashMap<String, PathwayExporter> getPathwayExporters() {
+		return exporters;
+	}
+		
+	public static HashMap<String, PathwayImporter> getPathwayImporters() {
+		return importers;
+	}
+	
+	public static DBConnector getDbConnector(int type) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
+		DBConnector connector = null;
+		String className = null;
+		switch(type) {
+		case DBConnector.TYPE_GDB:
+			className = SwtPreference.SWT_DB_ENGINE_GDB.getValue();
+			break;
+		case DBConnector.TYPE_GEX:
+			className = SwtPreference.SWT_DB_ENGINE_GDB.getValue();
+			break;
+		}
+		if(className == null) return null;
+		
+		Class dbc = Class.forName(className);
+		
+		if(Utils.isSubClass(dbc, DBConnector.class)) {
+			connector = (DBConnector)dbc.newInstance();
+			connector.setDbType(type);
+		}
+	
+		return connector;
+	}
+		
+	private static List<ApplicationEventListener> applicationEventListeners  = new ArrayList<ApplicationEventListener>();
+	
+	/**
+	 * Add an {@link ApplicationEventListener}, that will be notified if a
+	 * property changes that has an effect throughout the program (e.g. opening a pathway)
+	 * @param l The {@link ApplicationEventListener} to add
+	 */
+	public static void addApplicationEventListener(ApplicationEventListener l) {
+		applicationEventListeners.add(l);
+	}
+	
+	/**
+	 * Fire a {@link ApplicationEvent} to notify all {@link ApplicationEventListener}s registered
+	 * to this class
+	 * @param e
+	 */
+	public static void fireApplicationEvent(ApplicationEvent e) {
+		for(ApplicationEventListener l : applicationEventListeners) l.applicationEvent(e);
+	}
+	
+	public interface ApplicationEventListener {
+		public void applicationEvent(ApplicationEvent e);
+	}
+}
\ No newline at end of file
Index: trunk/src/swt/org/pathvisio/view/VPoint.java
===================================================================
--- trunk/src/swt/org/pathvisio/view/VPoint.java	(revision 0)
+++ trunk/src/swt/org/pathvisio/view/VPoint.java	(revision 961)
@@ -0,0 +1,147 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.view;
+
+import java.awt.Shape;
+import java.util.HashSet;
+import java.util.Set;
+
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.graphics.GC;
+import org.pathvisio.model.PathwayElement.MPoint;
+
+public class VPoint extends VPathwayElement {
+	Handle handle;
+	Set<Line> lines;
+	Set<MPoint> mPoints;
+	
+	VPoint(VPathway canvas) {
+		super(canvas);
+		mPoints = new HashSet<MPoint>();
+		lines = new HashSet<Line>();
+		handle = new Handle(Handle.DIRECTION_FREE, this, canvas);
+	}
+	
+	public int getDrawingOrder() {
+		return VPathway.DRAW_ORDER_LINE;
+	}
+	
+	protected void addMPoint(MPoint p) {
+		mPoints.add(p);
+	}
+	
+	protected void removeMPoint(MPoint p) {
+		mPoints.remove(p);
+	}
+	
+	protected void addLine(Line l) {
+		lines.add(l);
+	}
+	
+	protected void removeLine(Line l) {
+		lines.remove(l);
+		//Remove this VPoint when it links to no lines no more
+		if(lines.size() == 0) {
+			destroy();
+		}
+	}
+	
+	protected Set<Line> getLines() { return lines; }
+	
+	protected void link(Graphics g) {
+		if(lines.contains(g)) return; //Prevent linking to self
+		String id = g.getGmmlData().getGraphId();
+		if(id == null) id = g.getGmmlData().setGeneratedGraphId();
+		for(MPoint p : mPoints) p.setGraphRef(id);
+	}
+	
+	protected void link(VPoint p) {
+		if(p == this) return; //Already linked
+		for(MPoint mp : p.mPoints) {
+			mPoints.add(mp);
+		}
+		for(Line l : p.lines) {
+			l.swapPoint(p, this);
+			addLine(l);
+		}
+		p.lines.clear();
+		p.destroy();
+	}
+	
+	protected double getVX() { return vFromM(getMPoint().getX()); }
+	protected double getVY() { return vFromM(getMPoint().getY()); }
+	
+	protected void setVLocation(double vx, double vy) {
+		for(MPoint p : mPoints) {
+			p.setX(mFromV(vx));
+			p.setY(mFromV(vy));
+		}
+	}
+	
+	protected void vMoveBy(double dx, double dy) {
+		for(MPoint p : mPoints) {
+			p.moveBy(mFromV(dx), mFromV(dy));
+		}
+	}
+	
+	protected void setHandleLocation() {
+		MPoint mp = getMPoint();
+		handle.setMLocation(mp.getX(), mp.getY());
+	}
+	
+	private MPoint getMPoint() {
+		for(MPoint p : mPoints) return p;
+		return null;
+	}
+	
+	protected void adjustToHandle(Handle h) {
+		double mcx = h.mCenterx;
+		double mcy = h.mCentery;
+		for(MPoint p : mPoints) {
+			p.setX(mcx);
+			p.setY(mcy);
+		}
+	}
+	
+	protected Handle getHandle() {
+		return handle;
+	}
+	
+	protected Handle[] getHandles() {
+		return new Handle[] { handle };
+	}
+	
+	protected void draw(PaintEvent e) {
+		// TODO Auto-generated method stub
+	}
+
+	public void draw(PaintEvent e, GC buffer) {
+		// TODO Auto-generated method stub
+	}
+
+	protected Shape getVOutline() {
+		return handle.getVOutline();
+	}
+
+	protected void destroy() {
+		//Check if we can legally destroy this point
+		if(lines.size() > 0) 
+			throw new RuntimeException("VPoint cannot be destroyed: still linked to " + lines);
+
+		super.destroy();
+	}
+}
