Index: trunk/src/core/org/pathvisio/preferences/swt/SwtPreferences.java
===================================================================
--- trunk/src/core/org/pathvisio/preferences/swt/SwtPreferences.java	(revision 0)
+++ trunk/src/core/org/pathvisio/preferences/swt/SwtPreferences.java	(revision 958)
@@ -0,0 +1,195 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.preferences.swt;
+
+import java.io.File;
+import java.io.IOException;
+
+import org.eclipse.jface.preference.PreferenceStore;
+import org.eclipse.jface.util.IPropertyChangeListener;
+import org.eclipse.jface.util.PropertyChangeEvent;
+import org.pathvisio.Engine;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.Preference;
+import org.pathvisio.preferences.PreferenceCollection;
+import org.pathvisio.util.ColorConverter;
+import org.pathvisio.view.Graphics;
+
+import com.sun.org.apache.xpath.internal.operations.Bool;
+
+/**
+ * This class contains all user preferences used in this application
+ */
+public class SwtPreferences extends PreferenceStore implements PreferenceCollection, IPropertyChangeListener {
+	private static final File preferenceFile = new File(SwtEngine.getApplicationDir(), ".PathVisio");
+	
+	public SwtPreferences() {
+		this(preferenceFile.toString());
+	}
+	
+	public SwtPreferences(String fileName) {
+		super(fileName);
+		loadPreferences();
+	}
+	
+	public Preference byName(String name) {
+		Preference p = null;
+		if(name.startsWith("SWT")) {
+			p = SwtPreference.valueOf(name);
+		} else {
+			p = GlobalPreference.valueOf(name);
+		}
+		return p;
+	}
+	
+	protected void toEnums(Preference[] enumPrefs) {
+		for(Preference p : enumPrefs) {
+			p.setValue(getString(p.name()));
+		}
+	}
+	
+	protected void toEnums() {
+		toEnums(SwtPreference.values());
+		toEnums(GlobalPreference.values());
+	}
+	
+	protected void fromEnums(Preference[] enumPrefs) {
+		for(Preference p : enumPrefs) {
+			setValue(p.name(), p.getValue());
+		}
+	}
+	
+	protected void fromEnums() {
+		fromEnums(SwtPreference.values());
+		fromEnums(GlobalPreference.values());
+	}
+	
+	public void save() throws IOException {
+		fromEnums();
+		super.save();
+	}
+	
+	/**
+	 * Loads all stored users preferences and set defaults
+	 */
+	private void loadPreferences()
+	{
+		addPropertyChangeListener(this);
+		
+		for(Preference p : GlobalPreference.values()) {
+			setDefault(p);
+		}
+		
+		for(Preference p : SwtPreference.values()) {
+			setDefault(p);
+		}
+		
+		try {
+			load();
+		} catch(Exception e) { 
+			Engine.log.error("Unable to load preferences", e);
+		}
+		
+		toEnums();
+		
+		createDataDirectories();
+		
+	}
+	
+	private void setDefault(Preference p) {
+		setDefault(p.name(), p.getDefault());
+	}
+	
+	private void createDataDirectories() {
+		// For the data directories: if not defined by user, create default directories
+		Preference[] dataProps = new Preference[] 
+		{ 
+			SwtPreference.SWT_DIR_EXPR, SwtPreference.SWT_DIR_GDB, 
+			SwtPreference.SWT_DIR_PWFILES, SwtPreference.SWT_DIR_RDATA 
+		};
+		
+		for(Preference prop : dataProps) {
+			File dir = new File(prop.getValue());
+			if(!dir.exists()) dir.mkdirs();
+		}
+	}
+	
+	public void propertyChange(PropertyChangeEvent e) {
+		Preference p = byName(e.getProperty());
+		if(p != null) {
+			p.setValue(e.getNewValue().toString());
+		}
+		
+		if(e.getProperty().equals(GlobalPreference.COLOR_SELECTED.name())) { 
+			//if(e.getNewValue() instanceof RGB) Graphics.selectColor = (RGB)e.getNewValue();
+			//else 
+				Graphics.selectColor = ColorConverter.parseColorString((String)e.getNewValue());
+			Engine.getActiveVPathway().redraw();
+		}
+		else if(e.getProperty().equals(GlobalPreference.COLOR_HIGHLIGHTED.name())) {
+			//if(e.getNewValue() instanceof RGB) Graphics.highlightColor = (RGB)e.getNewValue();
+			//else 
+				Graphics.highlightColor = ColorConverter.parseColorString((String)e.getNewValue());
+				Engine.getActiveVPathway().redraw();
+		}
+		else if(e.getProperty().startsWith("directories")) {
+			createDataDirectories();
+		}
+	}
+	
+	public enum SwtPreference implements Preference {
+		SWT_DIR_PWFILES(new File(SwtEngine.getDataDir().toString(), "pathways").toString()),
+		SWT_DIR_GDB(new File(SwtEngine.getDataDir().toString(), "gene databases").toString()),
+		SWT_DIR_EXPR(new File(SwtEngine.getDataDir().toString(), "expression datasets").toString()),
+		SWT_DIR_RDATA(new File(SwtEngine.getDataDir().toString(), "R data").toString()),
+
+		SWT_CURR_GDB("none"),
+		SWT_DB_ENGINE_GDB("org.pathvisio.data.DBConnDerby"),
+		SWT_DB_ENGINE_EXPR("org.pathvisio.data.DBConnDerby"),
+		SWT_SIDEPANEL_SIZE("30"),
+		
+		SWT_SHOW_ADVANCED_ATTR(Boolean.toString(false));
+		
+		SwtPreference(String defaultValue) {
+			this.defaultValue = defaultValue;
+		}
+
+		private String defaultValue;
+		private String value;
+		
+		public String getDefault() {
+			return defaultValue;
+		}
+		
+		public void setDefault(String defValue) {
+			defaultValue = defValue;
+		}
+		
+		public void setValue(String newValue) {
+			value = newValue;
+		}
+		
+		public String getValue() {
+			if(value != null) {
+				return value;
+			} else {
+				return defaultValue;
+			}
+		}
+	}
+}
\ No newline at end of file
Index: trunk/src/core/org/pathvisio/preferences/swt/PreferenceDlg.java
===================================================================
--- trunk/src/core/org/pathvisio/preferences/swt/PreferenceDlg.java	(revision 0)
+++ trunk/src/core/org/pathvisio/preferences/swt/PreferenceDlg.java	(revision 958)
@@ -0,0 +1,145 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.preferences.swt;
+
+import org.eclipse.jface.preference.BooleanFieldEditor;
+import org.eclipse.jface.preference.ColorFieldEditor;
+import org.eclipse.jface.preference.DirectoryFieldEditor;
+import org.eclipse.jface.preference.FieldEditorPreferencePage;
+import org.eclipse.jface.preference.FileFieldEditor;
+import org.eclipse.jface.preference.IntegerFieldEditor;
+import org.eclipse.jface.preference.PreferenceManager;
+import org.eclipse.jface.preference.PreferenceNode;
+import org.eclipse.jface.preference.StringFieldEditor;
+import org.pathvisio.gui.swt.SwtEngine;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+
+public class PreferenceDlg extends PreferenceManager {
+	
+	public PreferenceDlg() {
+		super();
+
+		PreferenceNode display = new PreferenceNode("display", new DisplayPage());
+	    PreferenceNode colors = new PreferenceNode("colors", new ColorsPage());
+	    PreferenceNode directories = new PreferenceNode("directories", new DirectoriesPage());
+	    PreferenceNode files = new PreferenceNode("files", new FilesPage());
+	    PreferenceNode database = new PreferenceNode("database", new DatabasePage());
+	    
+	    addToRoot(display);
+	    addTo("display", colors);
+	    addToRoot(directories);
+	    addToRoot(files);
+	    addToRoot(database);
+	}
+	
+	private class FilesPage extends FieldEditorPreferencePage {
+		public FilesPage() {
+			super("Files", GRID);
+		}
+		
+		protected void createFieldEditors() {
+			FileFieldEditor f1 = new FileFieldEditor(GlobalPreference.FILE_LOG.name(), "Log file:", getFieldEditorParent());
+			addField(f1);
+		}
+	}
+	
+	private class DirectoriesPage extends FieldEditorPreferencePage {
+		public DirectoriesPage() {
+			super("Directories", GRID);
+			noDefaultAndApplyButton();
+		}
+		
+		protected void createFieldEditors() {
+			DirectoryFieldEditor d1 = new DirectoryFieldEditor(SwtPreference.SWT_DIR_PWFILES.name(),
+					"Gpml pathways:", getFieldEditorParent());
+			addField(d1);
+			
+			DirectoryFieldEditor d2 = new DirectoryFieldEditor(SwtPreference.SWT_DIR_GDB.name(),
+					"Gene databases:", getFieldEditorParent());
+			addField(d2);
+			
+			DirectoryFieldEditor d3 = new DirectoryFieldEditor(SwtPreference.SWT_DIR_EXPR.name(),
+					"Expression datasets:", getFieldEditorParent());
+			addField(d3);
+
+			if(SwtEngine.isUseR()) {
+				DirectoryFieldEditor d4 = new DirectoryFieldEditor(SwtPreference.SWT_DIR_RDATA.name(),
+						"Results from pathway statistics:", getFieldEditorParent());
+				addField(d4);
+			}
+		}
+	}
+	
+	private class DisplayPage extends FieldEditorPreferencePage {
+		public DisplayPage() {
+			super("Display", GRID);
+		}
+		
+		protected void createFieldEditors() {
+			IntegerFieldEditor f = new IntegerFieldEditor(SwtPreference.SWT_SIDEPANEL_SIZE.name(),
+					"Initial side panel size (percent of window size):", getFieldEditorParent());
+			f.setValidRange(0, 100);
+			addField(f);
+			
+			BooleanFieldEditor f2 =	new BooleanFieldEditor (
+					SwtPreference.SWT_SHOW_ADVANCED_ATTR.name(),									   
+					"Show advanced attributes (e.g. references):", getFieldEditorParent());
+				addField (f2);
+		}
+	}
+	private class ColorsPage extends FieldEditorPreferencePage {
+		public ColorsPage() {
+			super("Colors", GRID);
+		}
+		
+		protected void createFieldEditors() {
+			ColorFieldEditor f1 = new ColorFieldEditor(GlobalPreference.COLOR_NO_CRIT_MET.name(), 
+					"Default color for 'no criteria met':", getFieldEditorParent());
+			addField(f1);
+			ColorFieldEditor f2 = new ColorFieldEditor(GlobalPreference.COLOR_NO_GENE_FOUND.name(), 
+					"Default color for 'gene not found':", getFieldEditorParent());
+			addField(f2);
+			ColorFieldEditor f3 = new ColorFieldEditor(GlobalPreference.COLOR_NO_DATA_FOUND.name(), 
+					"Default color for 'no data found':", getFieldEditorParent());
+			addField(f3);
+			ColorFieldEditor f4 = new ColorFieldEditor(GlobalPreference.COLOR_SELECTED.name(), 
+					"Line color for selected objects:", getFieldEditorParent());
+			addField(f4);
+			ColorFieldEditor f5 = new ColorFieldEditor(GlobalPreference.COLOR_HIGHLIGHTED.name(), 
+					"Line color for highlighted objects:", getFieldEditorParent());
+			addField(f5);
+			
+		}
+	}
+	
+	private class DatabasePage extends FieldEditorPreferencePage {
+		public DatabasePage() {
+			super("Database", GRID);
+		}
+		
+		protected void createFieldEditors() {
+			StringFieldEditor f1 = new StringFieldEditor(SwtPreference.SWT_DB_ENGINE_GDB.name(),
+					"Database connector class for gene database:", getFieldEditorParent());
+			addField(f1);
+			StringFieldEditor f2 = new StringFieldEditor(SwtPreference.SWT_DB_ENGINE_EXPR.name(),
+					"Database connector class for expression dataset:", getFieldEditorParent());
+			addField(f2);
+		}
+	}
+	
+}
\ No newline at end of file

Property changes on: trunk/src/core/org/pathvisio/preferences/swt/PreferenceDlg.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/core/org/pathvisio/gui/swt/AboutDlg.java
===================================================================
--- trunk/src/core/org/pathvisio/gui/swt/AboutDlg.java	(revision 0)
+++ trunk/src/core/org/pathvisio/gui/swt/AboutDlg.java	(revision 958)
@@ -0,0 +1,95 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Dialog;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Listener;
+import org.eclipse.swt.widgets.Shell;
+import org.pathvisio.Globals;
+
+/**
+ * 
+ * A simple dialog box that shows about information
+ */
+public class AboutDlg extends Dialog
+{
+	private static final long serialVersionUID = 1L;
+
+	public AboutDlg(Shell parent) 
+	{
+		super (parent);
+	}
+
+	public AboutDlg(Shell parent, int style) 
+	{
+		super (parent, style);
+	}
+	
+	public void open()
+	{
+		Shell parent = getParent();
+		final Shell shell = new Shell (parent, SWT.TITLE | SWT.BORDER | SWT.APPLICATION_MODAL);
+
+		shell.setText ("About " + Globals.APPLICATION_VERSION_NAME);		
+		GridLayout ly = new GridLayout();
+		ly.numColumns = 2;
+		shell.setLayout (ly);
+		
+		Label lbl = new Label (shell, SWT.NULL);
+		lbl.setText (Globals.APPLICATION_VERSION_NAME + "\nRevision: " + Revision.REVISION);
+		GridData gd = new GridData (GridData.HORIZONTAL_ALIGN_CENTER);
+		gd.horizontalSpan = 2;		
+		lbl.setLayoutData (gd);
+		
+		lbl = new Label (shell, SWT.NULL);
+		lbl.setImage (SwtEngine.getImageRegistry().get("about.logo"));
+
+		lbl = new Label (shell, SWT.NULL);
+		lbl.setText ("R.M.H. Besseling\nS.P.M.Crijns\nI.Kaashoek\nM.M.Palm\n" +
+				"E.D Pelgrim\nT.A.J. Kelder\nM.P. van Iersel\nBiGCaT");
+		
+		final Button btnOk = new Button (shell, SWT.PUSH);
+		btnOk.setText ("OK");
+		gd = new GridData (GridData.HORIZONTAL_ALIGN_CENTER);
+		gd.horizontalSpan = 2;
+		gd.widthHint = 60;
+		btnOk.setLayoutData (gd);
+		
+		btnOk.addListener(SWT.Selection, new Listener() {
+			public void handleEvent (Event event) {
+					shell.dispose();
+			}
+		});
+			
+		shell.pack();
+		shell.open();
+		
+		Display display = parent.getDisplay();
+		while (!shell.isDisposed())
+		{
+			if (!display.readAndDispatch())
+				display.sleep();			
+		}
+	}
+}

Property changes on: trunk/src/core/org/pathvisio/gui/swt/AboutDlg.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/core/org/pathvisio/gui/swt/NewElementAction.java
===================================================================
--- trunk/src/core/org/pathvisio/gui/swt/NewElementAction.java	(revision 0)
+++ trunk/src/core/org/pathvisio/gui/swt/NewElementAction.java	(revision 958)
@@ -0,0 +1,225 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+
+package org.pathvisio.gui.swt;
+
+import java.net.URL;
+import java.util.Vector;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.action.ActionContributionItem;
+import org.eclipse.jface.action.IMenuCreator;
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Menu;
+import org.pathvisio.Engine;
+import org.pathvisio.view.VPathway;
+
+/**
+ * {@link Action} to add a new element to the gpml pathway
+ */
+public class NewElementAction extends Action
+{
+	MainWindow window;
+	int element;
+		
+	/**
+	 * Constructor for this class
+	 * @param e	type of element this action adds; a {@link VPathway} field constant
+	 */
+	public NewElementAction (int e)
+	{
+		// TODO: this should be moved to CommonActions, since it is both in v1 and v2
+		element = e;
+		
+		String toolTipText;
+		URL imageURL = null;
+		toolTipText = null;
+		switch(element) {
+		case VPathway.NEWLINE: 
+			toolTipText = "Draw new line";
+			imageURL = Engine.getResourceURL("icons/newline.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLINEARROW:
+			toolTipText = "Draw new arrow";
+			imageURL = Engine.getResourceURL("icons/newarrow.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLINEDASHED:
+			toolTipText = "Draw new dashed line";
+			imageURL = Engine.getResourceURL("icons/newdashedline.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLINEDASHEDARROW:
+			toolTipText = "Draw new dashed arrow";
+			imageURL = Engine.getResourceURL("icons/newdashedarrow.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLABEL:
+			toolTipText = "Draw new label";
+			imageURL = Engine.getResourceURL("icons/newlabel.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWARC:
+			toolTipText = "Draw new arc";
+			imageURL = Engine.getResourceURL("icons/newarc.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWBRACE:
+			toolTipText = "Draw new brace";
+			imageURL = Engine.getResourceURL("icons/newbrace.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWGENEPRODUCT:
+			toolTipText = "Draw new geneproduct";
+			imageURL = Engine.getResourceURL("icons/newgeneproduct.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWRECTANGLE:
+			imageURL = Engine.getResourceURL("icons/newrectangle.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWOVAL:
+			toolTipText = "Draw new oval";
+			imageURL = Engine.getResourceURL("icons/newoval.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWTBAR:
+			toolTipText = "Draw new TBar";
+			imageURL = Engine.getResourceURL("icons/newtbar.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWRECEPTORROUND:
+			toolTipText = "Draw new round receptor";
+			imageURL = Engine.getResourceURL("icons/newreceptorround.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWRECEPTORSQUARE:
+			toolTipText = "Draw new square receptor";
+			imageURL = Engine.getResourceURL("icons/newreceptorsquare.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLIGANDROUND:
+			toolTipText = "Draw new round ligand";
+			imageURL = Engine.getResourceURL("icons/newligandround.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLIGANDSQUARE:
+			toolTipText = "Draw new square ligand";
+			imageURL = Engine.getResourceURL("icons/newligandsquare.gif");
+			setChecked(false);
+			break;
+		case VPathway.NEWLINEMENU:
+			setMenuCreator(new NewItemMenuCreator(VPathway.NEWLINEMENU));
+			imageURL = Engine.getResourceURL("icons/newlinemenu.gif");
+			toolTipText = "Draw new line or arrow";
+			break;
+		case VPathway.NEWLINESHAPEMENU:
+			setMenuCreator(new NewItemMenuCreator(VPathway.NEWLINESHAPEMENU));
+			imageURL = Engine.getResourceURL("icons/newlineshapemenu.gif");
+			toolTipText = "Draw new ligand or receptor";
+			break;
+		}
+		setToolTipText(toolTipText);
+		setId("newItemAction");
+		if(imageURL != null) setImageDescriptor(ImageDescriptor.createFromURL(imageURL));
+	}
+				
+	public void run () {
+		if(isChecked())
+		{
+			SwtEngine.getWindow().deselectNewItemActions();
+			setChecked(true);
+			Engine.getActiveVPathway().setNewGraphics(element);
+		}
+		else
+		{	
+			Engine.getActiveVPathway().setNewGraphics(VPathway.NEWNONE);
+		}
+	}
+
+	/**
+	 * {@link IMenuCreator} that creates the drop down menus for 
+	 * adding new line-type and -shape elements
+	 */
+	private class NewItemMenuCreator implements IMenuCreator
+	{
+		private Menu menu;
+		int element;
+		
+		/**
+		 * Constructor for this class
+		 * @param e	type of menu to create; one of {@link VPathway}.NEWLINEMENU
+		 * , {@link VPathway}.NEWLINESHAPEMENU
+		 */
+		public NewItemMenuCreator(int e) 
+		{
+			element = e;
+		}
+		
+		public Menu getMenu(Menu parent)
+		{
+			return null;
+		}
+
+		public Menu getMenu(Control parent)
+		{
+			if (menu != null)
+				menu.dispose();
+			
+			menu = new Menu(parent);
+			Vector<Action> actions = new Vector<Action>();
+			switch(element)
+			{
+			case VPathway.NEWLINEMENU:
+				actions.add(new NewElementAction(VPathway.NEWLINE));
+				actions.add(new NewElementAction(VPathway.NEWLINEARROW));
+				actions.add(new NewElementAction(VPathway.NEWLINEDASHED));
+				actions.add(new NewElementAction(VPathway.NEWLINEDASHEDARROW));
+				break;
+			case VPathway.NEWLINESHAPEMENU:
+				actions.add(new NewElementAction(VPathway.NEWLIGANDROUND));
+				actions.add(new NewElementAction(VPathway.NEWRECEPTORROUND));
+				actions.add(new NewElementAction(VPathway.NEWLIGANDSQUARE));
+				actions.add(new NewElementAction(VPathway.NEWRECEPTORSQUARE));
+			}
+			
+			for (Action act : actions)
+			{			
+				addActionToMenu(menu, act);
+			}
+
+			return menu;
+		}
+		
+		protected void addActionToMenu(Menu parent, Action a)
+		{
+			ActionContributionItem item = new ActionContributionItem(a);
+			item.fill(parent, -1);
+		}
+		
+		public void dispose() 
+		{
+			if (menu != null)  {
+				menu.dispose();
+				menu = null;
+			}
+		}
+	}
+
+}

Property changes on: trunk/src/core/org/pathvisio/gui/swt/NewElementAction.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/core/org/pathvisio/gui/swt/GdbCellEditor.java
===================================================================
--- trunk/src/core/org/pathvisio/gui/swt/GdbCellEditor.java	(revision 0)
+++ trunk/src/core/org/pathvisio/gui/swt/GdbCellEditor.java	(revision 958)
@@ -0,0 +1,262 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Statement;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.FocusAdapter;
+import org.eclipse.swt.events.FocusEvent;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Layout;
+import org.pathvisio.Engine;
+import org.pathvisio.data.DataSources;
+import org.pathvisio.data.Gdb;
+import org.pathvisio.gui.swt.PropertyPanel.AutoFillData;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.PropertyType;
+import org.pathvisio.util.SuggestCellEditor;
+import org.pathvisio.util.SuggestCombo;
+import org.pathvisio.util.SuggestCombo.SuggestionListener;
+import org.pathvisio.util.SuggestCombo.SuggestionProvider;
+
+public class GdbCellEditor extends SuggestCellEditor implements SuggestionProvider, SuggestionListener {
+	public static final int TYPE_IDENTIFIER = 0;
+	public static final int TYPE_SYMBOL = 1;
+	int type;
+	
+	public static final int NO_LIMIT = 0;
+	public static final int NO_TIMEOUT = 0;
+	public static int query_timeout = 5; //seconds
+	
+	HashMap<String, PropertyPanel.AutoFillData> suggested;
+	
+	Button button;
+	
+	GdbCellEditor(Composite parent, int type) {
+		super();
+		this.type = type;
+		create(parent); //Set type before creating contol
+		suggestCombo.addSuggetsionListener(this);
+		suggested = new HashMap<String, PropertyPanel.AutoFillData>();
+	}
+		
+	protected Control createControl(Composite parent) {
+		if(type == TYPE_IDENTIFIER) {
+			Composite comp = new Composite(parent, SWT.NULL);
+			super.createControl(comp);
+			button = new Button(comp, SWT.PUSH);
+			button.setText("Set Label");
+			button.setToolTipText("Set the Label property by looking up the gene symbol in the synonym database");
+			button.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					Object value = doGetValue();
+					if(value instanceof AutoFillData) {
+						AutoFillData afd = (AutoFillData) value;
+						afd.setDoGuessData(true);
+						fireApplyEditorValue();
+						afd.setDoGuessData(false);
+					}
+				}
+			});
+			comp.setLayout(new CellLayout());
+			return comp;
+		} else {
+			return super.createControl(parent);
+		}
+	}
+	
+	protected void setFocusListeners() {
+        suggestCombo.getControl().addFocusListener(new FocusAdapter() {
+            public void focusLost(FocusEvent e) {
+            	if(!suggestCombo.isSuggestFocus() &&
+            		(button != null && !button.isFocusControl())) { //Also check focus on button
+            		GdbCellEditor.this.focusLost();
+            	}
+            }
+        });
+	}
+	
+    private class CellLayout extends Layout {
+    	//Adapted from DialogCellEditor
+        public void layout(Composite editor, boolean force) {
+            Rectangle bounds = editor.getClientArea();
+            Point size = button.computeSize(SWT.DEFAULT, SWT.DEFAULT, force);
+			suggestCombo.setBounds(0, 0, bounds.width - size.x, bounds.height);
+            button.setBounds(bounds.width - size.x, 0, size.x, bounds.height);
+        }
+
+        public Point computeSize(Composite editor, int wHint, int hHint,
+                boolean force) {
+            if (wHint != SWT.DEFAULT && hHint != SWT.DEFAULT) {
+				return new Point(wHint, hHint);
+			}
+            Point contentsSize = suggestCombo.computeSize(SWT.DEFAULT, SWT.DEFAULT,
+                    force);
+            Point buttonSize = button.computeSize(SWT.DEFAULT, SWT.DEFAULT,
+            		force);
+            Point result = new Point(buttonSize.x, Math.max(contentsSize.y,
+            		buttonSize.y));
+            return result;
+        }
+    }
+
+    public String getLabel(AutoFillData adf) {
+    	String iddb = adf.getProperty(PropertyType.GENEID) + " (" +
+    	adf.getProperty(PropertyType.SYSTEMCODE) + ")";
+    	switch(type) {
+    	case TYPE_IDENTIFIER:
+    		return 	iddb;
+    	case TYPE_SYMBOL:
+    	default:
+    		return adf.getProperty(PropertyType.TEXTLABEL) + ": " + iddb;
+    	}
+				
+	}
+	
+	public SuggestionProvider getSuggestionProvider() {
+		return this;
+	}
+
+	public void suggestionSelected(String suggestion) {
+		suggestCombo.setText(suggestion);
+		fireApplyEditorValue();
+	}
+	
+	protected Object doGetValue() {
+		String text = suggestCombo.getText();
+		AutoFillData suggestion = suggested.get(text);
+		if(suggestion == null) {
+			suggested.put(text, suggestion = new GdbAutoFillData(getMainPropertyType(), text));
+		}
+		return suggestion;
+	}
+	
+	protected PropertyType getMainPropertyType() {
+		switch(type) {
+		case TYPE_IDENTIFIER:
+			return PropertyType.GENEID;
+		case TYPE_SYMBOL:
+		default:
+			return PropertyType.TEXTLABEL;
+		}
+	}
+	
+	public String[] getSuggestions(String text, SuggestCombo suggestCombo) {
+		int limit = getLimit();
+		
+		List<String> sugg = new ArrayList<String>();
+		try {
+			Statement s = Gdb.getCon().createStatement();
+			
+			s.setQueryTimeout(query_timeout);
+			if(limit > NO_LIMIT) s.setMaxRows(limit);
+			
+			String query = "";
+			switch(type) {
+			case TYPE_IDENTIFIER:
+				query =
+						"SELECT id, code FROM gene WHERE " +
+						"id LIKE '" + text + "%'";
+				break;
+			case TYPE_SYMBOL:
+			default:
+				query =
+						"SELECT id, code, backpageText FROM gene WHERE " +
+						"backpageText LIKE '%<TH>Gene Name:<TH>" + text + "%'";
+			}
+			
+			ResultSet r = s.executeQuery(query);
+	
+			while(r.next()) {
+				String sysCode = r.getString("code");
+				String sysName = DataSources.sysCode2Name.get(sysCode);
+				
+				AutoFillData adf = null;
+				switch(type) {
+				case TYPE_IDENTIFIER:
+					adf = new GdbAutoFillData(PropertyType.GENEID, r.getString("id"));
+					adf.setProperty(PropertyType.SYSTEMCODE, sysName);
+					break;
+				case TYPE_SYMBOL:
+				default:
+					String symbol = Gdb.parseGeneSymbol(r.getString("backpageText"));
+					adf = new GdbAutoFillData(PropertyType.TEXTLABEL, symbol);
+					adf.setProperty(PropertyType.SYSTEMCODE, sysName);
+					adf.setProperty(PropertyType.GENEID, r.getString("id"));
+					
+				}
+				
+				String label = getLabel(adf);
+				suggested.put(label, adf);
+				sugg.add(label);
+			}
+		} catch (SQLException e) {
+			Engine.log.error("Unable to query suggestions", e);
+		}
+		if(limit > NO_LIMIT && sugg.size() == limit) sugg.add("...results limited to " + limit);
+		return sugg.toArray(new String[sugg.size()]);
+	}
+
+	int getLimit() {
+		switch(type) {
+		case TYPE_IDENTIFIER:
+			return 100;
+		case TYPE_SYMBOL:
+		default:
+			return 100;
+		}
+	}
+
+	class GdbAutoFillData extends AutoFillData {
+		public GdbAutoFillData(PropertyType mainProperty, String mainValue) {
+			super(mainProperty, mainValue);
+		}
+		
+		protected void guessData(PathwayElement o) {
+			//Fetch info from self
+			String id = getProperty(PropertyType.GENEID);
+			String sysName = getProperty(PropertyType.SYSTEMCODE);
+			
+			//If null, fetch from dataobject
+			if(id == null) id = (String)o.getProperty(PropertyType.GENEID);
+			if(sysName == null) sysName = (String)o.getProperty(PropertyType.SYSTEMCODE);
+			
+			String code = sysName == null ? null : DataSources.sysName2Code.get(sysName);
+			
+			//Guess symbol
+			if(id != null && code != null) {
+				String symbol = Gdb.getGeneSymbol(id, code);
+				if(symbol != null) {
+					setProperty(PropertyType.TEXTLABEL, symbol);
+				}
+			}
+		}
+	}
+
+}
Index: trunk/src/core/org/pathvisio/gui/swt/SwtEngine.java
===================================================================
--- trunk/src/core/org/pathvisio/gui/swt/SwtEngine.java	(revision 0)
+++ trunk/src/core/org/pathvisio/gui/swt/SwtEngine.java	(revision 958)
@@ -0,0 +1,443 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.io.File;
+import java.lang.reflect.InvocationTargetException;
+import java.net.URL;
+import java.util.List;
+
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.jface.dialogs.IDialogConstants;
+import org.eclipse.jface.dialogs.MessageDialog;
+import org.eclipse.jface.dialogs.ProgressMonitorDialog;
+import org.eclipse.jface.resource.ImageRegistry;
+import org.eclipse.jface.window.ApplicationWindow;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.graphics.DeviceData;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.FileDialog;
+import org.eclipse.swt.widgets.Shell;
+import org.pathvisio.Engine;
+import org.pathvisio.Globals;
+import org.pathvisio.Engine.ApplicationEvent;
+import org.pathvisio.debug.Sleak;
+import org.pathvisio.model.ConverterException;
+import org.pathvisio.model.Pathway;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.preferences.PreferenceCollection;
+import org.pathvisio.preferences.swt.SwtPreferences;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.util.SwtUtils.SimpleRunnableWithProgress;
+import org.pathvisio.view.VPathway;
+
+import edu.stanford.ejalbert.BrowserLauncher;
+import edu.stanford.ejalbert.exception.BrowserLaunchingExecutionException;
+import edu.stanford.ejalbert.exception.BrowserLaunchingInitializingException;
+import edu.stanford.ejalbert.exception.UnsupportedOperatingSystemException;
+
+/**
+ This class contains the essential parts of the program: the window, drawing and gpml data
+ It takes care of some basic Document handling facilities such as:
+ - creating a new document
+ - load / save / save as
+ - asking if a changed file should be saved before closing
+ */
+public class SwtEngine {
+	/**
+	 * {@link Pathway} object containing JDOM representation of the gpml pathway 
+	 * and handle gpml related actions
+	 */
+	
+	private static MainWindow window;
+	
+	private static ImageRegistry imageRegistry;
+	private static PreferenceCollection preferences;
+	
+	private static File DIR_APPLICATION;
+	private static File DIR_DATA;
+	static boolean USE_R;
+		
+	/**
+	 * application global clipboard.
+	 */
+	public static List<PathwayElement> clipboard = null;
+
+	/**
+	   Checks if the current pathway has changes, and if so, pops up a dialog
+	   offering to save.
+	   This should always be called before you change pathway
+
+	   @return returns false if the user pressed cancel. 
+	   
+	   TODO: Currently always asks, even if there were no changes since last save.
+	 */
+	static public boolean canDiscardPathway()
+	{
+		// checking not necessary if there is no pathway.
+		if (Engine.getActivePathway() == null) return true;
+		String[] opts =
+		{
+			IDialogConstants.YES_LABEL,
+			IDialogConstants.NO_LABEL,
+			IDialogConstants.CANCEL_LABEL
+		};
+		MessageDialog msgDlg = new MessageDialog (
+			window.getShell(),
+			"Save changes?",
+			null,
+			"Your pathway may have changed. Do you want to save?",
+			MessageDialog.QUESTION,
+			opts,
+			0);
+		int result = msgDlg.open();
+		if (result == 2) // cancel
+		{
+			return false;
+		}
+		else if (result == 0) // yes
+		{
+			// return false if save is cancelled.
+			return (savePathway());
+		}
+		// no
+		return true;
+	}
+	
+	public static void doOpenWebPage(String url) throws BrowserLaunchingInitializingException, BrowserLaunchingExecutionException, UnsupportedOperatingSystemException {
+		BrowserLauncher bl = new BrowserLauncher(null);
+		bl.openURLinBrowser(url);
+	}
+	
+	/**
+	 * Get the working directory of this application
+	 */
+	public static File getApplicationDir() {
+		if(DIR_APPLICATION == null) {
+			DIR_APPLICATION = new File(System.getProperty("user.home"), "." + Globals.APPLICATION_NAME);
+			if(!DIR_APPLICATION.exists()) DIR_APPLICATION.mkdir();
+		}
+		return DIR_APPLICATION;
+	}
+	
+	public static File getDataDir() {
+		if(DIR_DATA == null) {
+			DIR_DATA = new File(System.getProperty("user.home"), Globals.APPLICATION_NAME + "-Data");
+			if(!DIR_DATA.exists()) DIR_DATA.mkdir();
+		}
+		return DIR_DATA;
+	}
+		
+	/**
+	 * Get the {@link ImageRegistry} containing commonly used images
+	 */
+	public static ImageRegistry getImageRegistry() { 
+		if(imageRegistry == null) imageRegistry = new ImageRegistry();
+		return imageRegistry; 
+	}
+	
+	/**
+	 * Get the {@link SwtPreferences} containing the user preferences
+	 */
+	public static PreferenceCollection getPreferences() { 
+		if(preferences == null) preferences = new SwtPreferences();
+		return preferences; 
+	}
+	
+	/**
+	 * Get the {@link URL} for the resource stored in a jar file in the classpath
+	 * @param name	the filename of the resource
+	 * @return the URL pointing to the resource
+	 */
+	public static URL getResourceURL(String name) {
+		URL url = SwtEngine.class.getClassLoader().getResource(name);
+		if(url == null) Engine.log.error("Couldn't load resource '" + name + "'");
+		return url;
+	}
+		
+	/**
+	 * Initiates an instance of {@link MainWindow} that is monitored by Sleak.java,
+	 * to monitor what handles (to OS device context) are in use. For debug purposes only 
+	 * (to check for undisposed widgets)
+	 * @return The {@link MainWindow} monitored by Sleak.java
+	 */
+	public static MainWindow getSleakWindow() {
+		//<DEBUG to find undisposed system resources>
+		DeviceData data = new DeviceData();
+		data.tracking = true;
+		Display display = new Display(data);
+		Sleak sleak = new Sleak();
+		sleak.open();
+		
+		Shell shell = new Shell(display);
+		window = new MainWindow(shell);
+		return window;
+		//</DEBUG>
+	}
+	
+	/**
+	 * Get the {@link ApplicationWindow}, the UI of the program
+	 */
+	public static MainWindow getWindow() {
+		if(window == null) window = new MainWindow();
+		return window;
+	}
+	
+	public static boolean isUseR() { return USE_R; }
+
+	/**
+	 Create a new pathway (drawing + gpml data)
+	 Asks to discard an existing pathway
+	 */
+	public static void newPathway()
+	{
+		if (canDiscardPathway())
+		{
+			Pathway pathway = new Pathway();
+			pathway.initMappInfo();
+			VPathway vPathway = getWindow().createNewDrawing();
+			vPathway.fromGmmlData(pathway);
+			Engine.setActiveVPathway(pathway, vPathway);
+			Engine.fireApplicationEvent(new ApplicationEvent(vPathway, ApplicationEvent.PATHWAY_OPENED));
+			updateTitle();
+		}
+	}
+
+	/**
+	 Open a pathway from a gpml file
+	 Asks the user if the old pathway should be discarded, if necessary
+	 */
+	public static void openPathway(String pwf)
+	{
+		if (canDiscardPathway())
+		{
+			Pathway _gmmlData = null;
+			VPathway _drawing = getWindow().createNewDrawing();
+			
+			// initialize new JDOM gpml representation and read the file
+			try { 
+				Engine.openPathway(pwf);
+			} catch(ConverterException e) {		
+				if (e.getMessage().contains("Cannot find the declaration of element 'Pathway'"))
+				{
+					MessageDialog.openError(getWindow().getShell(), 
+						"Unable to open Gpml file", 
+						"Unable to open Gpml file.\n\n" +
+						"The most likely cause for this error is that you are trying to open an old Gpml file. " +
+						"Please note that the Gpml format has changed as of March 2007. " +
+						"The standard pathway set can be re-downloaded from http://pathvisio.org " +
+						"Non-standard pathways need to be recreated or upgraded. " +
+						"Please contact the authors at martijn.vaniersel@bigcat.unimaas.nl if you need help with this.\n" +
+						"\nSee error log for details");
+					Engine.log.error("Unable to open Gpml file", e);
+				}
+				else
+				{
+					MessageDialog.openError(getWindow().getShell(), 
+											"Unable to open Gpml file", e.getClass() + e.getMessage());
+					Engine.log.error("Unable to open Gpml file", e);
+				}
+			}
+			
+			if(_gmmlData != null) //Only continue if the data is correctly loaded
+			{
+				_drawing.fromGmmlData(_gmmlData);
+				Engine.setActiveVPathway(_gmmlData, _drawing);
+				updateTitle();
+				Engine.fireApplicationEvent(new ApplicationEvent(_drawing, ApplicationEvent.PATHWAY_OPENED));
+			}
+		}
+	}
+	
+	/**
+	   Opens a URL in the default webbrowser.  Uses a progress dialog
+	   if it takes a long time.  Shows an error message and returns
+	   false if it somehow failed to open the web page.
+	*/
+	public static boolean openWebPage(String url, String progressMsg, String errMsg) {
+		Shell shell = getWindow().getShell();
+		if(shell == null || shell.isDisposed()) return false;
+		
+		SimpleRunnableWithProgress rwp = new SimpleRunnableWithProgress(
+				Engine.class, "doOpenWebPage", new Class[] { String.class }, new Object[] { url }, null);
+		SimpleRunnableWithProgress.setMonitorInfo(progressMsg, IProgressMonitor.UNKNOWN);
+		ProgressMonitorDialog dialog = new ProgressMonitorDialog(shell);
+		try {
+			dialog.run(true, true, rwp);
+			return true;
+		} catch (InvocationTargetException e) {
+			Throwable cause = e.getCause();
+			String msg = cause == null ? null : cause.getMessage();
+			MessageDialog.openError(shell, "Error",
+			"Unable to open web browser" +
+			(msg == null ? "" : ": " + msg) +
+			"\n" + errMsg);
+			return false;
+		} catch (InterruptedException ignore) { return false; }
+	}
+	
+	/**
+	   save the current pathway
+	   returns false if the action was cancelled by the user
+	   
+	   Calls savePathwayAs if the filename of the current pathway is unknown,
+	   so that the user can set a location for this pathway
+	*/
+		public static boolean savePathway()
+		{
+			Pathway pathway = Engine.getActivePathway();
+			VPathway vPathway = Engine.getActiveVPathway();
+			
+			boolean result = true;
+			
+			double usedZoom = vPathway.getPctZoom();
+			// Set zoom to 100%
+			vPathway.setPctZoom(100);			
+			
+	        // Overwrite the existing xml file.
+			// If the target file is read-only, let the user select a new pathway
+			if (pathway.getSourceFile() != null && pathway.getSourceFile().canWrite())
+			{
+				try
+				{
+					Engine.savePathway();
+				}
+				catch (ConverterException e)
+				{
+					String msg = "While writing xml to " 
+						+ pathway.getSourceFile().getAbsolutePath();					
+					MessageDialog.openError (window.getShell(), "Error", 
+											 "Error: " + msg + "\n\n" + 
+											 "See the error log for details.");
+					Engine.log.error(msg, e);
+				}
+			}
+			else
+			{
+				result = savePathwayAs();
+			}
+			// Set zoom back
+			vPathway.setPctZoom(usedZoom);
+
+			return result;
+		}
+		
+	/**
+	   Opens a file dialog and lets user select a file.
+	   Then the pathways is saved to that file.
+	   returns false if the action was cancelled by the user
+	 */
+	public static boolean savePathwayAs()
+	{
+		Pathway pathway = Engine.getActivePathway();
+		VPathway vPathway = Engine.getActiveVPathway();
+		
+		// Check if a gpml pathway is loaded
+		if (pathway != null)
+		{
+			FileDialog fd = new FileDialog(window.getShell(), SWT.SAVE);
+			fd.setText("Save");
+			fd.setFilterExtensions(new String[] {"*." + Engine.PATHWAY_FILE_EXTENSION, "*.*"});
+			fd.setFilterNames(new String[] {Engine.PATHWAY_FILTER_NAME, "All files (*.*)"});
+			
+			File xmlFile = pathway.getSourceFile();
+			if(xmlFile != null) {
+				fd.setFileName(xmlFile.getName());
+				fd.setFilterPath(xmlFile.getPath());
+			} else {
+					fd.setFilterPath(SwtPreference.SWT_DIR_PWFILES.getValue());
+			}
+			String fileName = fd.open();
+			// Only proceed if user selected a file
+			
+			if(fileName == null) return false;
+			
+			// Append .gpml extension if not already present
+			if(!fileName.endsWith("." + Engine.PATHWAY_FILE_EXTENSION)) 
+				fileName += "." + Engine.PATHWAY_FILE_EXTENSION;
+			
+			File checkFile = new File(fileName);
+			boolean confirmed = true;
+			// If file exists, ask overwrite permission
+			if(checkFile.exists())
+			{
+				confirmed = MessageDialog.openQuestion(window.getShell(),"",
+													   "File already exists, overwrite?");
+			}
+			if(confirmed)
+			{
+				double usedZoom = vPathway.getPctZoom();
+				// Set zoom to 100%
+				vPathway.setPctZoom(100);					
+				// Overwrite the existing xml file
+				try
+				{
+					Engine.savePathway(checkFile);
+					updateTitle();
+					// Set zoom back
+					vPathway.setPctZoom(usedZoom);
+				}
+				catch (ConverterException e)
+				{
+					String msg = "While writing xml to " 
+						+ checkFile.getAbsolutePath();					
+					MessageDialog.openError (window.getShell(), "Error", 
+											 "Error: " + msg + "\n\n" + 
+											 "See the error log for details.");
+					Engine.log.error(msg, e);
+				}
+			}
+		}
+		else
+		{
+			MessageDialog.openError (window.getShell(), "Error", 
+									 "No gpml file loaded! Open or create a new gpml file first");
+		}			
+		return true;
+	}
+	
+	/**
+	 * Set the {@link ImageRegistry} containing commonly used images
+	 */
+	public static void setImageRegistry(ImageRegistry _imageRegistry) {
+		imageRegistry = _imageRegistry;
+	}
+	
+	/**
+	   Updates the title of the main window.
+	   Call at initialization of the program,
+	   whenever the filename of the current document has changed,
+	   or the change status has changed.
+	*/
+	public static void updateTitle()
+	{
+		if (Engine.getActivePathway() == null)
+		{
+			window.getShell().setText(Globals.APPLICATION_VERSION_NAME);
+		}
+		else
+		{
+			// get filename, or (New Pathway) if current pathway hasn't been opened yet
+			String fname = (Engine.getActivePathway().getSourceFile() == null) ? "(New Pathway)" :
+				Engine.getActivePathway().getSourceFile().getName();
+			window.getShell().setText(
+				"*" + fname + " - " +
+				Globals.APPLICATION_VERSION_NAME
+				);
+		}
+	}
+}
\ No newline at end of file

Property changes on: trunk/src/core/org/pathvisio/gui/swt/SwtEngine.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/core/org/pathvisio/gui/swt/PropertyPanel.java
===================================================================
--- trunk/src/core/org/pathvisio/gui/swt/PropertyPanel.java	(revision 0)
+++ trunk/src/core/org/pathvisio/gui/swt/PropertyPanel.java	(revision 958)
@@ -0,0 +1,657 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.awt.Color;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Set;
+
+import org.eclipse.jface.viewers.ArrayContentProvider;
+import org.eclipse.jface.viewers.CellEditor;
+import org.eclipse.jface.viewers.ColorCellEditor;
+import org.eclipse.jface.viewers.ComboBoxCellEditor;
+import org.eclipse.jface.viewers.ICellModifier;
+import org.eclipse.jface.viewers.ILabelProviderListener;
+import org.eclipse.jface.viewers.IStructuredContentProvider;
+import org.eclipse.jface.viewers.ITableLabelProvider;
+import org.eclipse.jface.viewers.TableViewer;
+import org.eclipse.jface.viewers.TextCellEditor;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.graphics.RGB;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Table;
+import org.eclipse.swt.widgets.TableColumn;
+import org.eclipse.swt.widgets.TableItem;
+import org.pathvisio.Engine;
+import org.pathvisio.biopax.gui.BiopaxCellEditor;
+import org.pathvisio.data.DataSources;
+import org.pathvisio.model.DataNodeType;
+import org.pathvisio.model.LineStyle;
+import org.pathvisio.model.LineType;
+import org.pathvisio.model.MappFormat;
+import org.pathvisio.model.ObjectType;
+import org.pathvisio.model.OrientationType;
+import org.pathvisio.model.PathwayElement;
+import org.pathvisio.model.PathwayEvent;
+import org.pathvisio.model.PathwayListener;
+import org.pathvisio.model.PropertyClass;
+import org.pathvisio.model.PropertyType;
+import org.pathvisio.model.ShapeType;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.util.ColorConverter;
+import org.pathvisio.util.SuggestCellEditor;
+import org.pathvisio.util.TableColumnResizer;
+import org.pathvisio.view.Graphics;
+import org.pathvisio.view.SelectionBox;
+import org.pathvisio.view.SelectionBox.SelectionEvent;
+import org.pathvisio.view.SelectionBox.SelectionListener;
+
+/**
+ * This class implements the sidepanel where you can edit graphical properties
+ * of each object on the pathway.
+ */
+public class PropertyPanel extends Composite implements PathwayListener, SelectionListener {
+	public TableViewer tableViewer;
+	CellEditor[] cellEditors = new CellEditor[2];
+	TextCellEditor textEditor;
+	ColorCellEditor colorEditor;
+	ComboBoxCellEditor comboBoxEditor;
+	SuggestCellEditor identifierSuggestEditor;
+	SuggestCellEditor symbolSuggestEditor;
+	BiopaxCellEditor biopaxEditor;
+	
+	private List<PathwayElement> dataObjects;
+	
+	private List<PropertyType> attributes;
+	
+	final static int TYPES_DIFF = ObjectType.MIN_VALID -1;
+	final static Object VALUE_DIFF = new Object() {
+		public boolean equals(Object o) { return false; }
+		public String toString() { return "different values"; }
+	};
+
+	/**
+	 * Add a {@link PathwayElement} to the list of objects of which 
+	 * the properties are displayed
+	 * @param o
+	 */
+	public void addGmmlDataObject(PathwayElement o) {
+		if(!dataObjects.contains(o)) {
+			if(dataObjects.add(o)) {
+				o.addListener(this);
+				refresh();
+			}
+		}
+	}
+	
+	/**
+	 * Remove a {@link PathwayElement} from the list of objects of which 
+	 * the properties are displayed
+	 * @param o
+	 */
+	public void removeGmmlDataObject(PathwayElement o) {
+		if(dataObjects.remove(o)) {
+			o.removeListener(this);
+			refresh();
+		}
+	}
+	
+	/**
+	 * Clear the list of objects of which the properties are displayed
+	 */
+	public void clearGmmlDataObjects() {
+		for(PathwayElement o : dataObjects) o.removeListener(this);
+		dataObjects.clear();
+		refresh();
+	}
+	
+	/**
+	 * Refresh the table and attributes to display
+	 */
+	void refresh() {
+		setAttributes();
+		tableViewer.refresh();
+	}
+	
+	int getAggregateType() {
+		int type = TYPES_DIFF;
+		for(int i = 0; i < dataObjects.size(); i++) {
+			PathwayElement g = dataObjects.get(i);
+			
+			if(i != 0 && type != g.getObjectType()) return TYPES_DIFF;
+			
+			type = g.getObjectType();
+		}
+		return type;
+	}
+	
+	Object getAggregateValue(PropertyType key) {
+		Object value = VALUE_DIFF;
+		for(int i = 0; i < dataObjects.size(); i++) {
+			PathwayElement g = dataObjects.get(i);
+			Object o = g.getProperty(key);
+			if(i != 0 && (o == null || !o.equals(value))) return VALUE_DIFF;
+
+			value = o;
+		}
+		return value;
+	}
+		
+	/**
+	 * Sets the attributes for the selected objects
+	 * Only attributes that are present in all objects in the selection will be
+	 * added to the attributes list and shown in the property table
+	 */
+	public void setAttributes ()
+	{
+		HashMap<PropertyType, Integer> master = new HashMap<PropertyType, Integer>();
+		for (PathwayElement o : dataObjects)
+		{
+			// get attributes. Only get advanced attributes if the preferences say so.
+			for (PropertyType attr : o.getAttributes(
+					 GlobalPreference.getValueBoolean(SwtPreference.SWT_SHOW_ADVANCED_ATTR)))
+			{
+				if (master.containsKey(attr))
+				{
+					// increment
+					master.put(attr, master.get(attr) + 1);
+				}
+				else
+				{
+					// set to 1
+					master.put(attr, 1);
+				}
+			}
+		}
+		attributes.clear();
+		for (PropertyType attr : master.keySet())
+		{
+			if (master.get(attr) == dataObjects.size())
+			{
+				attributes.add(attr);
+			}
+		}
+		// sortAttributes();
+		Collections.sort (attributes);		
+	}
+	
+//	void sortAttributes() {
+//		Collections.sort(attributes, new Comparator() {
+//			public int compare(Object o1, Object o2) {
+//				return o1.ordinal() - o2.ordinal();
+//			}
+//		});
+//	}
+
+	final static String[] colNames = new String[] {"Property", "Value"};
+				
+	PropertyPanel(Composite parent, int style)
+	{
+		super(parent, style);
+		setLayout(new FillLayout());
+		Table t = new Table(this, style);
+		TableColumn tcName = new TableColumn(t, SWT.LEFT);
+		TableColumn tcValue = new TableColumn(t, SWT.LEFT);
+		tcName.setText(colNames[0]);
+		tcValue.setText(colNames[1]);
+		tcName.setWidth(80);
+		tcValue.setWidth(70);
+		tableViewer = new TableViewer(t);
+		tableViewer.getTable().setLinesVisible(true);
+		tableViewer.getTable().setHeaderVisible(true);
+		tableViewer.setContentProvider(tableContentProvider);
+		tableViewer.setLabelProvider(tableLabelProvider);
+		
+		cellEditors[1] = cellEditors[0] = textEditor = new TextCellEditor(tableViewer.getTable());
+		colorEditor = new ColorCellEditor(tableViewer.getTable());
+		comboBoxEditor = new ComboBoxCellEditor(tableViewer.getTable(), new String[] {""});
+		identifierSuggestEditor = new GdbCellEditor(tableViewer.getTable(), GdbCellEditor.TYPE_IDENTIFIER);
+		symbolSuggestEditor = new GdbCellEditor(tableViewer.getTable(), GdbCellEditor.TYPE_SYMBOL);
+		biopaxEditor = new BiopaxCellEditor(tableViewer.getTable(), "...");
+		
+		tableViewer.setCellEditors(cellEditors);
+		tableViewer.setColumnProperties(colNames);
+		tableViewer.setCellModifier(cellModifier);
+		
+		t.addControlListener(new TableColumnResizer(t, t.getParent()));
+		
+		dataObjects = new ArrayList<PathwayElement>();
+		attributes = new ArrayList<PropertyType>();
+		tableViewer.setInput(attributes);
+		
+		SelectionBox.addListener(this);
+	}
+	
+	/**
+	 * return the right cell editor for a certain object. Will return
+	 * one of existing editors. In the case of a list of possible values, 
+	 * a comboboxeditor will be set up with the proper values for
+	 * the drop down list.
+	 */
+	final static String[] orientation_names = OrientationType.getNames();
+	final static String[] linestyle_names = LineStyle.getNames();
+	final static String[] boolean_names = {"false", "true"};
+	final static String[] shape_names = ShapeType.getNames();
+	final static String[] linetype_names = LineType.getNames(); 
+	final static String[] genetype_names = DataNodeType.getNames();
+	
+	private CellEditor getCellEditor(Object element)
+	{
+		PropertyType key = (PropertyType)element;
+		PropertyClass type = key.type();
+		switch(type)
+		{
+			case FONT:				
+			case STRING:
+			case DOUBLE:
+			case ANGLE:
+			case INTEGER: 	return textEditor;
+			case COLOR: 	return colorEditor;
+			case LINETYPE:
+				comboBoxEditor.setItems(linetype_names);
+				return comboBoxEditor;
+			case SHAPETYPE:
+				comboBoxEditor.setItems(shape_names);
+				return comboBoxEditor;
+			case DATASOURCE:			
+				comboBoxEditor.setItems(DataSources.dataSources);
+				return comboBoxEditor;
+			case ORIENTATION:
+				comboBoxEditor.setItems(orientation_names);
+				return comboBoxEditor;
+			case LINESTYLE:
+				comboBoxEditor.setItems(linestyle_names);
+				return comboBoxEditor;
+			case BOOLEAN:
+				comboBoxEditor.setItems(boolean_names);
+				return comboBoxEditor;
+			case ORGANISM:
+				comboBoxEditor.setItems(MappFormat.organism_latin_name);
+				return comboBoxEditor;
+			case GENETYPE:
+				comboBoxEditor.setItems(genetype_names);
+				return comboBoxEditor;
+			case DB_ID:
+				return identifierSuggestEditor;
+			case DB_SYMBOL:
+				return textEditor;
+			case BIOPAXREF:
+				return biopaxEditor;
+				
+		}
+		return textEditor;
+	}
+	
+	private ICellModifier cellModifier = new ICellModifier()
+	{
+		public boolean canModify(Object element, String property) {
+			if (!colNames[1].equals(property))
+			{
+				return false;
+			}
+			
+			cellEditors[1] = getCellEditor(element);
+			return true;
+		}
+
+		/**
+		 * Getvalue is the value that is passed to the Cell Editor when it is 
+		 * activated.
+		 * It should return an Integer object for ComboboxCellEditors.
+		 */
+		public Object getValue(Object element, String property) 
+		{
+			PropertyType key = (PropertyType)element;
+			Object value = getAggregateValue(key);
+			if(value == VALUE_DIFF) {
+				return VALUE_DIFF.toString();
+			}
+			switch(key.type())
+			{
+				case ANGLE:
+				{
+					Double x = Math.round((Double)(value) * 1800.0 / Math.PI) / 10.0;
+					return x.toString();
+				}
+				case DOUBLE:
+				{
+					Double x = Math.round((Double)(value) * 100.0) / 100.0;
+					return x.toString();
+				}
+				case INTEGER: 
+					return value.toString();
+				case ORGANISM:
+					return Arrays.asList(MappFormat.organism_latin_name).indexOf((String)value);
+				case GENETYPE:
+					return Arrays.asList(genetype_names).indexOf((String)value);
+				case STRING:
+				case FONT:
+					return value == null ? "" : (String)value;
+				case DATASOURCE:
+					return DataSources.lDataSources.indexOf((String)value);				
+				// for all combobox types:
+				case BOOLEAN:
+					return ((Boolean)value) ? 1 : 0;
+				case SHAPETYPE:
+					return (((ShapeType)value).ordinal());
+				case LINETYPE:
+					return (((LineType)value).ordinal());
+				case COLOR:
+					if(value instanceof Color)
+						value = ColorConverter.toRGB((Color)value);
+					return (RGB)value;
+				case ORIENTATION:
+				case LINESTYLE:
+				{
+//					try 
+//					{
+						return (Integer)value;
+//					}
+//					catch (ClassCastException e)
+//					{
+//						MessageDialog.openWarning(getShell(), "warning", "Can't cast " + value + " to Integer!");
+//					}
+				}
+				case DB_ID:
+				case DB_SYMBOL:
+					if(value instanceof String) return (String)value;
+					if(value instanceof PropertyPanel.AutoFillData) 
+						return ((PropertyPanel.AutoFillData)value).getMainValue();
+				case BIOPAXREF:
+					return value;
+					
+			}
+			return null;
+		}
+		
+		public void modify(Object element, String property, Object value) {
+			PropertyType key = (PropertyType)((TableItem)element).getData();
+			
+			if(value == VALUE_DIFF || value == VALUE_DIFF.toString()) {
+				return;
+			}
+			/*
+			 * Here, we transform the output of the cell editor
+			 * to a value understood by PathwayElement.SetProperty().
+			 * 
+			 * The output of a comboboxCellEditor is Integer.
+			 * The output of a textCellEditor is String.
+			 * 
+			 * For linetype and shapetype we go from Integer to Integer. easy
+			 * For boolean, we go from Integer to Boolean
+			 * For Double / Integer, we go from String to Double
+			 * For Datasource, we go from Integer to String.
+			 */
+			switch(key.type())
+			{
+			case ANGLE: 	
+				try 
+				{ 
+					// convert degrees (property editor) to radians (model)
+					value = Double.parseDouble((String)value) * Math.PI / 180;					
+					break;
+				} 
+				catch(Exception e) 
+				{
+					// invalid input, ignore
+					return; 
+				}
+			case DOUBLE: 	
+				try 
+				{ 
+					value = Double.parseDouble((String)value); 
+					break; 
+				} 
+				catch(Exception e) 
+				{
+					// invalid input, ignore
+					return; 
+				}
+			case INTEGER: 	
+				try 
+				{ 
+					value = Integer.parseInt((String)value); 
+					break; 
+				}
+				catch(Exception e) 
+				{ 
+					// invalid input, ignore 
+					return; 
+				}
+			case DATASOURCE:
+				if((Integer)value == -1) return; //Nothing selected
+				value = DataSources.lDataSources.get((Integer)value);
+				break;
+			case BOOLEAN:
+				if ((Integer)value == 0)
+				{
+					value = new Boolean (false);
+				}
+				else
+				{
+					value = new Boolean (true);
+				}
+				break;
+			case ORGANISM:
+				if((Integer)value == -1) return; //Nothing selected
+				value = MappFormat.organism_latin_name[(Integer)value];
+				break;
+			case GENETYPE:
+				if((Integer)value == -1) return; //Nothing selected
+				value = genetype_names[(Integer)value];
+				break;
+			case COLOR:
+				value = ColorConverter.fromRGB((RGB)value);
+			case DB_SYMBOL:
+			case DB_ID:
+				if(value instanceof PropertyPanel.AutoFillData) {
+					PropertyPanel.AutoFillData adf = (PropertyPanel.AutoFillData)value;
+					for(PathwayElement o : dataObjects) {
+						if(o.getObjectType() == ObjectType.DATANODE) {
+							adf.fillData(o);
+						}
+					}
+					value = adf.getMainValue();
+				}
+				break;
+			}
+			for(PathwayElement o : dataObjects) {
+				o.setProperty(key, value);
+			}
+			tableViewer.refresh();
+			Engine.getActiveVPathway().redrawDirtyRect();
+		}
+	};
+	
+	private IStructuredContentProvider tableContentProvider = new ArrayContentProvider();
+	
+	private ITableLabelProvider tableLabelProvider = new ITableLabelProvider() {
+		public Image getColumnImage(Object element, int columnIndex) {
+			return null;
+		}
+		public String getColumnText(Object element, int columnIndex) {
+			PropertyType key = (PropertyType)element;
+			switch(columnIndex) {
+				case 0:
+					return key.desc();					
+				case 1:
+					//TODO: prettier labels for different value types
+					if(attributes.contains(key))
+					{
+						Object value = getAggregateValue(key);
+						if (value == null)
+						{
+							return null;
+						}
+						else 
+						{
+							switch (key.type())
+							{
+								case ANGLE:
+								{
+									if (value instanceof Double)
+									{
+										Double x = Math.round((Double)(value) * 1800.0 / Math.PI) / 10.0;
+										return x.toString();
+									}
+									else
+										return value.toString();
+								}
+								case DOUBLE:								
+									if (value instanceof Double)
+									{
+										Double x = Math.round((Double)(value) * 10.0) / 10.0;
+										return x.toString();
+									}
+									else
+										return value.toString();
+										
+								case BOOLEAN:
+								{
+									if (value instanceof Boolean)
+									{
+										return (Boolean)(value) ? "true" : "false";
+									}
+									else
+										return value.toString();
+								}
+								case LINETYPE:
+								{
+									if (value instanceof Integer)
+										return linetype_names[(Integer)(value)];
+									else
+										return value.toString();
+								}
+								case LINESTYLE:
+								{
+									if (value instanceof Integer)
+										return linestyle_names[(Integer)(value)];
+									else
+										return value.toString();
+								}
+								case ORIENTATION:
+								{
+									if (value instanceof Integer)
+										return orientation_names[(Integer)(value)];
+									else
+										return value.toString();									
+								}
+								case SHAPETYPE:
+								{
+									if (value instanceof Integer)
+										return shape_names[(Integer)(value)];
+									else
+										return value.toString();
+								}
+								case COLOR:
+									if(value instanceof Color) {
+										return ColorConverter.toRGB((Color)value).toString();
+									}
+								default:
+									return value.toString();
+							}
+						}
+					}
+			}
+			return null;
+			}
+		
+		public void addListener(ILabelProviderListener listener) { }
+		public void dispose() {}
+		public boolean isLabelProperty(Object element, String property) {
+			return false;
+		}
+		public void removeListener(ILabelProviderListener listener) { }
+	};
+
+	public void gmmlObjectModified(PathwayEvent e) {
+		tableViewer.refresh();
+	}
+
+	//TODO: implement all attribute types as subclasses of MyType.
+//	class MyType {
+//		abstract String getColumnText(Object value);
+//		abstract Object adjustedValue(Object value);
+//		abstract CellEditor getCellEditor()
+//	}
+	
+	public void drawingEvent(SelectionEvent e) {
+		switch(e.type) {
+		case SelectionEvent.OBJECT_ADDED:
+			if(e.affectedObject instanceof Graphics)
+				addGmmlDataObject(((Graphics)e.affectedObject).getGmmlData());
+			break;
+		case SelectionEvent.OBJECT_REMOVED:
+			if(e.affectedObject instanceof Graphics)
+				removeGmmlDataObject(((Graphics)e.affectedObject).getGmmlData());
+			break;
+		case SelectionEvent.SELECTION_CLEARED:
+			 clearGmmlDataObjects();
+			break;
+		}
+		
+	}
+
+	static class AutoFillData {
+		PropertyType mProp;
+		Object mValue;
+		HashMap<PropertyType, String> values;
+		
+		private boolean doGuess = false;
+		
+		public AutoFillData(PropertyType mainProperty, String mainValue) {
+			values = new HashMap<PropertyType, String>();
+			mProp = mainProperty;
+			mValue = mainValue;
+			setProperty(mainProperty, mainValue);
+		}
+		
+		public void setProperty(PropertyType property, String value) {
+			values.put(property, value);
+		}
+		
+		public PropertyType getMainProperty() { return mProp; }
+		public Object getMainValue() { return mValue; }
+		
+		public String getProperty(PropertyType property) { return values.get(property); }
+		
+		public Set<PropertyType> getProperties() { return values.keySet(); }
+		
+		public void fillData(PathwayElement o) {
+			if(doGuess) guessData(o);
+			for(PropertyType p : getProperties()) {
+				Object vNew = getProperty(p);
+				o.setProperty(p, vNew);
+			}
+		}
+		
+		public void setDoGuessData(boolean doGuessData) {
+			doGuess = doGuessData;
+		}
+		
+		protected void guessData(PathwayElement o) {
+		}
+	}
+}
+

Property changes on: trunk/src/core/org/pathvisio/gui/swt/PropertyPanel.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/core/org/pathvisio/gui/swt/SidePanel.java
===================================================================
--- trunk/src/core/org/pathvisio/gui/swt/SidePanel.java	(revision 0)
+++ trunk/src/core/org/pathvisio/gui/swt/SidePanel.java	(revision 958)
@@ -0,0 +1,212 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.SashForm;
+import org.eclipse.swt.custom.StackLayout;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Sash;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+
+/**
+ * This class can be extended to create a sidepanel with minimize button
+ * for use as component of a {@link SashForm}
+ */
+public class SidePanel extends Composite {
+	private SashForm parentSash;
+	private Composite contentComposite;
+	
+	/**
+	 * Constructor for this class
+	 * @param parent	The parent composite (needs to be an {@link SashForm} for the
+	 * minimize button to work
+	 * @param style
+	 */
+	public SidePanel(Composite parent, int style) {
+		super(parent, style);
+		if(parent instanceof SashForm) //Minimize button only works if parent is sashform
+			parentSash = (SashForm)parent;
+		createControls();
+	}
+
+	public Composite getContentComposite() { return contentComposite; }
+	
+	Composite buttonBar;
+	Composite stackComposite;
+	Composite emptyComposite;
+	StackLayout stackLayout;
+	Button minButton;
+	/**
+	 * Creates the button controls to minimize the sidepanel and a {@link Composite} for the contents
+	 */
+	public void createControls() {
+		GridLayout topLayout = new GridLayout();
+		topLayout.verticalSpacing = topLayout.marginTop = topLayout.marginWidth = 0;
+		setLayout(topLayout);
+		
+		if(parentSash != null) {
+			//Create minimize control on top of content
+			buttonBar = new Composite(this, SWT.NULL);
+			GridLayout barLayout = new GridLayout(2, true);
+			barLayout.marginBottom = barLayout.marginHeight = barLayout.marginWidth = 1;
+			buttonBar.setLayout(barLayout);
+						
+			minButton = new Button(buttonBar, SWT.TOGGLE);
+			minButton.setToolTipText("Minimize this sidepanel");
+			minButton.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					if(minButton.getSelection()) {
+						minimize();
+						minButton.setToolTipText("Restore this sidepanel");
+					}
+					else {
+						restore();
+						minButton.setToolTipText("Minimize this sidepanel");
+					}
+				}
+			});
+			minButton.setImage(SwtEngine.getImageRegistry().get("sidepanel.minimize"));
+			final Button hideButton = new Button(buttonBar, SWT.PUSH);
+			hideButton.setToolTipText("Close this sidepanel (use view menu to open again)");
+			hideButton.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					hide();
+					SwtEngine.getWindow().showRightPanelAction.setChecked(false);
+				}
+			});
+			hideButton.setImage(SwtEngine.getImageRegistry().get("sidepanel.hide"));
+			
+			GridData buttonGrid = new GridData();
+			buttonGrid.widthHint = 12;
+			buttonGrid.heightHint =  12;
+			hideButton.setLayoutData(buttonGrid);
+			minButton.setLayoutData(buttonGrid);
+			
+			buttonBar.pack();
+		}
+		stackComposite = new Composite(this, SWT.NULL);
+		stackComposite.setLayoutData(new GridData(GridData.FILL_BOTH));
+		stackLayout = new StackLayout();
+		stackComposite.setLayout(stackLayout);
+		emptyComposite = new Composite(stackComposite, SWT.NULL);
+		emptyComposite.setLayout(new FillLayout());
+		contentComposite = new Composite(stackComposite, SWT.NULL);
+		contentComposite.setLayout(new FillLayout());
+		
+		stackLayout.topControl = contentComposite;
+	}
+	
+	/**
+	 * Minimizes this panel, while the minimize button will still be visible
+	 */
+	public void minimize() {
+		parentSash.setWeights(calculateWeights(WEIGHTS_MINIMIZE));
+		stackLayout.topControl = emptyComposite;
+		stackComposite.layout();
+	}
+	
+	/**
+	 * Hides this panel, the minimize button will not be visible anymore
+	 */
+	public void hide() {
+		parentSash.setWeights(calculateWeights(WEIGHTS_HIDE));
+	}
+	
+	public void show() {
+		int sidePanelSize = GlobalPreference.getValueInt(SwtPreference.SWT_SIDEPANEL_SIZE);
+		if(sidePanelSize == 0) sidePanelSize = 10; //Force show if initial size = 0
+		parentSash.setWeights(calculateWeights(sidePanelSize));
+	}
+	
+	/**
+	 * Restores the size of the panel to its previous size
+	 */
+	public void restore() {
+		if(oldWeights == null) return;
+		parentSash.setWeights(oldWeights);
+		stackLayout.topControl = contentComposite;
+		stackComposite.layout();
+	}
+	
+	private int[] oldWeights;
+	private static final int WEIGHTS_HIDE = -1;
+	private static final int WEIGHTS_MINIMIZE = -2;
+	/**
+	 * Calculates weights that have to be passed to the parent {@link SashForm#setWeights(int[])}
+	 * to resize, minimize or hide this panel
+	 * @param percent percentage of total size for this panel or 
+	 * one of WEIGHTS_HIDE or WEIGHTS_MINIMIZE, in the first case the panel is hidden,
+	 * so its weight is set to zero, in the second case the panel is miminized in a way the minimize 
+	 * button is still visible
+	 * @return
+	 */
+	private int[] calculateWeights(int percent) {
+		Control[] controls = parentSash.getChildren();
+		int[] weights = parentSash.getWeights();
+		oldWeights = weights.clone();
+		//Get the index of this control in the sashform
+		int thisIndex = 0;
+		for(int i = 0; i < controls.length; i++) {
+			if(controls[i] == this) break;
+			if(!(controls[i] instanceof Sash)) thisIndex++; //Don't count sash controls
+		}
+		
+		int thisWeight = weights[thisIndex];
+		
+		//Get the index of the neighbouring composite
+		int neighbourIndex = -1;
+		if(thisIndex == weights.length - 1) neighbourIndex = thisIndex - 1;
+		else neighbourIndex = thisIndex + 1;
+		
+		//Calculate widths needed to calculate new weight 
+		int newWidth;
+		switch(percent) {
+		case WEIGHTS_MINIMIZE: newWidth = minButton.getSize().x; break;
+		case WEIGHTS_HIDE: newWidth = 0; break;
+		default:
+			//Calculate new weights
+			int percentLeft = 100 - percent;
+			int sum = 0;
+			for(int i = 0; i < weights.length; i++) {
+				sum += weights[i];
+				if(i == thisIndex) continue;
+				weights[i] = (int)(((double)weights[i] / 100) * percentLeft);
+			}
+			weights[thisIndex] = (int)(((double)percent / 100) * sum);
+			return weights;
+			}
+		
+		int thisWidth = getSize().x;
+		
+		//Calculate new weights
+		int newWeight = (int)(((double)newWidth / thisWidth) * thisWeight);
+		//Adjust the weight of this and the next control
+		weights[thisIndex] = newWeight;
+		weights[neighbourIndex] += thisWeight - newWeight;
+		return weights;
+	}
+
+}

Property changes on: trunk/src/core/org/pathvisio/gui/swt/SidePanel.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/core/org/pathvisio/gui/swt/TabbedSidePanel.java
===================================================================
--- trunk/src/core/org/pathvisio/gui/swt/TabbedSidePanel.java	(revision 0)
+++ trunk/src/core/org/pathvisio/gui/swt/TabbedSidePanel.java	(revision 958)
@@ -0,0 +1,175 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.util.HashMap;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.CTabFolder;
+import org.eclipse.swt.custom.CTabItem;
+import org.eclipse.swt.custom.SashForm;
+import org.eclipse.swt.events.DisposeEvent;
+import org.eclipse.swt.events.DisposeListener;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.TabFolder;
+import org.eclipse.swt.widgets.TabItem;
+
+/**
+ * This class represents a side panel with contents placed in different
+ * tabitems. Components to add needs to be children of the {@link TabFolder}
+ * returned by {@link #getTabFolder()}
+ */
+public class TabbedSidePanel extends SidePanel {
+	private CTabFolder tabFolder;
+	HashMap<String, Control> controls;
+	HashMap<String, CTabItem> tabItems;
+	
+	/**
+	 * Returns the {@link TabFolder} containing the different
+	 * tabItems of this sidepanel
+	 */
+	public CTabFolder getTabFolder() { return tabFolder; }
+	
+	public HashMap<String, CTabItem> getTabItemHash() { return tabItems; }
+	
+	/**
+	 * Constructor for this class
+	 * @param parent	The parent composite (needs to be an {@link SashForm} for the
+	 * minimize button to work
+	 * @param style		
+	 */
+	public TabbedSidePanel(Composite parent, int style) {
+		super(parent, style);
+		controls = new HashMap<String, Control>();
+		tabItems = new HashMap<String, CTabItem>();
+		
+		tabFolder = new CTabFolder(getContentComposite(), SWT.BORDER);
+		tabFolder.setSimple(false);
+	}
+	
+	/**
+	 * Add a TabItem containing the given Control.
+	 * @param content	{@link Control} that needs to be a child of the
+	 * TabFolder returned by {@link #getTabFolder()}
+	 * @param title		The title for the TabItem
+	 */
+	public void addTab(Control content, String title)
+	{		
+		createTabItem(content, title, false);
+		controls.put(title, content);
+	}
+	
+	public void addTab(Control content, String title, boolean close)
+	{		
+		createTabItem(content, title, close);
+		controls.put(title, content);
+	}
+	
+	/**
+	 * Creates an {@link TabItem} with the given control and title
+	 * @param content
+	 * @param title
+	 * @param close
+	 * @returns
+	 */
+	private CTabItem createTabItem(Control content, String title, boolean close)
+	{
+		return createTabItem(content, title, tabFolder.getItemCount(), close);
+	}
+	
+	/**
+	 * Creates an {@link TabItem} with the given control and title at the given index.
+	 * If the index is lower than the number of tabitems, the new tabitem is placed before the first,
+	 * otherwise it is placed after the last.
+	 * @param content
+	 * @param title
+	 * @returns
+	 * @param index
+	 * @return
+	 */
+	private CTabItem createTabItem(Control content, String title, int index, boolean close) {
+		int nrTabs = tabFolder.getItemCount();
+		
+		if(index > nrTabs) index = nrTabs; //If index is invalid, choose first or last tab
+		else if(index < 0) index = 0;
+		
+		final CTabItem ti = new CTabItem(tabFolder, close ? SWT.CLOSE : SWT.NULL, index);
+		ti.setText(title);
+		ti.setControl(content);
+		ti.addDisposeListener(new DisposeListener() {
+			public void widgetDisposed(DisposeEvent e) {
+				tabItems.remove(ti.getText());
+			}
+		});
+		tabItems.put(title, ti);
+		return ti;
+	}
+	
+	/**
+	 * Hides a tab (without disposing the containing {@link Control})
+	 * @param title The title of the tab
+	 */
+	public void hideTab(String title) {
+		if(!tabItems.containsKey(title)) return;
+		tabItems.get(title).dispose();
+		tabItems.remove(title);
+	}
+	
+	/**
+	 * Shows a tab if a control with the given title exists
+	 * @param title	The title of the tabitem, also serves to find the {@link Control} for the tabItem
+	 * @return true if the tab is added, false if not ({@link Control} not found)
+	 */
+	public boolean unhideTab(String title) {
+		return unhideTab(title, tabFolder.getItemCount());
+	}
+	
+	/**
+	 * Shows a tab if a control with the given title exists
+	 * @param title	The title of the tabitem, also serves to find the {@link Control} for the tabItem
+	 * @param position The index of the position to add the tab
+	 * @return true if the tab is added, false if not ({@link Control} not found)
+	 */
+	public boolean unhideTab(String title, int position) {
+		if(controls.containsKey(title)) {
+			createTabItem(controls.get(title), title, position, false);
+			return true;
+		}
+		return false;
+	}
+	
+	public void selectTab(String title) {
+		if(tabItems.containsKey(title)) 
+			tabFolder.setSelection(tabItems.get(title));
+	}
+	
+	/**
+	 * Checks whether a tabitem is visible
+	 */
+	public boolean isVisible(String title) {
+		return tabItems.containsKey(title) && controls.containsKey(title);
+	}
+	
+	/**
+	 * Check whether a tabitem with the given title exists
+	 * @param title
+	 */
+	public boolean hasTab(String title) {
+		return tabItems.containsKey(title);
+	}
+}

Property changes on: trunk/src/core/org/pathvisio/gui/swt/TabbedSidePanel.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/core/org/pathvisio/gui/swt/MainWindowBase.java
===================================================================
--- trunk/src/core/org/pathvisio/gui/swt/MainWindowBase.java	(revision 0)
+++ trunk/src/core/org/pathvisio/gui/swt/MainWindowBase.java	(revision 958)
@@ -0,0 +1,438 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.action.ActionContributionItem;
+import org.eclipse.jface.action.ControlContribution;
+import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.action.IContributionItem;
+import org.eclipse.jface.action.MenuManager;
+import org.eclipse.jface.action.ToolBarContributionItem;
+import org.eclipse.jface.action.ToolBarManager;
+import org.eclipse.jface.dialogs.MessageDialog;
+import org.eclipse.jface.dialogs.ProgressMonitorDialog;
+import org.eclipse.jface.window.ApplicationWindow;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.SashForm;
+import org.eclipse.swt.custom.ScrolledComposite;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.widgets.Combo;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Shell;
+import org.pathvisio.Engine;
+import org.pathvisio.Engine.ApplicationEvent;
+import org.pathvisio.Engine.ApplicationEventListener;
+import org.pathvisio.data.DBConnector;
+import org.pathvisio.data.Gdb;
+import org.pathvisio.data.Gex;
+import org.pathvisio.data.Gex.ExpressionDataEvent;
+import org.pathvisio.data.Gex.ExpressionDataListener;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.search.PathwaySearchComposite;
+import org.pathvisio.view.GeneProduct;
+import org.pathvisio.view.VPathway;
+import org.pathvisio.view.VPathwayEvent;
+import org.pathvisio.view.VPathwayListener;
+import org.pathvisio.visualization.LegendPanel;
+
+/**
+ * MainWindowBase is an abstract and incomplete Main Window that contains some
+ * core functionality. This way we can create different flavours of the main window
+ * without having too much duplicate code. Descendants should at least provide
+ * a constructor, and override createCoolBarManager and createMenuManager.
+ */
+public abstract class MainWindowBase extends ApplicationWindow implements 
+	ApplicationEventListener, ExpressionDataListener, VPathwayListener
+{
+	private static final long serialVersionUID = 1L;
+	static int ZOOM_TO_FIT = -1;
+		
+	protected CommonActions.UndoAction undoAction = new CommonActions.UndoAction(this);	
+	protected CommonActions.NewAction newAction = new CommonActions.NewAction (this);
+	protected CommonActions.OpenAction openAction = new CommonActions.OpenAction (this);	
+	protected CommonActions.ImportAction importAction = new CommonActions.ImportAction (this);	
+	protected CommonActions.SaveAction saveAction = new CommonActions.SaveAction(this);	
+	protected CommonActions.SaveAsAction saveAsAction = new CommonActions.SaveAsAction (this);
+	protected CommonActions.ExportAction exportAction = new CommonActions.ExportAction (this);
+	protected CommonActions.ExitAction exitAction = new CommonActions.ExitAction(this);
+	protected CommonActions.PreferencesAction preferencesAction = new CommonActions.PreferencesAction(this);
+	protected CommonActions.AboutAction aboutAction = new CommonActions.AboutAction(this);
+	protected CommonActions.CopyAction copyAction = new CommonActions.CopyAction(this);
+	protected CommonActions.HelpAction helpAction = new CommonActions.HelpAction(this);	
+	protected CommonActions.PasteAction pasteAction = new CommonActions.PasteAction(this);
+	protected CommonActions.SwitchEditModeAction switchEditModeAction = new CommonActions.SwitchEditModeAction(this);
+	public ShowRightPanelAction showRightPanelAction = new ShowRightPanelAction(this);
+	protected SelectGdbAction selectGdbAction = new SelectGdbAction(this);
+	protected AlignActions.AlignCenterXAction alignCenterXAction = new AlignActions.AlignCenterXAction(this);
+	protected AlignActions.AlignCenterYAction alignCenterYAction = new AlignActions.AlignCenterYAction(this);
+	protected AlignActions.AlignLeftAction alignLeftAction = new AlignActions.AlignLeftAction(this);
+	protected AlignActions.AlignRightAction alignRightAction = new AlignActions.AlignRightAction(this);
+	protected AlignActions.AlignTopAction alignTopAction = new AlignActions.AlignTopAction(this);
+	protected AlignActions.AlignBottomAction alignBottomAction = new AlignActions.AlignBottomAction(this);
+	protected AlignActions.SetCommonWidthAction setCommonWidthAction = new AlignActions.SetCommonWidthAction(this);
+	protected AlignActions.SetCommonHeightAction setCommonHeightAction = new AlignActions.SetCommonHeightAction(this);
+
+	/**
+	 * {@link Action} to select a Gene Database
+	 */
+	private class SelectGdbAction extends Action
+	{
+		MainWindowBase window;
+		public SelectGdbAction(MainWindowBase w)
+		{
+			window = w;
+			setText("Select &Gene Database");
+			setToolTipText("Select Gene Database");
+		}
+		
+		public void run () {			
+			try {
+				DBConnector dbcon = Gdb.getDBConnector();
+				String dbName = dbcon.openChooseDbDialog(getShell());
+				
+				if(dbName == null) return;
+				
+				Gdb.connect(dbName);
+				setStatus("Using Gene Database: '" + SwtPreference.SWT_CURR_GDB + "'");
+				cacheExpressionData();
+			} catch(Exception e) {
+				String msg = "Failed to open Gene Database; " + e.getMessage();
+				MessageDialog.openError (window.getShell(), "Error", 
+						"Error: " + msg + "\n\n" + 
+						"See the error log for details.");
+				Engine.log.error(msg, e);
+			}
+		}
+	}
+
+	/**
+	 * deselect all buttons in the alignActionsCI coolbar
+	 */
+	public void deselectAlignItemActions()
+	{
+		IContributionItem[] items = alignActionsCI.getToolBarManager().getItems();
+		for(int i = 0; i < items.length; i++)
+		{
+			if(items[i] instanceof ActionContributionItem)
+			{
+				((ActionContributionItem)items[i]).getAction().setChecked(false);
+			}
+		}
+		Engine.getActiveVPathway().setNewGraphics(VPathway.NEWNONE);
+	}
+	
+	/**
+	 * {@link Action} to show or hide the right sidepanel
+	 */
+	public class ShowRightPanelAction extends Action
+	{
+		MainWindowBase window;
+		public ShowRightPanelAction (MainWindowBase w)
+		{
+			super("Show &information panel", IAction.AS_CHECK_BOX);
+			window = w;
+			setChecked(true);
+		}
+		
+		public void run() {
+			if(isChecked()) rightPanel.show();
+			else rightPanel.hide();
+		}
+	}
+
+	/**
+	 * Loads expression data for all {@link GeneProduct}s in the loaded pathway
+	 */
+	private void cacheExpressionData()
+	{
+		if(Engine.isDrawingOpen())
+		{
+			VPathway drawing = Engine.getActiveVPathway();
+			//Check for neccesary connections
+			if(Gex.isConnected() && Gdb.isConnected())
+			{
+				ProgressMonitorDialog dialog = new ProgressMonitorDialog(getShell());
+				try {
+					dialog.run(true, true, Gex.createCacheRunnable(drawing.getMappIds(), drawing.getSystemCodes()));
+					drawing.redraw();
+				} catch(Exception e) {
+					String msg = "while caching expression data: " + e.getMessage();					
+					MessageDialog.openError (getShell(), "Error", 
+							"Error: " + msg + "\n\n" + 
+							"See the error log for details.");
+					Engine.log.error(msg, e);
+				}
+			}
+		}
+	}
+
+	/**
+	 * Deselects all {@link NewElementAction}s on the toolbar and sets 
+	 * {@link VPathway}.newGraphics to {@link VPathway}.NEWNONE
+	 */
+	public void deselectNewItemActions()
+	{
+		IContributionItem[] items = editActionsCI.getToolBarManager().getItems();
+		for(int i = 0; i < items.length; i++)
+		{
+			if(items[i] instanceof ActionContributionItem)
+			{
+				((ActionContributionItem)items[i]).getAction().setChecked(false);
+			}
+		}
+		Engine.getActiveVPathway().setNewGraphics(VPathway.NEWNONE);
+	}
+
+	// Elements of the coolbar
+	ToolBarContributionItem commonActionsCI;
+	ToolBarContributionItem editActionsCI;
+	ToolBarContributionItem alignActionsCI;
+	ToolBarContributionItem viewActionsCI;
+	
+	/**
+	 * Creates element of the coolbar containing common actions as new, save etc.
+	 */
+	protected void createCommonActionsCI()
+	{
+		ToolBarManager toolBarManager = new ToolBarManager(SWT.FLAT);
+		toolBarManager.add(newAction);
+		toolBarManager.add(openAction);
+		toolBarManager.add(saveAction);
+		commonActionsCI = new ToolBarContributionItem(toolBarManager, "CommonActions");
+	}
+
+	/**
+	 * Creates element of the coolbar only shown in edit mode (new element actions)
+	 */
+	protected void createEditActionsCI()
+	{
+		ToolBarManager toolBarManager = new ToolBarManager(SWT.FLAT);		
+		toolBarManager.add(new NewElementAction(VPathway.NEWGENEPRODUCT));
+		toolBarManager.add(new NewElementAction(VPathway.NEWLABEL));
+		toolBarManager.add(new NewElementAction(VPathway.NEWLINEMENU));
+		toolBarManager.add(new NewElementAction(VPathway.NEWRECTANGLE));
+		toolBarManager.add(new NewElementAction(VPathway.NEWOVAL));
+		toolBarManager.add(new NewElementAction(VPathway.NEWARC));
+		toolBarManager.add(new NewElementAction(VPathway.NEWBRACE));
+		toolBarManager.add(new NewElementAction(VPathway.NEWTBAR));
+		toolBarManager.add(new NewElementAction(VPathway.NEWLINESHAPEMENU));
+
+		editActionsCI = new ToolBarContributionItem(toolBarManager, "EditModeActions");
+	}
+	
+	/**
+	 * Creates element of the coolbar containing controls related to viewing a pathway
+	 */
+	protected void createViewActionsCI()
+	{
+		final MainWindowBase window = this;
+		ToolBarManager toolBarManager = new ToolBarManager(SWT.FLAT);
+		//Add zoomCombo
+		toolBarManager.add(new ControlContribution("ZoomCombo") {
+			protected Control createControl(Composite parent) {
+				final Combo zoomCombo = new Combo(parent, SWT.DROP_DOWN);
+				zoomCombo.setItems(new String[] { "200%", "100%", "75%", "50%", "Zoom to fit" });
+				zoomCombo.setText("100%");
+				zoomCombo.addSelectionListener(new SelectionAdapter() {
+					public void widgetSelected(SelectionEvent e) {
+						int pctZoom = 100;
+						String zoomText = zoomCombo.getText().replace("%", "");
+						try {
+							pctZoom = Integer.parseInt(zoomText);
+						} catch (Exception ex) { 
+							if(zoomText.equals("Zoom to fit"))
+									{ pctZoom = ZOOM_TO_FIT; } else { return; }
+						}
+						new CommonActions.ZoomAction(window, pctZoom).run();
+					}
+					public void widgetDefaultSelected(SelectionEvent e) { widgetSelected(e); }
+				});
+				return zoomCombo;
+			}
+		});
+		//Add swich to editmode
+		toolBarManager.add(switchEditModeAction);
+		
+		viewActionsCI =  new ToolBarContributionItem(toolBarManager, "SwitchActions");
+	}
+		
+	/**
+	 * Shows or hides the editActionsCI
+	 * @param show	true/false for either show or hide
+	 */
+	public void showEditActionsCI(boolean show)
+	{
+		if(show) {
+			getCoolBarManager().insertAfter(viewActionsCI.getId(), editActionsCI);
+		}
+		else {
+			getCoolBarManager().remove(editActionsCI);
+		}
+//		showVisualizationCI(!show); //Visualizations can show up in edit mode...
+		getCoolBarManager().update(true);
+	}
+
+	/**
+	   Shows or hides the alignActionsCI.
+	   @param show	true/false for either show or hide
+	*/
+	public void showAlignActionsCI(boolean show)
+	{
+		if(show) {
+			getCoolBarManager().insertAfter(editActionsCI.getId(), alignActionsCI);
+		}
+		else {
+			getCoolBarManager().remove(alignActionsCI);
+		}
+//		showVisualizationCI(!show); //Visualizations can show up in edit mode...
+		getCoolBarManager().update(true);
+	}
+	
+	//	KH 20070514 begin
+	/**
+	 * set up the alignActions coolbar
+	 */
+	protected void createAlignActionsCI()
+	{
+		ToolBarManager toolBarManager = new ToolBarManager(SWT.FLAT);
+		toolBarManager.add(alignCenterXAction);
+		toolBarManager.add(alignCenterYAction);
+		toolBarManager.add(alignLeftAction);
+		toolBarManager.add(alignRightAction);
+		toolBarManager.add(alignTopAction);
+		toolBarManager.add(alignBottomAction);
+		toolBarManager.add(setCommonWidthAction);
+		toolBarManager.add(setCommonHeightAction);
+	
+		alignActionsCI = new ToolBarContributionItem(toolBarManager, "AlignActions");
+	}
+	
+//	KH end
+	/**
+	   Invoked when user tries to close window.
+	   We'll ask the user if he wants to save the pathway
+	*/
+	protected boolean canHandleShellCloseEvent()
+	{
+		return SwtEngine.canDiscardPathway();
+	}
+	
+	protected MenuManager menuManager = null;
+	/**
+	 * can be accessed by plugins etc. 
+	 * to add menu items and even complete menus.
+	 * 
+	 * (plugin API)
+	 */
+	public MenuManager getMenuManager()
+	{
+		return menuManager;
+	}
+		
+	public boolean close() {
+		Engine.fireApplicationEvent(
+				new ApplicationEvent(this, ApplicationEvent.APPLICATION_CLOSE));
+		return super.close();
+	}
+	
+	public ScrolledComposite sc;
+	public BackpagePanel bpBrowser; //Browser for showing backpage information
+	public PropertyPanel propertyTable;	//Table showing properties of Graphics objects
+	SashForm sashForm; //SashForm containing the drawing area and sidebar
+	TabbedSidePanel rightPanel; //side panel containing backbage browser and property editor
+	PathwaySearchComposite pwSearchComposite; //Composite that handles pathway searches and displays results
+	LegendPanel legend; //Legend to display colorset information
+	
+	public TabbedSidePanel getSidePanel() { return rightPanel; }
+	
+	public LegendPanel getLegend() { return legend; }
+	
+	public void showLegend(boolean show) {	
+		if(show && Gex.isConnected()) {
+			if(rightPanel.isVisible("Legend")) return; //Legend already visible, only refresh
+			rightPanel.unhideTab("Legend", 0);
+			rightPanel.selectTab("Legend");
+		}
+		
+		else rightPanel.hideTab("Legend");
+	}
+	
+	/**
+	 * Creates a new empty drawing canvas
+	 * @return the empty {@link VPathway}
+	 */
+	public VPathway createNewDrawing()
+	{		
+		return new VPathway(sc, SWT.NO_BACKGROUND);
+	}
+				
+	public void applicationEvent(ApplicationEvent e) {
+		switch(e.type) {
+		case ApplicationEvent.PATHWAY_OPENED:
+			if(Gex.isConnected()) cacheExpressionData();
+			break;
+		}
+		switch(e.type) {
+		case ApplicationEvent.PATHWAY_NEW:
+		case ApplicationEvent.PATHWAY_OPENED:
+			Engine.getActiveVPathway().addVPathwayListener(this);
+		}
+	}
+
+	public void expressionDataEvent(ExpressionDataEvent e) {
+		switch(e.type) {
+		case ExpressionDataEvent.CONNECTION_CLOSED:
+			getShell().getDisplay().syncExec(new Runnable() {
+				public void run() {
+					showLegend(false);
+				}
+			});
+			break;
+		case ExpressionDataEvent.CONNECTION_OPENED:
+			getShell().getDisplay().syncExec(new Runnable() {
+				public void run() {
+					cacheExpressionData();
+					showLegend(true);
+				}
+			});
+			break;
+		}
+	}
+	
+	public void vPathwayEvent(VPathwayEvent e) {
+		switch(e.getType()) {
+		case VPathwayEvent.EDIT_MODE_OFF:
+			showLegend(true);
+			break;
+		case VPathwayEvent.EDIT_MODE_ON:
+			showLegend(false);
+			break;
+		case VPathwayEvent.NEW_ELEMENT_ADDED:
+			deselectNewItemActions();
+			break;
+		}
+	}
+	
+	public MainWindowBase(Shell shell)
+	{
+		super(shell);
+	}
+
+}

Property changes on: trunk/src/core/org/pathvisio/gui/swt/MainWindowBase.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/core/org/pathvisio/gui/swt/CommonActions.java
===================================================================
--- trunk/src/core/org/pathvisio/gui/swt/CommonActions.java	(revision 0)
+++ trunk/src/core/org/pathvisio/gui/swt/CommonActions.java	(revision 958)
@@ -0,0 +1,625 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.dialogs.MessageDialog;
+import org.eclipse.jface.preference.PreferenceDialog;
+import org.eclipse.jface.preference.PreferenceManager;
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.widgets.FileDialog;
+import org.pathvisio.Engine;
+import org.pathvisio.Globals;
+import org.pathvisio.Engine.ApplicationEvent;
+import org.pathvisio.Engine.ApplicationEventListener;
+import org.pathvisio.biopax.gui.BiopaxDialog;
+import org.pathvisio.model.ConverterException;
+import org.pathvisio.model.Pathway;
+import org.pathvisio.model.PathwayExporter;
+import org.pathvisio.preferences.swt.PreferenceDlg;
+import org.pathvisio.preferences.swt.SwtPreferences;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.view.VPathway;
+
+/**
+   This class contains a large number of JFace Actions that are both in V1 and V2.
+*/   
+public class CommonActions
+{
+	static class UndoAction extends Action
+	{
+		MainWindowBase window;
+		public UndoAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Undo@Ctrl+Z");
+			setToolTipText ("Undo last action");
+		}
+		public void run() 
+		{
+			if (Engine.getActivePathway() != null)
+			{
+				Engine.getActivePathway().undo();
+			}
+		}
+	}
+	
+	/**
+	 * {@link Action} to create a new gpml pathway
+	 */
+	static class NewAction extends Action 
+	{
+		MainWindowBase window;
+		public NewAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&New pathway@Ctrl+N");
+			setToolTipText ("Create new pathway");
+			setImageDescriptor(ImageDescriptor.createFromURL(
+					Engine.getResourceURL("icons/new.gif")));
+		}
+		public void run ()
+		{			
+			SwtEngine.newPathway();
+		}	
+	}
+	
+	/**
+	 * {@link Action} to create a new gpml pathway
+	 */
+	static class SvgExportAction extends Action 
+	{
+		MainWindowBase window;
+		public SvgExportAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("Export to SVG");
+			setToolTipText ("Export to Scalable Vector Graphics (SVG) " +
+					"for publication-quality images");
+		}
+		public void run () 
+		{
+			//TODO: move to engine, merge with "save"
+			VPathway drawing = Engine.getActiveVPathway();
+			Pathway gmmlData = Engine.getActivePathway();
+			// Check if a gpml pathway is loaded
+			if (drawing != null)
+			{
+				FileDialog fd = new FileDialog(window.getShell(), SWT.SAVE);
+				fd.setText("Save");
+				fd.setFilterExtensions(new String[] {"*." + Engine.SVG_FILE_EXTENSION, "*.*"});
+				fd.setFilterNames(new String[] {Engine.SVG_FILTER_NAME, "All files (*.*)"});
+				
+				File xmlFile = gmmlData.getSourceFile();
+				if(xmlFile != null) {
+					String name = xmlFile.getName();
+					if (name.endsWith("." + Engine.PATHWAY_FILE_EXTENSION))
+					{
+						name = name.substring(0, name.length() - 
+							Engine.PATHWAY_FILE_EXTENSION.length()) +
+							Engine.SVG_FILE_EXTENSION;
+					}
+					fd.setFileName(name);
+					fd.setFilterPath(xmlFile.getPath());
+				} else {
+					fd.setFileName(SwtPreference.SWT_DIR_PWFILES.getValue());
+				}
+				String fileName = fd.open();
+				// Only proceed if user selected a file
+				
+				if(fileName == null) return;
+				
+				// Append .svg extension if not already present
+				if(!fileName.endsWith("." + Engine.SVG_FILE_EXTENSION)) 
+					fileName += "." + Engine.SVG_FILE_EXTENSION;
+				
+				File checkFile = new File(fileName);
+				boolean confirmed = true;
+				// If file exists, ask overwrite permission
+				if(checkFile.exists())
+				{
+					confirmed = MessageDialog.openQuestion(window.getShell(),"",
+					"File already exists, overwrite?");
+				}
+				if(confirmed)
+				{
+					try
+					{
+						gmmlData.writeToSvg(checkFile);
+					}
+					catch (ConverterException e)
+					{
+						String msg = "While writing svg to " 
+							+ checkFile.getAbsolutePath();					
+						MessageDialog.openError (window.getShell(), "Error", 
+								"Error: " + msg + "\n\n" + 
+								"See the error log for details.");
+						Engine.log.error(msg, e);
+					}
+				}
+			}
+			else
+			{
+				MessageDialog.openError (window.getShell(), "Error", 
+					"No pathway to save! Open or create a new pathway first");
+			}			
+		}
+	}
+
+	/**
+	 * {@link Action} to open an gpml pathway
+	 */
+	static class OpenAction extends Action 
+	{
+		MainWindowBase window;
+		public OpenAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Open pathway@Ctrl+O");
+			setToolTipText ("Open pathway");
+			setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/open.gif")));
+		}
+		public void run () 
+		{
+			FileDialog fd = new FileDialog(window.getShell(), SWT.OPEN);
+			fd.setText("Open");
+			String pwpath = SwtPreference.SWT_DIR_PWFILES.getValue();
+			fd.setFilterPath(pwpath);
+			fd.setFilterExtensions(new String[] {"*." + Engine.PATHWAY_FILE_EXTENSION, "*.*"});
+			fd.setFilterNames(new String[] {Engine.PATHWAY_FILTER_NAME, "All files (*.*)"});
+	        String fnMapp = fd.open();
+	        // Only open pathway if user selected a file
+	        
+	        if(fnMapp != null) { 
+	        	SwtEngine.openPathway(fnMapp); 
+	        }
+		}
+	}
+
+	/**
+	 * {@link Action} to open an gpml pathway
+	 */
+	static class ImportAction extends Action 
+	{
+		MainWindowBase window;
+		public ImportAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Import");
+			setToolTipText ("Import Pathway in GenMAPP format");
+		}
+		public void run () 
+		{
+			if(SwtEngine.canDiscardPathway())
+			{
+				FileDialog fd = new FileDialog(window.getShell(), SWT.OPEN);
+				fd.setText("Open");
+				fd.setFilterPath(SwtPreference.SWT_DIR_PWFILES.getValue());
+				fd.setFilterExtensions(new String[] {"*." + Engine.GENMAPP_FILE_EXTENSION, "*.*"});
+				fd.setFilterNames(new String[] {Engine.GENMAPP_FILTER_NAME, "All files (*.*)"});
+	        	String fnMapp = fd.open();
+	        	// Only open pathway if user selected a file
+	        	
+	        	if(fnMapp != null) { 
+	        		SwtEngine.openPathway(fnMapp); 
+	        	}
+	        }
+		}
+	}
+
+	/**
+	 * {@link Action} to save a gpml pathway to a file specified by the user
+	 */
+	static class SaveAsAction extends Action 
+	{
+		MainWindowBase window;
+		public SaveAsAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("Save pathway &As");
+			setToolTipText ("Save pathway with new file name");
+		}
+		
+		public void run () 
+		{
+			SwtEngine.savePathwayAs();
+		}
+	}
+
+	
+	/**
+	 * {@link Action} to save a gpml pathway to a file specified by the user
+	 */
+	static class ExportAction extends Action 
+	{
+		MainWindowBase window;
+		public ExportAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Export");
+			setToolTipText ("Export Pathway to GenMAPP format");
+		}
+		public void run () {
+			//TODO: move to engine, merge with "save" or "saveAs"
+			VPathway drawing = Engine.getActiveVPathway();
+			Pathway gmmlData = Engine.getActivePathway();
+			// Check if a gpml pathway is loaded
+			if (drawing != null)
+			{
+				FileDialog fd = new FileDialog(window.getShell(), SWT.SAVE);
+				fd.setText("Export");
+				
+				class FileType implements Comparable<FileType> {
+					final String name;
+					final String ext;
+					public FileType(String n, String e) { name = n; ext = e; }
+					public int compareTo(FileType o) {
+						return name.compareTo(o.name);
+					}
+				}
+				
+				ArrayList<FileType> fts = new ArrayList<FileType>();
+				HashMap<String, PathwayExporter> exporters = Engine.getPathwayExporters();
+								
+				for(String ext : exporters.keySet()) {
+					fts.add(new FileType(
+								exporters.get(ext).getName() + " (*." + ext + ")",
+								"*." + ext));
+				}
+				Collections.sort(fts);
+				String[] exts = new String[fts.size()];
+				String[] nms = new String[fts.size()];
+				for(int i = 0; i < fts.size(); i++) {
+					FileType ft = fts.get(i);
+					exts[i] = ft.ext;
+					nms[i] = ft.name;
+				}
+				fd.setFilterExtensions(exts);
+				fd.setFilterNames(nms);
+								
+				File xmlFile = gmmlData.getSourceFile();
+				if(xmlFile != null) {
+					String name = xmlFile.getName();
+					if (name.endsWith("." + Engine.PATHWAY_FILE_EXTENSION))
+					{
+						name = name.substring(0, name.length() - 
+							Engine.PATHWAY_FILE_EXTENSION.length() - 1);
+					}
+					fd.setFileName(name);
+					fd.setFilterPath(xmlFile.getPath());
+				} else {
+					fd.setFileName(SwtPreference.SWT_DIR_PWFILES.getValue());
+				}
+				String fileName = fd.open();
+				// Only proceed if user selected a file
+				if(fileName == null) return;
+				
+				int dot = fileName.lastIndexOf('.');
+				String ext = Engine.GENMAPP_FILE_EXTENSION;
+				if(dot >= 0) {
+					ext = fileName.substring(dot + 1, fileName.length());
+				}
+				PathwayExporter exporter = Engine.getPathwayExporter(ext);
+				
+				if(exporter == null) 
+					MessageDialog.openError (window.getShell(), "Error", 
+					"No exporter for '" + ext +  "' files");
+								
+				File checkFile = new File(fileName);
+				boolean confirmed = true;
+				// If file exists, ask overwrite permission
+				if(checkFile.exists())
+				{
+					confirmed = MessageDialog.openQuestion(window.getShell(),"",
+					"File already exists, overwrite?");
+				}
+				if(confirmed)
+				{
+					try
+					{
+						//gmmlData.writeToMapp(checkFile);
+						exporter.doExport(checkFile, gmmlData);
+					}
+					catch (ConverterException e)
+					{
+						String msg = "While exporting to " 
+							+ checkFile.getAbsolutePath();					
+						MessageDialog.openError (window.getShell(), "Error", 
+								"Error: " + msg + "\n\n" + 
+								"See the error log for details.");
+						Engine.log.error(msg, e);
+					}
+				}
+			}
+			else
+			{
+				MessageDialog.openError (window.getShell(), "Error", 
+					"No pathway to save! Open or create a new pathway first");
+			}			
+		}
+	}
+
+	/**
+	 * {@link Action} to exit the application
+	 */
+	static class ExitAction extends Action 
+	{
+		MainWindowBase window;
+		public ExitAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("E&xit@Ctrl+X");
+			setToolTipText ("Exit Application");
+		}
+		public void run () 
+		{
+			if (SwtEngine.canDiscardPathway())
+			{
+				window.close();
+			}
+		}
+	}
+	
+	static class PreferencesAction extends Action
+	{
+		MainWindowBase window;
+		public PreferencesAction (MainWindowBase w)
+		{
+			window = w;
+			setText("&Preferences");
+			setToolTipText("Edit preferences");
+		}
+		public void run () {
+			PreferenceManager pg = new PreferenceDlg();
+			PreferenceDialog pd = new PreferenceDialog(window.getShell(), pg);
+			pd.setPreferenceStore((SwtPreferences)SwtEngine.getPreferences());
+			pd.open();
+		}
+	}
+
+	/**
+	 * {@link Action} that zooms a mapp to the specified zoomfactor
+	 */
+	static class ZoomAction extends Action 
+	{
+		MainWindowBase window;
+		int pctZoomFactor;
+		
+		/**
+		 * Constructor for this class
+		 * @param w {@link MainWindow} window this action belongs to
+		 * @param newPctZoomFactor the zoom factor as percentage of original
+		 */
+		public ZoomAction (MainWindowBase w, int newPctZoomFactor)
+		{
+			window = w;
+			pctZoomFactor = newPctZoomFactor;
+			if(pctZoomFactor == MainWindowBase.ZOOM_TO_FIT) 
+			{
+				setText ("Zoom to fit");
+				setToolTipText("Zoom mapp to fit window");
+			}
+			else
+			{
+				setText (pctZoomFactor + " %");
+				setToolTipText ("Zoom mapp to " + pctZoomFactor + " %");
+			}
+		}
+		public void run () {
+			VPathway drawing = Engine.getActiveVPathway();
+			if (drawing != null)
+			{
+				drawing.setPctZoom(pctZoomFactor);
+			}
+			else
+			{
+				MessageDialog.openError (window.getShell(), "Error", 
+					"No gpml file loaded! Open or create a new gpml file first");
+			}
+		}
+	}
+
+	/**
+	 * {@link Action} to open a {@link AboutDlg} window
+	 */
+	static class AboutAction extends Action 
+	{
+		MainWindowBase window;
+		public AboutAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&About");
+			setToolTipText ("About " + Globals.APPLICATION_VERSION_NAME);
+		}
+		public void run () {
+			AboutDlg gmmlAboutBox = new AboutDlg(window.getShell(), SWT.NONE);
+			gmmlAboutBox.open();
+		}
+	}
+	
+	/**
+	 * {@link Action} to open a Help window
+	 */
+	static class HelpAction extends Action 
+	{
+		MainWindowBase window;
+		public HelpAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Help@F1");
+			setToolTipText ("Opens " + Globals.APPLICATION_VERSION_NAME + " help in your web browser");
+		}
+		public void run ()
+		{
+			SwtEngine.openWebPage(Globals.HELP_URL, "Opening help page in broswer",
+						"Unable to open web browser" +
+						"\nYou can open the help page manually:\n" +
+						Globals.HELP_URL);
+		}
+	}
+
+	static class CopyAction extends Action
+	{
+		MainWindowBase window;
+		public CopyAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("Copy@Ctrl+C");
+			setToolTipText ("Copy selected objects to clipboard");
+		}
+		public void run()
+		{
+			Engine.getActiveVPathway().copyToClipboard();
+		}
+	}
+
+	static class PasteAction extends Action
+	{
+		MainWindowBase window;
+		public PasteAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("Paste@Ctrl+V");
+			setToolTipText ("Paste contents of clipboard");
+		}
+		public void run()
+		{
+			Engine.getActiveVPathway().pasteFromClipboad();
+		}
+	}
+	
+	/**
+	 * {@link Action} to save a gpml pathway
+	 */
+	static class SaveAction extends Action 
+	{
+		MainWindowBase window;
+		public SaveAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("&Save pathway@Ctrl+S");
+			setToolTipText ("Save pathway");
+			setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/save.gif")));
+		}
+		
+		public void run ()
+		{
+			SwtEngine.savePathway();
+		}
+	}
+	
+	static class BiopaxAction extends Action 
+	{
+		MainWindowBase window;
+		public BiopaxAction (MainWindowBase w)
+		{
+			window = w;
+			setText ("Edit &BioPAX code");
+			setToolTipText ("Edit BioPAX code");
+		}
+		
+		public void run () {
+			BiopaxDialog d = new BiopaxDialog(window.getShell());
+			d.setPathway(Engine.getActivePathway());
+			d.open();
+		}
+	}
+	
+	/**
+	 * {@link Action} to switch between edit and view mode
+	 */
+	static class SwitchEditModeAction extends Action implements ApplicationEventListener
+	{
+		final String ttChecked = "Exit edit mode";
+		final String ttUnChecked = "Switch to edit mode to edit the pathway content";
+		MainWindowBase window;
+		public SwitchEditModeAction (MainWindowBase w)
+		{
+			super("&Edit mode", IAction.AS_CHECK_BOX);
+			setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/edit.gif")));
+			setToolTipText(ttUnChecked);
+			window = w;
+			
+			Engine.addApplicationEventListener(this);
+		}
+
+		public void run ()
+		{
+			if(Engine.isDrawingOpen())
+			{
+				VPathway drawing = Engine.getActiveVPathway();
+				Pathway pathway = Engine.getActivePathway();
+				if(isChecked())
+				{
+					// give a warning that this can't be edited.
+					if (pathway.getSourceFile() != null && !pathway.getSourceFile().canWrite())
+					{
+						MessageDialog.openWarning(
+								window.getShell(), "Read-only Warning",
+								"You're trying to edit a Read-only file.\n" +
+						"When you want to save your changes, you have to save to a different file.");
+					}
+					//Switch to edit mode: show edit toolbar, show property table in sidebar
+					drawing.setEditMode(true);
+					window.showEditActionsCI(true);
+					window.showAlignActionsCI(true);
+					window.rightPanel.getTabFolder().setSelection(1);
+				}
+				else
+				{
+					//Switch to view mode: hide edit toolbar, show backpage browser in sidebar
+					drawing.setEditMode(false);
+					window.showEditActionsCI(false);
+					window.showAlignActionsCI(false);
+					window.rightPanel.getTabFolder().setSelection(0);
+				}
+			}
+			else //No gpml pathway loaded, deselect action and do nothing
+			{
+				setChecked(false);
+			}
+			window.getCoolBarManager().update(true);
+		}
+		
+		public void setChecked(boolean check) {
+			super.setChecked(check);
+			setToolTipText(check ? ttChecked : ttUnChecked);
+		}
+
+		public void switchEditMode(boolean edit) {
+			setChecked(edit);
+			run();
+
+		}
+
+		public void applicationEvent(ApplicationEvent e) {
+			if(e.type == ApplicationEvent.PATHWAY_OPENED) {
+				Engine.getActiveVPathway().setEditMode(isChecked());
+			}
+			else if(e.type == ApplicationEvent.PATHWAY_NEW) {
+				switchEditMode(true);
+			}
+		}
+	}
+}

Property changes on: trunk/src/core/org/pathvisio/gui/swt/CommonActions.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/core/org/pathvisio/gui/swt/GuiMain.java
===================================================================
--- trunk/src/core/org/pathvisio/gui/swt/GuiMain.java	(revision 0)
+++ trunk/src/core/org/pathvisio/gui/swt/GuiMain.java	(revision 958)
@@ -0,0 +1,206 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.io.File;
+import java.io.PrintStream;
+
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.eclipse.jface.resource.ImageRegistry;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.graphics.ImageData;
+import org.eclipse.swt.widgets.Display;
+import org.pathvisio.Engine;
+import org.pathvisio.data.Gdb;
+import org.pathvisio.data.Gex;
+import org.pathvisio.model.ImageExporter;
+import org.pathvisio.model.MappFormat;
+import org.pathvisio.model.Pathway;
+import org.pathvisio.model.SvgFormat;
+import org.pathvisio.preferences.GlobalPreference;
+import org.pathvisio.preferences.Preference;
+import org.pathvisio.preferences.swt.SwtPreferences.SwtPreference;
+import org.pathvisio.util.SwtUtils;
+import org.pathvisio.visualization.VisualizationManager;
+import org.pathvisio.visualization.plugins.PluginManager;
+
+/**
+ * This class contains the main method and is responsible for initiating 
+ * the application by setting up the user interface and creating all necessary objects
+ */
+public class GuiMain {
+	
+	/**
+	 * Main method which will be carried out when running the program
+	 */
+	public static void main(String[] args)
+	{
+		boolean debugHandles = false;
+		for(String a : args) {
+			if(		a.equalsIgnoreCase("--MonitorHandles") ||
+					a.equalsIgnoreCase("-mh")) {
+				debugHandles = true;
+			}
+			else if(a.equalsIgnoreCase("--UseR") ||
+					a.equalsIgnoreCase("-ur")) {
+				SwtEngine.USE_R = true;
+			}
+		}
+		
+		//Setup the application window
+		MainWindow window = null;
+		if(debugHandles)	window = SwtEngine.getSleakWindow();
+		else				window = SwtEngine.getWindow();
+		
+		initiate();
+		
+		window.setBlockOnOpen(true);
+		window.open();
+		
+		//Perform exit operations
+		//TODO: implement PropertyChangeListener and fire exit property when closing
+		// make classes themself responsible for closing when exit property is changed
+		Gex.close();
+		Gdb.close();
+		//Close log stream
+		Engine.log.getStream().close();
+		
+		Display.getCurrent().dispose();
+	}
+	
+	/**
+	 * Initiates some objects used by the program
+	 */
+	public static void initiate() {
+		//initiate logger
+		try { 
+			GlobalPreference.FILE_LOG.setDefault(new File(SwtEngine.getApplicationDir(), ".PathVisioLog").toString());
+			Engine.log.setStream(new PrintStream(GlobalPreference.FILE_LOG.getValue())); 
+		} catch(Exception e) {}
+		Engine.log.setLogLevel(true, true, true, true, true, true);//Modify this to adjust log level
+		Pathway.setLogger(Engine.log);
+		
+		//load the preferences
+		loadPreferences();
+		
+		//initiate Gene database (to load previously used gdb)
+		Gdb.init();
+		
+		//load visualizations and plugins
+		loadVisualizations();
+		
+		//create data directories if they don't exist yet
+		createDataDirectories();
+		
+		//register listeners for static classes
+		registerListeners();
+				
+		registerExporters();
+		
+		//NOTE: ImageRegistry will be initiated in "createContents" of MainWindow,
+		//since the window has to be opened first (need an active Display)
+	}
+	
+	/**
+	 * Creates data directories stored in preferences (if not exist)
+	 */
+	static void createDataDirectories() {
+		Preference[] dirPrefs = new Preference[] {
+				SwtPreference.SWT_DIR_EXPR,
+				SwtPreference.SWT_DIR_GDB,
+				SwtPreference.SWT_DIR_PWFILES,
+				SwtPreference.SWT_DIR_RDATA,
+		};
+		for(Preference p : dirPrefs) {
+			File dir = new File(p.getValue());
+			if(!dir.exists()) dir.mkdir();
+		}
+	}
+	
+			
+	static void registerListeners() {
+		VisualizationManager vmgr = new VisualizationManager();
+		Gex gex = new Gex();
+		
+		Engine.addApplicationEventListener(vmgr);
+		Engine.addApplicationEventListener(gex);
+	}
+	
+	static void registerExporters() {
+		Engine.addPathwayExporter(new MappFormat());
+		Engine.addPathwayExporter(new SvgFormat());
+		Engine.addPathwayExporter(new ImageExporter(ImageExporter.TYPE_PNG));
+		Engine.addPathwayExporter(new ImageExporter(ImageExporter.TYPE_TIFF));
+		Engine.addPathwayExporter(new ImageExporter(ImageExporter.TYPE_PDF));
+	}
+	
+	static void loadVisualizations() {
+		//load visualization plugins
+		try {
+			PluginManager.loadPlugins();
+		} catch (Throwable e) {
+			Engine.log.error("When loading visualization plugins", e);
+		}
+		
+		VisualizationManager.loadGeneric();
+	}
+	
+	static void loadPreferences() {
+		SwtEngine.getPreferences();
+	}
+	
+	/**
+	 * Loads images used throughout the applications into an {@link ImageRegistry}
+	 */
+	static void loadImages(Display display)
+	{
+		ClassLoader cl = GuiMain.class.getClassLoader();
+	
+		ImageRegistry imageRegistry = new ImageRegistry(display);
+		
+		// Labels for color by expressiondata (mRNA and Protein)
+		ImageData img = new ImageData(cl.getResourceAsStream("images/mRNA.bmp"));
+		img.transparentPixel = img.palette.getPixel(SwtUtils.color2rgb(Engine.TRANSPARENT_COLOR));
+		imageRegistry.put("data.mRNA",
+				new Image(display, img));
+		img = new ImageData(cl.getResourceAsStream("images/protein.bmp"));
+		img.transparentPixel = img.palette.getPixel(SwtUtils.color2rgb(Engine.TRANSPARENT_COLOR));
+		imageRegistry.put("data.protein",
+				new Image(display, img));
+		imageRegistry.put("sidepanel.minimize",
+				ImageDescriptor.createFromURL(cl.getResource("icons/minimize.gif")));
+		imageRegistry.put("sidepanel.hide",
+				ImageDescriptor.createFromURL(cl.getResource("icons/close.gif")));
+		imageRegistry.put("shell.icon", 
+				ImageDescriptor.createFromURL(cl.getResource("images/bigcateye.gif")));
+		imageRegistry.put("about.logo",
+				ImageDescriptor.createFromURL(cl.getResource("images/logo.jpg")));
+						imageRegistry.put("checkbox.unchecked",
+				ImageDescriptor.createFromURL(cl.getResource("icons/unchecked.gif")));
+		imageRegistry.put("checkbox.unavailable",
+				ImageDescriptor.createFromURL(cl.getResource("icons/unchecked_unavailable.gif")));
+		imageRegistry.put("checkbox.checked",
+				ImageDescriptor.createFromURL(cl.getResource("icons/checked.gif")));
+		imageRegistry.put("tree.collapsed",
+				ImageDescriptor.createFromURL(cl.getResource("icons/tree_collapsed.gif")));
+		imageRegistry.put("tree.expanded",
+				ImageDescriptor.createFromURL(cl.getResource("icons/tree_expanded.gif")));
+		SwtEngine.setImageRegistry(imageRegistry);
+	}
+	
+}
+

Property changes on: trunk/src/core/org/pathvisio/gui/swt/GuiMain.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/core/org/pathvisio/gui/swt/AlignActions.java
===================================================================
--- trunk/src/core/org/pathvisio/gui/swt/AlignActions.java	(revision 0)
+++ trunk/src/core/org/pathvisio/gui/swt/AlignActions.java	(revision 958)
@@ -0,0 +1,177 @@
+//	 PathVisio,
+//	 a tool for data visualization and analysis using Biological Pathways
+//	 Copyright 2006-2007 BiGCaT Bioinformatics
+	//
+//	 Licensed under the Apache License, Version 2.0 (the "License"); 
+//	 you may not use this file except in compliance with the License. 
+//	 You may obtain a copy of the License at 
+//	 
+//	 http://www.apache.org/licenses/LICENSE-2.0 
+//	  
+//	 Unless required by applicable law or agreed to in writing, software 
+//	 distributed under the License is distributed on an "AS IS" BASIS, 
+//	 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+//	 See the License for the specific language governing permissions and 
+//	 limitations under the License.
+	//
+
+package org.pathvisio.gui.swt;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.pathvisio.Engine;
+public class AlignActions {
+
+		
+	public static final char CENTERX = 'x';
+	public static final char CENTERY = 'y';
+	public static final char LEFT = 'l';
+	public static final char RIGHT = 'r';
+	public static final char TOP = 't';
+	public static final char BOTTOM = 'b';
+	public static final char WIDTH = 'w';
+	public static final char HEIGHT = 'h';
+	
+	
+		static class AlignCenterXAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignCenterXAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align horizontal centers");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/aligncenterx.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(CENTERX);
+				
+			}
+		}
+		
+		static class AlignCenterYAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignCenterYAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align vertical centers");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/aligncentery.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(CENTERY);
+				
+			}
+		}
+		static class AlignLeftAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignLeftAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align left edges");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/alignleft.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(LEFT);
+				
+			}
+		}
+		static class AlignRightAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignRightAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align right edges");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/alignright.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(RIGHT);
+				
+			}
+		}
+		static class AlignTopAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignTopAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align top edges");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/aligntop.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(TOP);
+				
+			}
+		}
+		static class AlignBottomAction extends Action 
+		{
+			MainWindowBase window;
+			public AlignBottomAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Align bottom edges");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/alignbottom.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().alignSelected(BOTTOM);
+				
+			}
+		}
+		static class SetCommonHeightAction extends Action 
+		{
+			MainWindowBase window;
+			public SetCommonHeightAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Set common height");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/sizeheight.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().scaleSelected(HEIGHT);
+				
+			}
+		}
+		static class SetCommonWidthAction extends Action 
+		{
+			MainWindowBase window;
+			public SetCommonWidthAction (MainWindowBase w)
+			{
+				window = w;
+				setToolTipText ("Set common width");
+				setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL("icons/sizewidth.gif")));
+				
+			}
+			public void run () 
+			{
+				
+				Engine.getActiveVPathway().scaleSelected(WIDTH);
+				
+			}
+		}
+
+
+	}
+
+
Index: trunk/src/core/org/pathvisio/gui/swt/BackpagePanel.java
===================================================================
--- trunk/src/core/org/pathvisio/gui/swt/BackpagePanel.java	(revision 0)
+++ trunk/src/core/org/pathvisio/gui/swt/BackpagePanel.java	(revision 958)
@@ -0,0 +1,296 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio.gui.swt;
+
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.util.List;
+
+import org.eclipse.swt.browser.Browser;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.pathvisio.Engine;
+import org.pathvisio.data.DataSources;
+import org.pathvisio.data.Gdb;
+import org.pathvisio.data.Gex;
+import org.pathvisio.data.Gdb.IdCodePair;
+import org.pathvisio.util.Utils;
+import org.pathvisio.view.GeneProduct;
+import org.pathvisio.view.SelectionBox;
+import org.pathvisio.view.VPathwayElement;
+import org.pathvisio.view.SelectionBox.SelectionEvent;
+import org.pathvisio.view.SelectionBox.SelectionListener;
+
+/**
+ * Backpage browser - side panel that shows the backpage information when a GeneProduct is double-clicked
+ */
+public class BackpagePanel extends Composite implements SelectionListener {
+	/**
+	 * Directory containing HTML files needed to display the backpage information
+	 */
+	final static String BPDIR = "backpage";
+	/**
+	 * Header file, containing style information
+	 */
+	final static String HEADERFILE = "header.html";
+	
+	/**
+	 * Header for the gene information in HTML format
+	 */
+	final static String bpHeader = "<H1>Gene information</H1><P>";
+	/**
+	 * Header for the expression information in HTML format
+	 */
+	final static String gexHeader = "<H1>Expression data</H1><P>";
+	
+	private String bpText;
+	private String gexText;
+	private String header;
+	
+	private Browser bpBrowser;
+	
+	private GeneProduct geneProduct;
+	
+	/**
+	 * Constructor for this class
+	 * @param parent	Parent {@link Composite} for the Browser widget
+	 * @param style		Style for the Browser widget
+	 */
+	public BackpagePanel(Composite parent, int style) {
+		super(parent, style);
+		
+		initializeHeader(); //Load the header including style information
+		setLayout(new FillLayout());
+		bpBrowser = new Browser(this, style); //Set the Browser widget
+		setGeneText(null);
+		setGexText(null);
+		
+		SelectionBox.addListener(this);
+	}
+	
+	public void setGeneProduct(final GeneProduct gp) 
+	{ 
+		if(geneProduct == gp) return;
+		
+		Thread fetchThread = new Thread() {
+			public void run() {
+				geneProduct = gp;
+				if(gp == null) {
+					setGeneText(null);
+					setGexText(null);
+					return;
+				}
+				// Get the backpage text
+				String geneHeader = geneProduct.getGmmlData().getBackpageHead();
+				if (geneHeader == null) geneHeader = "";
+				String geneId = geneProduct.getGmmlData().getGeneID();
+				String systemCode = geneProduct.getGmmlData().getSystemCode();
+				String bpText = geneHeader.equals("") ? geneHeader : "<H2>" + geneHeader + "</H2><P>";
+				String bpInfo = Gdb.getBpInfo(geneId, systemCode);
+				bpText += bpInfo == null ? "<I>No gene information found</I>" : bpInfo;
+				String crossRefText = getCrossRefText(geneId, systemCode);
+				String gexText = Gex.getDataString(new IdCodePair(geneId, systemCode));
+				if (bpText != null) 	setGeneText(bpText);
+				if (gexText != null)	setGexText(gexText + crossRefText);
+				else 					setGexText("<I>No expression data found</I>");
+			}
+		};
+		
+		//Run in seperate thread so that this method can return
+		fetchThread.start();
+	}
+		
+	public String getCrossRefText(String id, String code) {
+		List<IdCodePair> crfs = Gdb.getCrossRefs(id, code);
+		if(crfs.size() == 0) return "";
+		StringBuilder crt = new StringBuilder("<H1>Cross references</H1><P>");
+		for(IdCodePair cr : crfs) {
+			String idtxt = cr.getId();
+			String url = getCrossRefLink(cr);
+			if(url != null) {
+				int os = Utils.getOS();
+				if(os == Utils.OS_WINDOWS) {
+					//In windows: open in new browser window
+					idtxt = "<a href='" + url + "' target='_blank'>" + idtxt + "</a>";
+				} else {
+					//This doesn't work under ubuntu, so no new windoe there
+					idtxt = "<a href='" + url + "'>" + idtxt + "</a>";
+				}
+				
+			}
+			String dbName = DataSources.sysCode2Name.get(cr.getCode());
+			crt.append( idtxt + ", " + (dbName != null ? dbName : cr.getCode()) + "<br>");
+		}
+		return crt.toString();
+	}
+	
+	String getCrossRefLink(IdCodePair idc) {
+		String c = idc.getCode();
+		String id = idc.getId();
+		if(c.equalsIgnoreCase("En"))
+			return "http://www.ensembl.org/Homo_sapiens/searchview?species=all&idx=Gene&q=" + id;
+		if(c.equalsIgnoreCase("P"))
+			return "http://www.expasy.org/uniprot/" + id;
+		if(c.equalsIgnoreCase("Q")) {
+			String pre = "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?";
+			if(id.startsWith("NM")) {
+				return pre + "db=Nucleotide&cmd=Search&term=" + id;
+			} else {
+				return pre + "db=Protein&cmd=search&term=" + id;
+			}
+		}
+		if(c.equalsIgnoreCase("T"))
+			return "http://godatabase.org/cgi-bin/go.cgi?view=details&search_constraint=terms&depth=0&query=" + id;
+		if(c.equalsIgnoreCase("I"))
+			return "http://www.ebi.ac.uk/interpro/IEntry?ac=" + id;
+		if(c.equalsIgnoreCase("Pd"))
+			return "http://bip.weizmann.ac.il/oca-bin/ocashort?id=" + id;
+		if(c.equalsIgnoreCase("X"))
+			return "http://www.ensembl.org/Homo_sapiens/featureview?type=OligoProbe;id=" + id;
+		if(c.equalsIgnoreCase("Em"))
+			return "http://www.ebi.ac.uk/cgi-bin/emblfetch?style=html&id=" + id;
+		if(c.equalsIgnoreCase("L"))
+			return "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=gene&cmd=Retrieve&dopt=full_report&list_uids=" + id;
+		if(c.equalsIgnoreCase("H"))
+			return "http://www.gene.ucl.ac.uk/cgi-bin/nomenclature/get_data.pl?hgnc_id=" + id;
+		if(c.equalsIgnoreCase("I"))
+			return "http://www.ebi.ac.uk/interpro/IEntry?ac=" + id;
+		if(c.equalsIgnoreCase("M"))
+			return "http://www.informatics.jax.org/searches/accession_report.cgi?id=" + id;
+		if(c.equalsIgnoreCase("Om"))
+			return "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=OMIM&cmd=Search&doptcmdl=Detailed&term=?" + id;
+		if(c.equalsIgnoreCase("Pf"))
+			return "http://www.sanger.ac.uk//cgi-bin/Pfam/getacc?" + id;
+		if(c.equalsIgnoreCase("R"))
+			return "http://rgd.mcw.edu/generalSearch/RgdSearch.jsp?quickSearch=1&searchKeyword=" + id;
+		if(c.equalsIgnoreCase("D"))
+			return "http://db.yeastgenome.org/cgi-bin/locus.pl?locus=" + id;
+		if(c.equalsIgnoreCase("S"))
+			return "http://www.expasy.org/uniprot/" + id;
+		if(c.equalsIgnoreCase("U")) {
+			String [] org_nr = id.split("\\.");
+			if(org_nr.length == 2) {
+				return "http://www.ncbi.nlm.nih.gov/UniGene/clust.cgi?ORG=" + 
+				org_nr[0] + "&CID=" + org_nr[1];
+			}
+			else {
+				return null;
+			}
+		}
+		if (c.equalsIgnoreCase("Nw"))
+		{
+			return "http://nugowiki.org/index.php/" + id;
+		}
+		if (c.equalsIgnoreCase("Ca"))
+		{
+			return "http://chem.sis.nlm.nih.gov/chemidplus/direct.jsp?regno=" + id;
+		}
+		if (c.equalsIgnoreCase("Cp"))
+		{
+			return "http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi?cid=" + id;
+		}
+		if (c.equalsIgnoreCase("Ce"))
+		{
+			return "http://www.ebi.ac.uk/chebi/searchId=CHEBI:" + id;
+		}
+		if (c.equalsIgnoreCase("Ch"))
+		{
+			return "http://www.hmdb.ca/scripts/show_card.cgi?METABOCARD=" + id + ".txt";
+		}
+		if (c.equalsIgnoreCase("Ck"))
+		{
+			return "http://www.genome.jp/dbget-bin/www_bget?cpd:" + id;
+		}
+		return null;
+	}
+	
+	/**
+	 * Sets the text for the Gene information part of the browser. Will be prepended by a paragraph
+	 * header as defined in bpHeader
+	 * @param bpText	Text to display in HTML format
+	 */
+	public void setGeneText(String bpText) {
+		if(bpText == null) { //In case no information has to be displayed
+			this.bpText = bpHeader + "<I>No gene selected</I>";
+		} else {
+			this.bpText = bpHeader + bpText;
+		}
+		refresh();
+	}
+	
+	/**
+	 * Sets the text for the expression part of the browser. Will be prepended by a paragraph
+	 * header as defined in gexHeader
+	 * @param gexText	Text to display in HTML format
+	 */
+	public void setGexText(String gexText) {
+		if(gexText != null) { //In case no information has to be displayed
+			this.gexText = gexHeader + gexText;
+		} else {
+			this.gexText = "";
+		}
+		refresh();
+	}
+	
+	/**
+	 * Refreshes the text displayed in the browser
+	 */
+	public void refresh() {
+		getDisplay().asyncExec(new Runnable() {
+			public void run() {
+				bpBrowser.setText(header + bpText + gexText);	
+			}
+		});
+	}
+	
+	/**
+	 * Reads the header of the HTML content displayed in the browser. This header is displayed in the
+	 * file specified in the {@link HEADERFILE} field
+	 */
+	private void initializeHeader() {
+		try {
+			BufferedReader input = new BufferedReader(new InputStreamReader(
+						Engine.getResourceURL(BPDIR + "/" + HEADERFILE).openStream()));
+			String line;
+			header = "";
+			while((line = input.readLine()) != null) {
+				header += line.trim();
+			}
+		} catch (Exception e) {
+			Engine.log.error("Unable to read header file for backpage browser: " + e.getMessage(), e);
+		}
+	}
+
+	public void drawingEvent(SelectionEvent e) {
+		switch(e.type) {
+		case SelectionEvent.OBJECT_ADDED:
+			//Just take the first GeneProduct in the selection
+			for(VPathwayElement o : e.selection) {
+				if(o instanceof GeneProduct) {
+					if(geneProduct != o) setGeneProduct((GeneProduct)o);
+					break; //Selects the first, TODO: use setGmmlDataObjects
+				}
+			}
+			break;
+		case SelectionEvent.OBJECT_REMOVED:
+			if(e.selection.size() != 0) break;
+		case SelectionEvent.SELECTION_CLEARED:
+			setGeneProduct(null);
+			break;
+		}
+	}
+}

Property changes on: trunk/src/core/org/pathvisio/gui/swt/BackpagePanel.java
___________________________________________________________________
Name: svn:eol-style
   + native

