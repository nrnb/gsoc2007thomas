Index: trunk/wikipathways/wpi/batchDownload.php
===================================================================
--- trunk/wikipathways/wpi/batchDownload.php	(revision 0)
+++ trunk/wikipathways/wpi/batchDownload.php	(revision 1110)
@@ -0,0 +1,136 @@
+<?php
+require_once('includes/zip.lib.php');
+require_once('wpi.php');
+
+//As mediawiki extension
+$wgExtensionFunctions[] = "wfBatchDownload";
+
+function wfBatchDownload() {
+    global $wgParser;
+    $wgParser->setHook( "batchDownload", "createDownloadLinks" );
+}
+
+//To be called directly
+if(realpath($_SERVER['SCRIPT_FILENAME']) == realpath(__FILE__)) {
+	wfDebug("PROCESSING BATCH DOWNLOAD\n");
+	$species = $_GET['species'];
+	$fileType = $_GET['fileType'];
+
+	if($species) {
+		batchDownload($species, $fileType);
+	}
+}
+
+function createDownloadLinks($input, $argv, &$parser) {
+	$fileType = $argv['filetype'];
+	foreach(Pathway::getAvailableSpecies() as $species) {
+		$html .= tag('li', 
+					tag('a',$species,array('href'=> WPI_URL . '/' . "batchDownload.php?species=$species&fileType=$fileType", 'target'=>'_new')));
+	}
+	$html = tag('ul', $html);
+	return $html;
+}
+
+function batchDownload($species, $fileType) {
+	if(!(
+		$fileType == FILETYPE_GPML ||
+		$fileType == FILETYPE_IMG ||
+		$fileType == FILETYPE_PNG)) {
+		throw new Exception("Invalid file type: $fileType");
+	}
+	$pathways = getPathways(array(
+		"page_title LIKE '$species%'"		
+	));
+	doDownload($pathways, $fileType); //Exits script
+}
+
+function getPathways($conditions = array()) {
+	$conditions = array_merge($conditions,
+		array(
+			'page_namespace' => NS_PATHWAY,
+			'page_is_redirect' => 0,
+			"page_title != 'Human:Sandbox'"
+		)
+	);
+	$dbr =& wfGetDB( DB_SLAVE );
+	$res = $dbr->select( 'page',
+		array( 'page_namespace', 'page_title', 'page_is_redirect' ),
+		$conditions
+	);
+
+	$pathways = array();
+	while($s = $dbr->fetchObject( $res ) ) {
+			$t = Title::makeTitle( $s->page_namespace, $s->page_title );
+			try {
+				$pw = Pathway::newFromTitle($t);
+				array_unshift($pathways, $pw);
+			} catch(Exception $e) {
+				wfDebug("Unable to create pathway object", $e);
+			}
+	}
+	return $pathways;
+}
+
+function doDownload($pathways, $fileType) {
+	ob_start();
+/*	$zip = new zipfile();
+	
+	//Fill zip file
+	foreach($pathways as $pw) {
+		$file = $pw->getFileLocation($fileType);
+		$zip->addFile(file_get_contents($file), basename($file));
+	}
+	$zipData = $zip->file();
+*/	
+	$zipFile = tempnam(WPI_TMP_PATH, 'batchDownload') . '.zip';
+	foreach($pathways as $pw) {
+		$files .= $pw->getFileLocation($fileType) . ' ';
+	}
+	$cmd = "zip -j $zipFile $files 2>&1";
+	exec($cmd, $output, $status);
+	foreach($output as $line) {
+		$msg .= $line . "\n";
+	}
+	if($status != 0) {
+		exit("<H1>Unable process download</H1><P>$msg</P>");
+	}
+
+	$time = time();
+	ob_clean();
+	header("Cache-Control: must-revalidate, post-check=0, pre-check=0");
+	header("Cache-Control: private", false);
+	header("Content-Disposition: attachment; filename=wikipathways_$time.zip");
+	header('Content-Type: application/octet-stream');
+	header("Content-Transfer-Encoding: binary");
+	//header("Content-Length: ".filesize($zipFile));
+	set_time_limit(0); //In case reading file takes a long time
+	readfile_chunked($zipFile);
+}
+
+function readfile_chunked($filename,$retbytes=true) { 
+   $chunksize = 1*(1024*1024); // how many bytes per chunk 
+   $buffer = ''; 
+   $cnt =0; 
+   // $handle = fopen($filename, 'rb'); 
+   $handle = fopen($filename, 'rb'); 
+   if ($handle === false) { 
+       return false; 
+   } 
+   while (!feof($handle)) { 
+       $buffer = fread($handle, $chunksize); 
+       echo $buffer; 
+       ob_flush(); 
+       flush(); 
+       if ($retbytes) { 
+           $cnt += strlen($buffer); 
+       } 
+   } 
+       $status = fclose($handle); 
+   if ($retbytes && $status) { 
+       return $cnt; // return num. bytes delivered like readfile() does. 
+   } 
+   return $status; 
+
+} 
+
+?>

Property changes on: trunk/wikipathways/wpi/batchDownload.php
___________________________________________________________________
Name: svn:executable
   + *

Index: trunk/wikipathways/wpi/extensions/MostEditedPathwaysPage/MostEditedPathwaysPage_body.php
===================================================================
--- trunk/wikipathways/wpi/extensions/MostEditedPathwaysPage/MostEditedPathwaysPage_body.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/MostEditedPathwaysPage/MostEditedPathwaysPage_body.php	(revision 1110)
@@ -0,0 +1,161 @@
+<?php
+require_once("QueryPage.php");
+require_once($wgScriptPath . "wpi/wpi.php");
+
+class MostEditedPathwaysPage extends SpecialPage
+{		
+        function MostEditedPathwaysPage() {
+                SpecialPage::SpecialPage("MostEditedPathwaysPage");
+                self::loadMessages();
+        }
+
+        function execute( $par ) {
+                global $wgRequest, $wgOut;
+                
+                $this->setHeaders();
+
+                list( $limit, $offset ) = wfCheckLimits();
+				
+				//Most revisioned pathway images
+				$wgOut->addWikiText("== Pathways Changed  ==");
+				$ppp = new PathwayQueryPage(NS_GPML);
+
+				$ppp->doQuery( $offset, $limit );
+				
+				//Most edited pathway articles
+				$wgOut->addWikiText("== Descriptions & Bibliographies Changed ==");
+				$ppp = new PathwayQueryPage(NS_PATHWAY);
+
+				$ppp->doQuery( $offset, $limit );
+							
+				return true;
+        }
+
+        function loadMessages() {
+                static $messagesLoaded = false;
+                global $wgMessageCache;
+                if ( $messagesLoaded ) return;
+                $messagesLoaded = true;
+
+                require( dirname( __FILE__ ) . '/MostEditedPathwaysPage.i18n.php' );
+                foreach ( $allMessages as $lang => $langMessages ) {
+                        $wgMessageCache->addMessages( $langMessages, $lang );
+                }
+        }
+		
+}
+
+class PathwayQueryPage extends QueryPage {
+	private $namespace;
+	
+	function __construct($namespace) {
+		$this->namespace = $namespace;
+	}
+	
+	function getName() {
+		return "MostEditedPathwaysPage";
+	}
+
+	function isExpensive() {
+		# page_counter is not indexed
+		return true;
+	}
+	function isSyndicated() { return false; }
+
+	function getSQL() {
+		$dbr =& wfGetDB( DB_SLAVE );
+		list( $revision, $page ) = $dbr->tableNamesN( 'revision', 'page' );
+		return
+			"
+			SELECT
+				'Mostrevisions' as type,
+				page_namespace as namespace,
+				page_title as title,
+				COUNT(*) as value
+			FROM $revision
+			JOIN $page ON page_id = rev_page
+			WHERE page_namespace = " . $this->namespace . "
+			AND page_title NOT LIKE '%Sandbox%'
+			AND page_is_redirect = 0
+			GROUP BY 1,2,3
+			HAVING COUNT(*) > 1
+			";
+	}
+
+	function formatResult( $skin, $result ) {
+		global $wgLang, $wgContLang;
+
+/**AP20070508 */
+		$title = Title::makeTitle( NS_PATHWAY, $result->title ); 
+		
+		$text = $wgContLang->convert("$result->value revisions");
+
+		$plink = $skin->makeKnownLinkObj( $title, htmlspecialchars( $wgContLang->convert($title->getBaseText())) );
+
+		/* Not link to history for now, later on link to our own pathway history
+		$nl = wfMsgExt( 'nrevisions', array( 'parsemag', 'escape'),
+			$wgLang->formatNum( $result->value ) );
+		$nlink = $skin->makeKnownLinkObj( $nt, $nl, 'action=history' );
+		*/
+
+		return wfSpecialList($plink, $text);
+	}
+}
+
+class MEGPMLQueryPage extends QueryPage {
+
+	function getName() {
+		return "MostEditedPathwaysPage";
+	}
+
+	function isExpensive() {
+		# page_counter is not indexed
+		return true;
+	}
+	function isSyndicated() { return false; }
+
+	function getSQL() {
+		$dbr =& wfGetDB( DB_SLAVE );
+		list( $revision, $page ) = $dbr->tableNamesN( 'oldimage', 'page' );
+		return
+			"
+			SELECT
+				'Mostrevisions' as type,
+				page_namespace as namespace,
+				page_title as title,
+				COUNT(*) as value
+			FROM oldimage
+			JOIN page ON page_title = oi_name
+			WHERE page_title LIKE '%.gpml'
+			AND page_title NOT LIKE '%Sandbox%'
+			GROUP BY 1,2,3
+			";
+	}
+
+	function formatResult( $skin, $result ) {
+		global $wgLang, $wgContLang;
+		
+		try {
+
+		$pathway = Pathway::newFromFileTitle($result->title);
+		
+/** AP20070502 */
+		$title = $pathway->getTitleObject();
+		$plink = $skin->makeKnownLinkObj( $title, htmlspecialchars( $wgContLang->convert( $title->getBaseText() ) ) );
+
+		$text = $wgContLang->convert("$result->value revisions");
+
+		/* No link to history for now, later on link to our own pathway history
+		$nl = wfMsgExt( 'nrevisions', array( 'parsemag', 'escape'),
+			$wgLang->formatNum( $result->value ) );
+		$nlink = $skin->makeKnownLinkObj( $nt, $nl, 'action=history' );
+		*/
+		
+		return wfSpecialList($plink, $text);
+		} catch(Exception $e) {
+			return '';
+		}
+	}
+}
+
+?>
Index: trunk/wikipathways/wpi/extensions/MostEditedPathwaysPage/MostEditedPathwaysPage.i18n.php
===================================================================
--- trunk/wikipathways/wpi/extensions/MostEditedPathwaysPage/MostEditedPathwaysPage.i18n.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/MostEditedPathwaysPage/MostEditedPathwaysPage.i18n.php	(revision 1110)
@@ -0,0 +1,7 @@
+<?php
+$allMessages = array(
+        'en' => array( 
+                'mosteditedpathwayspage' => 'Most edited pathways'
+        )
+);
+?>
\ No newline at end of file
Index: trunk/wikipathways/wpi/extensions/MostEditedPathwaysPage/MostEditedPathwaysPage.php
===================================================================
--- trunk/wikipathways/wpi/extensions/MostEditedPathwaysPage/MostEditedPathwaysPage.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/MostEditedPathwaysPage/MostEditedPathwaysPage.php	(revision 1110)
@@ -0,0 +1,15 @@
+<?php
+# Not a valid entry point, skip unless MEDIAWIKI is defined
+if (!defined('MEDIAWIKI')) {
+        echo <<<EOT
+To install MostEditedPathwaysPage, put the following line in LocalSettings.php:
+require_once( "$IP/extensions/MostEditedPathwaysPage/MostEditedPathwaysPage.php" );
+EOT;
+        exit( 1 );
+}
+
+$wgAutoloadClasses['MostEditedPathwaysPage'] = dirname(__FILE__) . '/MostEditedPathwaysPage_body.php';
+$wgSpecialPages['MostEditedPathwaysPage'] = 'MostEditedPathwaysPage';
+$wgHooks['LoadAllMessages'][] = 'MostEditedPathwaysPage::loadMessages';
+
+?>
\ No newline at end of file
Index: trunk/wikipathways/wpi/extensions/pathwayInfo.php
===================================================================
--- trunk/wikipathways/wpi/extensions/pathwayInfo.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/pathwayInfo.php	(revision 1110)
@@ -0,0 +1,246 @@
+<?php
+
+require_once("wpi/wpi.php");
+require_once("Article.php");
+require_once("ImagePage.php");
+
+/*
+Statistics for pathway page
+- Description
+	> parse pathway comments from GPML
+- Datanode list
+	> generate list of datanodes
+*/
+
+#### DEFINE EXTENSION
+# Define a setup function
+$wgExtensionFunctions[] = 'wfPathwayInfo';
+# Add a hook to initialise the magic word
+$wgHooks['LanguageGetMagic'][]  = 'wfPathwayInfo_Magic';
+
+function wfPathwayInfo() {
+        global $wgParser;
+        # Set a function hook associating the "example" magic word with our function
+        $wgParser->setFunctionHook( 'pathwayInfo', 'getPathwayInfo' );
+}
+
+function getPathwayInfo( &$parser, $pathway, $type ) {
+	$parser->disableCache();
+	try {
+		$pathway = Pathway::newFromTitle($pathway);
+		$info = new PathwayInfo($parser, $pathway);
+		return $info->$type();
+	} catch(Exception $e) {
+		return "Error: $e";
+	}
+}
+
+function wfPathwayInfo_Magic( &$magicWords, $langCode ) {
+        # Add the magic word
+        # The first array element is case sensitive, in this case it is not case sensitive
+        # All remaining elements are synonyms for our parser function
+        $magicWords['pathwayInfo'] = array( 0, 'pathwayInfo' );
+        # unless we return true, other parser functions extensions won't get loaded.
+        return true;
+}
+
+class PathwayInfo {
+	private $parser;
+	private $pathway;
+	private $gpml;
+	
+	function __construct($parser, $pathway) {
+		$this->parser = $parser;
+		$this->pathway = $pathway;
+	}
+		
+	function comments() {
+		$this->loadGpml();
+		foreach($this->gpml->Comment as $comment) {
+			$text = (string)$comment;
+			$text = htmlentities($text);
+			$text = nl2br($text);
+			$text = formatPubMed($text);
+			$text = uni2ascii($text);
+			//$text = str_replace('&#xD','<br>',$text);
+			if(!$text) continue;
+			$output .= "; " . $comment['Source'] . " : " . $text . "\n";
+		}
+		return $output;
+	}
+	
+	function datanodes() {
+		$this->loadGpml();
+					$table = <<<TABLE
+{|class="wikitable"
+|-
+!Name
+!Type
+!Backpage Header
+!Database reference
+
+TABLE;
+//style="border:1px #AAA solid;margin:1em 1em 0;background:#F9F9F9"
+			$nodes = getUniqueDataNodes($this->gpml, 'TextLabel');
+			sort($nodes);
+			foreach($nodes as $datanode) {
+				$table .= "|-\n";
+				$table .= '|' . $datanode['TextLabel'] . "\n";
+				$table .= '|' . $datanode['Type'] . "\n";
+				$table .= '|' . $datanode['BackpageHead'] . "\n";
+				$xref = $datanode->Xref;
+				if(!$xref['ID']) {
+					$table .= '|-\n';
+				} else {
+					$table .= '|[' . getXrefLink($xref) . " $xref[ID] ($xref[Database])]\n";
+				}
+			}
+			$table .= '|}';
+			return $table;
+	}
+	
+	private function loadGpml() {
+		$gpmlFile = $this->pathway->getFileLocation(FILETYPE_GPML);
+		$this->gpml = simplexml_load_file($gpmlFile);
+	}
+}
+
+$unicode_array = array(
+        "&#8211;" => "-",
+        "&#8212;" => "-",
+        "?" => "-",
+        "&#8216;" => "'",
+        "?" => "'",
+        "&#8217;" => "'",
+        "?" => "'",
+        "&#8230;" => "...",
+        "?" => "...",
+        "?" => "\"",
+        "&#8220;" => "\"",
+        "?" => "\"",
+        "&#8221;" => "\"",
+);
+	
+function uni2ascii($str) {
+	global $unicode_array;
+	return strtr($str, $unicode_array);
+}
+
+function formatPubMed($text) {
+	$link = "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=pubmed&cmd=Retrieve&dopt=AbstractPlus&list_uids=";
+	if(preg_match_all("/PMID: ([0-9]+)/", $text, $ids)) {
+		foreach($ids[1] as $id) {
+			$text = str_replace($id, "[$link$id $id]", $text);
+		}
+	}
+	return $text;
+}
+
+function getUniqueDataNodes($gpml, $uniqueAttribute) {
+	$unique = array();
+	foreach($gpml->DataNode as $node) {
+		$key = $node[$uniqueAttribute];
+		$unique[(string)$key] = $node;
+	}
+	return $unique;
+}
+
+function getXrefLink($xref) {
+	$db = $xref['Database'];
+	$id = $xref['ID'];
+
+	switch($db) {
+	case 'Ensembl':
+		return "http://www.ensembl.org/Homo_sapiens/searchview?species=all&idx=Gene&q=" . $id;
+	case 'Entrez Gene':
+		return "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=gene&cmd=Retrieve&dopt=full_report&list_uids=" . $id;
+	case 'SwissProt':
+		return "http://www.expasy.org/uniprot/" . $id;
+	case 'GenBank':
+		return "http://www.ebi.ac.uk/cgi-bin/emblfetch?style=html&id=" . $id;
+	case 'RefSeq':
+		$ret = "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?";
+		if(substr($id,0,2) == 'NM') return $ret . "db=Nucleotide&cmd=Search&term=" . $id;
+		else return $ret . "db=Protein&cmd=search&term=" . $id;		
+	default:
+		return $id;
+	}
+}
+
+/* TODO: put in switch
+if(c.equalsIgnoreCase("En"))
+			return "http://www.ensembl.org/Homo_sapiens/searchview?species=all&idx=Gene&q=" + id;
+		if(c.equalsIgnoreCase("P"))
+			return "http://www.expasy.org/uniprot/" + id;
+		if(c.equalsIgnoreCase("Q")) {
+			String pre = "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?";
+			if(id.startsWith("NM")) {
+				return pre + "db=Nucleotide&cmd=Search&term=" + id;
+			} else {
+				return pre + "db=Protein&cmd=search&term=" + id;
+			}
+		}
+		if(c.equalsIgnoreCase("T"))
+			return "http://godatabase.org/cgi-bin/go.cgi?view=details&search_constraint=terms&depth=0&query=" + id;
+		if(c.equalsIgnoreCase("I"))
+			return "http://www.ebi.ac.uk/interpro/IEntry?ac=" + id;
+		if(c.equalsIgnoreCase("Pd"))
+			return "http://bip.weizmann.ac.il/oca-bin/ocashort?id=" + id;
+		if(c.equalsIgnoreCase("X"))
+			return "http://www.ensembl.org/Homo_sapiens/featureview?type=OligoProbe;id=" + id;
+		if(c.equalsIgnoreCase("Em"))
+			return "http://www.ebi.ac.uk/cgi-bin/emblfetch?style=html&id=" + id;
+		if(c.equalsIgnoreCase("L"))
+			return "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=gene&cmd=Retrieve&dopt=full_report&list_uids=" + id;
+		if(c.equalsIgnoreCase("H"))
+			return "http://www.gene.ucl.ac.uk/cgi-bin/nomenclature/get_data.pl?hgnc_id=" + id;
+		if(c.equalsIgnoreCase("I"))
+			return "http://www.ebi.ac.uk/interpro/IEntry?ac=" + id;
+		if(c.equalsIgnoreCase("M"))
+			return "http://www.informatics.jax.org/searches/accession_report.cgi?id=" + id;
+		if(c.equalsIgnoreCase("Om"))
+			return "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=OMIM&cmd=Search&doptcmdl=Detailed&term=?" + id;
+		if(c.equalsIgnoreCase("Pf"))
+			return "http://www.sanger.ac.uk//cgi-bin/Pfam/getacc?" + id;
+		if(c.equalsIgnoreCase("R"))
+			return "http://rgd.mcw.edu/generalSearch/RgdSearch.jsp?quickSearch=1&searchKeyword=" + id;
+		if(c.equalsIgnoreCase("D"))
+			return "http://db.yeastgenome.org/cgi-bin/locus.pl?locus=" + id;
+		if(c.equalsIgnoreCase("S"))
+			return "http://www.expasy.org/uniprot/" + id;
+		if(c.equalsIgnoreCase("U")) {
+			String [] org_nr = id.split("\\.");
+			if(org_nr.length == 2) {
+				return "http://www.ncbi.nlm.nih.gov/UniGene/clust.cgi?ORG=" + 
+				org_nr[0] + "&CID=" + org_nr[1];
+			}
+			else {
+				return null;
+			}
+		}
+		if (c.equalsIgnoreCase("Nw"))
+		{
+			return "http://nugowiki.org/index.php/" + id;
+		}
+		if (c.equalsIgnoreCase("Ca"))
+		{
+			return "http://chem.sis.nlm.nih.gov/chemidplus/direct.jsp?regno=" + id;
+		}
+		if (c.equalsIgnoreCase("Cp"))
+		{
+			return "http://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi?cid=" + id;
+		}
+		if (c.equalsIgnoreCase("Ce"))
+		{
+			return "http://www.ebi.ac.uk/chebi/searchId=CHEBI:" + id;
+		}
+		if (c.equalsIgnoreCase("Ch"))
+		{
+			return "http://www.hmdb.ca/scripts/show_card.cgi?METABOCARD=" + id + ".txt";
+		}
+		if (c.equalsIgnoreCase("Ck"))
+		{
+			return "http://www.genome.jp/dbget-bin/www_bget?cpd:" + id;
+		}
+*/
+?>
Index: trunk/wikipathways/wpi/extensions/editApplet.php
===================================================================
--- trunk/wikipathways/wpi/extensions/editApplet.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/editApplet.php	(revision 1110)
@@ -0,0 +1,79 @@
+<?php
+require_once('wpi/wpi.php');
+
+$wgExtensionFunctions[] = 'wfEditApplet';
+$wgHooks['LanguageGetMagic'][]  = 'wfEditApplet_Magic';
+
+function wfEditApplet() {
+	global $wgParser;
+	$wgParser->setFunctionHook( "editApplet", "createApplet" );
+}
+
+function wfEditApplet_Magic( &$magicWords, $langCode ) {
+	$magicWords['editApplet'] = array( 0, 'editApplet' );
+	return true;
+}
+
+function createApplet( &$parser, $idClick = 'appletButton', $idReplace = 'pwThumb', $new = '', $pwTitle = '' ) {
+	$parser->disableCache();
+	try {
+		if(!$pwTitle) {
+			$pathway = Pathway::newFromTitle($parser->mTitle);
+		} else {
+			$pathway = Pathway::newFromTitle($pwTitle);
+		}
+		$appletCode = makeAppletFunctionCall($pathway, $idReplace, $idClick, $new);
+		$output = scriptTag('', JS_SRC_APPLETOBJECT) . scriptTag('', JS_SRC_PROTOTYPE) . scriptTag('', JS_SRC_RESIZE) . scriptTag('', JS_SRC_EDITAPPLET) . $appletCode;
+	} catch(Exception $e) {
+		return "Error: $e";
+	}
+
+	return array($output, 'isHTML'=>1, 'noparse'=>1);
+}
+
+function scriptTag($code, $src = '') {
+	$src = $src ? 'src="' . $src . '"' : '';
+	return '<script type="text/javascript" ' . $src . '>' . $code . '</script>';
+}
+
+function createJsArray($array) {
+	$jsa = "new Array(";      
+	foreach($array as $elm) {
+		$jsa .= "'{$elm}', ";
+	}
+	return substr($jsa, 0, strlen($jsa) - 2) . ')';
+}
+
+function makeAppletFunctionCall($pathway, $idReplace, $idClick, $new) {
+	global $wgUser;
+	if($new) {
+		$pwUrl = $pathway->getTitleObject()->getFullURL();
+	} else {
+		$pwUrl = $pathway->getFileURL(FILETYPE_GPML);
+	}
+
+	$args = array(
+		'rpcUrl' => "http://" . $_SERVER['HTTP_HOST'] . "/wpi/wpi_rpc.php",
+		'pwName' =>     $pathway->name(),
+		'pwSpecies' => $pathway->species(),
+		'pwUrl' => $pwUrl
+	);
+	if($wgUser && $wgUser->isLoggedIn()) {
+		$args = array_merge($args, array('user' => $wgUser->getRealName()));
+	}
+	if($new) {
+		$args = array_merge($args, array('new' => true));
+	}
+	$keys = createJsArray(array_keys($args));
+	$values = createJsArray(array_values($args));
+
+	//$function = "replaceWithApplet('{$idReplace}', 'applet', {$keys}, {$values});";
+	$function = "doApplet('{$idReplace}', 'applet', {$keys}, {$values});";
+	return scriptTag(
+		"var elm = document.getElementById('{$idClick}');" . 
+		"var listener = function() { $function };" .
+		"if(elm.attachEvent) { elm.attachEvent('onclick',listener); }" .
+		"else { elm.addEventListener('click',listener, false); }"
+	);
+}
+?>
Index: trunk/wikipathways/wpi/extensions/listPathways.php
===================================================================
--- trunk/wikipathways/wpi/extensions/listPathways.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/listPathways.php	(revision 1110)
@@ -0,0 +1,45 @@
+<?php
+require_once('wpi/wpi.php');
+
+define('SEPARATOR', ',');
+define('PAR_PATHWAYS', 'pathways');
+
+$wgExtensionFunctions[] = 'wfListPathways';
+
+function wfListPathways() {
+        global $wgParser;
+        $wgParser->setHook('listPathways', 'createPathwayList');
+}
+
+function createPathwayList($input, $argv, &$parser) {
+	$parser->disableCache();
+
+	//Try to get the input parameters from $input and $argv
+	if($input) $pwString = $input . SEPARATOR;
+
+
+	//Try to get the input from the url request
+	if($_GET[PAR_PATHWAYS]) $pwString .= $_GET[PAR_PATHWAYS];
+	
+	//Parse the pathway array
+	$pathways = explode(SEPARATOR, $pwString);
+
+	$pwTagList = array();
+	foreach($pathways as $pw) {
+		try {
+			$pwObject = Pathway::newFromTitle($pw);
+			$link = tag('a', $pwObject->name() . " (" . $pwObject->species() . ")", array('href' => $pwObject->getFullUrl()));
+			array_push($pwTagList, $link);
+		} catch(Exception $e) {
+			//Ignore..
+		}
+	}
+	
+	//Create HTML
+	foreach($pwTagList as $pwTag) {
+		$html .= tag('li', $pwTag);
+	}
+	$html = tag('ul', $html);
+	return $html;
+}
+?>
Index: trunk/wikipathways/wpi/extensions/LabeledSectionTransclusion/lsth.php
===================================================================
--- trunk/wikipathways/wpi/extensions/LabeledSectionTransclusion/lsth.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/LabeledSectionTransclusion/lsth.php	(revision 1110)
@@ -0,0 +1,97 @@
+<?php
+if ( ! defined( 'MEDIAWIKI' ) )
+	die();
+
+/**#@+ 
+ *
+ * A parser extension that further extends labeled section transclusion,
+ * adding a function, #lsth for transcluding marked sections of text,
+ *
+ * This calls internal functions from lst.php.  It will not work if that
+ * extension is not enabled, and may not work if the two files are not in
+ * sync.
+ *
+ * @addtogroup Extensions
+ *
+ * @link http://www.mediawiki.org/wiki/Extension:Labeled_Section_Transclusion Documentation
+ *
+ * @author Steve Sanbeg
+ * @copyright Copyright © 2006, Steve Sanbeg
+ * @license http://www.gnu.org/copyleft/gpl.html GNU General Public License 2.0 or later
+ */
+
+##
+# Standard initialisation code
+##
+
+$wgExtensionFunctions[]="wfLabeledSectionTransclusionHeading";
+$wgHooks['LanguageGetMagic'][] = 'wfLabeledSectionTransclusionHeadingMagic';
+$wgParserTestFiles[] = dirname( __FILE__ ) . "/lsthParserTests.txt";
+
+function wfLabeledSectionTransclusionHeading() 
+{
+  global $wgParser;
+  $wgParser->setFunctionHook( 'lsth', 'wfLstIncludeHeading' );
+}
+
+function wfLabeledSectionTransclusionHeadingMagic( &$magicWords, $langCode ) {
+  // Add the magic words
+  $magicWords['lsth'] = array( 0, 'lsth', 'section-h' );
+  return true;
+}
+
+///section inclusion - include all matching sections
+function wfLstIncludeHeading($parser, $page='', $sec='', $to='')
+{
+  if (wfLst_text_($parser, $page, $title, $text) == false)
+    return $text;
+
+  //Generate a regex to match the === classical heading section(s) === we're
+  //interested in.
+  if ($sec == '') {
+    $begin_off = 0;
+    $head_len = 6;
+  } else {
+    $pat = '^(={1,6})\s*' . preg_quote($sec, '/') . '\s*\1\s*($)' ;
+    if ( preg_match( "/$pat/im", $text, $m, PREG_OFFSET_CAPTURE) ) {
+      $begin_off = $m[2][1];
+      $head_len = strlen($m[1][0]);
+      //wfDebug( "LSTH: offset is $begin_off" );
+    } else {
+      //wfDebug( "LSTH: match failed: '$pat'" );
+      return '';
+    }
+    
+  }
+
+  if ($to != '') {
+    //if $to is supplied, try and match it.  If we don't match, just
+    //ignore it.
+    $pat = '^(={1,6})\s*' . preg_quote($to, '/') . '\s*\1\s*$';
+    if (preg_match( "/$pat/im", $text, $m, PREG_OFFSET_CAPTURE, $begin_off))
+      $end_off = $m[0][1]-1;
+  }
+
+
+  if (! isset($end_off)) {
+    $pat = '^(={1,'.$head_len.'})(?!=).*?\1\s*$';
+    if (preg_match( "/$pat/im", $text, $m, PREG_OFFSET_CAPTURE, $begin_off))
+      $end_off = $m[0][1]-1;
+    else 
+      wfDebug("LSTH: fail end match: '$pat'");
+
+    //wfDebug("LSTH:head len is $head_len, pat is $pat, head is '.$m[1][0]'";
+  } 
+
+  $nhead = wfLst_count_headings_($text, $begin_off);
+  wfDebug( "LSTH: head offset = $nhead" );
+
+  if (isset($end_off))
+    $result = substr($text, $begin_off, $end_off - $begin_off);
+  else
+    $result = substr($text, $begin_off);
+  
+  return wfLst_parse_($parser,$title,$result, "#lsth:${page}|${sec}", $nhead);
+}
+
+?>
Index: trunk/wikipathways/wpi/extensions/LabeledSectionTransclusion/lst.php
===================================================================
--- trunk/wikipathways/wpi/extensions/LabeledSectionTransclusion/lst.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/LabeledSectionTransclusion/lst.php	(revision 1110)
@@ -0,0 +1,196 @@
+<?php
+if ( ! defined( 'MEDIAWIKI' ) )
+	die();
+/**#@+
+ * A parser extension that adds two functions, #lst and #lstx, and the 
+ * <section> tag, for transcluding marked sections of text.
+ *
+ * @addtogroup Extensions
+ *
+ * @link http://www.mediawiki.org/wiki/Extension:Labeled_Section_Transclusion Documentation
+ *
+ * @bug 5881
+ *
+ * @author Steve Sanbeg
+ * @copyright Copyright © 2006, Steve Sanbeg
+ * @license http://www.gnu.org/copyleft/gpl.html GNU General Public License 2.0 or later
+ */
+
+##
+# Standard initialisation code
+##
+
+$wgExtensionFunctions[]="wfLabeledSectionTransclusion";
+$wgHooks['LanguageGetMagic'][]       = 'wfLabeledSectionTransclusionMagic';
+
+$wgExtensionCredits['parserhook'][] = array(
+        'name' => 'LabeledSectionTransclusion',
+        'author' => 'Steve Sanbeg',
+        'description' => 'adds #lst and #lstx functions and &lt;section&gt; tag, enables marked sections of text to be transcluded',
+        'url' => 'http://www.mediawiki.org/wiki/Extension:Labeled_Section_Transclusion'
+        );
+$wgParserTestFiles[] = dirname( __FILE__ ) . "/lstParserTests.txt";
+
+function wfLabeledSectionTransclusion() 
+{
+  global $wgParser, $wgVersion, $wgHooks;
+  
+  $wgParser->setHook( 'section', 'wfLstNoop' );
+  $wgParser->setFunctionHook( 'lst', 'wfLstInclude' );
+  $wgParser->setFunctionHook( 'lstx', 'wfLstExclude' );
+}
+
+/// Add the magic words - possibly with more readable aliases
+function wfLabeledSectionTransclusionMagic( &$magicWords, $langCode ) {
+  $magicWords['lst'] = array( 0, 'lst', 'section' );
+  $magicWords['lstx'] = array( 0, 'lstx', 'section-x' );
+  return true;
+}
+
+##############################################################
+# To do transclusion from an extension, we need to interact with the parser
+# at a low level.  This is the general transclusion functionality
+##############################################################
+
+///Register what we're working on in the parser, so we don't fall into a trap.
+function wfLst_open_($parser, $part1) 
+{
+  // Infinite loop test
+  if ( isset( $parser->mTemplatePath[$part1] ) ) {
+    wfDebug( __METHOD__.": template loop broken at '$part1'\n" );
+    return false;
+  } else {
+    $parser->mTemplatePath[$part1] = 1;
+    return true;
+  }
+  
+}
+
+///Finish processing the function.
+function wfLst_close_($parser, $part1) 
+{
+  // Infinite loop test
+  if ( isset( $parser->mTemplatePath[$part1] ) ) {
+    unset( $parser->mTemplatePath[$part1] );
+  } else {
+    wfDebug( __METHOD__.": close unopened template loop at '$part1'\n" );
+  }
+}
+
+/**
+ * Handle recursive substitution here, so we can break cycles, and set up
+ * return values so that edit sections will resolve correctly.
+ **/
+function wfLst_parse_($parser, $title, $text, $part1, $skiphead=0) 
+{
+  // if someone tries something like<section begin=blah>lst only</section>
+  // text, may as well do the right thing.
+  $text = str_replace('</section>', '', $text);
+
+  if (wfLst_open_($parser, $part1)) {
+    //Handle recursion here, so we can break cycles.
+    global $wgVersion;
+    if( version_compare( $wgVersion, "1.9" ) < 0 ) {
+      $text = $parser->replaceVariables($text);
+      wfLst_close_($parser, $part1);
+    }
+    
+    //Try to get edit sections correct by munging around the parser's guts.
+    return array($text, 'title'=>$title, 'replaceHeadings'=>true, 
+		 'headingOffset'=>$skiphead);
+  }  else {
+    return "[[" . $title->getPrefixedText() . "]]". 
+      "<!-- WARNING: LST loop detected -->";
+  }
+  
+}
+
+##############################################################
+# And now, the labeled section transclusion
+##############################################################
+
+///The section markers aren't paired, so we only need to remove them.
+function wfLstNoop( $in, $assocArgs=array(), $parser=null ) {
+  return '';
+}
+
+///Generate a regex to match the section(s) we're interested in.
+function wfLst_pat_($sec, $to) 
+{
+  $to_sec = ($to == '')?$sec : $to;
+  $sec = preg_quote($sec, '/');
+  $to_sec = preg_quote($to_sec, '/');
+  $ws="(?:\s+[^>]+)?"; //was like $ws="\s*"
+  return "/<section$ws\s+(?i:begin)=".
+    "(?:$sec|\"$sec\"|'$sec')".
+    "$ws\/?>(.*?)\n?<section$ws\s+(?:[^>]+\s+)?(?i:end)=".
+    "(?:$to_sec|\"$to_sec\"|'$to_sec')".
+    "$ws\/?>/s";
+}
+
+///Count headings in skipped text; the $parser arg could go away in the future.
+function wfLst_count_headings_($text,$limit) 
+{
+  //count skipped headings, so parser (as of r18218) can skip them, to
+  //prevent wrong heading links (see bug 6563).
+  $pat = '^(={1,6}).+\1\s*$';
+  return preg_match_all( "/$pat/im", substr($text,0,$limit), $m);
+}
+
+function wfLst_text_($parser, $page, &$title, &$text) 
+{
+  $title = Title::newFromText($page);
+  
+  if (is_null($title) ) {
+    $text = '';
+    return true;
+  } else {
+    if (method_exists($parser, 'fetchTemplateAndTitle')) {
+      list($text,$title) = $parser->fetchTemplateAndTitle($title);
+    } else {
+      $text = $parser->fetchTemplate($title);
+    }
+  }
+  
+  //if article doesn't exist, return a red link.
+  if ($text == false) {
+    $text = "[[" . $title->getPrefixedText() . "]]";
+    return false;
+  } else {
+    return true;
+  }
+}
+
+///section inclusion - include all matching sections
+function wfLstInclude($parser, $page='', $sec='', $to='')
+{
+  if (wfLst_text_($parser, $page, $title, $text) == false)
+    return $text;
+  $pat = wfLst_pat_($sec,$to);
+
+  if(preg_match_all( $pat, $text, $m, PREG_OFFSET_CAPTURE)) {
+    $headings = wfLst_count_headings_($text, $m[0][0][1]);
+  } else {
+    $headings = 0;
+  }
+  
+  $text = '';
+  foreach ($m[1] as $piece)  {
+    $text .= $piece[0];
+  }
+
+  //wfDebug("wfLstInclude: skip $headings headings");
+  return wfLst_parse_($parser,$title,$text, "#lst:${page}|${sec}", $headings);
+}
+  
+///section exclusion, with optional replacement
+function wfLstExclude($parser, $page='', $sec='', $repl='',$to='')
+{
+  if (wfLst_text_($parser, $page, $title, $text) == false)
+    return $text;
+  $pat = wfLst_pat_($sec,$to);
+  $text = preg_replace( $pat, $repl, $text);
+  return wfLst_parse_($parser,$title,$text, "#lstx:$page|$sec");
+}
+
+?>
Index: trunk/wikipathways/wpi/extensions/LabeledSectionTransclusion/compat.php
===================================================================
--- trunk/wikipathways/wpi/extensions/LabeledSectionTransclusion/compat.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/LabeledSectionTransclusion/compat.php	(revision 1110)
@@ -0,0 +1,28 @@
+<?php
+
+/**
+
+This file contains compatability functions for other extensions which may
+have called them, primarily DynamicPageList2.  This file is not used by the
+Labeled Section Transclusion extension, but is provided to insulate other
+extensions from code refactoring.
+
+**/
+
+///Fetch the page to be transcluded from the database.
+function wfLst_fetch_($parser, $page, $ns = NS_MAIN) 
+{
+  $title = Title::newFromText($page,$ns);
+  if ( !is_null( $title ) ) {
+    $text = $parser->fetchTemplate($title);
+  }
+  return $text;
+}
+
+
+function wfLstIncludeHeading2($parser, $page='', $sec='', $to='') 
+{
+  return wfLstIncludeHeading($parser, $page, $sec, $to);
+}
+
+?>
Index: trunk/wikipathways/wpi/extensions/pathwayHistory.php
===================================================================
--- trunk/wikipathways/wpi/extensions/pathwayHistory.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/pathwayHistory.php	(revision 1110)
@@ -0,0 +1,151 @@
+<?php
+require_once('wpi/wpi.php');
+require_once('Pager.php');
+require_once('PageHistory.php');
+
+
+$wgExtensionFunctions[] = "wfPathwayHistory";
+
+function wfPathwayHistory() {
+    global $wgParser;
+    $wgParser->setHook( "pathwayHistory", "history" );
+}
+
+function history( $input, $argv, &$parser ) {
+	try {
+		$pathway = Pathway::newFromTitle($parser->mTitle);
+		return getHistory($pathway);
+	} catch(Exception $e) {
+		return "Error: $e";
+	}
+}
+
+function getHistory($pathway) {
+		global $wgUser, $wpiScriptURL;
+		
+		$gpmlTitle = $pathway->getFileTitle(FILETYPE_GPML);
+		$gpmlArticle = new Article($gpmlTitle);
+		$hist = new PageHistory($gpmlArticle);
+
+		$pager = new GpmlHistoryPager( $pathway, $hist );
+
+		$s = $pager->getBody();
+		
+		if($wgUser->isAllowed('delete')) {
+			$pwTitle = $pathway->getTitleObject()->getDBKey();
+			$delete = "<p><a href=$wpiScriptURL?action=delete&pwTitle=$pwTitle>Delete this pathway</a></p>";
+			$s = $delete . $s;
+		}
+		return $s;
+		/*global $wgUser, $wpiScriptURL;
+		$sk = $wgUser->getSkin();
+		
+		$imgTitle = $pathway->getFileTitle(FILETYPE_GPML);
+		$img = new Image($imgTitle);
+		$line = $img->nextHistoryLine();
+		$nrShow = 4;
+		$buttonStyle = 'color:#0000FF';
+		$expand = "<B>View all</B>";
+		$collapse = "<B>View last " . ($nrShow - 1) . "</B>";
+		if ( $line ) {
+			$table = "<TABLE  id='historyTable' class='wikitable'><TR><TH><TH>Time<TH>User<TH>Comment";
+			$table .= historyRow(historyLine(true, $line, $pathway), '');
+			$nr = 0;
+			while($line = $img->nextHistoryLine()) {
+				$h = historyLine(false, $line, $pathway);
+				$style = $n<$nrShow ? '' : 'style="display:none"';
+				$table .= historyRow($h, $style);
+				$n++;
+			}
+			$table .= "</TABLE>";
+		}
+		if($n >= $nrShow - 1) {
+			$button = "<p onClick='toggleRows(\"historyTable\", this, \"$expand\", 
+				\"$collapse\", $nrShow, true)' style='cursor:pointer;color:#0000FF'>$expand</p>";
+			$table = $button . $table;
+		}
+		if($wgUser->isAllowed('delete')) {
+			$pwTitle = $pathway->getTitleObject()->getDBKey();
+			$delete = "<p><a href=$wpiScriptURL?action=delete&pwTitle=$pwTitle>Delete this pathway</a></p>";
+			$table = $delete . $table;
+		}
+		return $table;
+		*/
+}
+
+function historyRow($h, $style) {
+	return "<TR $style><TD>$h[rev]$h[view]<TD>$h[date]<TD>$h[user]<TD>$h[descr]";
+}
+
+function historyLine($pathway, $row, $cur = false) {
+	global $wpiScript, $wgLang, $wgUser, $wgTitle;
+	
+	$rev = new Revision( $row );
+	$rev->setTitle( $pathway->getFileTitle(FILETYPE_GPML) );
+
+	$revUrl = 'http://'.$_SERVER['HTTP_HOST'] . '/' .$wpiScript . '?action=revert&pwTitle=' .
+				$pathway->getTitleObject()->getPartialURL() .
+				"&oldId={$rev->getId()}";
+	
+	if($wgUser->getID() != 0 && $wgTitle && $wgTitle->userCanEdit()) {
+		$revert = $cur ? "" : "(<A href=$revUrl>revert</A>), ";
+	}
+	
+	$dt = $wgLang->timeanddate( wfTimestamp(TS_MW, $rev->getTimestamp()), true );
+	$view = $wgUser->getSkin()->makeKnownLinkObj($pathway->getFileTitle(FILETYPE_GPML), 'view', "oldid=" . $rev->getId() );
+
+	$date = $wgLang->timeanddate( $rev->getTimestamp(), true );
+	$user = $wgUser->getSkin()->userLink( $rev->getUser(), $rev->getUserText() );
+	$descr = $rev->getComment();
+	return array('rev'=>$revert, 'view'=>$view, 'date'=>$date, 'user'=>$user, 'descr'=>$descr);
+}
+
+class GpmlHistoryPager extends PageHistoryPager {
+	private $pathway;
+	private $nrShow = 4;
+
+	function __construct( $pathway, $pageHistory ) {
+		parent::__construct( $pageHistory );
+		$this->pathway = $pathway;
+	}
+
+	function formatRow( $row ) {
+		$latest = $this->mCounter == 1;
+		$style = ($this->mCounter <= $this->nrShow) ? '' : 'style="display:none"';
+		
+		$s = historyRow(historyLine($this->pathway, $row, $latest), $style);
+		
+		$this->mLastRow = $row;
+		$this->mCounter++;
+		return $s;
+	}
+
+	function getStartBody() {
+		$this->mLastRow = false;
+		$this->mCounter = 1;
+		
+		$nr = $this->getNumRows();
+		
+		if($nr < 1) {
+			$table = '';
+		} else {
+			$table = "<TABLE  id='historyTable' class='wikitable'><TR><TH><TH>Time<TH>User<TH>Comment";
+		}
+
+		if($nr >= $this->nrShow) {
+			$expand = "<B>View all</B>";
+			$collapse = "<B>View last " . ($this->nrShow - 1) . "</B>";
+			$button = "<p onClick='toggleRows(\"historyTable\", this, \"$expand\", 
+				\"$collapse\", {$this->nrShow}, true)' style='cursor:pointer;color:#0000FF'>$expand</p>";
+			$table = $button . $table;
+		}
+
+		return $table;
+	}
+
+	function getEndBody() {
+		return "</TABLE>";
+	}
+}
+
+?>
Index: trunk/wikipathways/wpi/extensions/magicWords.php
===================================================================
--- trunk/wikipathways/wpi/extensions/magicWords.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/magicWords.php	(revision 1110)
@@ -0,0 +1,70 @@
+<?php
+
+require_once("wpi/wpi.php");
+require_once("PathwayOfTheDay.php");
+
+$wgCustomVariables = array(	'PATHWAYNAME','PATHWAYSPECIES', 
+							'PATHWAYIMAGEPAGE', 'PATHWAYGPMLPAGE',
+							'PATHWAYOFTHEDAY'
+					);
+
+$wgHooks['MagicWordMagicWords'][]          = 'wfAddCustomVariable';
+$wgHooks['MagicWordwgVariableIDs'][]       = 'wfAddCustomVariableID';
+$wgHooks['LanguageGetMagic'][]             = 'wfAddCustomVariableLang';
+$wgHooks['ParserGetVariableValueSwitch'][] = 'wfGetCustomVariable';
+
+function wfAddCustomVariable(&$magicWords) {
+        foreach($GLOBALS['wgCustomVariables'] as $var) $magicWords[] = "MAG_$var";
+        return true;
+        }
+
+function wfAddCustomVariableID(&$variables) {
+        foreach($GLOBALS['wgCustomVariables'] as $var) $variables[] = constant("MAG_$var");
+        return true;
+        }
+
+function wfAddCustomVariableLang(&$langMagic, $langCode = 0) {
+        foreach($GLOBALS['wgCustomVariables'] as $var) {
+                $magic = "MAG_$var";
+                $langMagic[defined($magic) ? constant($magic) : $magic] = array(0,$var);
+                }
+        return true;
+        }
+
+function wfGetCustomVariable(&$parser,&$cache,&$index,&$ret) {
+        switch ($index) {
+				case MAG_PATHWAYOFTHEDAY:
+						$pwd = new PathwayOfTheDay(null);
+						$pw = $pwd->todaysPathway();
+						$ret = $pw->getTitleObject()->getFullText();
+						break;
+                case MAG_PATHWAYNAME:
+				case MAG_PATHWAYSPECIES:
+				case MAG_PATHWAYIMAGEPAGE:
+				case MAG_PATHWAYGPMLPAGE:
+						$title = $parser->mTitle;
+						if($title->getNamespace() == NS_PATHWAY) {
+							$pathway = Pathway::newFromTitle($title);
+							$ret = getPathwayVariable($pathway, $index);
+						} else {
+							$ret = "NOT A PATHWAY";
+						}
+                        break;
+                }
+        return true;
+}
+
+function getPathwayVariable($pathway, $index) {
+	switch($index) {
+		case MAG_PATHWAYNAME:
+			return $pathway->name();
+		case MAG_PATHWAYSPECIES:
+			return $pathway->species();	
+		case MAG_PATHWAYIMAGEPAGE:
+			return $pathway->getFileTitle(FILETYPE_IMG)->getFullText();
+		case MAG_PATHWAYGPMLPAGE:
+			return $pathway->getFileTitle(FILETYPE_GPML)->getFullText();					
+	}
+}
+
+?>

Property changes on: trunk/wikipathways/wpi/extensions/magicWords.php
___________________________________________________________________
Name: svn:executable
   + *

Index: trunk/wikipathways/wpi/extensions/DynamicPageList2.php
===================================================================
--- trunk/wikipathways/wpi/extensions/DynamicPageList2.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/DynamicPageList2.php	(revision 1110)
@@ -0,0 +1,1491 @@
+<?php
+/**
+ * Main include file for the DynamicPageList2 extension of MediaWiki.
+ * This code is released under the GNU General Public License.
+ *
+ *  Purpose:
+ * 	outputs a union of articles residing in a selection of categories and namespaces using configurable output- and ordermethods
+ * 
+ * Note: DynamicPageList2 is based on DynamicPageList.
+ *
+ * Usage:
+ * 	require_once("extensions/DynamicPageList2.php"); in LocalSettings.php
+ * 
+ * @addtogroup Extensions
+ * @link http://www.mediawiki.org/wiki/Extension:DynamicPageList2 Documentation
+ * @author n:en:User:IlyaHaykinson 
+ * @author n:en:User:Amgine 
+ * @author w:de:Benutzer:Unendlich 
+ * @author m:User:Dangerman <cyril.dangerville@gmail.com>
+ * @license http://opensource.org/licenses/gpl-license.php GNU Public License
+ * @version 0.8.1
+ */
+
+/*
+ * Current version
+ */
+define('DPL2_VERSION', '0.8.1');
+
+/**
+ * Register the extension with MediaWiki
+ */
+$wgExtensionFunctions[] = "wfDynamicPageList2";
+$wgExtensionCredits['parserhook'][] = array(
+	'name' => 'DynamicPageList2',
+	'author' => '[http://en.wikinews.org/wiki/User:IlyaHaykinson IlyaHaykinson], [http://en.wikinews.org/wiki/User:Amgine Amgine], [http://de.wikipedia.org/wiki/Benutzer:Unendlich Unendlich], [http://meta.wikimedia.org/wiki/User:Dangerman Cyril Dangerville]',
+	'url' => 'http://www.mediawiki.org/wiki/Extension:DynamicPageList2',
+	'description' => 'hack of the original [http://www.mediawiki.org/wiki/Extension:DynamicPageList DynamicPageList] extension featuring many Improvements',
+  	'version' => DPL2_VERSION
+  );
+
+/**
+ * Extension settings 
+ */
+
+# Maximum number of categories allowed in the Query
+$wgDPL2MaxCategoryCount = 4;
+
+# Minimum number of categories needed in the Query
+$wgDPL2MinCategoryCount = 0;
+
+# Maximum number of results to allow
+$wgDPL2MaxResultCount = 50;
+
+# Max length to format a list of articles chunked by letter as bullet list
+# if list is bigger, columnar format user (same as cutoff arg for
+# CategoryPage::formatList())
+$wgDPL2CategoryStyleListCutoff = 6;
+
+# Allow unlimited categories in the Query
+$wgDPL2AllowUnlimitedCategories = true;
+
+# Allow unlimited results to be shown
+$wgDPL2AllowUnlimitedResults = true;
+
+# To be initialized at first use of DPL2, array of all namespaces except
+# Media and Special, because we cannot use the DB for these to generate
+# dynamic page lists. Cannot be customized !
+# Use $wgDPL2Options['namespace'] or $wgDPL2Options['notnamespace'] for customization.
+$wgDPL2AllowedNamespaces = NULL;
+
+/**
+ * Map parameters to possible values.
+ * A 'default' key indicates the default value for the parameter.
+ * A 'pattern' key indicates a pattern for regular expressions (that the value must match).
+ * For some options (e.g. 'namespace'), possible values are not yet defined
+ * but will be if necessary (for debugging)
+ */
+$wgDPL2Options = array(
+	'addcategories' => array('default' => 'false', 'false', 'true'),
+	'addpagecounter' => array('default' => 'false', 'false', 'true'),
+	'addeditdate' => array('default' => 'false', 'false', 'true'),
+	'addfirstcategorydate' => array('default' => 'false', 'false', 'true'),
+	'addpagetoucheddate' => array('default' => 'false', 'false', 'true'),
+	'adduser' => array('default' => 'false', 'false', 'true'),
+
+	/**
+	 * category= Cat11 | Cat12 | ...
+	 * category= Cat21 | Cat22 | ...
+	 * ...
+	 * [Special value] catX='' (empty string without quotes) means pseudo-categoy of Uncategorized pages
+	 * Means pages have to be in category (Cat11 OR (inclusive) Cat2 OR...) AND (Cat21 OR Cat22 OR...) AND...
+	 * If '+' prefixes the list of categories (e.g. category=+ Cat1 | Cat 2 ...), only these categories can be used as headings in the DPL. See  'headingmode' param.
+	 * Magic words allowed.
+	 * @todo define 'category' options (retrieve list of categories from 'categorylinks' table?)
+	 */
+	'category' => NULL,
+
+	/**
+	 * Maximum number of results to be displayed.
+	 * Empty count value (default) indicates no limit.
+	 */
+	'count' => array(
+		'default' => '',
+		'pattern' => '/^\d*$/'
+	),
+
+	/**
+	 * debug=...
+	 * - 0: displays no debug message;
+	 * - 1: displays fatal errors only; 
+	 * - 2: fatal errors + warnings only;
+	 * - 3: every debug message.
+	 */
+	'debug' => array(
+		'default' => '2',
+		'0', '1', '2', '3'
+	),
+
+	/**
+	 * Mode at the heading level with ordermethod on multiple components,
+	 * e.g. category heading with ordermethod=category,...: 
+	 * html headings (H2, H3, H4), definition list, no heading (none), ordered,
+	 * unordered.
+	 */
+	'headingmode' => array(
+		'default' => 'none',
+		'H2', 'H3', 'H4', 'definition', 'none', 'ordered', 'unordered'
+	),
+
+	/**
+	 * Attributes for HTML list items (headings) at the heading level,
+	 * depending on 'headingmode' (e.g. 'li' for ordered/unordered)
+	 * Not yet applicable to 'headingmode=none | definition | H2 | H3 | H4'.
+	 * @todo Make 'hitemattr' param applicable to  'none', 'definition', 'H2', 'H3', 'H4' headingmodes.
+	 * Example: hitemattr= class="topmenuli" style="color: red;"
+	 */
+	'hitemattr' => array('default' => ''),
+
+	/**
+	 * Attributes for the HTML list element at the heading/top level, depending
+	 * on 'headingmode' (e.g. 'ol' for ordered, 'ul' for unordered, 'dl' for definition)
+	 * Not yet applicable to 'headingmode=none'.
+	 * @todo Make 'hlistattr' param applicable to  headingmode=none.
+	 * Example: hlistattr= class="topmenul" id="dmenu"
+	 */
+	'hlistattr' => array('default' => ''),
+
+	/**
+	 * PAGE TRANSCLUSION: includepage=...
+	 *
+	 * To include the whole page, use a wildcard:
+	 *     includepage =*
+	 *
+	 * To include sections labeled 'sec1' or 'sec2' or... from the page
+	 * (see the doc of the LabeledSectionTransclusion extension for more info)
+	 *     includepage = sec1,sec2,..
+	 *
+	 * To include from the first occurrence of the heading 'heading1'
+	 * (resp. 'heading2') until the next heading of the same or lower level.
+	 * Note that this comparison is case insensitive. (See http://www.mediawiki.org/wiki/Extension:Labeled_Section_Transclusion#Transcluding_visual_headings.) :
+	 *     includepage = #heading1,#heading2,....
+	 *
+	 * You can combine the above options:
+	 *     includepage= sec1,#heading1,...
+	 *
+	 * To include nothing from the page (no transclusion), leave empty:
+	 * includepage =
+	 */
+    'includepage' => array('default' => ''),
+
+	/** 
+	 * Inline text is some wiki text used to separate list items with 'mode=inline'.
+	 */
+	'inlinetext' => array(
+		'default' => '&nbsp;-&nbsp;'
+	),
+
+	/**
+	 * Attributes for HTML list items, depending on 'mode':
+	 *     - 'li' for ordered/unordered
+	 *     - 'span' for others).
+	 *
+	 * Not applicable to 'mode=category'.
+	 *
+	 * @todo Make 'itemattr' param applicable to 'mode=category'.
+	 *
+	 * Example:
+	 *     itemattr= class="submenuli" style="color: red;"
+	 */
+	'itemattr' => array('default' => ''),
+
+	/**
+	 * Attributes for HTML list elements, depending on 'mode':
+	 *    - 'ol' for ordered
+	 *    - 'ul' for unordered
+	 *    - 'div' for others
+     *
+	 * Can be used with pseudo 'mode=inline' where 'inlinetext' contains one or more <BR/>.
+	 *
+	 * Not applicable to 'mode=category' or 'mode=inline' (with no <BR/> in inlinetext).
+	 *
+	 * @todo Make 'listattr' param applicable to 'mode=category'.
+	 *
+	 * Example:
+	 *     listattr= class="submenul" style="color: red;"
+	 */
+	'listattr' => array('default' => ''),
+
+	/**
+	 * This parameter restricts the output to articles which contain
+	 * a reference to the specified page.
+	 * Magic words allowed.
+	 * Examples:
+	 *     linksto=my article
+	 *     linksto=Template:my template
+	 *     linksto = {{FULLPAGENAME}}
+	 */
+    'linksto' => array('default' => ''),
+
+	/**
+	 * Mode for list of pages (possibly within a heading, see 'headingmode' param).
+	 * 'none' mode is implemented as a specific submode of 'inline' with <BR/> as inline text
+	 */
+	'mode' => array('default' => 'unordered', 'category', 'inline', 'none', 'ordered', 'unordered'),
+
+	/**
+	 * namespace= Ns1 | Ns2 | ...
+	 * [Special value] NsX='' (empty string without quotes) means Main namespace
+	 * Means pages have to be in namespace Ns1 OR Ns2 OR...
+	 * Magic words allowed.
+	 */
+	'namespace' => NULL,
+
+	/**
+	 * notcategory= Cat1
+	 * notcategory = Cat2
+	 * ...
+	 * Means pages can be NEITHER in category Cat1 NOR in Cat2 NOR...
+	 * Magic words allowed.
+	 * @todo define 'notcategory' options (retrieve list of categories from 'categorylinks' table?)
+	 */
+	'notcategory' => NULL,
+
+	/**
+	 * notnamespace= Ns1
+ 	 * notnamespace= Ns2
+ 	 * ...
+	 * [Special value] NsX='' (empty string without quotes) means Main namespace
+	 * Means pages have to be NEITHER in namespace Ns1 NOR Ns2 NOR...
+	 * Magic words allowed.
+	*/
+	'notnamespace' => NULL,
+	'order' => array(
+		'default' => 'ascending',
+		'ascending', 'descending'
+	),
+
+	/**
+	 * 'ordermethod=param1,param2' means ordered by param1 first, then by param2.
+	 * @todo: add 'ordermethod=category,categoryadd' (for each category CAT,
+	 * pages ordered by date when page was added to CAT).
+	 */
+	'ordermethod' => array(
+		'default' => 'title',
+		'counter', 'category,firstedit', 'category,lastedit', 'category,pagetouched',
+		'category,sortkey', 'categoryadd', 'firstedit', 'lastedit', 'pagetouched',
+		'title', 'user,firstedit', 'user,lastedit'
+	),
+
+	/**
+	 * minoredits =... (compatible with ordermethod=...,firstedit | lastedit only)
+	 * - exclude: ignore minor edits when sorting the list (rev_minor_edit = 0 only)
+	 * - include: include minor edits
+	 */
+	'minoredits' => array(
+		'default' => 'include',
+		'exclude', 'include'
+	),
+
+	/**
+	 * redirects =...
+	 * - exclude: excludes redirect pages from lists (page_is_redirect = 0 only)
+	 * - include: allows redirect pages to appear in lists
+	 * - only: lists only redirect pages in lists (page_is_redirect = 1 only)
+	 */
+	'redirects' => array(
+		'default' => 'exclude',
+		'exclude', 'include', 'only'
+	),
+
+	/**
+	 * secseparators  is a sequence of html texts used to separate sections
+	*  (see "includepage=name1, name2, .."). There are four items which must
+	 * be separated by "," as delimiter :
+	 *     - t1 and t4 define an outer frame for sections of an article
+	 *     - t2 and t3 build an inner frame for each section
+	 * Example:
+	 *     secseparators=<table><tr>,<td>,</td>,</tr></table>
+	 */
+	'secseparators'  => array('default' => ',,,'),
+	'shownamespace' => array(
+		'default' => 'true',
+		'false', 'true'
+	),
+
+	/**
+	 * Max # characters of page title to display.
+	 * Empty value (default) means no limit.
+	 * Not applicable to mode=category.
+	 */
+	'titlemaxlength' => array(
+		'default' => '',
+		'pattern' => '/^\d*$/'
+	),
+);
+
+/**
+ *  Define codes and map debug message to min debug level above which message can be displayed
+ */
+$wgDPL2DebugCodes = array(
+	// (FATAL) ERRORS
+	'DPL2_ERR_WRONGNS' => 1,
+	'DPL2_ERR_WRONGLINKSTO' => 1,
+ 	'DPL2_ERR_TOOMANYCATS' => 1,
+	'DPL2_ERR_TOOFEWCATS' => 1,
+	'DPL2_ERR_CATDATEBUTNOINCLUDEDCATS' => 1,
+	'DPL2_ERR_CATDATEBUTMORETHAN1CAT' => 1,
+	'DPL2_ERR_MORETHAN1TYPEOFDATE' => 1,
+	'DPL2_ERR_WRONGORDERMETHOD' => 1,
+	'DPL2_ERR_NOCLVIEW' => 1,
+	// WARNINGS
+	'DPL2_WARN_UNKNOWNPARAM' => 2,
+	'DPL2_WARN_WRONGPARAM' => 2,
+	'DPL2_WARN_WRONGPARAM_INT' => 2,
+	'DPL2_WARN_NORESULTS' => 2,
+	'DPL2_WARN_CATOUTPUTBUTWRONGPARAMS' => 2,
+	'DPL2_WARN_HEADINGBUTSIMPLEORDERMETHOD' => 2,
+	'DPL2_WARN_DEBUGPARAMNOTFIRST' => 2,
+	'DPL2_WARN_TRANSCLUSIONLOOP' => 2,
+	// OTHERS
+	'DPL2_QUERY' => 3
+);
+
+$wgDPL2DebugMinLevels = array();
+$i = 0;
+foreach ($wgDPL2DebugCodes as $name => $minlevel ) {
+	define( $name, $i );
+	$wgDPL2DebugMinLevels[$i] = $minlevel;
+	$i++;
+}
+
+// Internationalization file
+require_once( 'DynamicPageList2.i18n.php' );
+
+function wfDynamicPageList2() {
+	global $wgParser, $wgMessageCache, $wgDPL2Messages;
+	foreach( $wgDPL2Messages as $sLang => $aMsgs ) {
+		$wgMessageCache->addMessages( $aMsgs, $sLang );
+	}
+	$wgParser->setHook( "DPL", "DynamicPageList2" );
+}
+
+
+// The callback function for converting the input text to HTML output
+function DynamicPageList2( $input, $params, &$parser ) {
+
+	error_reporting(E_ALL);
+	
+	global $wgUser, $wgContLang, $wgDPL2AllowedNamespaces, $wgDPL2Options, $wgDPL2MaxCategoryCount, $wgDPL2MinCategoryCount, $wgDPL2MaxResultCount, $wgDPL2AllowUnlimitedCategories, $wgDPL2AllowUnlimitedResults;
+	
+	//logger (display of debug messages)
+	$logger = new DPL2Logger();
+	
+	//check that we are not in an infinite transclusion loop
+	if ( isset( $parser->mTemplatePath[$parser->getTitle()->getPrefixedText()] ) ) {
+		return $logger->escapeMsg(DPL2_WARN_TRANSCLUSIONLOOP, $parser->getTitle()->getPrefixedText());
+	}
+	
+	// INVALIDATE CACHE
+	$parser->disableCache();
+	
+	/**
+	 * Initialization
+	 */
+	 // Local parser created. See http://meta.wikimedia.org/wiki/MediaWiki_extensions_FAQ#How_do_I_render_wikitext_in_my_extension.3F
+	$localParser = new Parser();
+	$pOptions = $parser->getOptions();
+	$pTitle = $parser->getTitle();
+	
+	// Extension variables
+	// Allowed namespaces for DPL2: all namespaces except the first 2: Media (-2) and Special (-1), because we cannot use the DB for these to generate dynamic page lists.
+	if( !is_array($wgDPL2AllowedNamespaces) ) { // Initialization
+		$aNs = $wgContLang->getNamespaces();
+		$wgDPL2AllowedNamespaces = array_slice($aNs, 2, count($aNs), true);
+		if( !is_array($wgDPL2Options['namespace']) )
+			$wgDPL2Options['namespace'] = $wgDPL2AllowedNamespaces;
+		else // Make sure user namespace options are allowed.
+			$wgDPL2Options['namespace'] = array_intersect($wgDPL2Options['namespace'], $wgDPL2AllowedNamespaces);
+		if( !isset($wgDPL2Options['namespace']['default']) )
+			$wgDPL2Options['namespace']['default'] = NULL;
+		if( !is_array($wgDPL2Options['notnamespace']) )
+			$wgDPL2Options['notnamespace'] = $wgDPL2AllowedNamespaces;
+		else
+			$wgDPL2Options['notnamespace'] = array_intersect($wgDPL2Options['notnamespace'], $wgDPL2AllowedNamespaces);
+		if( !isset($wgDPL2Options['notnamespace']['default']) )
+			$wgDPL2Options['notnamespace']['default'] = NULL;
+	}
+	
+	// Options
+	$aOrderMethods = explode(',', $wgDPL2Options['ordermethod']['default']);
+	$sOrder = $wgDPL2Options['order']['default'];
+	$sPageListMode = $wgDPL2Options['mode']['default'];
+	$sHListMode = $wgDPL2Options['headingmode']['default'];
+	$sMinorEdits = NULL;
+	$sRedirects = $wgDPL2Options['redirects']['default'];
+	$sInlTxt = $wgDPL2Options['inlinetext']['default'];
+	$bShowNamespace = $wgDPL2Options['shownamespace']['default'] == 'true';
+	$bAddFirstCategoryDate = $wgDPL2Options['addfirstcategorydate']['default'] == 'true';
+	$bAddPageCounter = $wgDPL2Options['addpagecounter']['default'] == 'true';
+	$bAddPageTouchedDate = $wgDPL2Options['addpagetoucheddate']['default'] == 'true';
+	$bAddEditDate = $wgDPL2Options['addeditdate']['default'] == 'true';
+	$bAddUser = $wgDPL2Options['adduser']['default'] == 'true';
+	$bAddCategories = $wgDPL2Options['addcategories']['default'] == 'true';
+	$_incpage = $wgDPL2Options['includepage']['default'];
+	$bIncPage =  is_string($_incpage) && $_incpage !== '';
+	$aSecLabels = array();
+	if($bIncPage && $_incpage != '*')
+		$aSecLabels = explode(',', $_incpage);
+	$aSecSeparators = array();
+    $aSecSeparators  = explode(',', $wgDPL2Options['secseparators']['default']);
+	$_sCount = $wgDPL2Options['count']['default'];
+	$iCount = ($_sCount == '') ? NULL: intval($_sCount);
+	$sListHtmlAttr = $wgDPL2Options['listattr']['default'];
+	$sItemHtmlAttr = $wgDPL2Options['itemattr']['default'];
+	$sHListHtmlAttr = $wgDPL2Options['hlistattr']['default'];
+	$sHItemHtmlAttr = $wgDPL2Options['hitemattr']['default'];
+	$_sTitleMaxLen = $wgDPL2Options['titlemaxlength']['default'];
+	$iTitleMaxLen = ($_sTitleMaxLen == '') ? NULL: intval($_sTitleMaxLen);
+	$tLinksTo = Title::newFromText($localParser->transformMsg($wgDPL2Options['linksto']['default'], $pOptions));
+	
+	$aIncludeCategories = array(); // $aIncludeCategories is a 2-dimensional array: Memberarrays are linked using 'AND'
+	$aExcludeCategories = array();
+	$aCatHeadings = array();
+	$aNamespaces = array();
+	$aExcludeNamespaces  = array();
+	
+	// Output
+	$output = '';
+
+// ###### PARSE PARAMETERS ######
+	$aParams = explode("\n", $input);
+	$bIncludeUncat = false; // to check if pseudo-category of Uncategorized pages is included
+	
+	foreach($aParams as $iParam => $sParam) {
+		
+		$aParam = explode('=', $sParam, 2);
+		if( count( $aParam ) < 2 )
+			continue;
+		$sType = trim($aParam[0]);
+		$sArg = trim($aParam[1]);
+		
+		switch ($sType) {
+			/**
+			 * FILTER PARAMETERS
+			 */
+			case 'category':
+				// Init array of categories to include
+				$aCategories = array();
+				$bHeading = false;
+				if($sArg != '' && $sArg[0] == '+') {// categories are headings
+					$bHeading = true;
+					$sArg[0] = '';
+				}
+				$aParams = explode('|', $sArg);
+				foreach($aParams as $sParam) {
+					$sParam=trim($sParam);
+					if($sParam == '') { // include uncategorized pages (special value: empty string)
+						$bIncludeUncat = true;
+						$aCategories[] = '';
+					} else {
+						$title = Title::newFromText($localParser->transformMsg($sParam, $pOptions));
+						if( !is_null($title) )
+							$aCategories[] = $title->getDbKey();
+					}
+				}
+				if( !empty($aCategories) ) {
+					$aIncludeCategories[] = $aCategories;
+					if($bHeading)
+						$aCatHeadings = array_unique($aCatHeadings + $aCategories);
+				}	
+				break;
+				
+			case 'notcategory':
+				$title = Title::newFromText($localParser->transformMsg($sArg, $pOptions));
+				if( !is_null($title) )
+					$aExcludeCategories[] = $title->getDbKey();
+				break;
+				
+			case 'namespace':
+				$aParams = explode('|', $sArg);
+				foreach($aParams as $sParam) {
+					$sParam=trim($sParam);
+					$sNs = $localParser->transformMsg($sParam, $pOptions);
+					if( !in_array($sNs, $wgDPL2Options['namespace']) )
+						return $logger->msgWrongParam('namespace', $sParam);
+					$aNamespaces[] = $wgContLang->getNsIndex($sNs);
+				}
+				break;
+			
+			case 'notnamespace':
+				$sArg=trim($sArg);
+				$sNs = $localParser->transformMsg($sArg, $pOptions);
+				if( !in_array($sNs, $wgDPL2Options['notnamespace']) )
+					return $logger->msgWrongParam('notnamespace', $sArg);
+				$aExcludeNamespaces[] = $wgContLang->getNsIndex($sNs);
+				break;
+			
+			case 'linksto':
+				$tLinksTo = Title::newFromText($localParser->transformMsg($sArg, $pOptions));
+				if( is_null($tLinksTo) ) // wrong param
+					return $logger->msgWrongParam('linksto', $sArg);
+				break;
+			
+			case 'minoredits':
+				if( in_array($sArg, $wgDPL2Options['minoredits']) )
+					$sMinorEdits = $sArg;
+				else { //wrong param val, using default
+					$sMinorEdits = $wgDPL2Options['minoredits']['default'];
+					$output .= $logger->msgWrongParam('minoredits', $sArg);
+				}
+				break;
+				
+			case 'redirects':
+				if( in_array($sArg, $wgDPL2Options['redirects']) )
+					$sRedirects = $sArg;
+				else
+					$output .= $logger->msgWrongParam('redirects', $sArg);
+				break;
+				
+			case 'count':
+				//ensure that $iCount is a number or no count limit;
+				if( preg_match($wgDPL2Options['count']['pattern'], $sArg) )
+					$iCount = ($sArg == '') ? NULL: intval($sArg);
+				else // wrong value
+					$output .= $logger->msgWrongParam('count', $sArg);
+				break;
+			
+			/**
+			 * CONTENT PARAMETERS
+			 */
+			case 'addcategories':
+				if( in_array($sArg, $wgDPL2Options['addcategories']))
+					$bAddCategories = $sArg == 'true';
+				else
+					$output .= $logger->msgWrongParam('addcategories', $sArg);
+				break;
+			
+			case 'addeditdate':
+				if( in_array($sArg, $wgDPL2Options['addeditdate']))
+					$bAddEditDate = $sArg == 'true';
+				else
+					$output .= $logger->msgWrongParam('addeditdate', $sArg);
+				break;
+			
+			case 'addfirstcategorydate':
+				if( in_array($sArg, $wgDPL2Options['addfirstcategorydate']))
+					$bAddFirstCategoryDate = $sArg == 'true';
+				else
+					$output .= $logger->msgWrongParam('addfirstcategorydate', $sArg);
+				break;
+				
+			case 'addpagecounter':
+				if( in_array($sArg, $wgDPL2Options['addpagecounter']))
+					$bAddPageCounter = $sArg == 'true';
+				else
+					$output .= $logger->msgWrongParam('addpagecounter', $sArg);
+				break;
+				
+			case 'addpagetoucheddate':
+				if( in_array($sArg, $wgDPL2Options['addpagetoucheddate']))
+					$bAddPageTouchedDate = $sArg == 'true';
+				else
+					$output .= $logger->msgWrongParam('addpagetoucheddate', $sArg);
+				break;
+			
+			case 'includepage':
+				$bIncPage =  $sArg !== '';
+				if($bIncPage && $sArg != '*')
+					$aSecLabels= explode(',', $sArg);
+				break;
+
+			case 'adduser':
+				if( in_array($sArg, $wgDPL2Options['adduser']))
+					$bAddUser = $sArg == 'true';
+				else
+					$output .= $logger->msgWrongParam('adduser', $sArg);
+				break;
+				
+			/**
+			 * ORDER PARAMETERS
+			 */	
+			case 'ordermethod':
+				if( in_array($sArg, $wgDPL2Options['ordermethod']) )
+					$aOrderMethods = explode(',', $sArg);
+				else
+					$output .= $logger->msgWrongParam('ordermethod', $sArg);
+				break;
+			
+			case 'order':
+				if( in_array($sArg, $wgDPL2Options['order']) )
+					$sOrder = $sArg;
+				else
+					$output .= $logger->msgWrongParam('order', $sArg);
+				break;
+				
+			/**
+			 * FORMAT/HTML PARAMETERS
+			 * @todo allow addpagetoucheddate, addeditdate, adduser, addcategories to have effect with 'mode=category'
+			 */
+			case 'headingmode':
+				if( in_array($sArg, $wgDPL2Options['headingmode']) )
+					$sHListMode = $sArg;
+				else
+					$output .= $logger->msgWrongParam('headingmode', $sArg);
+				break;
+				
+			case 'mode':
+				if( in_array($sArg, $wgDPL2Options['mode']) )
+					//'none' mode is implemented as a specific submode of 'inline' with <BR/> as inline text
+					if($sArg == 'none') {
+						$sPageListMode = 'inline';
+						$sInlTxt = '<BR/>';
+					} else
+					$sPageListMode = $sArg;
+				else
+					$output .= $logger->msgWrongParam('mode', $sArg);
+				break;
+				
+			case 'inlinetext':
+				//parse wiki text and get HTML output
+				$sInlTxt = $parser->recursiveTagParse($sArg);
+				break;
+			
+			case 'secseparators':
+				//parse wiki text and get HTML output
+				$aSecSeparators = explode (',', $parser->recursiveTagParse($sArg), 4);
+				break;
+			
+			case 'shownamespace':
+				if( in_array($sArg, $wgDPL2Options['shownamespace']))
+					$bShowNamespace = $sArg == 'true';
+				else
+					$output .= $logger->msgWrongParam('shownamespace', $sArg);
+				break;
+			
+			case 'titlemaxlength':
+				//processed like 'count' param
+				if( preg_match($wgDPL2Options['titlemaxlength']['pattern'], $sArg) )
+					$iTitleMaxLen = ($sArg == '') ? NULL: intval($sArg);
+				else // wrong value
+					$output .= $logger->msgWrongParam('titlemaxlength', $sArg);
+				break;
+				
+			case 'listattr':
+				$sListHtmlAttr = $sArg;
+				break;
+			case 'itemattr':
+				$sItemHtmlAttr = $sArg;
+				break;
+			case 'hlistattr':
+				$sHListHtmlAttr = $sArg;
+				break;
+			case 'hitemattr':
+				$sHItemHtmlAttr = $sArg;
+				break;
+				
+			/**
+			 * DEBUG PARAMETER
+			 */
+			case 'debug':
+				if( in_array($sArg, $wgDPL2Options['debug']) ) {
+					if($iParam > 1)
+						$output .= $logger->escapeMsg(DPL2_WARN_DEBUGPARAMNOTFIRST, $sArg );
+					$logger->iDebugLevel = intval($sArg);
+				}
+				else
+					$output .= $logger->msgWrongParam('debug', $sArg);
+				break;
+				
+			/**
+			 * UNKNOWN PARAMETER
+			 */
+			default:
+				$output .= $logger->escapeMsg(DPL2_WARN_UNKNOWNPARAM, $sType, implode(', ', array_keys($wgDPL2Options)));
+		}
+	}
+	
+	$iIncludeCatCount = count($aIncludeCategories);
+	$iTotalIncludeCatCount = count($aIncludeCategories, COUNT_RECURSIVE) - $iIncludeCatCount;
+	$iExcludeCatCount = count($aExcludeCategories);
+	$iTotalCatCount = $iTotalIncludeCatCount + $iExcludeCatCount;
+
+// ###### CHECKS ON PARAMETERS ######
+	// too many categories!!
+	if ( ($iTotalCatCount > $wgDPL2MaxCategoryCount) && (!$wgDPL2AllowUnlimitedCategories) )
+		return $logger->escapeMsg(DPL2_ERR_TOOMANYCATS, $wgDPL2MaxCategoryCount);
+
+	// too few categories!!
+	if ($iTotalCatCount < $wgDPL2MinCategoryCount)
+		return $logger->escapeMsg(DPL2_ERR_TOOFEWCATS, $wgDPL2MinCategoryCount);
+		
+	// no included categories but ordermethod=categoryadd or addfirstcategorydate=true!!
+	if ($iTotalIncludeCatCount == 0 && ($aOrderMethods[0] == 'categoryadd' || $bAddFirstCategoryDate == true) )
+		return $logger->escapeMsg(DPL2_ERR_CATDATEBUTNOINCLUDEDCATS);
+
+	// more than one included category but ordermethod=categoryadd or addfirstcategorydate=true!!
+	if ($iTotalIncludeCatCount > 1 && ($aOrderMethods[0] == 'categoryadd' || $bAddFirstCategoryDate == true) )
+		return $logger->escapeMsg(DPL2_ERR_CATDATEBUTMORETHAN1CAT);
+		
+	// no more than one type of date at a time!!
+	if($bAddPageTouchedDate + $bAddFirstCategoryDate + $bAddEditDate > 1)
+		return $logger->escapeMsg(DPL2_ERR_MORETHAN1TYPEOFDATE);
+
+	// category-style output requested with not compatible order method
+	if ($sPageListMode == 'category' && !array_intersect($aOrderMethods, array('sortkey', 'title')) )
+		return $logger->escapeMsg(DPL2_ERR_WRONGORDERMETHOD,  'mode=category', 'sortkey | title' );
+	
+	// addpagetoucheddate=true with unappropriate order methods
+	if( $bAddPageTouchedDate && !array_intersect($aOrderMethods, array('pagetouched', 'title')) )
+		return $logger->escapeMsg(DPL2_ERR_WRONGORDERMETHOD,  'addpagetoucheddate=true', 'pagetouched | title' );
+	
+	// addeditdate=true but not (ordermethod=...,firstedit or ordermethod=...,lastedit)
+	//firstedit (resp. lastedit) -> add date of first (resp. last) revision
+	if( $bAddEditDate && !array_intersect($aOrderMethods, array('firstedit', 'lastedit')) )
+		return $logger->escapeMsg(DPL2_ERR_WRONGORDERMETHOD, 'addeditdate=true', 'firstedit | lastedit' );
+	
+	// adduser=true but not (ordermethod=...,firstedit or ordermethod=...,lastedit)
+	/**
+	 * @todo allow to add user for other order methods.
+	 * The fact is a page may be edited by multiple users. Which user(s) should we show? all? the first or the last one?
+	 * Ideally, we could use values such as 'all', 'first' or 'last' for the adduser parameter.
+	*/
+	if( $bAddUser && !array_intersect($aOrderMethods, array('firstedit', 'lastedit')) )
+		return $logger->escapeMsg(DPL2_ERR_WRONGORDERMETHOD, 'adduser=true', 'firstedit | lastedit' );
+	
+	if( isset($sMinorEdits) && !array_intersect($aOrderMethods, array('firstedit', 'lastedit')) )
+		return $logger->escapeMsg(DPL2_ERR_WRONGORDERMETHOD, 'minoredits', 'firstedit | lastedit' );
+	
+	/**
+	 * If we include the Uncategorized, we need the 'dpl_clview': VIEW of the categorylinks table where we have cl_to='' (empty string) for all uncategorized pages. This VIEW must have been created by the administrator of the mediawiki DB at installation. See the documentation.
+	 */
+	$dbr =& wfGetDB( DB_SLAVE );
+	$sPageTable = $dbr->tableName( 'page' );
+	$sCategorylinksTable = $dbr->tableName( 'categorylinks' );
+	$sDplClView = '';
+	if($bIncludeUncat) {
+		$sDplClView = $dbr->tableName( 'dpl_clview' );
+		// If the view is not there, we can't perform logical operations on the Uncategorized.
+		if ( !$dbr->tableExists( 'dpl_clview' ) ) {
+			$sSqlCreate_dpl_clview = 'CREATE VIEW ' . $sDplClView . " AS SELECT IFNULL(cl_from, page_id) AS cl_from, IFNULL(cl_to, '') AS cl_to, cl_sortkey FROM " . $sPageTable . ' LEFT OUTER JOIN ' . $sCategorylinksTable . ' ON page_id=cl_from';
+			$output .= $logger->escapeMsg(DPL2_ERR_NOCLVIEW, $sDplClView, $sSqlCreate_dpl_clview);
+			return $output;
+		}
+	}
+	
+	//add*** parameters have no effect with 'mode=category' (only namespace/title can be viewed in this mode)
+	if( $sPageListMode == 'category' && ($bAddCategories || $bAddEditDate || $bAddFirstCategoryDate || $bAddPageTouchedDate || $bIncPage || $bAddUser) )
+		$output .= $logger->escapeMsg(DPL2_WARN_CATOUTPUTBUTWRONGPARAMS);
+		
+	//headingmode has effects with ordermethod on multiple components only
+	if( $sHListMode != 'none' && count($aOrderMethods) < 2 ) {
+		$output .= $logger->escapeMsg(DPL2_WARN_HEADINGBUTSIMPLEORDERMETHOD, $sHListMode, 'none');
+		$sHListMode = 'none';
+	}
+
+	// justify limits
+	if ( isset($iCount) ) {
+		if($iCount > $wgDPL2MaxResultCount)
+			$iCount = $wgDPL2MaxResultCount;
+	} elseif(!$wgDPL2AllowUnlimitedResults)
+		$iCount = $wgDPL2MaxResultCount;
+
+
+// ###### BUILD SQL QUERY ######
+	$sSqlPage_counter = '';
+	$sSqlPage_touched = '';
+	$sSqlSortkey = '';
+	$sSqlCl_to = '';
+	$sSqlCats = '';
+	$sSqlCl_timestamp = '';
+	$sSqlClHeadTable = '';
+	$sSqlCond_page_cl_head = '';
+	$sSqlClTableForGC = '';
+	$sSqlCond_page_cl_gc = '';
+	$sRevisionTable = $dbr->tableName( 'revision' );
+	$sSqlRevisionTable = '';
+	$sSqlRev_timestamp = '';
+	$sSqlRev_user = '';
+	$sSqlCond_page_rev = '';
+	$sPageLinksTable = $dbr->tableName( 'pagelinks' );
+	$sSqlPageLinksTable = '';
+	$sSqlCond_page_pl = '';
+	$sSqlWhere = ' WHERE 1=1 ';
+	$sSqlGroupBy = '';
+	
+	foreach($aOrderMethods as $sOrderMethod) {
+		switch ($sOrderMethod) {
+			case 'category':
+				$sSqlCl_to = "cl_head.cl_to, "; // Gives category headings in the result
+				$sSqlClHeadTable = ( in_array('', $aCatHeadings) ? $sDplClView : $sCategorylinksTable ) . ' AS cl_head'; // use dpl_clview if Uncategorized in headings
+				$sSqlCond_page_cl_head = 'page_id=cl_head.cl_from';
+				if(!empty($aCatHeadings))
+					$sSqlWhere .= " AND cl_head.cl_to IN (" . $dbr->makeList( $aCatHeadings ) . ")";
+				break;
+			case 'firstedit':
+				$sSqlRevisionTable = $sRevisionTable . ' AS rev, ';
+				$sSqlRev_timestamp = ', rev_timestamp';
+				$sSqlCond_page_rev = ' AND page_id=rev.rev_page AND rev.rev_timestamp=( SELECT MIN(rev_aux.rev_timestamp) FROM ' . $sRevisionTable . ' AS rev_aux WHERE rev_aux.rev_page=rev.rev_page )';
+				break;
+			case 'lastedit':
+				$sSqlRevisionTable = $sRevisionTable . ' AS rev, ';
+				$sSqlRev_timestamp = ', rev_timestamp';
+				$sSqlCond_page_rev = ' AND page_id=rev.rev_page AND rev.rev_timestamp=( SELECT MAX(rev_aux.rev_timestamp) FROM ' . $sRevisionTable . ' AS rev_aux WHERE rev_aux.rev_page=rev.rev_page )';
+				break;
+			case 'sortkey':
+				// We need the namespaces with strictly positive indices (DPL2 allowed namespaces, except the first one: Main).
+				$aStrictNs = array_slice($wgDPL2AllowedNamespaces, 1, count($wgDPL2AllowedNamespaces), true);
+				// map ns index to name
+				$sSqlNsIdToText = 'CASE page_namespace';
+				foreach($aStrictNs as $iNs => $sNs)
+					$sSqlNsIdToText .= ' WHEN ' . intval( $iNs ) . " THEN " . $dbr->addQuotes( $sNs );
+				$sSqlNsIdToText .= ' END';
+				// If cl_sortkey is null (uncategorized page), generate a sortkey in the usual way (full page name, underscores replaced with spaces).
+				/**AP20070503*/
+				$sSqlSortkey = ", IFNULL(cl_head.cl_sortkey, page_title) as sortkey";
+				break;
+			case 'title':
+				$aStrictNs = array_slice($wgDPL2AllowedNamespaces, 1, count($wgDPL2AllowedNamespaces), true);
+				// map ns index to name
+				$sSqlNsIdToText = 'CASE page_namespace';
+				foreach($aStrictNs as $iNs => $sNs)
+					$sSqlNsIdToText .= ' WHEN ' . intval( $iNs ) . " THEN " . $dbr->addQuotes( $sNs ) ;
+				$sSqlNsIdToText .= ' END';
+				// Generate sortkey like for category links.
+				/**AP20070503*/
+				$sSqlSortkey = ", page_title as sortkey";
+				break;
+			case 'user':
+				$sSqlRevisionTable = $sRevisionTable . ', ';
+				$sSqlRev_user = ', rev_user, rev_user_text';
+				break;
+		}
+	}
+	
+	if ( !is_null($tLinksTo) ) {
+		$sSqlPageLinksTable = $sPageLinksTable . ' as pl, ';
+		$sSqlCond_page_pl = ' AND page_id=pl.pl_from  AND pl.pl_namespace=' . intval( $tLinksTo->getNamespace() ) . 
+			" AND pl.pl_title=" . $dbr->addQuotes( $tLinksTo->getDbKey() );
+ 	}
+	
+	if ($bAddFirstCategoryDate)
+		//format cl_timestamp field (type timestamp) to string in same format as rev_timestamp field
+		//to make it compatible with $wgLang->date() function used in function DPL2OutputListStyle() to show "firstcategorydate"
+		$sSqlCl_timestamp = ", DATE_FORMAT(cl0.cl_timestamp, '%Y%m%d%H%i%s') AS cl_timestamp";
+	if ($bAddPageCounter)
+		$sSqlPage_counter = ', page_counter';
+	if ($bAddPageTouchedDate)
+		$sSqlPage_touched = ', page_touched';
+	if ($bAddUser)
+		$sSqlRev_user = ', rev_user, rev_user_text';
+	if ($bAddCategories) {
+		$sSqlCats = ", GROUP_CONCAT(DISTINCT cl_gc.cl_to ORDER BY cl_gc.cl_to ASC SEPARATOR ' | ') AS cats"; // Gives list of all categories linked from each article, if any.
+		$sSqlClTableForGC = $sCategorylinksTable . ' AS cl_gc'; // Categorylinks table used by the Group Concat (GC) function above
+		$sSqlCond_page_cl_gc = 'page_id=cl_gc.cl_from';
+		$sSqlGroupBy = ' GROUP BY ' . $sSqlCl_to . 'page_id';
+	}
+	
+	// SELECT ... FROM
+	$sSqlSelectFrom = 'SELECT DISTINCT ' . $sSqlCl_to . 'page_namespace, page_title' . $sSqlSortkey . $sSqlPage_counter . $sSqlPage_touched . $sSqlRev_user . $sSqlRev_timestamp . $sSqlCats . $sSqlCl_timestamp . ' FROM ' . $sSqlRevisionTable . $sSqlPageLinksTable . $sPageTable;
+	
+	// JOIN ...
+	if($sSqlClHeadTable != '' || $sSqlClTableForGC != '') {
+		$b2tables = ($sSqlClHeadTable != '') && ($sSqlClTableForGC != '');
+		$sSqlSelectFrom .= ' LEFT OUTER JOIN (' . $sSqlClHeadTable . ($b2tables ? ', ' : '') . $sSqlClTableForGC . ') ON (' . $sSqlCond_page_cl_head . ($b2tables ? ' AND ' : '') . $sSqlCond_page_cl_gc . ')';
+	}
+	
+	// Include categories...
+	$iClTable = 0;
+	for ($i = 0; $i < $iIncludeCatCount; $i++) {
+		// If we want the Uncategorized
+		$sSqlSelectFrom .= ' INNER JOIN ' . ( in_array('', $aIncludeCategories[$i]) ? $sDplClView : $sCategorylinksTable ) . ' AS cl' . $iClTable . ' ON page_id=cl' . $iClTable . '.cl_from AND (cl' . $iClTable . '.cl_to=' . $dbr->addQuotes($aIncludeCategories[$i][0]);
+		for ($j = 1; $j < count($aIncludeCategories[$i]); $j++)
+			$sSqlSelectFrom .= ' OR cl' . $iClTable . '.cl_to=' . $dbr->addQuotes($aIncludeCategories[$i][$j]);
+		$sSqlSelectFrom .= ') ';
+		$iClTable++;
+	}
+	
+	// Exclude categories...
+	for ($i = 0; $i < $iExcludeCatCount; $i++) {
+		$sSqlSelectFrom .=
+			' LEFT OUTER JOIN ' . $sCategorylinksTable . ' AS cl' . $iClTable .
+			' ON page_id=cl' . $iClTable . '.cl_from' .
+			' AND cl' . $iClTable . '.cl_to=' . $dbr->addQuotes($aExcludeCategories[$i]);
+		$sSqlWhere .= ' AND cl' . $iClTable . '.cl_to IS NULL';
+		$iClTable++;
+	}
+
+	// WHERE... (actually finish the WHERE clause we may have started if we excluded categories - see above)
+	// Namespace IS ...
+	if ( !empty($aNamespaces)) {
+		$sSqlWhere .= ' AND page_namespace IN (' . $dbr->makeList( $aNamespaces) . ')';
+	}
+	// Namespace IS NOT ...
+    if ( !empty($aExcludeNamespaces)) {
+        $sSqlWhere .= ' AND page_namespace NOT IN (' . $dbr->makeList( $aExcludeNamespaces ) . ')';
+    }
+    // rev_minor_edit IS
+    if( isset($sMinorEdits) && $sMinorEdits == 'exclude' )
+		$sSqlWhere .= ' AND rev_minor_edit=0';
+	// page_is_redirect IS ...	
+	switch ($sRedirects) {
+		case 'only':
+			$sSqlWhere .= ' AND page_is_redirect=1';
+			break;
+		case 'exclude':
+			$sSqlWhere .= ' AND page_is_redirect=0';
+			break;
+	}
+	
+	// page_id=rev_page (if revision table required)
+	$sSqlWhere .= $sSqlCond_page_rev;
+	// page_id=pl.pl_from (if pagelinks table required)
+	$sSqlWhere .= $sSqlCond_page_pl;
+	
+	// GROUP BY ...
+	$sSqlWhere .= $sSqlGroupBy;
+	
+	// ORDER BY ...
+	$sSqlWhere .= ' ORDER BY ';
+	foreach($aOrderMethods as $i => $sOrderMethod) {
+		if($i > 0)
+			$sSqlWhere .= ', ';
+		switch ($sOrderMethod) {
+			case 'category':
+				$sSqlWhere .= 'cl_head.cl_to';
+				break;
+			case 'categoryadd':
+				$sSqlWhere .= 'cl0.cl_timestamp';
+				break;
+			case 'counter':
+				$sSqlWhere .= 'page_counter';
+				break;
+			case 'firstedit':
+			case 'lastedit':
+				$sSqlWhere .= 'rev_timestamp';
+				break;
+			case 'pagetouched':
+				$sSqlWhere .= 'page_touched';
+				break;
+			case 'sortkey':
+			case 'title':
+				$sSqlWhere .= 'sortkey';
+				break;
+			case 'user':
+				// rev_user_text can discriminate anonymous users (e.g. based on IP), rev_user cannot (=' 0' for all)
+				$sSqlWhere .= 'rev_user_text';
+				break;
+		}
+	}
+	if ($sOrder == 'descending')
+		$sSqlWhere .= ' DESC';
+	else
+		$sSqlWhere .= ' ASC';
+
+	// LIMIT ....
+	if ( isset($iCount) )
+		$sSqlWhere .= ' LIMIT ' . intval( $iCount );
+
+
+
+// ###### PROCESS SQL QUERY ######
+	//DEBUG: output SQL query 
+	$output .= $logger->escapeMsg(DPL2_QUERY, $sSqlSelectFrom . $sSqlWhere);
+	//echo 'QUERY: [' . $sSqlSelectFrom . $sSqlWhere . "]<br />";
+
+	$res = $dbr->query($sSqlSelectFrom . $sSqlWhere);
+	if ($dbr->numRows( $res ) == 0) {
+		$output .= $logger->escapeMsg(DPL2_WARN_NORESULTS);
+		return $output;
+	}
+	
+	$sk =& $wgUser->getSkin();
+	// generate link to Special:Uncategorizedpages (used if ordermethod=category,...)
+	$tSpecUncat = Title::makeTitle( NS_SPECIAL, 'Uncategorizedpages' );
+	$sSpecUncatLnk = $sk->makeKnownLinkObj( $tSpecUncat, wfMsg('uncategorizedpages') );
+	// generate title for Special:Contributions (used if adduser=true)
+	$tSpecContribs = Title::makeTitle( NS_SPECIAL, 'Contributions' );
+	// linkBatch used to check the existence of titles
+	$linkBatch = new LinkBatch();
+	$aHeadings = array(); // maps heading to count (# of pages under each heading)
+	//heading titles to be checked by $linkBatch for existence
+	$aUncheckedHeadingTitles = array();
+	$aArticles = array();
+	//user titles to be checked by $linkBatch for existence
+	$aUncheckedUserTitles = array();
+	//category titles to be checked by $linkBatch for existence
+	$aUncheckedCatTitles = array();
+	
+	$iArticle = 0;
+	while( $row = $dbr->fetchObject ( $res ) ) {
+		//PAGE TITLE
+		$title = Title::makeTitle($row->page_namespace, $row->page_title);
+		$dplArticle = new DPL2Article( $title );
+		//PAGE LINK
+		$sTitleText = $title->getText();
+		//chop off title if "too long"
+		if( isset($iTitleMaxLen) && (strlen($sTitleText) > $iTitleMaxLen) )
+			$sTitleText = substr($sTitleText, 0, $iTitleMaxLen) . '...';
+		if ($bShowNamespace)
+			//Adapted from Title::getPrefixedText()
+            $sTitleText = str_replace( '_', ' ', $title->prefix($sTitleText) );
+		//AP20070710
+		$titleText = $wgContLang->convert( $sTitleText);
+		$pick = 'Human';
+		if (isset($_GET["browse"])){
+                        $pick = $_GET["browse"];
+		}
+		if(preg_match('/\:/', $titleText) && $pick != 'All Species'){
+			$parts = explode(':', $titleText);
+			if(count($parts) < 1){
+				throw new Exception("Invalid pathway article title: $titleText");
+                	}
+			$titleSpecies = array_shift($parts); 
+                	$titleText = array_shift($parts);
+		}
+		$articleLink = $sk->makeKnownLinkObj( $title, htmlspecialchars( $titleText)); // $wgContLang->convert( $sTitleText ) ) );
+		$dplArticle->mLink = $articleLink;
+		
+		//get first char used for category-style output
+		if( isset($row->sortkey) )
+			$dplArticle->mStartChar = $wgContLang->convert($wgContLang->firstChar($row->sortkey));
+			
+		//SHOW PAGE_COUNTER
+		if( isset($row->page_counter) )
+			$dplArticle->mCounter = $row->page_counter;
+		
+		//SHOW "PAGE_TOUCHED" DATE, "FIRSTCATEGORYDATE" OR (FIRST/LAST) EDIT DATE
+		if($bAddPageTouchedDate)
+			$dplArticle->mDate = $row->page_touched;
+		elseif ($bAddFirstCategoryDate)
+			$dplArticle->mDate = $row->cl_timestamp;
+		elseif ($bAddEditDate)
+			$dplArticle->mDate = $row->rev_timestamp;
+		
+		//USER/AUTHOR(S)
+		if($bAddUser)
+			// Adapted from Linker::userLink()
+			if($row->rev_user == 0) { //anonymous user
+				$encName = htmlspecialchars( $row->rev_user_text );
+				$dplArticle->mUserLink = $sk->makeKnownLinkObj($tSpecContribs,  $encName, 'target=' . urlencode($row->rev_user_text) );
+			} else {
+				$tUser = Title::makeTitle( NS_USER, $row->rev_user_text );
+				//The user title may not exist. Add title to LinkBatch to check that out and to make link accordingly.
+				$linkBatch->addObj($tUser);
+				$aUncheckedUserTitles[$iArticle] = $tUser;
+			}
+		
+		//CATEGORY LINKS FROM CURRENT PAGE 
+		if($bAddCategories && ($row->cats != '')) {
+			$artCatNames = explode(' | ', $row->cats);
+			foreach($artCatNames as $iArtCat => $artCatName) {
+				$tArtCat = Title::makeTitle(NS_CATEGORY, $artCatName);
+				//The category title may not exist. Add title to LinkBatch to check that out and to make link accordingly.
+				$linkBatch->addObj($tArtCat);
+				$aUncheckedCatTitles[$iArticle][$iArtCat] = $tArtCat;
+				$dplArticle->mCategoryLinks[] = NULL; //will be set later after link check
+			}
+		}
+		
+		// PARENT HEADING (category of the page, editor (user) of the page, etc. Depends on ordermethod param)
+		if($sHListMode != 'none') {
+			switch($aOrderMethods[0]) {
+				case 'category':
+					//count one more page in this heading
+					$aHeadings[$row->cl_to] = isset($aHeadings[$row->cl_to]) ? $aHeadings[$row->cl_to] + 1 : 1;
+					if($row->cl_to == '') //uncategorized page
+						$dplArticle->mParentHLink = $sSpecUncatLnk;
+					else {
+						$tCat = Title::makeTitle(NS_CATEGORY, $row->cl_to);
+						//The category title may not exist. Add title to LinkBatch to check that out and to make link accordingly.
+						$linkBatch->addObj($tCat);
+						$aUncheckedHeadingTitles[$iArticle] = $tCat;
+					}
+					break;
+				case 'user':
+					$aHeadings[$row->rev_user_text] = isset($aHeadings[$row->rev_user_text]) ? $aHeadings[$row->rev_user_text] + 1 : 1;
+					// Adapted from Linker::userLink()
+					if($row->rev_user == 0) { //anonymous user
+						$encName = htmlspecialchars( $row->rev_user_text );
+						$dplArticle->mParentHLink = $sk->makeKnownLinkObj($tSpecContribs,  $encName, 'target=' . urlencode($row->rev_user_text) );
+					} else {
+						$tUser = Title::makeTitle( NS_USER, $row->rev_user_text );
+						//The user title may not exist. Add title to LinkBatch to check that out and to make link accordingly.
+						$linkBatch->addObj($tUser);
+						$aUncheckedHeadingTitles[$iArticle] = $tUser;
+					}
+					break;
+			}
+		}
+		
+		$aArticles[] = $dplArticle;
+		$iArticle++;
+	}
+	$dbr->freeResult( $res );
+	
+	//check titles in $linkBatch and update links accordingly
+	$linkCache = new LinkCache();
+	$linkBatch->executeInto($linkCache);
+	DPL2UpdateArticleMemberLinks($aUncheckedHeadingTitles, $linkCache, $aArticles, 'mParentHLink');
+	DPL2UpdateArticleMemberLinks($aUncheckedUserTitles, $linkCache, $aArticles, 'mUserLink');
+	DPL2UpdateArticleMemberLinks($aUncheckedCatTitles, $linkCache, $aArticles, 'mCategoryLinks');
+
+// ###### SHOW OUTPUT ######
+	$listMode = new DPL2ListMode($sPageListMode, $aSecSeparators, $sInlTxt, $sListHtmlAttr, $sItemHtmlAttr);
+	$hListMode = new DPL2ListMode($sHListMode, $aSecSeparators, '', $sHListHtmlAttr, $sHItemHtmlAttr);
+	$dpl = new DPL2($aHeadings, $aArticles, $aOrderMethods[0], $hListMode, $listMode, $bIncPage, $aSecLabels, $parser, $logger);
+	return $output . $dpl->getText();
+}
+
+
+// Simple Article/Page class with properties used in the DPL
+class DPL2Article {
+	var $mTitle = ''; // title
+	var $mLink = ''; // html link to page
+	var $mStartChar = ''; // page title first char
+	var $mParentHLink = ''; // heading (link to the associated page) that page belongs to in the list (default '' means no heading)
+	var $mCategoryLinks = array(); // category links in the page
+	var $mCounter = ''; // Number of times this page has been viewed
+	var $mDate = ''; // timestamp depending on the user's request (can be first/last edit, page_touched, ...)
+	var $mUserLink = ''; // link to editor (first/last, depending on user's request) 's page or contributions if not registered
+	
+	function DPL2Article($title) {
+		$this->mTitle = $title;
+	}
+}
+
+
+// Updates links in the members (parent heading, category links...) of a DPL2Article according to a LinkCache object
+function DPL2UpdateArticleMemberLinks($titles, $linkcache, &$articles, $member) {
+	global $wgUser, $wgContLang;
+	$sk =& $wgUser->getSkin();
+	foreach($titles as $tkey => $titleval) {
+		if($member == 'mCategoryLinks') { // $titleval is an array
+			foreach($titleval as $catKey => $catTitle) {
+				$linkText = htmlspecialchars( $wgContLang->convertHtml($catTitle->getText()) );
+				$articles[$tkey]->mCategoryLinks[$catKey] = $linkcache->isBadLink($catTitle->getPrefixedDbKey()) ? $sk->makeBrokenLinkObj($catTitle, $linkText) : $sk->makeKnownLinkObj($catTitle, $linkText);
+			}
+		} else {
+				$linkText = htmlspecialchars( $wgContLang->convertHtml($titleval->getText()) );
+				$articles[$tkey]->$member = $linkcache->isBadLink($titleval->getPrefixedDbKey()) ? $sk->makeBrokenLinkObj($titleval, $linkText) : $sk->makeKnownLinkObj($titleval, $linkText);
+		}
+	}
+}
+
+
+class DPL2ListMode {
+	var $name;
+	var $sListStart = '';
+	var $sListEnd = '';
+	var $sHeadingStart = '';
+	var $sHeadingEnd = '';
+	var $sItemStart = '';
+	var $sItemEnd = '';
+	var $sInline = '';
+	var $sSecStartAll = '';
+	var $sSecStart = '';
+	var $sSecEnd = '';
+	var $sSecEndAll = '';
+	
+	function DPL2ListMode($listmode, $secseparators, $inlinetext = '&nbsp;-&nbsp', $listattr = '', $itemattr = '') {
+		$this->name = $listmode;
+		$_listattr = ($listattr == '') ? '' : ' ' . Sanitizer::fixTagAttributes( $listattr, 'ul' );
+		$_itemattr = ($itemattr == '') ? '' : ' ' . Sanitizer::fixTagAttributes( $itemattr, 'li' );
+		
+		switch(count($secseparators)) {
+			case 4:
+				$this->sSecEndAll = $secseparators[3];
+			case 3:
+				$this->sSecEnd = $secseparators[2];
+			case 2:
+				$this->sSecStart = $secseparators[1];
+			case 1:
+				$this->sSecStartAll = $secseparators[0];
+		}
+
+		switch ($listmode) {
+			case 'inline':
+				if( stristr($inlinetext, '<BR />') ) { //one item per line (pseudo-inline)
+					$this->sListStart = '<DIV'. $_listattr . '>';
+					$this->sListEnd = '</DIV>';
+				}
+				$this->sItemStart = '<SPAN' . $_itemattr . '>';
+				$this->sItemEnd = '</SPAN>';
+				$this->sInline = $inlinetext;
+				break;
+			case 'ordered':
+				$this->sListStart = '<OL' . $_listattr . '>';
+				$this->sListEnd = '</OL>';
+				$this->sItemStart = '<LI'. $_itemattr . '>';
+				$this->sItemEnd = '</LI>';
+				break;
+			case 'unordered':
+				$this->sListStart = '<UL' . $_listattr . '>';
+				$this->sListEnd = '</UL>';
+				$this->sItemStart = '<LI' . $_itemattr . '>';
+				$this->sItemEnd = '</LI>';
+				break;
+			case 'definition':
+				$this->sListStart = '<DL' . $_listattr . '>';
+				$this->sListEnd = '</DL>';
+				// item html attributes on dt element or dd element ?
+				$this->sHeadingStart = '<DT>';
+				$this->sHeadingEnd = '</DT><DD>';
+				$this->sItemEnd = '</DD>';
+				break;
+			case 'H2':
+			case 'H3':
+			case 'H4':
+				$this->sListStart = '<DIV' . $_listattr . '>';
+				$this->sListEnd = '</DIV>';
+				$this->sHeadingStart = '<' . $listmode .'>';
+				$this->sHeadingEnd = '</' . $listmode . '>';
+				break;
+		}
+	}
+}
+
+
+class DPL2 {
+	
+	var $mArticles;
+	var $mHeadingType; // type of heading: category, user, etc. (depends on 'ordermethod' param)
+	var $mHListMode; // html list mode for headings
+	var $mListMode; // html list mode for pages
+	var $mIncPage; // true only if page transclusion is enabled
+	var $mIncSecLabels = array(); // array of labels of sections to transclude
+	var $mParser;
+	var $mParserOptions;
+	var $mParserTitle;
+	var $mLogger; // DPL2Logger
+	var $mOutput;
+	
+	function DPL2($headings, $articles, $headingtype, $hlistmode, $listmode, $includepage, $includeseclabels,&$parser, $logger) {
+		$this->mArticles = $articles;
+		$this->mListMode = $listmode;
+		$this->mIncPage = $includepage;
+		if($includepage)
+			$this->mIncSecLabels = $includeseclabels;
+		$this->mParser = $parser;
+		$this->mParserOptions = $parser->getOptions();
+		$this->mParserTitle = $parser->getTitle();
+		$this->mLogger = $logger;
+		
+		if(!empty($headings)) {
+			$this->mHeadingType = $headingtype;
+			$this->mHListMode = $hlistmode;
+			$this->mOutput .= $hlistmode->sListStart;
+			$headingStart = 0;
+			foreach($headings as $heading => $headingCount) {
+				$headingLink = $articles[$headingStart]->mParentHLink;
+				$this->mOutput .= $hlistmode->sItemStart;
+				$this->mOutput .= $hlistmode->sHeadingStart . $headingLink . $hlistmode->sHeadingEnd;
+				$this->mOutput .= $this->formatCount($headingCount);
+				$this->mOutput .= $this->formatList($headingStart, $headingCount);
+				$this->mOutput .= $hlistmode->sItemEnd;
+				$headingStart += $headingCount;
+			}
+			$this->mOutput .= $hlistmode->sListEnd;
+		} else
+			$this->mOutput .= $this->formatList(0, count($articles));
+	}
+	
+	function formatCount($numart) {
+		global $wgLang;
+		if($this->mHeadingType == 'category')
+			$message = 'categoryarticlecount';
+		else 
+			$message = 'dpl2_articlecount';
+		return '<p>' . $this->msgExt( $message, array( 'parse' ), $numart) . '</p>';
+	}
+	
+	function formatList($iStart, $iCount) {
+		global $wgUser, $wgLang, $wgContLang;
+		
+		$mode = $this->mListMode;
+		//categorypage-style list output mode
+		if($mode->name == 'category')
+			return $this->formatCategoryList($iStart, $iCount);
+		
+		//other list modes
+		$sk = & $wgUser->getSkin();
+		// generate link to Special:Categories (used if addcategories=true)
+		$tSpecCats = Title::makeTitle( NS_SPECIAL, 'Categories' );
+		$sSpecCatsLnk = $sk->makeKnownLinkObj( $tSpecCats, wfMsg('categories'));
+		
+		//process results of query, outputing equivalent of <li>[[Article]]</li> for each result,
+		//or something similar if the list uses other startlist/endlist;
+		$r = $mode->sListStart;
+		for ($i = $iStart; $i < $iStart+$iCount; $i++) {
+			if($i > $iStart)
+				$r .= $mode->sInline; //If mode is not 'inline', sInline attribute is empty, so does nothing
+			$r .= $mode->sItemStart;
+			$article = $this->mArticles[$i];
+			if($article->mDate != '')
+				$r .=  $wgLang->timeanddate($article->mDate, true) . ': ';
+			$r .= $article->mLink;
+			if($article->mCounter != '') {
+				// Adapted from SpecialPopularPages::formatResult()
+				$nv = $this->msgExt( 'nviews', array( 'parsemag', 'escape'), $wgLang->formatNum( $article->mCounter ) );
+				$r .=  ' ' . $wgContLang->getDirMark() . '(' . $nv . ')';
+			}
+			if($article->mUserLink != '')
+				$r .= ' . . ' . $article->mUserLink;
+			if( !empty($article->mCategoryLinks) )
+				$r .= ' . . <SMALL>' . $sSpecCatsLnk . ': ' . implode(' | ', $article->mCategoryLinks) . '</SMALL>';
+			
+			// Page transclusion or "labeled section transclusion" (see LabeledSectionTransclusion extension for more info)
+			if ($this->mIncPage) {
+				if(empty($this->mIncSecLabels)) {
+					// Uses wfLst_fetch_() from LabeledSectionTransclusion extension to include the whole page
+					$incwiki = wfLst_fetch_($this->mParser, $article->mTitle->getPrefixedText());
+				} else {
+					$incwiki = $mode->sSecStartAll;
+					foreach ($this->mIncSecLabels as $sSecLabel) {
+						$sSecLabel = trim($sSecLabel);
+						if ($sSecLabel == '') break;
+						$incwiki .= $mode->sSecStart;
+						if($sSecLabel[0] == '#') {
+							// Uses wfLstIncludeHeading2() from LabeledSectionTransclusion extension to include headings from the page
+							$secPiece = wfLstIncludeHeading2($this->mParser, $article->mTitle->getPrefixedText(), substr($sSecLabel, 1));
+						} else {
+							// Uses wfLstInclude() from LabeledSectionTransclusion extension to include labeled sections from the page
+							$secPiece = wfLstInclude($this->mParser, $article->mTitle->getPrefixedText(), $sSecLabel);
+						}
+						/**
+						* $secPiece can be: 
+						* - array($text, 'title'=>$title, 'replaceHeadings'=>true, 'headingOffset'=>$skiphead)
+						* - "[[" . $title->getPrefixedText() . "]]<!-- WARNING: LST loop detected -->";
+						*/
+						$incwiki .= is_array($secPiece) ? $secPiece[0] : $secPiece;
+						$incwiki .= $mode->sSecEnd;
+					}
+					$incwiki .= $mode->sSecEndAll;
+				}
+				wfLst_open_($this->mParser, $this->mParserTitle->getPrefixedText());
+				$r .= '<p>' . $this->mParser->recursiveTagParse($incwiki) . '</p>';
+				wfLst_close_($this->mParser, $this->mParserTitle->getPrefixedText());
+			}
+	
+			$r .= $mode->sItemEnd;
+		}
+		$r .= $mode->sListEnd;
+		return $r;
+	}
+	
+	//slightly different from CategoryViewer::formatList() (no need to instantiate a CategoryViewer object)
+	function formatCategoryList($iStart, $iCount) {
+		global $wgDPL2CategoryStyleListCutoff;
+		
+		for($i = $iStart; $i < $iStart + $iCount; $i++) {
+			$aArticles[] = $this->mArticles[$i]->mLink;
+			$aArticles_start_char[] = $this->mArticles[$i]->mStartChar;
+		}
+		require_once ('CategoryPage.php');
+		if ( count ( $aArticles ) > $wgDPL2CategoryStyleListCutoff ) {
+			return CategoryViewer::columnList( $aArticles, $aArticles_start_char );
+		} elseif ( count($aArticles) > 0) {
+			// for short lists of articles in categories.
+			return CategoryViewer::shortList( $aArticles, $aArticles_start_char );
+		}
+		return '';
+	}
+	
+	/**
+	* Returns message in the requested format after parsing wikitext to html
+	* This is meant to be equivalent to wfMsgExt() with parse, parsemag and escape as available options but using the DPL2 local parser instead of the global one (bugfix).
+	*/
+	function msgExt( $key, $options ) {
+		$args = func_get_args();
+		array_shift( $args );
+		array_shift( $args );
+	
+		if( !is_array($options) ) {
+			$options = array($options);
+		}
+	
+		$string = wfMsgGetKey( $key, true, false, false );
+	
+		$string = wfMsgReplaceArgs( $string, $args );
+	
+		if( in_array('parse', $options) ) {
+			$this->mParserOptions->setInterfaceMessage(true);
+			$string = $this->mParser->recursiveTagParse( $string );
+			$this->mParserOptions->setInterfaceMessage(false);
+			//$string = $parserOutput->getText();
+		} elseif ( in_array('parsemag', $options) ) {
+			$parser = new Parser();
+			$parserOptions = new ParserOptions();
+			$parserOptions->setInterfaceMessage( true );
+			$parser->startExternalParse( $this->mParserTitle, $parserOptions, OT_MSG );
+			$string = $parser->transformMsg( $string, $parserOptions );
+		}
+	
+		if ( in_array('escape', $options) ) {
+			$string = htmlspecialchars ( $string );
+		}
+	
+		return $string;
+	}
+	
+	function getText() {
+		return $this->mOutput;
+	}
+	
+}
+
+
+class DPL2Logger {
+	var $iDebugLevel;
+	
+	function DPL2Logger() {
+		global $wgDPL2Options;
+		$this->iDebugLevel = $wgDPL2Options['debug']['default'];
+	}
+
+	/**
+	 * Get a message, with optional parameters
+	 * Parameters from user input must be escaped for HTML *before* passing to this function
+	 */
+	function msg($msgid) {
+		global $wgDPL2DebugMinLevels;
+		if($this->iDebugLevel >= $wgDPL2DebugMinLevels[$msgid]) {
+			$args = func_get_args();
+			array_shift( $args );
+			/**
+			 * @todo add a DPL id to identify the DPL tag that generates the message, in case of multiple DPLs in the page
+			 */
+			return '<p>%DPL2-' . DPL2_VERSION . '-' .  wfMsg('dpl2_debug_' . $msgid, $args) . '</p>';
+		}
+		return '';
+	}
+
+	/**
+	 * Get a message. 
+	 * Parameters may be unescaped, this function will escape them for HTML.
+	 */
+	function escapeMsg( $msgid /*, ... */ ) {
+		$args = func_get_args();
+		$args = array_map( 'htmlspecialchars', $args );
+		return call_user_func_array( array( &$this, 'msg' ), $args );
+	}
+
+	/**
+	 * Get a "wrong parameter" message.
+	 * @param $paramvar The parameter name
+	 * @param $val The unescaped input value
+	 * @return HTML error message
+	 */
+	function msgWrongParam($paramvar, $val) {
+		global $wgContLang, $wgDPL2Options;
+		$msgid = DPL2_WARN_WRONGPARAM;
+		switch($paramvar) {
+			case 'namespace':
+			case 'notnamespace':
+				$msgid = DPL2_ERR_WRONGNS;
+				break;
+			case 'linksto':
+				$msgid = DPL2_ERR_WRONGLINKSTO;
+				break;
+			case 'count':
+			case 'titlemaxlength':
+				$msgid = DPL2_WARN_WRONGPARAM_INT;
+				break;
+		}
+		$paramoptions = array_unique($wgDPL2Options[$paramvar]);
+		sort($paramoptions);
+		return $this->escapeMsg( $msgid, $paramvar, htmlspecialchars( $val ), $wgDPL2Options[$paramvar]['default'], implode(' | ', $paramoptions ));
+	}
+	
+}
+?>
Index: trunk/wikipathways/wpi/extensions/PathwayOfTheDay.php
===================================================================
--- trunk/wikipathways/wpi/extensions/PathwayOfTheDay.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/PathwayOfTheDay.php	(revision 1110)
@@ -0,0 +1,192 @@
+<?php
+
+require_once("wpi/wpi.php");
+
+/*
+Pathway of the day generator
+
+We need:
+	- a randomized list of all pathways
+	- remove pathway that is used
+	- randomize again when we're at the end!
+	- update list when new pathways are added....randomize every time (but exclude those we've already had)
+
+Concerning MediaWiki:
+	- create a new SpecialPage: Special:PathwayOfTheDay
+	- create an extension that implements above in php
+	
+We need:
+	- to pick a random pathway everyday (from all articles in namespace pathway)
+	- remember this pathway and the day it was picked, store that in cache
+	- on a new day, pick a new pathway, replace cache and update history
+*/
+
+#### DEFINE EXTENSION
+# Define a setup function
+$wgExtensionFunctions[] = 'wfPathwayOfTheDay';
+# Add a hook to initialise the magic word
+$wgHooks['LanguageGetMagic'][]  = 'wfPathwayOfTheDay_Magic';
+
+function wfPathwayOfTheDay() {
+        global $wgParser;
+        # Set a function hook associating the "example" magic word with our function
+        $wgParser->setFunctionHook( 'pathwayOfTheDay', 'getPathwayOfTheDay' );
+}
+
+function wfPathwayOfTheDay_Magic( &$magicWords, $langCode ) {
+        # Add the magic word
+        # The first array element is case sensitive, in this case it is not case sensitive
+        # All remaining elements are synonyms for our parser function
+        $magicWords['pathwayOfTheDay'] = array( 0, 'pathwayOfTheDay' );
+        # unless we return true, other parser functions extensions won't get loaded.
+        return true;
+}
+
+function getPathwayOfTheDay( &$parser, $date ) {	
+	wfDebug("GETTING PATHWAY OF THE DAY for date: $date\n");
+	$potd = new PathwayOfTheDay($date);
+    $out =  $potd->getWikiOutput();
+	wfDebug("END GETTING PATHWAY OF THE DAY for date: $date\n");
+	return $out;
+}
+
+class PathwayOfTheDay {
+	private static $historytable = 'pathwayOfTheDay_history';
+	private static $daytable = 'pathwayOfTheDay_today';
+	private static $table = 'pathwayOfTheDay';
+	
+	var $todaysPw; //Todays pathway
+	var $today; //Day todaysPw was marked as today's
+		
+	function __construct($date) {
+		PathwayOfTheDay::setupDB(); //TODO: remove this after first use
+		if($date) {
+			$this->today = $date;
+		} else {
+			$this->today = date("l j F Y");
+		}
+		$this->todaysPw = $this->fetchTodaysPathway();
+	}
+	
+	public function getWikiOutput() {
+		if($this->today == '{{{date}}}') {//Template variable not set, use dummy return values
+			$pw = "TemplatePathway";
+			$date = "TemplateDate";
+		} else {
+			$pw = $this->todaysPathway();
+			$name = $pw->name();
+			$species = $pw->species();
+			$article = $pw->getTitleObject()->getFullText();
+			$image = $pw->getImageTitle()->getFullText();
+			$date = $this->today;
+		}
+		return "{{Template:TodaysPathway|pwName=$name|pwSpecies=$species|article=$article|image=$image|date=$date}}";
+	}
+	
+	private function fetchTodaysPathway() {
+		$dbr =& wfGetDB(DB_SLAVE);
+		$res = $dbr->select( PathwayOfTheDay::$table, array('pathway'), array('day' => $this->today));
+		$row = $dbr->fetchRow( $res );
+		$dbr->freeResult( $res );
+		return $row[0];
+	}
+	
+	//Get the pathway for today
+	public function todaysPathway() {
+		if(!$this->todaysPw) { //No pathway in history yet
+			$this->brandNewDay();
+		}
+		return Pathway::newFromTitle(Title::newFromText($this->todaysPw, NS_PATHWAY));
+	}
+	
+	//Create and fill the tables
+	private static function setupDB() {
+		$ind_pw = 'pathwayOfTheDay_pathway';
+		$ind_day = 'pathwayOfTheDay_day';
+		$tbl = PathwayOfTheDay::$table;
+		$dbw =& wfGetDB(DB_MASTER);
+		wfDebug("\tCreating tables\n");
+		$dbw->query( "CREATE TABLE IF NOT EXISTS $tbl ( pathway varchar(255), day varchar(50) )", DB_MASTER );
+		#Index...doesn't work yet
+		/*$dbw->query( "IF NOT EXISTS (SELECT * from SYSINDEXES
+						WHERE id=object_id('$tbl') AND name='$ind_pw')
+						CREATE INDEX $ind_pw on $tbl(pathway)", 
+					DB_MASTER );
+		$dbw->query( "IF NOT EXISTS (SELECT * from SYSINDEXES
+						WHERE id=object_id('$tbl') AND name='$ind_day')
+						CREATE INDEX $ind_day on $tbl(pathway)", 
+					DB_MASTER );
+					*/
+		wfDebug("\tDone!\n");
+	}
+	
+	//A brand new day, fetch new random patwhay that we haven't had before
+	private function brandNewDay() {
+		wfDebug("\tA brand new day....refreshing pathway of the day\n");
+		$this->findFreshPathway();
+	}
+	
+	private function findFreshPathway() {
+		wfDebug("\tSearching for fresh pathway\n");
+		$pw = $this->fetchRandomPathway();
+		wfDebug("\t\tPathway in cache: '$pw'\n");
+		while($this->hadBefore($pw)) {
+			//Keep on searching until we found one that we haven't had before 
+			$pw = $this->fetchRandomPathway();	
+			wfDebug("\t\tTrying: '$pw'\n");
+			$tried++;
+			wfDebug("\t\t\t$tried attempt\n");
+			if($tried > 100) { 
+				wfDebug("\tTried too often, clearing history\n");
+				//However, if we tried too often, just pick a pathway and reset the pathway list
+				//TODO: 'too often' needs to be the number of pathways...
+				$this->clearHistory();
+				$this->clearHistory();
+				$tried = 0;
+			}
+		}
+		$this->todaysPw = $pw;
+		//We found  a new pathway, now update history
+		$this->updateHistory();
+	}
+	
+	private function hadBefore($pathway) {
+		wfDebug("\tDid we have $pathway before? ");
+		if(!$pathway) {
+			wfDebug(" we don't have a pathway\n");
+			return true;
+		}
+		$dbr =& wfGetDB(DB_SLAVE);
+		$res = $dbr->select( PathwayOfTheDay::$table, array('pathway'), array('pathway' => $pathway) );
+		$row = $dbr->fetchRow( $res );
+		$dbr->freeResult( $res );
+		$had = $row ? true : false;
+		wfDebug(" $had\n");
+		return $had;
+	}
+	
+	private function clearHistory() {
+		$dbw =& wfGetDB(DB_MASTER);
+		wfDebug("\tClearing history\n");
+		$dbw->query( "TRUNCATE TABLE " . PathwayOfTheDay::$historytable, DB_MASTER );
+	}
+		
+	private function updateHistory() {
+		$dbw =& wfGetDB(DB_MASTER);
+		$dbw->insert(PathwayOfTheDay::$table, array('pathway' => $this->todaysPw, 'day' => $this->today));
+	}
+	
+	//Select a random pathway
+	private function fetchRandomPathway() {
+		wfDebug("Fetching random pathway...\n");
+		$dbr =& wfGetDB(DB_SLAVE);
+		//Pick a random pathway from all articles in namespace NS_PATHWAY
+		$res = $dbr->query(
+			"SELECT page_title FROM page WHERE page_namespace = " . NS_PATHWAY .
+				" AND page_is_redirect = 0 ORDER BY RAND() LIMIT 1" ,DB_SLAVE ); //RAND() only works in MySQL?
+		$row = $dbr->fetchRow($res);
+		wfDebug("Resulting pathway: " . $row[0] . "\n");
+		return $row[0];
+	}
+}
+?>
Index: trunk/wikipathways/wpi/extensions/googleSearch.php
===================================================================
--- trunk/wikipathways/wpi/extensions/googleSearch.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/googleSearch.php	(revision 1110)
@@ -0,0 +1,45 @@
+<?php
+# Google Custom Search Engine Extension
+# 
+# Tag :
+#   <Googlecoop></Googlecoop>
+# Ex :
+#   Add this tag to the wiki page you configed at your google co-op control panel.
+#   
+# 
+# Enjoy !
+
+$wgExtensionFunctions[] = 'GoogleCoop';
+$wgExtensionCredits['parserhook'][] = array(
+        'name' => 'Google Co-op Extension',
+        'description' => 'Using Google Co-op',
+        'author' => 'Liang Chen The BiGreat',
+        'url' => 'http://liang-chen.com'
+);
+
+function GoogleCoop() {
+        global $wgParser;
+        $wgParser->setHook('Googlecoop', 'renderGoogleCoop');
+}
+
+# The callback function for converting the input text to HTML output
+function renderGoogleCoop($input) {
+        
+        $output='
+<!-- Google Search Result Snippet Begins -->
+  <div id="results_002915365922082279465:6qd0wwvwtwu"></div>
+  <script type="text/javascript">
+    var googleSearchIframeName = "results_002915365922082279465:6qd0wwvwtwu";
+    var googleSearchFormName = "searchbox_002915365922082279465:6qd0wwvwtwu";
+    var googleSearchFrameWidth = 600;
+    var googleSearchFrameborder = 0;
+    var googleSearchDomain = "www.google.com";
+    var googleSearchPath = "/cse";	 
+  </script>
+  <script type="text/javascript" src="http://www.google.com/afsonline/show_afs_search.js"></script>
+<!-- Google Search Result Snippet Ends -->
+                                        ';//google code end here
+
+        return $output;
+}
+?>
Index: trunk/wikipathways/wpi/extensions/movePathway.php
===================================================================
--- trunk/wikipathways/wpi/extensions/movePathway.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/movePathway.php	(revision 1110)
@@ -0,0 +1,47 @@
+<?php
+require_once('wpi/wpi.php');
++$wgHooks['SpecialMovepageAfterMove'][] = 'movePathwayPages';
+
+function movePathwayPages(&$movePageForm , &$ot , &$nt) {
+	if($ot->getNamespace() == NS_PATHWAY) {
+		wfDebug("MOVINGPATHWAY!!");
+		$pwOld = Pathway::newFromTitle($ot);
+		$pwNew = Pathway::newFromTitle($nt);
+		moveAlong($pwOld->getFileTitle(FILETYPE_GPML), $pwNew->getFileTitle(FILETYPE_GPML), $movePageForm);
+		
+		$pwOld->clearCache(null, true);
+		$pwNew->updateCache();
+	}
+	return(true);
+}
+
+function moveAlong($ot, $nt, $movePageForm) {
+		wfDebug("MOVING PAGE " . $ot->getFullText() . " TO " . $nt->getFullText() . "\n");
+		##MODIFIED FROM SpecialMovePage, doSubmit()
+		##This is a quick hack to make moving pathway pages work
+		##Will be removed when all pathway information is combined on a single wiki page
+		$error = $ot->moveTo( $nt, true, $movePageForm->reason );
+		wfDebug("\tMOVING....title says:$error\n");
+		# Move the talk page if relevant, if it exists, and if we've been told to
+		$ott = $ot->getTalkPage();
+		if( $ott->exists() ) {
+			if( !$ot->isTalkPage() && !$nt->isTalkPage() ) {
+				$ntt = $nt->getTalkPage();
+	
+				# Attempt the move
+				$ott->moveTo( $ntt, true, $movePageForm->reason );
+			}
+		}
+		
+/*		
+		# Deal with watches
+		if( $movePageForm->watch ) {
+			$wgUser->addWatch( $ot );
+			$wgUser->addWatch( $nt );
+		} else {
+			$wgUser->removeWatch( $ot );
+			$wgUser->removeWatch( $nt );
+		}
+*/
+}
Index: trunk/wikipathways/wpi/extensions/redirectImage.php
===================================================================
--- trunk/wikipathways/wpi/extensions/redirectImage.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/redirectImage.php	(revision 1110)
@@ -0,0 +1,29 @@
+<?php
+/* 
+When this extension is enabled, it redirects every Image Page to the actual file, 
+unless 'showPage' is specified in the GET header 
+(e.g. http://wiki.org/wiki.php/Image:test.jpg?showPage=1)
+*/
+
+$wgHooks['OutputPageBeforeHTML'][] = 'redirectOnImagePage';
+
+function redirectOnImagePage($out, $text) {
+	global $wgTitle;
+	#Check if 'showPage' is specified in GET header
+	#if so, return
+	if($_GET['showPage']) {
+		return true;
+	} else {
+                return false;
+	}
+	#If this is an Image Page, redirect to file
+	$ns = Namespace::getCanonicalName($wgTitle->getNamespace());
+	if($ns == 'Image') {
+		$image = new Image($wgTitle);
+                $url = $image->getURL();
+                $out->redirect($url);
+		return false;
+	} else {
+		return true;
+	}
+}
Index: trunk/wikipathways/wpi/extensions/CreatePathwayPage/CreatePathwayPage_body.php
===================================================================
--- trunk/wikipathways/wpi/extensions/CreatePathwayPage/CreatePathwayPage_body.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/CreatePathwayPage/CreatePathwayPage_body.php	(revision 1110)
@@ -0,0 +1,49 @@
+<?php
+require_once("wpi/wpi.php");
+
+class CreatePathwayPage extends SpecialPage
+{		
+        function CreatePathwayPage() {
+                SpecialPage::SpecialPage("CreatePathwayPage");
+                self::loadMessages();
+        }
+
+        function execute( $par ) {
+                global $wgRequest, $wgOut, $wpiScriptURL;
+                
+                $this->setHeaders();
+				
+				$html = tag('p', 'To create a new pathway, specify the pathway name and species 
+									and then click "create pathway" to open the pathway editor.<br>
+									You can then draw your pathway and close the editor to save it to WikiPathway.org');
+				$html .= "	<input type='hidden' name='action' value='new'>
+							<td>Pathway name:
+							<td><input type='text' name='pwName'>
+							<tr><td>Species:<td>
+							<select name='pwSpecies'>";
+				$species = Pathway::getAvailableSpecies();
+				foreach($species as $sp) {
+					$html .= "<option value=$sp" . (!$selected ? ' selected' : '') . ">$sp";
+					$selected = true;
+				}
+				$html .= '</select>';
+				$html = tag('table', $html);
+				$html .= tag('input', "", array('type'=>'submit', 'value'=>'Create pathway'));
+				$html = tag('form', $html, array('action'=>$wpiScriptURL, 'method'=>'get'));
+				$html .= "<HR><A href='http://blog.bigcat.unimaas.nl/~gmmlvisio/pathvisio_v1.jnlp'>Create new local pathway</A>";
+				$wgOut->addHTML($html);
+        }
+
+        function loadMessages() {
+                static $messagesLoaded = false;
+                global $wgMessageCache;
+                if ( $messagesLoaded ) return;
+                $messagesLoaded = true;
+
+                require( dirname( __FILE__ ) . '/CreatePathwayPage.i18n.php' );
+                foreach ( $allMessages as $lang => $langMessages ) {
+                        $wgMessageCache->addMessages( $langMessages, $lang );
+                }
+        }
+}
+?>
Index: trunk/wikipathways/wpi/extensions/CreatePathwayPage/CreatePathwayPage.i18n.php
===================================================================
--- trunk/wikipathways/wpi/extensions/CreatePathwayPage/CreatePathwayPage.i18n.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/CreatePathwayPage/CreatePathwayPage.i18n.php	(revision 1110)
@@ -0,0 +1,7 @@
+<?php
+$allMessages = array(
+        'en' => array( 
+                'createpathwaypage' => 'Create new pathway'
+        )
+);
+?>
\ No newline at end of file
Index: trunk/wikipathways/wpi/extensions/CreatePathwayPage/CreatePathwayPage.php
===================================================================
--- trunk/wikipathways/wpi/extensions/CreatePathwayPage/CreatePathwayPage.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/CreatePathwayPage/CreatePathwayPage.php	(revision 1110)
@@ -0,0 +1,15 @@
+<?php
+# Not a valid entry point, skip unless MEDIAWIKI is defined
+if (!defined('MEDIAWIKI')) {
+        echo <<<EOT
+To install CreatePathwayPage, put the following line in LocalSettings.php:
+require_once( "$IP/extensions/CreatePathwayPage/CreatePathwayPage.php" );
+EOT;
+        exit( 1 );
+}
+
+$wgAutoloadClasses['CreatePathwayPage'] = dirname(__FILE__) . '/CreatePathwayPage_body.php';
+$wgSpecialPages['CreatePathwayPage'] = 'CreatePathwayPage';
+$wgHooks['LoadAllMessages'][] = 'CreatePathwayPage::loadMessages';
+
+?>
\ No newline at end of file
Index: trunk/wikipathways/wpi/extensions/PopularPathwaysPage/BrowsePathwaysPage_body.php
===================================================================
--- trunk/wikipathways/wpi/extensions/PopularPathwaysPage/BrowsePathwaysPage_body.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/PopularPathwaysPage/BrowsePathwaysPage_body.php	(revision 1110)
@@ -0,0 +1,201 @@
+<?php
+/**
+ * @package MediaWiki
+ * @subpackage SpecialPage
+ */
+
+/** AP20070419
+ * Added wpi.php to access Pathway class and getAvailableSpecies()
+ */
+require_once('/var/www/wikipathways/wpi/wpi.php');
+
+/**
+ * Entry point : initialise variables and call subfunctions.
+ * @param $par String: becomes "FOO" when called like Special:BrowsePathwaysPage/FOO (default NULL)
+ * @param $specialPage @see SpecialPage object.
+ */
+function wfSpecialBrowsePathwaysPage( $par=NULL, $specialPage ) {
+	global $wgRequest, $wgOut, $wgContLang, $from;
+
+	# GET values
+
+//	$pick = $_POST["from"];
+//	if (isset($_POST['browse'])){
+//	echo "Pick: ".$pick."<br/>";
+//	}
+
+/** AP20070419	
+ * Parse species header from 'from' so that prev/next links can work
+ */
+	$from = $wgRequest->getVal( 'from' );
+	$from_pathway = null;
+	if(preg_match('/\:/', $from)){	   
+		$from_pathway = $from;
+		$parts = explode(':', $from);
+        	if(count($parts) < 1) {
+        		     throw new Exception("Invalid pathway article title: $from");
+        	}
+        	$from = array_shift($parts);
+	}
+
+
+/** AP20070419	
+ *	$namespace = $wgRequest->getInt( 'namespace' );
+ *	
+ *	Set $namespace to equal 100 (Pathway)
+ */
+	$namespace = 100;
+
+	$namespaces = $wgContLang->getNamespaces();
+
+	$indexPage = new BrowsePathwaysPage();
+
+	if( !in_array($namespace, array_keys($namespaces)) )
+		$namespace = 0;
+
+echo $from, $namespace;
+
+/** AP20070419	
+ *	$wgOut->setPagetitle( $namespace > 0 ?
+ *		wfMsg( 'allinnamespace', str_replace( '_', ' ', $namespaces[$namespace] ) ) :
+ *		wfMsg( 'allarticles' )
+ *		);
+ *
+ *	Set Pagetitle to "Browse Pathways"
+ */
+	// $wgOut->setPagetitle("Browse Pathways");
+
+/** AP20070419
+ *	Set default $indexPage to show Human
+ */
+}
+
+class BrowsePathwaysPage extends SpecialPage {
+
+	function BrowsePathwaysPage() {
+		SpecialPage::SpecialPage("BrowsePathwaysPage");
+		self::loadMessages();
+	}
+
+	function execute( $par) {
+        	
+		global $wgOut, $from, $pick, $all;
+ 		//$pick = $wgRequest->getVal( 'browse'); 
+		$pick = $_GET["browse"];
+		$picked = $pick;
+		$all = 'All Species';
+		if ($pick == $all){
+			$picked = '';
+	                $arr = Pathway::getAvailableSpecies();
+        	        asort($arr);
+                	foreach ($arr as $index) {
+				$picked .=  $index."|";	
+			}
+			$picked[strlen($picked)-1] = ' ';
+		}
+        	if (!isset($pick)){
+			$pick = 'Human';
+			$picked = $pick;
+        	}
+  		//$wgOut->addHtml("Pick: ".$pick.$picked."<br/>");
+
+	        $wgOut->setPagetitle("Browse Pathways");
+
+		$nsForm = $this->namespaceForm( $namespace, $pick);       
+
+                $wgOut->addHtml( $nsForm . '<hr />');
+		$wgOut->addWikiText("<DPL>category=$picked
+                                notnamespace=Image
+                                namespace=Pathway
+                                shownamespace=false
+                                mode=category
+                                ordermethod=title
+                                </DPL>");
+
+//                                notcategory=Cellular Process
+//                                notcategory=Molecular Function
+//                                notcategory=Metabolic Process
+//                                notcategory=Physiological Process
+
+	}
+
+       function loadMessages() {
+                static $messagesLoaded = false;
+                global $wgMessageCache;
+                if ( $messagesLoaded ) return;
+                $messagesLoaded = true;
+
+                require( dirname( __FILE__ ) . '/BrowsePathwaysPage.i18n.php' );
+                foreach ( $allMessages as $lang => $langMessages ) {
+                        $wgMessageCache->addMessages( $langMessages, $lang );
+                }
+        }
+
+	var $maxPerPage=960;
+	var $topLevelMax=50;
+	var $name='BrowsePathwaysPage';
+	# Determines, which message describes the input field 'nsfrom' (->SpecialPrefixindex.php)
+	var $nsfromMsg='allpagesfrom';
+
+
+/**
+ * HTML for the top form
+ * @param integer $namespace A namespace constant (default NS_PATHWAY).
+ * @param string $from Article name we are starting listing at.
+ */
+function namespaceForm ( $namespace = NS_PATHWAY, $pick ) {
+	global $wgScript, $wgContLang;
+	$t = SpecialPage::getTitleFor( $this->name );
+
+/** AP20070419
+ *	$namespaceselect = HTMLnamespaceselector($namespace, null);
+ *
+ *	$frombox = "<input type='text' size='20' name='from' id='nsfrom' value=\""
+ *	            . htmlspecialchars ( $from ) . '"/>';
+ */
+
+                $speciesselect = "\n<select name='browse' class='namespaceselector'>\n";
+
+		$arr = Pathway::getAvailableSpecies();
+		asort($arr);
+		$selected = $pick;
+		$all = 'All Species';
+
+                foreach ($arr as $index) {
+                        if ($index === $selected) {
+                                $speciesselect .= "\t" . Xml::element("option",
+                                                array("value" => $index, "selected" => "selected"), $index) . "\n";
+                        } else {
+                                $speciesselect .= "\t" . Xml::element("option", array("value" => $index), $index) . "\n";
+                        }
+                }
+		if ($selected == $all){
+			$speciesselect .= "\t" . Xml::element("option",
+                                         array("value" => $all, "selected" => "selected"), $all) . "\n";
+                 } else {
+                         $speciesselect .= "\t" . Xml::element("option", array("value" => $all), $all) . "\n";
+                 }
+
+                $speciesselect .= "</select>\n";
+
+	$submitbutton = '<input type="submit" value="Go" name="pick" />';
+
+	$out = "<form method='get' action='{$wgScript}'>";
+	$out .= '<input type="hidden" name="title" value="'.$t->getPrefixedText().'" />';
+	$out .= "
+<table id='nsselect' class='allpages'>
+	<tr>
+		<td align='right'>Display pathways from:</td>
+		<td align='left'>
+		    $speciesselect $submitbutton
+		</td>
+	</tr>
+</table>
+";
+
+	$out .= '</form>';
+		return $out;
+}
+}
+
+?>
Index: trunk/wikipathways/wpi/extensions/PopularPathwaysPage/BrowsePathwaysPage.i18n.php
===================================================================
--- trunk/wikipathways/wpi/extensions/PopularPathwaysPage/BrowsePathwaysPage.i18n.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/PopularPathwaysPage/BrowsePathwaysPage.i18n.php	(revision 1110)
@@ -0,0 +1,7 @@
+<?php
+$allMessages = array(
+        'en' => array( 
+                'browsepathwayspage' => 'Most viewed pathways'
+        )
+);
+?>
Index: trunk/wikipathways/wpi/extensions/PopularPathwaysPage/PopularPathwaysPage_body.php
===================================================================
--- trunk/wikipathways/wpi/extensions/PopularPathwaysPage/PopularPathwaysPage_body.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/PopularPathwaysPage/PopularPathwaysPage_body.php	(revision 1110)
@@ -0,0 +1,72 @@
+<?php
+require_once("QueryPage.php");
+
+class PopularPathwaysPage extends SpecialPage
+{		
+        function PopularPathwaysPage() {
+                SpecialPage::SpecialPage("PopularPathwaysPage");
+                self::loadMessages();
+        }
+
+        function execute( $par ) {
+                global $wgRequest, $wgOut;
+                
+                $this->setHeaders();
+
+                list( $limit, $offset ) = wfCheckLimits();
+
+				$ppp = new PPQueryPage();
+
+				return $ppp->doQuery( $offset, $limit );
+        }
+
+        function loadMessages() {
+                static $messagesLoaded = false;
+                global $wgMessageCache;
+                if ( $messagesLoaded ) return;
+                $messagesLoaded = true;
+
+                require( dirname( __FILE__ ) . '/PopularPathwaysPage.i18n.php' );
+                foreach ( $allMessages as $lang => $langMessages ) {
+                        $wgMessageCache->addMessages( $langMessages, $lang );
+                }
+        }
+}
+
+class PPQueryPage extends QueryPage {
+
+	function getName() {
+		return "PopularPathways";
+	}
+
+	function isExpensive() {
+		# page_counter is not indexed
+		return true;
+	}
+	function isSyndicated() { return false; }
+
+	function getSQL() {
+		$dbr =& wfGetDB( DB_SLAVE );
+		$page = $dbr->tableName( 'page' );
+
+		return
+			"SELECT 'Popularpages' as type,
+			        page_namespace as namespace,
+			        page_title as title,
+			        page_counter as value
+			FROM $page
+			WHERE page_namespace=".NS_PATHWAY." 
+			AND page_title NOT LIKE '%Sandbox%'
+			AND page_is_redirect=0";
+	}
+
+	function formatResult( $skin, $result ) {
+		global $wgLang, $wgContLang;
+		$title = Title::makeTitle( $result->namespace, $result->title );
+		$link = $skin->makeKnownLinkObj( $title, htmlspecialchars( $wgContLang->convert( $title->getBaseText() ) ) );
+		$nv = wfMsgExt( 'nviews', array( 'parsemag', 'escape'),
+			$wgLang->formatNum( $result->value ) );
+		return wfSpecialList($link, $nv);
+	}
+}
+?>
Index: trunk/wikipathways/wpi/extensions/PopularPathwaysPage/PopularPathwaysPage.i18n.php
===================================================================
--- trunk/wikipathways/wpi/extensions/PopularPathwaysPage/PopularPathwaysPage.i18n.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/PopularPathwaysPage/PopularPathwaysPage.i18n.php	(revision 1110)
@@ -0,0 +1,7 @@
+<?php
+$allMessages = array(
+        'en' => array( 
+                'popularpathwayspage' => 'Most viewed pathways'
+        )
+);
+?>
\ No newline at end of file
Index: trunk/wikipathways/wpi/extensions/PopularPathwaysPage/BrowsePathwaysPage.php
===================================================================
--- trunk/wikipathways/wpi/extensions/PopularPathwaysPage/BrowsePathwaysPage.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/PopularPathwaysPage/BrowsePathwaysPage.php	(revision 1110)
@@ -0,0 +1,15 @@
+<?php
+# Not a valid entry point, skip unless MEDIAWIKI is defined
+if (!defined('MEDIAWIKI')) {
+        echo <<<EOT
+To install BrowsePathwaysPage, put the following line in LocalSettings.php:
+require_once( "$IP/extensions/BrowsePathwayPage/BrowsePathwayPage.php" );
+EOT;
+        exit( 1 );
+}
+
+$wgAutoloadClasses['BrowsePathwaysPage'] = dirname(__FILE__) . '/BrowsePathwaysPage_body.php';
+$wgSpecialPages['BrowsePathwaysPage'] = 'BrowsePathwaysPage';
+$wgHooks['LoadAllMessages'][] = 'BrowsePathwaysPage::loadMessages';
+
+?>
Index: trunk/wikipathways/wpi/extensions/PopularPathwaysPage/PopularPathwaysPage.php
===================================================================
--- trunk/wikipathways/wpi/extensions/PopularPathwaysPage/PopularPathwaysPage.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/PopularPathwaysPage/PopularPathwaysPage.php	(revision 1110)
@@ -0,0 +1,15 @@
+<?php
+# Not a valid entry point, skip unless MEDIAWIKI is defined
+if (!defined('MEDIAWIKI')) {
+        echo <<<EOT
+To install PopularPathwaysPage, put the following line in LocalSettings.php:
+require_once( "$IP/extensions/PopularPathwayPage/PopularPathwayPage.php" );
+EOT;
+        exit( 1 );
+}
+
+$wgAutoloadClasses['PopularPathwaysPage'] = dirname(__FILE__) . '/PopularPathwaysPage_body.php';
+$wgSpecialPages['PopularPathwaysPage'] = 'PopularPathwaysPage';
+$wgHooks['LoadAllMessages'][] = 'PopularPathwaysPage::loadMessages';
+
+?>
\ No newline at end of file
Index: trunk/wikipathways/wpi/extensions/button.php
===================================================================
--- trunk/wikipathways/wpi/extensions/button.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/button.php	(revision 1110)
@@ -0,0 +1,36 @@
+<?php
+
+$wgExtensionFunctions[] = "wfButton";
+
+function wfButton() {
+    global $wgParser;
+    $wgParser->setHook( "button", "renderButton" );
+}
+
+function renderButton( $input, $argv, &$parser ) {
+    $href = attr('href', $argv['href']);
+	$src = attr('src', $argv['image']);
+	$width = attr('width', $argv['width']);
+	$height = attr('height', $argv['height']);
+
+	$mOver = jsSetAttr('onmouseOver', 'src', $argv['mouseoverimg']);
+	$mOut = jsSetAttr('onmouseOut', 'src', $argv['mouseoutimg']);
+	$mDown = jsSetAttr('onmouseDown', 'src', $argv['mousedownimg']);
+
+	$output = "<a $href><img $src $width $height $mOver $mOut $mDown></a>";
+    return $output;
+}
+
+function attr($name, $value) {
+	return $value ? "$name='$value'" : "";
+}
+
+function jsSetAttr($name, $attr, $value) {
+	if($value) {
+		return "$name=\"this.setAttribute('$attr','$value');\"";
+	} else {
+		return '';
+	}
+}
+
+?>
Index: trunk/wikipathways/wpi/extensions/imageSize.php
===================================================================
--- trunk/wikipathways/wpi/extensions/imageSize.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/imageSize.php	(revision 1110)
@@ -0,0 +1,34 @@
+<?php
+
+#### DEFINE EXTENSION
+# Define a setup function
+$wgExtensionFunctions[] = 'wfImageSize';
+# Add a hook to initialise the magic word
+$wgHooks['LanguageGetMagic'][]  = 'wfImageSize_Magic';
+
+function wfImageSize() {
+        global $wgParser;
+        # Set a function hook associating the "example" magic word with our function
+        $wgParser->setFunctionHook( 'maxImageSize', 'getSize' );
+}
+
+function wfImageSize_Magic( &$magicWords, $langCode ) {
+        # Add the magic word
+        # The first array element is case sensitive, in this case it is not case sensitive
+        # All remaining elements are synonyms for our parser function
+        $magicWords['maxImageSize'] = array( 0, 'maxImageSize' );
+        # unless we return true, other parser functions extensions won't get loaded.
+        return true;
+}
+
+function getSize( &$parser, $image, $maxWidth ) {
+	try {
+		$img = new Image(Title::newFromText($image));
+		$w = $img->getWidth();
+		if($w > $maxWidth) $w = $maxWidth;
+		return $w . 'px';
+	} catch (Exception $e) {
+		return "Error: $e";
+	}
+}
+?>

Property changes on: trunk/wikipathways/wpi/extensions/imageSize.php
___________________________________________________________________
Name: svn:executable
   + *

Index: trunk/wikipathways/wpi/extensions/DynamicPageList2.i18n.php
===================================================================
--- trunk/wikipathways/wpi/extensions/DynamicPageList2.i18n.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/DynamicPageList2.i18n.php	(revision 1110)
@@ -0,0 +1,1003 @@
+<?php
+/**
+ * Internationalization file for DynamicPageList2 extension.
+ *
+ * @addtogroup Extensions
+ * @author m:User:Dangerman <cyril.dangerville@gmail.com>
+*/
+
+$wgDPL2Messages = array();
+
+/**
+ * To translate messages into your language, create a $wgDPL2Messages['lang'] array where 'lang' is your language code and take $wgDPL2Messages['en'] as a model. Replace values with appropriate translations.
+ */
+
+$wgDPL2Messages['en'] = array(
+	/*
+		Debug
+	*/
+	// (FATAL) ERRORS
+	/**
+	 * $0: 'namespace' or 'notnamespace'
+	 * $1: wrong parameter given by user
+	 * $3: list of possible titles of namespaces (except pseudo-namespaces: Media, Special)
+	 */
+	'dpl2_debug_' . DPL2_ERR_WRONGNS => "ERROR: Wrong '$0' parameter: '$1'! Help:  <code>$0= <i>empty string</i> (Main)$3</code>. (Equivalents with magic words are allowed too.)",
+	/**
+	 * $0: 'linksto' (left as $0 just in case the parameter is renamed in the future)
+	 * $1: wrong parameter given by user
+	*/
+	'dpl2_debug_' . DPL2_ERR_WRONGLINKSTO => "ERROR: Wrong '$0' parameter: '$1'! Help:  <code>$0= <i>full pagename</i></code>. (Magic words are allowed.)",
+	/**
+	 * $0: max number of categories that can be included
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOMANYCATS => 'ERROR: Too many categories! Maximum: $0. Help: increase <code>$wgDPL2MaxCategoryCount</code> to specify more categories or set <code>$wgDPL2AllowUnlimitedCategories=true</code> for no limitation. (Set the variable in <code>LocalSettings.php</code>, after including <code>DynamicPageList2.php</code>.)',
+	/**
+	 * $0: min number of categories that have to be included
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOFEWCATS => 'ERROR: Too few categories! Minimum: $0. Help: decrease <code>$wgDPL2MinCategoryCount</code> to specify fewer categories. (Set the variable preferably in <code>LocalSettings.php</code>, after including <code>DynamicPageList2.php</code>.)',
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTNOINCLUDEDCATS => "ERROR: You need to include at least one category if you want to use 'addfirstcategorydate=true' or 'ordermethod=categoryadd'!",
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTMORETHAN1CAT => "ERROR: If you include more than one category, you cannot use 'addfirstcategorydate=true' or 'ordermethod=categoryadd'!",
+	'dpl2_debug_' . DPL2_ERR_MORETHAN1TYPEOFDATE => 'ERROR: You cannot add more than one type of date at a time!',
+	/**
+	 * $0: param=val that is possible only with $1 as last 'ordermethod' parameter
+	 * $1: last 'ordermethod' parameter required for $0
+	*/
+	'dpl2_debug_' . DPL2_ERR_WRONGORDERMETHOD => "ERROR: You can use '$0' with 'ordermethod=[...,]$1' only!",
+	/**
+	 * $0: prefix_dpl_clview where 'prefix' is the prefix of your mediawiki table names
+	 * $1: SQL query to create the prefix_dpl_clview on your mediawiki DB
+	*/
+	'dpl2_debug_' . DPL2_ERR_NOCLVIEW => "ERROR: Cannot perform logical operations on the Uncategorized pages (e.g. with the 'category' parameter) because the $0 view does not exist on the database! Help: have the DB admin execute this query: <code>$1</code>.",
+
+	// WARNINGS
+	/**
+	 * $0: unknown parameter given by user
+	 * $1: list of DPL2 available parameters separated by ', '
+	*/
+	'dpl2_debug_' . DPL2_WARN_UNKNOWNPARAM => "WARNING: Unknown parameter '$0' is ignored. Help: available parameters: <code>$1</code>.",
+	/**
+	 * $3: list of valid param values separated by ' | '
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM => "WARNING: Wrong '$0' parameter: '$1'! Using default: '$2'. Help: <code>$0= $3</code>.",
+	/**
+	 * $0: param name
+	 * $1: wrong param value given by user
+	 * $2: default param value used instead by program
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM_INT => "WARNING: Wrong '$0' parameter: '$1'! Using default: '$2' (no limit). Help: <code>$0= <i>empty string</i> (no limit) | n</code>, with <code>n</code> a positive integer.",
+	'dpl2_debug_' . DPL2_WARN_NORESULTS => 'WARNING: No results!',
+	'dpl2_debug_' . DPL2_WARN_CATOUTPUTBUTWRONGPARAMS => "WARNING: Add* parameters ('adduser', 'addeditdate', etc.)' and 'includepage' have no effect with 'mode=category'. Only the page namespace/title can be viewed in this mode.",
+	/**
+	 * $0: 'headingmode' value given by user
+	 * $1: value used instead by program (which means no heading)
+	*/
+	'dpl2_debug_' . DPL2_WARN_HEADINGBUTSIMPLEORDERMETHOD => "WARNING: 'headingmode=$0' has no effect with 'ordermethod' on a single component. Using: '$1'. Help: you can use not-$1 'headingmode' values with 'ordermethod' on multiple components. The first component is used for headings. E.g. 'ordermethod=category,<i>comp</i>' (<i>comp</i> is another component) for category headings.",
+	/**
+	 * $0: 'debug' value
+	*/
+	'dpl2_debug_' . DPL2_WARN_DEBUGPARAMNOTFIRST => "WARNING: 'debug=$0' is not in first position in the DPL element. The new debug settings are not applied before all previous parameters have been parsed and checked.",
+	/**
+	 * $0: title of page that creates an infinite transclusion loop
+	*/
+	'dpl2_debug_' . DPL2_WARN_TRANSCLUSIONLOOP => "WARNING: An infinite transclusion loop is created by page '$0'.",
+
+	// OTHERS
+	/**
+	 * $0: SQL query executed to generate the dynamic page list
+	*/
+	'dpl2_debug_' . DPL2_QUERY => 'QUERY: <code>$0</code>',
+
+	/*
+	   Output formatting
+	*/
+	/**
+	 * $1: number of articles
+	*/
+	'dpl2_articlecount' => 'There {{PLURAL:$1|is one article|are $1 articles}} in this heading.'
+);
+$wgDPL2Messages['fr'] = array(
+	/*
+		Debug
+	*/
+	// (FATAL) ERRORS
+	/**
+	 * $0: 'namespace' or 'notnamespace'
+	 * $1: wrong parameter given by user
+	 * $3: list of possible titles of namespaces (except pseudo-namespaces: Media, Special)
+	 */
+	'dpl2_debug_' . DPL2_ERR_WRONGNS => "ERREUR : Mauvais paramètre '$0' : '$1'! Aide :  <code>$0= <i>chaîne vide</i> (Principal)$3</code>. (Les équivalents avec des mots magiques sont aussi autorisés.)",
+	/**
+	 * $0: 'linksto' (left as $0 just in case the parameter is renamed in the future)
+	 * $1: wrong parameter given by user
+	*/
+	'dpl2_debug_' . DPL2_ERR_WRONGLINKSTO => "ERREUR : Mauvais paramètre '$0' : '$1'! Aide :  <code>$0= <i>Nom complet de la page</i></code>. (Les mots magiques sont autorisés.)",
+	/**
+	 * $0: max number of categories that can be included
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOMANYCATS => 'ERREUR : Trop de catégories ! Maximum : $0. Aide : accroître <code>$wgDPL2MaxCategoryCount</code> pour autoriser plus de catégories ou régler <code>$wgDPL2AllowUnlimitedCategories=true</code> pour aucune limite. (À régler dans <code>LocalSettings.php</code>, après avoir inclus <code>DynamicPageList2.php</code>.)',
+	/**
+	 * $0: min number of categories that have to be included
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOFEWCATS => 'ERREUR : Pas assez de catégories ! Minimum : $0. Aide : décroître <code>$wgDPL2MinCategoryCount</code> pour autoriser moins de catégories. (À régler dans <code>LocalSettings.php</code> de préférence, après avoir inclus <code>DynamicPageList2.php</code>.)',
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTNOINCLUDEDCATS => "ERREUR : Vous devez inclure au moins une catégorie si vous voulez utiliser 'addfirstcategorydate=true' ou 'ordermethod=categoryadd' !",
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTMORETHAN1CAT => "ERREUR : Si vous incluez plus d’une catégorie, vous ne pouvez pas utiliser 'addfirstcategorydate=true' ou 'ordermethod=categoryadd' !",
+	'dpl2_debug_' . DPL2_ERR_MORETHAN1TYPEOFDATE => 'ERREUR : Vous ne pouvez pas utiliser plus d’un type de date à la fois !',
+	/**
+	 * $0: param=val that is possible only with $1 as last 'ordermethod' parameter
+	 * $1: last 'ordermethod' parameter required for $0
+	*/
+	'dpl2_debug_' . DPL2_ERR_WRONGORDERMETHOD => "ERREUR : Vous ne pouvez utiliser '$0' qu’avec 'ordermethod=[...,]$1' !",
+	/**
+	 * $0: prefix_dpl_clview where 'prefix' is the prefix of your mediawiki table names
+	 * $1: SQL query to create the prefix_dpl_clview on your mediawiki DB
+	*/
+	'dpl2_debug_' . DPL2_ERR_NOCLVIEW => "ERREUR : Ne peut pas effectuer d’opérations logiques sur les pages sans catégories (avec la paramètre 'category') car la vue $0 n’existe pas dans la base de données ! Aide : demander à un administrateur de la base de données d'effectuer : <code>$1</code>.",
+
+	// WARNINGS
+	/**
+	 * $0: unknown parameter given by user
+	 * $1: list of DPL2 available parameters separated by ', '
+	*/
+	'dpl2_debug_' . DPL2_WARN_UNKNOWNPARAM => "AVERTISSEMENT : Le paramètre inconnu '$0' est ignoré. Aide : paramètres disponibles : <code>$1</code>.",
+	/**
+	 * $3: list of valid param values separated by ' | '
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM => "AVERTISSEMENT : Mauvais paramètre '$0' : '$1'! Utilisation de la valeur par défaut : '$2'. Aide : <code>$0= $3</code>.",
+	/**
+	 * $0: param name
+	 * $1: wrong param value given by user
+	 * $2: default param value used instead by program
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM_INT => "AVERTISSEMENT : Mauvais paramètre '$0' : '$1'! Utilisattion de la valeur par défaut : '$2' (aucune limite). Aide : <code>$0= <i>chaîne vide</i> (aucune limite) | n</code>, avec <code>n</code> un entier positif.",
+	'dpl2_debug_' . DPL2_WARN_NORESULTS => 'AVERTISSEMENT : No results!',
+	'dpl2_debug_' . DPL2_WARN_CATOUTPUTBUTWRONGPARAMS => "AVERTISSEMENT : Les paramètres Add* ('adduser', 'addeditdate', etc.)' et 'includepage' n’ont aucun effet avec 'mode=category'. Seuls l’espace de nom et le titre de la page peuvent être vus dans ce mode..",
+	/**
+	 * $0: 'headingmode' value given by user
+	 * $1: value used instead by program (which means no heading)
+	*/
+	'dpl2_debug_' . DPL2_WARN_HEADINGBUTSIMPLEORDERMETHOD => "AVERTISSEMENT : 'headingmode=$0' has no effect with 'ordermethod' on a single component. Using: '$1'. Help: you can use not-$1 'headingmode' values with 'ordermethod' on multiple components. The first component is used for headings. E.g. 'ordermethod=category,<i>comp</i>' (<i>comp</i> is another component) for category headings.",
+	/**
+	 * $0: 'debug' value
+	*/
+	'dpl2_debug_' . DPL2_WARN_DEBUGPARAMNOTFIRST => "AVERTISSEMENT : 'debug=$0' n’est pas en première position dans l’élément DPL. Les nouveaux réglages de débuggage ne seront appliqués qu’après que les paramètres précédents aient été vérifiés.",
+	/**
+	 * $0: title of page that creates an infinite transclusion loop
+	*/
+	'dpl2_debug_' . DPL2_WARN_TRANSCLUSIONLOOP => "AVERTISSEMENT : Une boucle d’inclusion infinie est créée par la page '$0'.",
+
+	// OTHERS
+	/**
+	 * $0: SQL query executed to generate the dynamic page list
+	*/
+	'dpl2_debug_' . DPL2_QUERY => 'REQUÊTE : <code>$0</code>',
+
+	/*
+	   Output formatting
+	*/
+	/**
+	 * $1: number of articles
+	*/
+	'dpl2_articlecount' => 'Il y a {{PLURAL:$1|un article|$1 articles}} dans cette section.'
+);
+$wgDPL2Messages['he'] = array(
+	/*
+		Debug
+	*/
+	// (FATAL) ERRORS
+	/**
+	 * $0: 'namespace' or 'notnamespace'
+	 * $1: wrong parameter given by user
+	 * $3: list of possible titles of namespaces (except pseudo-namespaces: Media, Special)
+	 */
+	'dpl2_debug_' . DPL2_ERR_WRONGNS => "שגיאה: פרמטר '$0' שגוי: '$1'! עזרה: <code>$0= <i>מחרוזת ריקה</i> (ראשי)$3</code>. (ניתן להשתמש גם בשווי ערך באמצעות מילות קסם.)",
+	/**
+	 * $0: 'linksto' (left as $0 just in case the parameter is renamed in the future)
+	 * $1: wrong parameter given by user
+	*/
+	'dpl2_debug_' . DPL2_ERR_WRONGLINKSTO => "שגיאה: פרמטר '$0' שגוי: '$1'! עזרה: <code>$0= <i>שם הדף המלא</i></code>. (ניתן להשתמש במילות קסם.)",
+	/**
+	 * $0: max number of categories that can be included
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOMANYCATS => 'שגיאה: קטגוריות רבות מדי! מקסימום: $0. עזרה: העלו את <code>$wgDPL2MaxCategoryCount</code> כדי לציין עוד קטגוריות או הגדירו <code>$wgDPL2AllowUnlimitedCategories=true</code> כדי לבטל את ההגבלה. (הגידרו את המשתנה בקובץ <code>LocalSettings.php</code>, לאחר הכללת <code>DynamicPageList2.php</code>.)',
+	/**
+	 * $0: min number of categories that have to be included
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOFEWCATS => 'שגיאה: קטגוריות מעטות מדי! מינימום: $0. עזרה: הורידו את <code>$wgDPL2MinCategoryCount</code> כדי לציין פחות קטגוריות. (הגידרו את המשתנה בקובץ <code>LocalSettings.php</code>, לאחר הכללת <code>DynamicPageList2.php</code>.)',
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTNOINCLUDEDCATS => "שגיאה: עליכם להכליל לפחות קטגוריה אחת אם ברצונכם להשתמש ב־'addfirstcategorydate=true' או ב־'ordermethod=categoryadd'!",
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTMORETHAN1CAT => "שגיאה: אם אתם מכלילים יותר מקטגוריה אחת, אינכם יכולים להשתמש ב־'addfirstcategorydate=true' או ב־'ordermethod=categoryadd'!",
+	'dpl2_debug_' . DPL2_ERR_MORETHAN1TYPEOFDATE => 'שגיאה: אינכם יכולים להוסיף יותר מסוג אחד של תאריך בו זמנית!',
+	/**
+	 * $0: param=val that is possible only with $1 as last 'ordermethod' parameter
+	 * $1: last 'ordermethod' parameter required for $0
+	*/
+	'dpl2_debug_' . DPL2_ERR_WRONGORDERMETHOD => "שגיאה: באפשרותכם להשתמש ב־'$0' עם 'ordermethod=[...,]$1' בלבד!",
+	/**
+	 * $0: prefix_dpl_clview where 'prefix' is the prefix of your mediawiki table names
+	 * $1: SQL query to create the prefix_dpl_clview on your mediawiki DB
+	*/
+	'dpl2_debug_' . DPL2_ERR_NOCLVIEW => "שגיאה: לא ניתן לבצע פעולות לוגיות על דפים ללא קטגוריות (למשל, עם הפרמטר 'קטגוריה') כיוון שתצוגת $0 אינה קיימת במסד הנתונים! עזרה: מנהל מסד הנתונים צריך להריץ את השאילתה: <code>$1</code>.",
+
+	// WARNINGS
+	/**
+	 * $0: unknown parameter given by user
+	 * $1: list of DPL2 available parameters separated by ', '
+	*/
+	'dpl2_debug_' . DPL2_WARN_UNKNOWNPARAM => "אזהרה: בוצעה התעלמות מהפרמטר הלא ידוע '$0'. עזרה: פרמטרים זמינים: <code>$1</code>.",
+	/**
+	 * $3: list of valid param values separated by ' | '
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM => "אזהרה: פרמטר '$0' שגוי: '$1'! משתמש בברירת המחדל: '$2'. עזרה: <code>$0= $3</code>.",
+	/**
+	 * $0: param name
+	 * $1: wrong param value given by user
+	 * $2: default param value used instead by program
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM_INT => "אזהרה: פרמטר '$0' שגוי: '$1'! משתמש בברירת המחדל: '$2' (ללא הגבלה). עזרה: <code>$0= <i>מחרוזת ריקה</i> (ללא הגבלה) | n</code>, עם <code>n</code> כמספר שלם וחיובי.",
+	'dpl2_debug_' . DPL2_WARN_NORESULTS => 'אזהרה: אין תוצאות!',
+	'dpl2_debug_' . DPL2_WARN_CATOUTPUTBUTWRONGPARAMS => "אזהרה: להוספת* הפרמטרים ('adduser',‏ 'addeditdate' וכדומה) וכן ל־'includepage' אין השפעה עם 'mode=category'. ניתן לצפות רק במרחב השם או בכותרת הדף במצב זה.",
+	/**
+	 * $0: 'headingmode' value given by user
+	 * $1: value used instead by program (which means no heading)
+	*/
+	'dpl2_debug_' . DPL2_WARN_HEADINGBUTSIMPLEORDERMETHOD => "אזהרה: ל־'headingmode=$0' אין השפעה עם 'ordermethod' על פריט יחיד. משתמש ב: '$1'. עזרה: באפשרותכם להשתמש בערכים של 'headingmode' שאינם $1 עם 'ordermethod' על פריטים מרובים. משתמשים בפריט הראשון לכותרת. למשל, 'ordermethod=category,<i>comp</i>' (<i>comp</i> הוא פריט אחר) לכותרות הקטגוריה.",
+	/**
+	 * $0: 'debug' value
+	*/
+	'dpl2_debug_' . DPL2_WARN_DEBUGPARAMNOTFIRST => "אזהרה: 'debug=$0w הוא לא במקום הראשון ברכיב ה־DPL. הגדרות ניפוי השגיאות החדשות לא יחולו לפני שכל הפרמטרים הקודמים ינותחו וייבדקו.",
+	/**
+	 * $0: title of page that creates an infinite transclusion loop
+	*/
+	'dpl2_debug_' . DPL2_WARN_TRANSCLUSIONLOOP => "אזהרה: לולאת הכללה אינסופית נוצרה בדף '$0'.",
+
+	// OTHERS
+	/**
+	 * $0: SQL query executed to generate the dynamic page list
+	*/
+	'dpl2_debug_' . DPL2_QUERY => 'שאילתה: <code>$0</code>',
+
+	/*
+	   Output formatting
+	*/
+	/**
+	 * $1: number of articles
+	*/
+	'dpl2_articlecount' => '{{plural:$1|ישנם $1 דפים|ישנו דף אחד}} תחת כותרת זו.'
+);
+$wgDPL2Messages['id'] = array(
+	'dpl2_debug_' . DPL2_ERR_WRONGNS => "KESALAHAN: Parameter '$0' salah: '$1'! Bantuan: <code>$0= <i>string kosong</i> (Utama)$3</code>. (Ekivalen kata kunci juga diizinkan.)",
+	'dpl2_debug_' . DPL2_ERR_WRONGLINKSTO => "KESALAHAN: Parameter '$0' salah: '$1'! Bantuan:  <code>$0= <i>nama lengkap halaman</i></code>. (Kata kunci diizinkan.)",
+	'dpl2_debug_' . DPL2_ERR_TOOMANYCATS => 'KESALAHAN: Kategori terlalu banyak! Maksimum: $0. Bantuan: perbesar <code>$wgDPL2MaxCategoryCount</code> untuk memberikan lebih banyak kategori atau atur  <code>$wgDPL2AllowUnlimitedCategories=true</code> untuk menghapus batasan. (Atur variabel tersebut di <code>LocalSettings.php</code>, setelah mencantumkan <code>DynamicPageList2.php</code>.)',
+	'dpl2_debug_' . DPL2_ERR_TOOFEWCATS => 'KESALAHAN: Kategori terlalu sedikit! Minimum: $0. Bantuan: kurangi <code>$wgDPL2MinCategoryCount</code> untuk mengurangi kategori. (Atur variabel tersebut di <code>LocalSettings.php</code>, setelah mencantumkan <code>DynamicPageList2.php</code>.)',
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTNOINCLUDEDCATS => "KESALAHAN: Anda harus memberikan paling tidak satu kategori jika menggunakan 'addfirstcategorydate=true' atau 'ordermethod=categoryadd'!",
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTMORETHAN1CAT => "KESALAHAN: Jika Anda memberikan lebih dari satu kategori, Anda tidak dapat menggunakan 'addfirstcategorydate=true' atau 'ordermethod=categoryadd'!",
+	'dpl2_debug_' . DPL2_ERR_MORETHAN1TYPEOFDATE => 'KESALAHAN: Anda tidak dapat memberikan lebih dari satu jenis tanggal dalam satu waktu!',
+	'dpl2_debug_' . DPL2_ERR_WRONGORDERMETHOD => "KESALAHAN: Anda dapat menggunakan '$0' hanya dengan 'ordermethod=[...,]$1'!",
+	'dpl2_debug_' . DPL2_ERR_NOCLVIEW => "KESALAHAN: Tidak dapat melakukan operasi logika pada halaman yang tak terkategori (misalnya dengan parameter 'kategori') karena view $0 tidak ada di basis data! Bantuan: mintalah admin basis data untuk menjalankan kueri berikut: <code>$1</code>.",
+	'dpl2_debug_' . DPL2_WARN_UNKNOWNPARAM => "KESALAHAN: Paramater yang tak dikenal '$0' diabaikan. Bantuan: parameter yang tersedia: <code>$1</code>.",
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM => "KESALAHAN: Parameter '$0' salah: '$1'! Menggunakan konfigurasi baku: '$2'. Bantuan: <code>$0= $3</code>.",
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM_INT => "KESALAHAN: Parameter '$0' salah: '$1'! Menggunakan konfigurasi baku: '$2' (tanpa limitasi). Bantuan: <code>$0= <i>string kosong</i> (tanpa limitasi) | n</code>, dengan <code>n</code> suatu bilangan positif.",
+	'dpl2_debug_' . DPL2_WARN_NORESULTS => 'KESALAHAN: Hasil tak ditemukan!',
+	'dpl2_debug_' . DPL2_WARN_CATOUTPUTBUTWRONGPARAMS => "KESALAHAN: Menambahkan * parameter ('adduser', 'addeditdate', dll.)' dan 'includepage' tidak berpengaruh pada 'mode=category'. Hanya ruang nama/judul halaman yang dapat ditampilkan dengan mode ini.",
+	'dpl2_debug_' . DPL2_WARN_HEADINGBUTSIMPLEORDERMETHOD => "KESALAHAN: 'headingmode=$0' tidak berpengaruh dengan 'ordermethod' pada suatu komponen tunggal. Menggunakan: '$1'. Bantuan: Anda dapat menggunakan nilai not-$1 'headingmode' dengan 'ordermethod' terhadap beberapa komponen. Komponen pertama digunakan sebagai judul. Misalnya 'ordermethod=category,<i>comp</i>' (<i>comp</i> adalah komponen lain) untuk judul kategori.",
+	'dpl2_debug_' . DPL2_WARN_DEBUGPARAMNOTFIRST => "KESALAHAN: 'debug=$0' tidak pada posisi pertama pada elemen DPL. Aturan debug tidak diterapkan sebelum semua variabel sebelumnya telah diparsing dan dicek.",
+	'dpl2_debug_' . DPL2_WARN_TRANSCLUSIONLOOP => "KESALAHAN: Suatu lingkaran transklusi tak hingga ditimbulkan oleh halaman '$0'.",
+	'dpl2_debug_' . DPL2_QUERY => 'KUERI: <code>$0</code>',
+	'dpl2_articlecount' => 'Terdapat {{PLURAL:$1|artikel|artikel}} dalam judul ini.'
+);
+$wgDPL2Messages['it'] = array(
+	/*
+		Debug
+	*/
+	// (FATAL) ERRORS
+	/**
+	 * $0: 'namespace' or 'notnamespace'
+	 * $1: wrong parameter given by user
+	 * $3: list of possible titles of namespaces (except pseudo-namespaces: Media, Special)
+	 */
+	'dpl2_debug_' . DPL2_ERR_WRONGNS => "ERRORE nel parametro '$0': '$1'. Suggerimento:  <code>$0= <i>stringa vuota</i> (Principale)$3</code>. (Sono ammessi gli equivalenti con 'magic word'.)",
+	/**
+	 * $0: 'linksto' (left as $0 just in case the parameter is renamed in the future)
+	 * $1: wrong parameter given by user
+	*/
+	'dpl2_debug_' . DPL2_ERR_WRONGLINKSTO => "ERRORE nel parametro '$0': '$1'. Suggerimento:  <code>$0= <i>nome completo della pagina</i></code>. (Sono ammesse le 'magic word'.)",
+	/**
+	 * $0: max number of categories that can be included
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOMANYCATS => 'ERRORE: Categorie sovrabbondanti (massimo $0). Suggerimento: aumentare il valore di <code>$wgDPL2MaxCategoryCount</code> per indicare un numero maggiore di categorie, oppure impostare <code>$wgDPL2AllowUnlimitedCategories=true</code> per non avere alcun limite. (Impostare le variabili nel file <code>LocalSettings.php</code>, dopo l\'inclusione di <code>DynamicPageList2.php</code>.)',
+	/**
+	 * $0: min number of categories that have to be included
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOFEWCATS => 'ERRORE: Categorie insufficienti (minimo $0). Suggerimento: diminuire il valore di <code>$wgDPL2MinCategoryCount</code> per indicare un numero minore di categorie. (Impostare la variabile nel file <code>LocalSettings.php</code>, dopo l\'inclusione di <code>DynamicPageList2.php</code>.)',
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTNOINCLUDEDCATS => "ERRORE: L'uso dei parametri 'addfirstcategorydate=true' e 'ordermethod=categoryadd' richiede l'inserimento di una o più categorie.",
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTMORETHAN1CAT => "ERRORE: L'inserimento di più categorie impedisce l'uso dei parametri 'addfirstcategorydate=true' e 'ordermethod=categoryadd'.",
+	'dpl2_debug_' . DPL2_ERR_MORETHAN1TYPEOFDATE => 'ERRORE: Non è consentito l\'uso contemporaneo di più tipi di data.',
+	/**
+	 * $0: param=val that is possible only with $1 as last 'ordermethod' parameter
+	 * $1: last 'ordermethod' parameter required for $0
+	*/
+	'dpl2_debug_' . DPL2_ERR_WRONGORDERMETHOD => "ERRORE: L'uso del parametro '$0' è consentito unicamente con 'ordermethod=[...,]$1'.",
+	/**
+	 * $0: prefix_dpl_clview where 'prefix' is the prefix of your mediawiki table names
+	 * $1: SQL query to create the prefix_dpl_clview on your mediawiki DB
+	*/
+	'dpl2_debug_' . DPL2_ERR_NOCLVIEW => "ERRORE: Impossibile effettuare operazioni logiche sulle pagine prive di categoria (ad es. con il parametro 'category') in quanto il database non contiene la vista $0. Suggerimento: chiedere all'amministratore del database di eseguire la seguente query: <code>$1</code>.",
+
+	// WARNINGS
+	/**
+	 * $0: unknown parameter given by user
+	 * $1: list of DPL2 available parameters separated by ', '
+	*/
+	'dpl2_debug_' . DPL2_WARN_UNKNOWNPARAM => "ATTENZIONE: Il parametro non riconosciuto '$0' è stato ignorato. Suggerimento: i parametri disponibili sono: <code>$1</code>.",
+	/**
+	 * $3: list of valid param values separated by ' | '
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM => "ATTENZIONE: Errore nel parametro '$0': '$1'. È stato usato il valore predefinito '$2'. Suggerimento: <code>$0= $3</code>.",
+	/**
+	 * $0: param name
+	 * $1: wrong param value given by user
+	 * $2: default param value used instead by program
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM_INT => "ATTENZIONE: errore nel parametro '$0': '$1'. È stato usato il valore predefinito '$2' (nessun limite). Suggerimento: <code>$0= <i>stringa vuota</i> (nessun limite) | n</code>, con <code>n</code> intero positivo.",
+	'dpl2_debug_' . DPL2_WARN_NORESULTS => 'ATTENZIONE: Nessun risultato.',
+	'dpl2_debug_' . DPL2_WARN_CATOUTPUTBUTWRONGPARAMS => "ATTENZIONE: I parametri add* ('adduser', 'addeditdate', ecc.)' non hanno alcun effetto quando è specificato 'mode=category'. In tale modalità vengono visualizzati unicamente il namespace e il titolo della pagina.",
+	/**
+	 * $0: 'headingmode' value given by user
+	 * $1: value used instead by program (which means no heading)
+	*/
+	'dpl2_debug_' . DPL2_WARN_HEADINGBUTSIMPLEORDERMETHOD => "ATTENZIONE: Il parametro 'headingmode=$0' non ha alcun effetto quando è specificato 'ordermethod' su un solo componente. Verrà utilizzato il valore '$1'. Suggerimento: è posibile utilizzare i valori diversi da $1 per il parametro 'headingmode' nel caso di 'ordermethod' su più componenti. Il primo componente viene usato per generare i titoli di sezione. Ad es. 'ordermethod=category,<i>comp</i>' (dove <i>comp</i> è un altro componente) per avere titoli di sezione basati sulla categoria.",
+	/**
+	 * $0: 'debug' value
+	*/
+	'dpl2_debug_' . DPL2_WARN_DEBUGPARAMNOTFIRST => "ATTENZIONE: Il parametro 'debug=$0' non è il primo elemento della sezione DPL. Le nuove impostazioni di debug non verranno applicate prima di aver completato il parsing e la verifica di tutti i parametri che lo precedono.",
+
+	// OTHERS
+	/**
+	 * $0: SQL query executed to generate the dynamic page list
+	*/
+	'dpl2_debug_' . DPL2_QUERY => 'QUERY: <code>$0</code>',
+
+	/*
+	   Output formatting
+	*/
+	/**
+	 * $1: number of articles
+	*/
+	'dpl2_articlecount' => 'Questa sezione contiene {{PLURAL:$1|una voce|$1 voci}}.'
+);
+$wgDPL2Messages['nl'] = array(
+	/*
+		Debug
+	*/
+	// (FATAL) ERRORS
+	/**
+	 * $0: 'namespace' or 'notnamespace'
+	 * $1: wrong parameter given by user
+	 * $3: list of possible titles of namespaces (except pseudo-namespaces: Media, Special)
+	 */
+	'dpl2_debug_' . DPL2_ERR_WRONGNS => "FOUT: Verkeerde parameter '$0': '$1'! Hulp:  <code>$0= <i>lege string</i> (Main)$3</code>. Equivalenten met magic words zijn ook toegestaan.",
+	/**
+	 * $0: 'linksto' (left as $0 just in case the parameter is renamed in the future)
+	 * $1: wrong parameter given by user
+	*/
+	'dpl2_debug_' . DPL2_ERR_WRONGLINKSTO => "FOUT: Verkeerde paramater'$0': '$1'! Help:  <code>$0= <i>full pagename</i></code>. Magic words zijn toegestaan.",
+	/**
+	 * $0: max number of categories that can be included
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOMANYCATS => 'FOUT: Te veel categoriën! Maximum: $0. Hulp: verhoog <code>$wgDPL2MaxCategoryCount</code> om meer categorieën op te kunnen geven of stel geen limiet in met <code>$wgDPL2AllowUnlimitedCategories=true</code>. (Neem deze variabele op in <code>LocalSettings.php</code>, na het toevoegen van <code>DynamicPageList2.php</code>.)',
+	/**
+	 * $0: min number of categories that have to be included
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOFEWCATS => 'FOUT: Te weinig categorieën! Minimum: $0. Hulp: verlaag <code>$wgDPL2MinCategoryCount</code> om minder categorieën aan te hoeven geven. (Stel de variabele bij voorkeur in via <code>LocalSettings.php</code>, na het toevoegen van <code>DynamicPageList2.php</code>.)',
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTNOINCLUDEDCATS => "FOUT: U dient tenminste één categorie op te nemen als u 'addfirstcategorydate=true' of 'ordermethod=categoryadd' wilt gebruiken!",
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTMORETHAN1CAT => "FOUT: Als u meer dan één categorie opneemt, kunt u 'addfirstcategorydate=true' of 'ordermethod=categoryadd' niet gebruiken!",
+	'dpl2_debug_' . DPL2_ERR_MORETHAN1TYPEOFDATE => 'FOUT: U kunt niet meer dan één type of datum tegelijk gebruiken!',
+	/**
+	 * $0: param=val that is possible only with $1 as last 'ordermethod' parameter
+	 * $1: last 'ordermethod' parameter required for $0
+	*/
+	'dpl2_debug_' . DPL2_ERR_WRONGORDERMETHOD => "FOUT: U kunt '$0' alleen met 'ordermethod=[...,]$1' gebruiken!",
+	/**
+	 * $0: prefix_dpl_clview where 'prefix' is the prefix of your mediawiki table names
+	 * $1: SQL query to create the prefix_dpl_clview on your mediawiki DB
+	*/
+	'dpl2_debug_' . DPL2_ERR_NOCLVIEW => $wgDPL2Messages['en']['dpl2_debug_' . DPL2_ERR_NOCLVIEW],
+
+	// WARNINGS
+	/**
+	 * $0: unknown parameter given by user
+	 * $1: list of DPL2 available parameters separated by ', '
+	*/
+	'dpl2_debug_' . DPL2_WARN_UNKNOWNPARAM => $wgDPL2Messages['en']['dpl2_debug_' . DPL2_WARN_UNKNOWNPARAM],
+	/**
+	 * $3: list of valid param values separated by ' | '
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM => "WAARSCHUWING: Verkeerde parameter '$0': '$1'! Nu wordt de standaard gebruikt: '$2'. Hulp: <code>$0= $3</code>.",
+	/**
+	 * $0: param name
+	 * $1: wrong param value given by user
+	 * $2: default param value used instead by program
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM_INT => $wgDPL2Messages['en']['dpl2_debug_' . DPL2_WARN_WRONGPARAM_INT],
+	'dpl2_debug_' . DPL2_WARN_NORESULTS => 'WAARSCHUWING: Geen resultaten!',
+	'dpl2_debug_' . DPL2_WARN_CATOUTPUTBUTWRONGPARAMS => "WAARSCHUWING: Add* parameters ('adduser', 'addeditdate', etc.)' en 'includepage' heeft geen effect bij 'mode=category'. Alleen de paginanaamruimte/titel is in deze modus te bekijken.",
+	/**
+	 * $0: 'headingmode' value given by user
+	 * $1: value used instead by program (which means no heading)
+	*/
+	'dpl2_debug_' . DPL2_WARN_HEADINGBUTSIMPLEORDERMETHOD => "WAARSCHUWING: 'headingmode=$0' heeft geen effect met 'ordermethod' op een enkele component. Nu wordt gebruikt: '$1'. Hulp: u kunt een niet-$1 'headingmode'-waarde gebruiken met 'ordermethod' op meerdere componenten. De eerste component wordt gebruikt als kop. Bijvoorbeeld 'ordermethod=category,<i>comp</i>' (<i>comp</i> is een ander component) voor categoriekoppen.",
+	/**
+	 * $0: 'debug' value
+	*/
+	'dpl2_debug_' . DPL2_WARN_DEBUGPARAMNOTFIRST => "WAARSCHUWING: 'debug=$0' is niet de eerste positie in het DPL-element. De nieuwe debuginstellingen zijn niet toegepast voor alle voorgaande parameters zijn verwerkt en gecontroleerd.",
+	/**
+	 * $0: title of page that creates an infinite transclusion loop
+	*/
+	'dpl2_debug_' . DPL2_WARN_TRANSCLUSIONLOOP => "WAARSCHUWING: Pagina '$0' veroorzaakt een oneindige transclusie.",
+
+	// OTHERS
+	/**
+	 * $0: SQL query executed to generate the dynamic page list
+	*/
+	'dpl2_debug_' . DPL2_QUERY => 'QUERY: <code>$0</code>',
+
+	/*
+	   Output formatting
+	*/
+	/**
+	 * $1: number of articles
+	*/
+	'dpl2_articlecount' => 'Er {{PLURAL:$1|is één pagina|zijn $1 pagina\'s}} onder deze kop.'
+);
+$wgDPL2Messages['ru'] = array(
+	/*
+		Debug
+	*/
+	// (FATAL) ERRORS
+	/**
+	 * $0: 'namespacenamespace' or 'notnamespace'
+	 * $1: wrong parameter given by user
+	 * $3: list of possible titles of namespaces (except pseudo-namespaces: Media, Special)
+	 */
+	'dpl2_debug_' . DPL2_ERR_WRONGNS => "ОШИБКА: неправильный «$0»-параметр: «$1»! Подсказка:  <code>$0= <i>пустая строка</i> (Основное)$3</code>.",
+	/**
+	 * $0: max number of categories that can be included
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOMANYCATS => 'ОШИБКА: слишком много категорий! Максимум: $0. Подсказка: увеличте <code>$wgDPL2MaxCategoryCount</code> чтобы разрешить больше категорий или установите <code>$wgDPL2AllowUnlimitedCategories=true</code> для снятия ограничения. (Устанавливайте переменные в <code>LocalSettings.php</code>, после подключения <code>DynamicPageList2.php</code>.)',
+	/**
+	 * $0: min number of categories that have to be included
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOFEWCATS => 'ОШИБКА: слишком мало категорий! Минимум: $0. Подсказка: уменьшите <code>$wgDPL2MinCategoryCount</code> чтобы разрешить меньше категорий. (Устанавливайте переменную в <code>LocalSettings.php</code>, после подключения <code>DynamicPageList2.php</code>.)',
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTNOINCLUDEDCATS => "ОШИБКА: вы должны включить хотя бы одну категорию, если вы хотите использовать «addfirstcategorydate=true» или «ordermethod=categoryadd»!",
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTMORETHAN1CAT => "ОШИБКА: если вы включаете больше одной категории, то вы не можете использовать «addfirstcategorydate=true» или «ordermethod=categoryadd»!",
+	'dpl2_debug_' . DPL2_ERR_MORETHAN1TYPEOFDATE => 'ОШИБКА: вы не можете добавить более одного типа данных за раз!',
+	/**
+	 * $0: param=val that is possible only with $1 as last 'ordermethod' parameter
+	 * $1: last 'ordermethod' parameter required for $0
+	*/
+	'dpl2_debug_' . DPL2_ERR_WRONGORDERMETHOD => "ОШИБКА: вы можете использовать «$0» только с «ordermethod=[...,]$1»!",
+	/**
+	 * $0: prefix_dpl_clview where 'prefix' is the prefix of your mediawiki table names
+	 * $1: SQL query to create the prefix_dpl_clview on your mediawiki DB
+	*/
+	'dpl2_debug_' . DPL2_ERR_NOCLVIEW => $wgDPL2Messages['en']['dpl2_debug_' . DPL2_ERR_NOCLVIEW],
+
+	// WARNINGS
+	/**
+	 * $0: unknown parameter given by user
+	 * $1: list of DPL2 available parameters separated by ', '
+	*/
+	'dpl2_debug_' . DPL2_WARN_UNKNOWNPARAM => "ПРЕДУПРЕЖДЕНИЕ: неизвестный параметр «$0» проигнорирован. Подсказка: доступные параметры: <code>$1</code>.",
+	/**
+	 * $3: list of valid param values separated by ' | '
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM => "ПРЕДУПРЕЖДЕНИЕ: неправильный параметр «$0»: «$1»! Использование параметра по умолчанию: «$2». Подсказка: <code>$0= $3</code>.",
+	/**
+	 * $0: param name
+	 * $1: wrong param value given by user
+	 * $2: default param value used instead by program
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM_INT => "ПРЕДУПРЕЖДЕНИЕ: неправильный параметр «$0»: «$1»! Использование параметра по умолчанию: «$2» (без ограничений). Подсказка: <code>$0= <i>пустая строка</i> (без ограничений) | n</code>, с <code>n</code> равным положительному целому числу.",
+	'dpl2_debug_' . DPL2_WARN_NORESULTS => 'ПРЕДУПРЕЖДЕНИЕ: не найдено!',
+	'dpl2_debug_' . DPL2_WARN_CATOUTPUTBUTWRONGPARAMS => "ПРЕДУПРЕЖДЕНИЕ: Добавление* параметров («adduser», «addeditdate», и др.) не действительны с «mode=category». Только пространства имён или названия могут просматриваться в этом режиме.",
+	/**
+	 * $0: 'headingmode' value given by user
+	 * $1: value used instead by program (which means no heading)
+	*/
+	'dpl2_debug_' . DPL2_WARN_HEADINGBUTSIMPLEORDERMETHOD => "ПРЕДУПРЕЖДЕНИЕ: «headingmode=$0» не действителен с «ordermethod» в одном компоненте. Использование: «$1». Подсказка: вы можете использоватьe не-$1 «headingmode» значения с «ordermethod» во множестве компонентов. Первый компонент используется для заголовков. Например, «ordermethod=category,<i>comp</i>» (<i>comp</i> является другим компонентом) для заголовков категорий.",
+	/**
+	 * $0: 'debug' value
+	*/
+	'dpl2_debug_' . DPL2_WARN_DEBUGPARAMNOTFIRST => "ПРЕДУПРЕЖДЕНИЕ: «debug=$0» не находится на первом месте в DPL-элементе. Новые настройки отладки не будут применены пока все предыдущие параметры не будут разобраны и проверены.",
+
+	// OTHERS
+	/**
+	 * $0: SQL query executed to generate the dynamic page list
+	*/
+	'dpl2_debug_' . DPL2_QUERY => 'ЗАПРОС: <code>$0</code>',
+
+	/*
+	   Output formatting
+	*/
+	/**
+	 * $1: number of articles
+	*/
+	'dpl2_articlecount' => 'В этом заголовке $1 {{PLURAL:$1|статья|статьи|статей}}.'
+);
+$wgDPL2Messages['sk'] = array(
+	/*
+		Debug
+	*/
+	// (FATAL) ERRORS
+	/**
+	 * $0: 'namespace' or 'notnamespace'
+	 * $1: wrong parameter given by user
+	 * $3: list of possible titles of namespaces (except pseudo-namespaces: Media, Special)
+	 */
+	'dpl2_debug_' . DPL2_ERR_WRONGNS => "CHYBA: nesprávny parameter '$0': '$1'! Pomocník <code>$0= <i>prázdny reťazec</i> (Hlavný)$3<code>. (Ekvivalenty s magickými slovami sú tiež povolené.)",
+	/**
+	 * $0: 'linksto' (left as $0 just in case the parameter is renamed in the future)
+	 * $1: wrong parameter given by user
+	*/
+	'dpl2_debug_' . DPL2_ERR_WRONGLINKSTO => "CHYBA: Zlý parameter '$0': '$1'! Pomocník <code>$0= <i>plný názov stránky</i></code>. (Magické slová sú povolené.)",
+	/**
+	 * $0: max number of categories that can be included
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOMANYCATS => 'CHYBA: Príliš veľa kategórií! Maximum: $0. Pomocník: zväčšite <code>$wgDPL2MaxCategoryCount</code>, aby ste mohli špecifikovať viac kategórií alebo nastavte <code>$wgDPL2AllowUnlimitedCategories=true</code> pre vypnutie limitu. (Premennú nastatavte v <code>LocalSettings.php</code>, potom ako bol includovaný <code>DynamicPageList2.php</code>.)',
+	/**
+	 * $0: min number of categories that have to be included
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOFEWCATS => 'CHYBA: Príliš málo kategórií! Minimum: $0. Pomocník: znížte <code>$wgDPL2MinCategoryCount</code>, aby ste mohli špecifikovať menej kategórií. (Premennú nastavte najlepšie v <code>LocalSettings.php</code> potom, ako v ňom bol includovaný <code>DynamicPageList2.php</code>.)',
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTNOINCLUDEDCATS => "CHYBA: Musíte uviesť aspoň jednu kategóriu ak chcete použiť 'addfirstcategorydate=true' alebo 'ordermethod=categoryadd'!",
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTMORETHAN1CAT => "CHYBA: Ak zahrniete viac ako jednu kategóriu, nemôžete použiť 'addfirstcategorydate=true' alebo 'ordermethod=categoryadd'!",
+	'dpl2_debug_' . DPL2_ERR_MORETHAN1TYPEOFDATE => 'CHYBA: Nemôžete naraz pridať viac ako jeden typ dátumu!',
+	/**
+	 * $0: param=val that is possible only with $1 as last 'ordermethod' parameter
+	 * $1: last 'ordermethod' parameter required for $0
+	*/
+	'dpl2_debug_' . DPL2_ERR_WRONGORDERMETHOD => "CHYBA: '$0' môžete použiť iba s 'ordermethod=[...,]$1'!",
+	/**
+	 * $0: prefix_dpl_clview where 'prefix' is the prefix of your mediawiki table names
+	 * $1: SQL query to create the prefix_dpl_clview on your mediawiki DB
+	*/
+	'dpl2_debug_' . DPL2_ERR_NOCLVIEW => "CHYBA: Nie je momožné vykonávať logické operácie na nekategorizovaných kategóriách (napr. s parametrom 'Kategória') lebo neexistuje na databázu pohľad $0! Pomocník: nech admin databázy vykoná tento dotaz: <code>$1</code>.",
+
+	// WARNINGS
+	/**
+	 * $0: unknown parameter given by user
+	 * $1: list of DPL2 available parameters separated by ', '
+	*/
+	'dpl2_debug_' . DPL2_WARN_UNKNOWNPARAM => "VAROVANIE: Neznámy parameter '$0' ignorovaný. Pomocník: dostupné parametre: <code>$1</code>.",
+	/**
+	 * $3: list of valid param values separated by ' | '
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM => "VAROVANIE: Nesprávny '$0' parameter: '$1'! Používam štandardný '$2'. Pomocník: <code>$0= $3</code>.",
+	/**
+	 * $0: param name
+	 * $1: wrong param value given by user
+	 * $2: default param value used instead by program
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM_INT => "VAROVANIE: Nesprávny parameter  '$0': '$1'! Používam štandardný: '$2' (bez obmedzenia). Pomocník: <code>$0= <i>prázdny reťazec</i> (bez obmedzenia) | n</code>, s kladným celým číslom <code>n</code>.",
+	'dpl2_debug_' . DPL2_WARN_NORESULTS => 'VAROVANIE: No results!',
+	'dpl2_debug_' . DPL2_WARN_CATOUTPUTBUTWRONGPARAMS => "VAROVANIE: Parametre Add* ('adduser', 'addeditdate', atď' nepracujú s mode=category'. V tomto režime je možné prehliadať iba menný priestor/titulok stránky.",
+	/**
+	 * $0: 'headingmode' value given by user
+	 * $1: value used instead by program (which means no heading)
+	*/
+	'dpl2_debug_' . DPL2_WARN_HEADINGBUTSIMPLEORDERMETHOD => "VAROVANIE: 'headingmode=$0' nepracuje s 'ordermethod' na jednom komponente. Použitie: '$1'. Pomocník: môžete použiť not-$1 hodnoty 'headingmode' s 'ordermethod' na viaceré komponenty. Prvý komponent sa používa na nadpisy. Napr. 'ordermethod=category,<i>comp</i>' (<i>comp</i> je iný komponent) pre nadpisy kategórií.",
+	/**
+	 * $0: 'debug' value
+	*/
+	'dpl2_debug_' . DPL2_WARN_DEBUGPARAMNOTFIRST => "VAROVANIE: 'debug=$0' nie je na prvej pozícii v prvku DPL. Nové ladiacie nastavenia nebudú použíté skôr než budú parsované a skontrolované všetky predchádzajúce.",
+
+	// OTHERS
+	/**
+	 * $0: SQL query executed to generate the dynamic page list
+	*/
+	'dpl2_debug_' . DPL2_QUERY => 'DOTAZ: <code>$0</code>',
+
+	/*
+	   Output formatting
+	*/
+	/**
+	 * $1: number of articles
+	*/
+	'dpl2_articlecount' => 'V tomto nadpise {{PLURAL:$1|je jeden článok|sú $1 články|je $1 článkov}}.'
+);
+$wgDPL2Messages['sr-ec'] = array(
+	/*
+		Debug
+	*/
+	// (FATAL) ERRORS
+	/**
+	 * $0: 'namespace' или 'notnamespace'
+	 * $1: корисник је унео погрешан параметар
+	 * $3: списак могућих наслова за именски простор (сем именских простора: Медија, Посебно)
+	 */
+	'dpl2_debug_' . DPL2_ERR_WRONGNS => "ГРЕШКА: Погреан '$0' параметар: '$1'! Помоћ:  <code>$0= <i>погрешан стринг</i> (Главно)$3</code>. (Еквиваленти са магичним речима су такође дозвољени.)",
+	/**
+	 * $0: 'linksto' (остављено као $0 у случају да се параметар промени у будућности)
+	 * $1: корисник је унео погрешан параметар
+	*/
+	'dpl2_debug_' . DPL2_ERR_WRONGLINKSTO => "ГРЕШКА: Погрешан '$0' параметар: '$1'! Помоћ:  <code>$0= <i>пуно име странице</i></code>. (Магичне речи су дозвољене.)",
+	/**
+	 * $0: максималан број категорија које се могу укључити
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOMANYCATS => 'ГРЕШКА: Превише категорија! Максимум је: $0. Помоћ: повећајте <code>$wgDPL2MaxCategoryCount</code> како бисте поставили више категорија или промените <code>$wgDPL2AllowUnlimitedCategories=true</code> за без граница. (Подесите варијаблу у <code>LocalSettings.php</code>, након укључивања <code>DynamicPageList2.php</code>.)',
+	/**
+	 * $0: минималан број категорија који се могу укључити
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOFEWCATS => 'ГРЕШКА: Премало категорија! Минимум је: $0. Помоћ: повећајте <code>$wgDPL2MinCategoryCount</code> како бисте поставили мање категорија. (Подесите варијаблу у <code>LocalSettings.php</code>, након укључивања <code>DynamicPageList2.php</code>.)',
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTNOINCLUDEDCATS => "ГРЕШКА: Морате укључити бар једну категорију уколико желите да користите 'addfirstcategorydate=true' или 'ordermethod=categoryadd'!",
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTMORETHAN1CAT => "ГРЕШКА: Уколико укључујете више од једне категорије, не можете користити 'addfirstcategorydate=true' или 'ordermethod=categoryadd'!",
+	'dpl2_debug_' . DPL2_ERR_MORETHAN1TYPEOFDATE => 'ГРЕШКА: Не можете додати више од једног типа датума!',
+	/**
+	 * $0: param=val је могућ само са $1 на мање 'ordermethod' параметром
+	 * $1: последњи 'ordermethod' параметар је потребан за $0
+	*/
+	'dpl2_debug_' . DPL2_ERR_WRONGORDERMETHOD => "ГРЕШКА: Можете користити '$0' са 'ordermethod=[...,]$1' искључиво!",
+	/**
+	 * $0: prefix_dpl_clview где је 'prefix' префикс имена медијавики табела
+	 * $1: SQL упит за креирање prefix_dpl_clview на бази података вашег МедијаВикија
+	*/
+	'dpl2_debug_' . DPL2_ERR_NOCLVIEW => "ГРЕШКА: Немогуће извршити операцију на некатегоризованим страницама (нпр. са 'category' параметром) зато што $0 преглед не постоји у бази података! Помоћ: нека администратор базе изврши овај упит: <code>$1</code>.",
+
+	// WARNINGS
+	/**
+	 * $0: корисник је унео непознат параметар
+	 * $1: списак DPL2 могућих параметара одвојених са ', '
+	*/
+	'dpl2_debug_' . DPL2_WARN_UNKNOWNPARAM => "ПАЖЊА: Непознат параметар '$0' је игнорисан. Помоћ: доступни параметри су: <code>$1</code>.",
+	/**
+	 * $3: списак валидних података параметара одвојених са ' | '
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM => "ПАЖЊА: Погрешан '$0' параметар: '$1'! Користи се основни: '$2'. Помоћ: <code>$0= $3</code>.",
+	/**
+	 * $0: име параметра
+	 * $1: корисник је унео непознат параметар
+	 * $2: користи се основни податак параметра уместо програмски
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM_INT => "ПАЖЊА: Погрешан '$0' параметар: '$1'! Користи се основни: '$2' (без границе). Помоћ: <code>$0= <i>празан стринг</i> (без границе) | n</code>, с <code>n</code> је позитиван интегер.",
+	'dpl2_debug_' . DPL2_WARN_NORESULTS => 'ПАЖЊА: Нема резултата!',
+	'dpl2_debug_' . DPL2_WARN_CATOUTPUTBUTWRONGPARAMS => "ПАЖЊА: Додавање* параметара ('adduser', 'addeditdate', итд.)' и 'includepage' нема ефекта са 'mode=category'. Искључиво име странице/именски простор могу да се виде у овом моду.",
+	/**
+	 * $0: 'headingmode' податак који је унео корисник
+	 * $1: подаци кориштени уместо програма (што значи без наслова)
+	*/
+	'dpl2_debug_' . DPL2_WARN_HEADINGBUTSIMPLEORDERMETHOD => "ПАЖЊА: 'headingmode=$0' нема ефекта са 'ordermethod' на једној компоненти. Користи се: '$1'. Помоћ: не морате користити-$1 'headingmode' податке 'ordermethod' на више компоненти. Прва компонента се користи за наслов. Нпр. 'ordermethod=category,<i>компонента</i>' (<i>компонента</i> је друга компонента) за наслове категорија.",
+	/**
+	 * $0: 'debug' value
+	*/
+	'dpl2_debug_' . DPL2_WARN_DEBUGPARAMNOTFIRST => "ПАЖЊА: 'debug=$0' није на првом месту у DPL елементу. Нова дебаг подешавања нису примењена пре свих параметара који су проверени",
+	/**
+	 * $0: наслов странице која прави бесконачну петљу.
+	*/
+	'dpl2_debug_' . DPL2_WARN_TRANSCLUSIONLOOP => "ПАЖЊА: Бесконачна петљаса странице '$0'.",
+
+	// OTHERS
+	/**
+	 * $0: SQL упит за генерисање динамичног списка страница
+	*/
+	'dpl2_debug_' . DPL2_QUERY => 'УПИТ: <code>$0</code>',
+
+	/*
+	   Output formatting
+	*/
+	/**
+	 * $1: број чланака
+	*/
+	'dpl2_articlecount' => 'У овом наслову се тренутно налази {{PLURAL:$1|један чланак|$1 чланка|$1 чланака}}.'
+);
+$wgDPL2Messages['sr-el'] = array(
+	/*
+		Debug
+	*/
+	// (FATAL) ERRORS
+	/**
+	 * $0: 'namespace' ili 'notnamespace'
+	 * $1: korisnik je uneo pogrešan parametar
+	 * $3: spisak mogućih naslova za imenski prostor (sem imenskih prostora: Medija, Posebno)
+	 */
+	'dpl2_debug_' . DPL2_ERR_WRONGNS => "GREŠKA: Pogrean '$0' parametar: '$1'! Pomoć:  <code>$0= <i>pogrešan string</i> (Glavno)$3</code>. (Ekvivalenti sa magičnim rečima su takođe dozvoljeni.)",
+	/**
+	 * $0: 'linksto' (ostavljeno kao $0 u slučaju da se parametar promeni u budućnosti)
+	 * $1: korisnik je uneo pogrešan parametar
+	*/
+	'dpl2_debug_' . DPL2_ERR_WRONGLINKSTO => "GREŠKA: Pogrešan '$0' parametar: '$1'! Pomoć:  <code>$0= <i>puno ime stranice</i></code>. (Magične reči su dozvoljene.)",
+	/**
+	 * $0: maksimalan broj kategorija koje se mogu uključiti
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOMANYCATS => 'GREŠKA: Previše kategorija! Maksimum je: $0. Pomoć: povećajte <code>$wgDPL2MaxCategoryCount</code> kako biste postavili više kategorija ili promenite <code>$wgDPL2AllowUnlimitedCategories=true</code> za bez granica. (Podesite varijablu u <code>LocalSettings.php</code>, nakon uključivanja <code>DynamicPageList2.php</code>.)',
+	/**
+	 * $0: minimalan broj kategorija koji se mogu uključiti
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOFEWCATS => 'GREŠKA: Premalo kategorija! Minimum je: $0. Pomoć: povećajte <code>$wgDPL2MinCategoryCount</code> kako biste postavili manje kategorija. (Podesite varijablu u <code>LocalSettings.php</code>, nakon uključivanja <code>DynamicPageList2.php</code>.)',
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTNOINCLUDEDCATS => "GREŠKA: Morate uključiti bar jednu kategoriju ukoliko želite da koristite 'addfirstcategorydate=true' ili 'ordermethod=categoryadd'!",
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTMORETHAN1CAT => "GREŠKA: Ukoliko uključujete više od jedne kategorije, ne možete koristiti 'addfirstcategorydate=true' ili 'ordermethod=categoryadd'!",
+	'dpl2_debug_' . DPL2_ERR_MORETHAN1TYPEOFDATE => 'GREŠKA: Ne možete dodati više od jednog tipa datuma!',
+	/**
+	 * $0: param=val je moguć samo sa $1 na manje 'ordermethod' parametrom
+	 * $1: poslednji 'ordermethod' parametar je potreban za $0
+	*/
+	'dpl2_debug_' . DPL2_ERR_WRONGORDERMETHOD => "GREŠKA: Možete koristiti '$0' sa 'ordermethod=[...,]$1' isključivo!",
+	/**
+	 * $0: prefix_dpl_clview gde je 'prefix' prefiks imena medijaviki tabela
+	 * $1: SQL upit za kreiranje prefix_dpl_clview na bazi podataka vašeg MedijaVikija
+	*/
+	'dpl2_debug_' . DPL2_ERR_NOCLVIEW => "GREŠKA: Nemoguće izvršiti operaciju na nekategorizovanim stranicama (npr. sa 'category' parametrom) zato što $0 pregled ne postoji u bazi podataka! Pomoć: neka administrator baze izvrši ovaj upit: <code>$1</code>.",
+
+	// WARNINGS
+	/**
+	 * $0: korisnik je uneo nepoznat parametar
+	 * $1: spisak DPL2 mogućih parametara odvojenih sa ', '
+	*/
+	'dpl2_debug_' . DPL2_WARN_UNKNOWNPARAM => "PAŽNJA: Nepoznat parametar '$0' je ignorisan. Pomoć: dostupni parametri su: <code>$1</code>.",
+	/**
+	 * $3: spisak validnih podataka parametara odvojenih sa ' | '
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM => "PAŽNJA: Pogrešan '$0' parametar: '$1'! Koristi se osnovni: '$2'. Pomoć: <code>$0= $3</code>.",
+	/**
+	 * $0: ime parametra
+	 * $1: korisnik je uneo nepoznat parametar
+	 * $2: koristi se osnovni podatak parametra umesto programski
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM_INT => "PAŽNJA: Pogrešan '$0' parametar: '$1'! Koristi se osnovni: '$2' (bez granice). Pomoć: <code>$0= <i>prazan string</i> (bez granice) | n</code>, s <code>n</code> je pozitivan integer.",
+	'dpl2_debug_' . DPL2_WARN_NORESULTS => 'PAŽNJA: Nema rezultata!',
+	'dpl2_debug_' . DPL2_WARN_CATOUTPUTBUTWRONGPARAMS => "PAŽNJA: Dodavanje* parametara ('adduser', 'addeditdate', itd.)' i 'includepage' nema efekta sa 'mode=category'. Isključivo ime stranice/imenski prostor mogu da se vide u ovom modu.",
+	/**
+	 * $0: 'headingmode' podatak koji je uneo korisnik
+	 * $1: podaci korišteni umesto programa (što znači bez naslova)
+	*/
+	'dpl2_debug_' . DPL2_WARN_HEADINGBUTSIMPLEORDERMETHOD => "PAŽNJA: 'headingmode=$0' nema efekta sa 'ordermethod' na jednoj komponenti. Koristi se: '$1'. Pomoć: ne morate koristiti-$1 'headingmode' podatke 'ordermethod' na više komponenti. Prva komponenta se koristi za naslov. Npr. 'ordermethod=category,<i>komponenta</i>' (<i>komponenta</i> je druga komponenta) za naslove kategorija.",
+	/**
+	 * $0: 'debug' value
+	*/
+	'dpl2_debug_' . DPL2_WARN_DEBUGPARAMNOTFIRST => "PAŽNJA: 'debug=$0' nije na prvom mestu u DPL elementu. Nova debag podešavanja nisu primenjena pre svih parametara koji su provereni",
+	/**
+	 * $0: naslov stranice koja pravi beskonačnu petlju.
+	*/
+	'dpl2_debug_' . DPL2_WARN_TRANSCLUSIONLOOP => "PAŽNJA: Beskonačna petljasa stranice '$0'.",
+
+	// OTHERS
+	/**
+	 * $0: SQL upit za generisanje dinamičnog spiska stranica
+	*/
+	'dpl2_debug_' . DPL2_QUERY => 'UPIT: <code>$0</code>',
+
+	/*
+	   Output formatting
+	*/
+	/**
+	 * $1: broj članaka
+	*/
+	'dpl2_articlecount' => 'U ovom naslovu se trenutno nalazi {{PLURAL:$1|jedan članak|$1 članka|$1 članaka}}.'
+);
+$wgDPL2Messages['sr'] = $wgDPL2Messages['sr-ec'];
+$wgDPL2Messages['zh-cn'] = array(
+	/*
+		Debug
+	*/
+	// (FATAL) ERRORS
+	/**
+	 * $0: 'namespace' or 'notnamespace'
+	 * $1: wrong parameter given by user
+	 * $3: list of possible titles of namespaces (except pseudo-namespaces: Media, Special)
+	 */
+	'dpl2_debug_' . DPL2_ERR_WRONGNS => "错误: 错误的 '$0' 参数: '$1'! 帮助:  <code>$0= <i>空白字符串</i> (主)$3</code>。",
+	/**
+	 * $0: max number of categories that can be included
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOMANYCATS => '错误: 过多分类! 最大值: $0。 帮助: 增加 <code>$wgDPL2MaxCategoryCount</code> 的值去指定更多的分类或设定 <code>$wgDPL2AllowUnlimitedCategories=true</code> 以解除限制。 (当加上 <code>DynamicPageList2.php</code>后，在<code>LocalSettings.php</code>中设定变量。)',
+	/**
+	 * $0: min number of categories that have to be included
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOFEWCATS => '错误: 过少分类! 最小值: $0。 帮助: 减少 <code>$wgDPL2MinCategoryCount</code> 的值去指定更少的分类。 (当加上 <code>DynamicPageList2.php</code>后，在<code>LocalSettings.php</code>中设定一个合适的变量。)',
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTNOINCLUDEDCATS => "错误: 如果您想用 'addfirstcategorydate=true' 或 'ordermethod=categoryadd' ，您需要包含最少一个分类!",
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTMORETHAN1CAT => "错误: 如果您包含多一个分类，您不可以用 'addfirstcategorydate=true' 或 'ordermethod=categoryadd'!",
+	'dpl2_debug_' . DPL2_ERR_MORETHAN1TYPEOFDATE => '错误: 您不可以在一个时间里加入多于一种嘅日期!',
+	/**
+	 * $0: param=val that is possible only with $1 as last 'ordermethod' parameter
+	 * $1: last 'ordermethod' parameter required for $0
+	*/
+	'dpl2_debug_' . DPL2_ERR_WRONGORDERMETHOD => "错误: 你只可以用 'ordermethod=[...,]$1' 在 '$0' 上!",
+	/**
+	 * $0: prefix_dpl_clview where 'prefix' is the prefix of your mediawiki table names
+	 * $1: SQL query to create the prefix_dpl_clview on your mediawiki DB
+	*/
+	'dpl2_debug_' . DPL2_ERR_NOCLVIEW => $wgDPL2Messages['en']['dpl2_debug_' . DPL2_ERR_NOCLVIEW],
+
+	// WARNINGS
+	/**
+	 * $0: unknown parameter given by user
+	 * $1: list of DPL2 available parameters separated by ', '
+	*/
+	'dpl2_debug_' . DPL2_WARN_UNKNOWNPARAM => "警告: 不明的参数 '$0' 被忽略。 帮助: 可用的参数: <code>$1</code>。",
+	/**
+	 * $3: list of valid param values separated by ' | '
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM => "警告: 错误的 '$0' 参数: '$1'! 正在使用默认值: '$2'。 帮助: <code>$0= $3</code>。",
+	/**
+	 * $0: param name
+	 * $1: wrong param value given by user
+	 * $2: default param value used instead by program
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM_INT => "警告: 错误的 '$0' 参数: '$1'! 正在使用默认值: '$2' (没有上限)。 帮助: <code>$0= <i>空白字符串</i> (没有上限) | n</code>, <code>n</code>是一个正整数。",
+	'dpl2_debug_' . DPL2_WARN_NORESULTS => '警告: 无结果!',
+	'dpl2_debug_' . DPL2_WARN_CATOUTPUTBUTWRONGPARAMS => "警告: 加入* 参数 ('adduser', 'addeditdate', 等)' 是对 'mode=category' 没有作用。只有页面空间名／标题才可以在这个模式度看到。",
+	/**
+	 * $0: 'headingmode' value given by user
+	 * $1: value used instead by program (which means no heading)
+	*/
+	'dpl2_debug_' . DPL2_WARN_HEADINGBUTSIMPLEORDERMETHOD => "警告: 在单一部件中， 'ordermethod' 用 'headingmode=$0' 是没有作用的。 正在使用: '$1'。 帮助: 你可以用非$1 'headingmode' 数值，在多个部件中用 'ordermethod' 。第一个部是用来作标题。例如在分类标题中用 'ordermethod=category,<i>comp</i>' (<i>comp</i>是另外一个部件) 。",
+	/**
+	 * $0: 'debug' value
+	*/
+	'dpl2_debug_' . DPL2_WARN_DEBUGPARAMNOTFIRST => "警告: 'debug=$0' 不是第一个在DPL元素嘅第一位置。新的除错设定在所有参数都能处理和检查前都不会应用。",
+
+	// OTHERS
+	/**
+	 * $0: SQL query executed to generate the dynamic page list
+	*/
+	'dpl2_debug_' . DPL2_QUERY => '查訽: <code>$0</code>',
+
+	/*
+	   Output formatting
+	*/
+	/**
+	 * $1: number of articles
+	*/
+	'dpl2_articlecount' => '在这个标题中有$1篇条目。'
+);
+$wgDPL2Messages['zh-tw'] = array(
+	/*
+		Debug
+	*/
+	// (FATAL) ERRORS
+	/**
+	 * $0: 'namespace' or 'notnamespace'
+	 * $1: wrong parameter given by user
+	 * $3: list of possible titles of namespaces (except pseudo-namespaces: Media, Special)
+	 */
+	'dpl2_debug_' . DPL2_ERR_WRONGNS => "錯誤: 錯誤的 '$0' 參數: '$1'! 說明:  <code>$0= <i>空白字串</i> (主)$3</code>。",
+	/**
+	 * $0: max number of categories that can be included
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOMANYCATS => '錯誤: 過多分類! 最大值: $0。 說明: 增加 <code>$wgDPL2MaxCategoryCount</code> 的值去指定更多的分類或設定 <code>$wgDPL2AllowUnlimitedCategories=true</code> 以解除限制。 (當加上 <code>DynamicPageList2.php</code>後，在<code>LocalSettings.php</code>中設定變數。)',
+	/**
+	 * $0: min number of categories that have to be included
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOFEWCATS => '錯誤: 過少分類! 最小值: $0。 說明: 減少 <code>$wgDPL2MinCategoryCount</code> 的值去指定更少的分類。 (當加上 <code>DynamicPageList2.php</code>後，在<code>LocalSettings.php</code>中設定一個合適的變數。)',
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTNOINCLUDEDCATS => "錯誤: 如果您想用 'addfirstcategorydate=true' 或 'ordermethod=categoryadd' ，您需要包含最少一個分類!",
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTMORETHAN1CAT => "錯誤: 如果您包含多一個分類，您不可以用 'addfirstcategorydate=true' 或 'ordermethod=categoryadd'!",
+	'dpl2_debug_' . DPL2_ERR_MORETHAN1TYPEOFDATE => '錯誤: 您不可以在一個時間裡加入多於一種嘅日期!',
+	/**
+	 * $0: param=val that is possible only with $1 as last 'ordermethod' parameter
+	 * $1: last 'ordermethod' parameter required for $0
+	*/
+	'dpl2_debug_' . DPL2_ERR_WRONGORDERMETHOD => "錯誤: 你只可以用 'ordermethod=[...,]$1' 在 '$0' 上!",
+	/**
+	 * $0: prefix_dpl_clview where 'prefix' is the prefix of your mediawiki table names
+	 * $1: SQL query to create the prefix_dpl_clview on your mediawiki DB
+	*/
+	'dpl2_debug_' . DPL2_ERR_NOCLVIEW => $wgDPL2Messages['en']['dpl2_debug_' . DPL2_ERR_NOCLVIEW],
+
+	// WARNINGS
+	/**
+	 * $0: unknown parameter given by user
+	 * $1: list of DPL2 available parameters separated by ', '
+	*/
+	'dpl2_debug_' . DPL2_WARN_UNKNOWNPARAM => "警告: 不明的參數 '$0' 被忽略。 說明: 可用的參數: <code>$1</code>。",
+	/**
+	 * $3: list of valid param values separated by ' | '
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM => "警告: 錯誤的 '$0' 參數: '$1'! 正在使用預設值: '$2'。 說明: <code>$0= $3</code>。",
+	/**
+	 * $0: param name
+	 * $1: wrong param value given by user
+	 * $2: default param value used instead by program
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM_INT => "警告: 錯誤的 '$0' 參數: '$1'! 正在使用預設值: '$2' (沒有上限)。 說明: <code>$0= <i>空白字串</i> (沒有上限) | n</code>, <code>n</code>是一個正整數。",
+	'dpl2_debug_' . DPL2_WARN_NORESULTS => '警告: 無結果!',
+	'dpl2_debug_' . DPL2_WARN_CATOUTPUTBUTWRONGPARAMS => "警告: 加入* 參數 ('adduser', 'addeditdate', 等)' 是對 'mode=category' 沒有作用。只有頁面空間名／標題才可以在這個模式度看到。",
+	/**
+	 * $0: 'headingmode' value given by user
+	 * $1: value used instead by program (which means no heading)
+	*/
+	'dpl2_debug_' . DPL2_WARN_HEADINGBUTSIMPLEORDERMETHOD => "警告: 在單一部件中， 'ordermethod' 用 'headingmode=$0' 是沒有作用的。 正在使用: '$1'。 說明: 你可以用非$1 'headingmode' 數值，在多個部件中用 'ordermethod' 。第一個部是用來作標題。例如在分類標題中用 'ordermethod=category,<i>comp</i>' (<i>comp</i>是另外一個部件) 。",
+	/**
+	 * $0: 'debug' value
+	*/
+	'dpl2_debug_' . DPL2_WARN_DEBUGPARAMNOTFIRST => "警告: 'debug=$0' 不是第一個在DPL元素嘅第一位置。新的除錯設定在所有參數都能處理和檢查前都不會應用。",
+
+	// OTHERS
+	/**
+	 * $0: SQL query executed to generate the dynamic page list
+	*/
+	'dpl2_debug_' . DPL2_QUERY => '查訽: <code>$0</code>',
+
+	/*
+	   Output formatting
+	*/
+	/**
+	 * $1: number of articles
+	*/
+	'dpl2_articlecount' => '在這個標題中有$1篇條目。'
+);
+$wgDPL2Messages['zh-yue'] = array(
+	/*
+		Debug
+	*/
+	// (FATAL) ERRORS
+	/**
+	 * $0: 'namespace' or 'notnamespace'
+	 * $1: wrong parameter given by user
+	 * $3: list of possible titles of namespaces (except pseudo-namespaces: Media, Special)
+	 */
+	'dpl2_debug_' . DPL2_ERR_WRONGNS => "錯誤: 錯嘅 '$0' 參數: '$1'! 幫助:  <code>$0= <i>空字串</i> (主)$3</code>。",
+	/**
+	 * $0: max number of categories that can be included
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOMANYCATS => '錯誤: 太多分類! 最大值: $0。 幫助: 增加 <code>$wgDPL2MaxCategoryCount</code> 嘅值去指定更多嘅分類或者設定 <code>$wgDPL2AllowUnlimitedCategories=true</code> 以解除限制。 (當加上 <code>DynamicPageList2.php</code>之後，響<code>LocalSettings.php</code>度設定變數。)',
+	/**
+	 * $0: min number of categories that have to be included
+	*/
+	'dpl2_debug_' . DPL2_ERR_TOOFEWCATS => '錯誤: 太少分類! 最小值: $0. 幫助: 減少 <code>$wgDPL2MinCategoryCount</code> 嘅值去指定更少嘅分類。 (當加上 <code>DynamicPageList2.php</code>之後，響<code>LocalSettings.php</code>度設定一個合適嘅變數。)',
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTNOINCLUDEDCATS => "錯誤: 如果你想去用 'addfirstcategorydate=true' 或者 'ordermethod=categoryadd' ，你需要包含最少一個分類!",
+	'dpl2_debug_' . DPL2_ERR_CATDATEBUTMORETHAN1CAT => "錯誤: 如果你包含多過一個分類，你唔可以用 'addfirstcategorydate=true' 或者 'ordermethod=categoryadd'!",
+	'dpl2_debug_' . DPL2_ERR_MORETHAN1TYPEOFDATE => '錯誤: 你唔可以響一個時間度加入多個一種嘅日期!',
+	/**
+	 * $0: param=val that is possible only with $1 as last 'ordermethod' parameter
+	 * $1: last 'ordermethod' parameter required for $0
+	*/
+	'dpl2_debug_' . DPL2_ERR_WRONGORDERMETHOD => "錯誤: 你只可以用 'ordermethod=[...,]$1' 響 '$0' 上!",
+	/**
+	 * $0: prefix_dpl_clview where 'prefix' is the prefix of your mediawiki table names
+	 * $1: SQL query to create the prefix_dpl_clview on your mediawiki DB
+	*/
+	'dpl2_debug_' . DPL2_ERR_NOCLVIEW => $wgDPL2Messages['en']['dpl2_debug_' . DPL2_ERR_NOCLVIEW],
+
+	// WARNINGS
+	/**
+	 * $0: unknown parameter given by user
+	 * $1: list of DPL2 available parameters separated by ', '
+	*/
+	'dpl2_debug_' . DPL2_WARN_UNKNOWNPARAM => "警告: 不明嘅參數 '$0' 被忽略。 幫助: 可用嘅參數: <code>$1</code>。",
+	/**
+	 * $3: list of valid param values separated by ' | '
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM => "警告: 錯誤嘅 '$0' 參數: '$1'! 用緊預設嘅: '$2'。 幫助: <code>$0= $3</code>。",
+	/**
+	 * $0: param name
+	 * $1: wrong param value given by user
+	 * $2: default param value used instead by program
+	*/
+	'dpl2_debug_' . DPL2_WARN_WRONGPARAM_INT => "警告: 錯誤嘅 '$0' 參數: '$1'! 用緊預設嘅: '$2' (冇上限)。 幫助: <code>$0= <i>空字串</i> (冇上限) | n</code>, <code>n</code>係一個正整數。",
+	'dpl2_debug_' . DPL2_WARN_NORESULTS => '警告: 無結果!',
+	'dpl2_debug_' . DPL2_WARN_CATOUTPUTBUTWRONGPARAMS => "警告: 加入* 參數 ('adduser', 'addeditdate', 等)' 係對 'mode=category' 冇作用嘅。只有頁空間名／標題至可以響呢個模式度睇到。",
+	/**
+	 * $0: 'headingmode' value given by user
+	 * $1: value used instead by program (which means no heading)
+	*/
+	'dpl2_debug_' . DPL2_WARN_HEADINGBUTSIMPLEORDERMETHOD => "警告: 響單一部件中， 'ordermethod' 度用 'headingmode=$0' 係冇作用嘅。 用緊: '$1'。 幫助: 你可以用非$1 'headingmode' 數值，響多個部件中用 'ordermethod' 。第一個部件係用嚟做標題。例如響分類標題度用 'ordermethod=category,<i>comp</i>' (<i>comp</i>係另外一個部件) 。",
+	/**
+	 * $0: 'debug' value
+	*/
+	'dpl2_debug_' . DPL2_WARN_DEBUGPARAMNOTFIRST => "警告: 'debug=$0' 唔係第一個響DPL元素嘅第一位。新嘅除錯設定響所有參數都能夠處理同檢查之前都唔會應用。",
+
+	// OTHERS
+	/**
+	 * $0: SQL query executed to generate the dynamic page list
+	*/
+	'dpl2_debug_' . DPL2_QUERY => '查訽: <code>$0</code>',
+
+	/*
+	   Output formatting
+	*/
+	/**
+	 * $1: number of articles
+	*/
+	'dpl2_articlecount' => '響呢個標題度有$1篇文。'
+);
+$wgDPL2Messages['zh-hk'] = $wgDPL2Messages['zh-tw'];
+$wgDPL2Messages['zh-sg'] = $wgDPL2Messages['zh-cn'];
+?>
Index: trunk/wikipathways/wpi/extensions/pathwayThumb.php
===================================================================
--- trunk/wikipathways/wpi/extensions/pathwayThumb.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/pathwayThumb.php	(revision 1110)
@@ -0,0 +1,124 @@
+<?php
+
+define("JS_OPEN_EDITOR_APPLET", "JS_OPEN_EDITOR_APPLET");
+
+$wgExtensionFunctions[] = 'wfPathwayThumb';
+$wgHooks['LanguageGetMagic'][]  = 'wfPathwayThumb_Magic';
+
+function wfPathwayThumb() {
+    global $wgParser;
+    $wgParser->setFunctionHook( "pwImage", "renderPathwayImage" );
+}
+
+function wfPathwayThumb_Magic( &$magicWords, $langCode ) {
+        $magicWords['pwImage'] = array( 0, 'pwImage' );
+        return true;
+}
+
+function renderPathwayImage( &$parser, $pwTitle, $width = 0, $align = '', $caption = '', $href = '', $tooltip = '', $id='pwthumb') {      
+      try {
+                $pathway = Pathway::newFromTitle($pwTitle);
+                $img = new Image($pathway->getFileTitle(FILETYPE_IMG));
+                switch($href) {
+                        case 'svg':
+                                $href = Image::imageUrl($pathway->getFileTitle(FILETYPE_IMG)->getPartialURL());
+                                break;
+                        case 'pathway':
+                                $href = $pathway->getFullURL();
+                                break;
+                        default:
+                                if(!$href) $href = $pathway->getFullURL();
+                }
+
+                $caption = html_entity_decode($caption);        //This can be quite dangerous (injection),
+                                                                //we would rather parse wikitext, let me know if
+                                                                //you know a way to do that (TK)
+                $output = makeThumbLinkObj($pathway, $caption, $href, $tooltip, $align, $id, $width);
+
+        } catch(Exception $e) {
+                return "invalid pathway title: $e";
+        }
+        return array($output, 'isHTML'=>1, 'noparse'=>1);
+}
+
+    /** MODIFIED FROM Linker.php
+        * Make HTML for a thumbnail including image, border and caption
+        * $img is an Image object
+        */
+    function makeThumbLinkObj( $pathway, $label = '', $href = '', $alt, $align = 'right', $id = 'thumb', $boxwidth = 180, $boxheight=false, $framed=false ) {
+            global $wgStylePath, $wgContLang;
+
+            $img = new Image($pathway->getFileTitle(FILETYPE_IMG));
+            $imgURL = $img->getURL();
+
+            $thumbUrl = '';
+            $error = '';
+
+            $width = $height = 0;
+            if ( $img->exists() ) {
+                    $width  = $img->getWidth();
+                    $height = $img->getHeight();
+            }
+            if ( 0 == $width || 0 == $height ) {
+                    $width = $height = 180;
+            }
+            if ( $boxwidth == 0 ) {
+                    $boxwidth = 180;
+            }
+            if ( $framed ) {
+                    // Use image dimensions, don't scale
+                    $boxwidth  = $width;
+                    $boxheight = $height;
+                    $thumbUrl  = $img->getViewURL();
+            } else {
+                    if ( $boxheight === false ) $boxheight = -1;
+                    $thumb = $img->getThumbnail( $boxwidth, $boxheight );
+                    if ( $thumb ) {
+                            $thumbUrl = $thumb->getUrl();
+                            $boxwidth = $thumb->width;
+                            $boxheight = $thumb->height;
+                    } else {
+                            $error = $img->getLastError();
+                    }
+            }
+            $oboxwidth = $boxwidth + 2;
+
+            $more = htmlspecialchars( wfMsg( 'thumbnail-more' ) );
+            $magnifyalign = $wgContLang->isRTL() ? 'left' : 'right';
+            $textalign = $wgContLang->isRTL() ? ' style="text-align:right"' : '';
+
+            $s = "<div id=\"{$id}\" class=\"thumb t{$align}\"><div class=\"thumbinner\" style=\"width:{$oboxwidth}px;\">";
+            if( $thumbUrl == '' ) {
+                    // Couldn't generate thumbnail? Scale the image client-side.
+                    $thumbUrl = $img->getViewURL();
+                    if( $boxheight == -1 ) {
+                            // Approximate...
+                            $boxheight = intval( $height * $boxwidth / $width );
+                    }
+            }
+            if ( $error ) {
+                    $s .= htmlspecialchars( $error );
+                    $zoomicon = '';
+            } elseif( !$img->exists() ) {
+                    $s .= "Image does not exist";
+                    $zoomicon = '';
+            } else {
+                    $s .= '<a href="'.$href.'" class="internal" title="'.$alt.'">'.
+                            '<img src="'.$thumbUrl.'" alt="'.$alt.'" ' .
+                            'width="'.$boxwidth.'" height="'.$boxheight.'" ' .
+                            'longdesc="'.$href.'" class="thumbimage" /></a>';
+                    if ( $framed ) {
+                            $zoomicon="";
+                    } else {
+                            $zoomicon =  '<div class="magnify" style="float:'.$magnifyalign.'">'.
+                                    '<a href="'.$imgURL.'" class="internal" title="'.$more.'">'.
+                                    '<img src="'.$wgStylePath.'/common/images/magnify-clip.png" ' .
+                                    'width="15" height="11" alt="" /></a></div>';
+                    }
+            }
+            $s .= '  <div class="thumbcaption"'.$textalign.'>'.$zoomicon.$label."</div></div></div>";
+            return str_replace("\n", ' ', $s);
+            //return $s;
+    }
+
+?>
Index: trunk/wikipathways/wpi/extensions/NewPathwaysPage/SpecialNewimages_example.php
===================================================================
--- trunk/wikipathways/wpi/extensions/NewPathwaysPage/SpecialNewimages_example.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/NewPathwaysPage/SpecialNewimages_example.php	(revision 1110)
@@ -0,0 +1,209 @@
+<?php
+/**
+ *
+ * @package MediaWiki
+ * @subpackage SpecialPage
+ */
+
+/**
+ *
+ */
+function wfSpecialNewimages( $par, $specialPage ) {
+	global $wgUser, $wgOut, $wgLang, $wgRequest, $wgGroupPermissions;
+
+	$wpIlMatch = $wgRequest->getText( 'wpIlMatch' );
+	$dbr =& wfGetDB( DB_SLAVE );
+	$sk = $wgUser->getSkin();
+	$shownav = !$specialPage->including();
+	$hidebots = $wgRequest->getBool('hidebots',1);
+
+	$hidebotsql = '';
+	if ($hidebots) {
+
+		/** Make a list of group names which have the 'bot' flag
+		    set.
+		*/
+		$botconds=array();
+		foreach ($wgGroupPermissions as $groupname=>$perms) {
+			if(array_key_exists('bot',$perms) && $perms['bot']) {
+				$botconds[]="ug_group='$groupname'";
+			}
+		}
+
+		/* If not bot groups, do not set $hidebotsql */
+		if ($botconds) {
+			$isbotmember=$dbr->makeList($botconds, LIST_OR);
+
+			/** This join, in conjunction with WHERE ug_group
+			    IS NULL, returns only those rows from IMAGE
+		    	where the uploading user is not a member of
+		    	a group which has the 'bot' permission set.
+			*/
+			$ug = $dbr->tableName('user_groups');
+			$hidebotsql = " LEFT OUTER JOIN $ug ON img_user=ug_user AND ($isbotmember)";
+		}
+	}
+
+	$image = $dbr->tableName('image');
+
+	$sql="SELECT img_timestamp from $image";
+	if ($hidebotsql) {
+		$sql .= "$hidebotsql WHERE ug_group IS NULL";
+	}
+	$sql.=' ORDER BY img_timestamp DESC LIMIT 1';
+	$res = $dbr->query($sql, 'wfSpecialNewImages');
+	$row = $dbr->fetchRow($res);
+	if($row!==false) {
+		$ts=$row[0];
+	} else {
+		$ts=false;
+	}
+	$dbr->freeResult($res);
+	$sql='';
+
+	/** If we were clever, we'd use this to cache. */
+	$latestTimestamp = wfTimestamp( TS_MW, $ts);
+
+	/** Hardcode this for now. */
+	$limit = 48;
+
+	if ( $parval = intval( $par ) ) {
+		if ( $parval <= $limit && $parval > 0 ) {
+			$limit = $parval;
+		}
+	}
+
+	$where = array();
+	$searchpar = '';
+	if ( $wpIlMatch != '' ) {
+		$nt = Title::newFromUrl( $wpIlMatch );
+		if($nt ) {
+			$m = $dbr->strencode( strtolower( $nt->getDBkey() ) );
+			$m = str_replace( '%', "\\%", $m );
+			$m = str_replace( '_', "\\_", $m );
+			$where[] = "LCASE(img_name) LIKE '%{$m}%'";
+			$searchpar = '&wpIlMatch=' . urlencode( $wpIlMatch );
+		}
+	}
+
+	$invertSort = false;
+	if( $until = $wgRequest->getVal( 'until' ) ) {
+		$where[] = 'img_timestamp < ' . $dbr->timestamp( $until );
+	}
+	if( $from = $wgRequest->getVal( 'from' ) ) {
+		$where[] = 'img_timestamp >= ' . $dbr->timestamp( $from );
+		$invertSort = true;
+	}
+	$sql='SELECT img_size, img_name, img_user, img_user_text,'.
+	     "img_description,img_timestamp FROM $image";
+
+	if($hidebotsql) {
+		$sql .= $hidebotsql;
+		$where[]='ug_group IS NULL';
+	}
+	if(count($where)) {
+		$sql.=' WHERE '.$dbr->makeList($where, LIST_AND);
+	}
+	$sql.=' ORDER BY img_timestamp '. ( $invertSort ? '' : ' DESC' );
+	$sql.=' LIMIT '.($limit+1);
+	$res = $dbr->query($sql, 'wfSpecialNewImages');
+
+	/**
+	 * We have to flip things around to get the last N after a certain date
+	 */
+	$images = array();
+	while ( $s = $dbr->fetchObject( $res ) ) {
+		if( $invertSort ) {
+			array_unshift( $images, $s );
+		} else {
+			array_push( $images, $s );
+		}
+	}
+	$dbr->freeResult( $res );
+
+	$gallery = new ImageGallery();
+	$firstTimestamp = null;
+	$lastTimestamp = null;
+	$shownImages = 0;
+	foreach( $images as $s ) {
+		if( ++$shownImages > $limit ) {
+			# One extra just to test for whether to show a page link;
+			# don't actually show it.
+			break;
+		}
+
+		$name = $s->img_name;
+		$ut = $s->img_user_text;
+
+		$nt = Title::newFromText( $name, NS_IMAGE );
+		$img = new Image( $nt );
+		$ul = $sk->makeLinkObj( Title::makeTitle( NS_USER, $ut ), $ut );
+
+		$gallery->add( $img, "$ul<br />\n<i>".$wgLang->timeanddate( $s->img_timestamp, true )."</i><br />\n" );
+
+		$timestamp = wfTimestamp( TS_MW, $s->img_timestamp );
+		if( empty( $firstTimestamp ) ) {
+			$firstTimestamp = $timestamp;
+		}
+		$lastTimestamp = $timestamp;
+	}
+
+	$bydate = wfMsg( 'bydate' );
+	$lt = $wgLang->formatNum( min( $shownImages, $limit ) );
+	if ($shownav) {
+		$text = wfMsgExt( 'imagelisttext', array('parse'), $lt, $bydate );
+		$wgOut->addHTML( $text . "\n" );
+	}
+
+	$sub = wfMsg( 'ilsubmit' );
+	$titleObj = SpecialPage::getTitleFor( 'Newimages' );
+	$action = $titleObj->escapeLocalURL( $hidebots ? '' : 'hidebots=0' );
+	if ($shownav) {
+		$wgOut->addHTML( "<form id=\"imagesearch\" method=\"post\" action=\"" .
+		  "{$action}\">" .
+		  "<input type='text' size='20' name=\"wpIlMatch\" value=\"" .
+		  htmlspecialchars( $wpIlMatch ) . "\" /> " .
+		  "<input type='submit' name=\"wpIlSubmit\" value=\"{$sub}\" /></form>" );
+	}
+
+	/**
+	 * Paging controls...
+	 */
+
+	# If we change bot visibility, this needs to be carried along.
+	if(!$hidebots) {
+		$botpar='&hidebots=0';
+	} else {
+		$botpar='';
+	}
+	$now = wfTimestampNow();
+	$date = $wgLang->timeanddate( $now, true );
+	$dateLink = $sk->makeKnownLinkObj( $titleObj, wfMsg( 'sp-newimages-showfrom', $date ), 'from='.$now.$botpar.$searchpar );
+
+	$botLink = $sk->makeKnownLinkObj($titleObj, wfMsg( 'showhidebots', ($hidebots ? wfMsg('show') : wfMsg('hide'))),'hidebots='.($hidebots ? '0' : '1').$searchpar);
+
+	$prevLink = wfMsg( 'prevn', $wgLang->formatNum( $limit ) );
+	if( $firstTimestamp && $firstTimestamp != $latestTimestamp ) {
+		$prevLink = $sk->makeKnownLinkObj( $titleObj, $prevLink, 'from=' . $firstTimestamp . $botpar . $searchpar );
+	}
+
+	$nextLink = wfMsg( 'nextn', $wgLang->formatNum( $limit ) );
+	if( $shownImages > $limit && $lastTimestamp ) {
+		$nextLink = $sk->makeKnownLinkObj( $titleObj, $nextLink, 'until=' . $lastTimestamp.$botpar.$searchpar );
+	}
+
+	$prevnext = '<p>' . $botLink . ' '. wfMsg( 'viewprevnext', $prevLink, $nextLink, $dateLink ) .'</p>';
+
+	if ($shownav)
+		$wgOut->addHTML( $prevnext );
+
+	if( count( $images ) ) {
+		$wgOut->addHTML( $gallery->toHTML() );
+		if ($shownav)
+			$wgOut->addHTML( $prevnext );
+	} else {
+		$wgOut->addWikiText( wfMsg( 'noimages' ) );
+	}
+}
+
+?>
Index: trunk/wikipathways/wpi/extensions/NewPathwaysPage/NewPathwaysPage_body.php
===================================================================
--- trunk/wikipathways/wpi/extensions/NewPathwaysPage/NewPathwaysPage_body.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/NewPathwaysPage/NewPathwaysPage_body.php	(revision 1110)
@@ -0,0 +1,72 @@
+<?php
+require_once("QueryPage.php");
+
+class NewPathwaysPage extends SpecialPage
+{		
+        function NewPathwaysPage() {
+                SpecialPage::SpecialPage("NewPathwaysPage");
+                self::loadMessages();
+        }
+
+        function execute( $par ) {
+                global $wgRequest, $wgOut;
+                
+                $this->setHeaders();
+
+                list( $limit, $offset ) = wfCheckLimits();
+
+				$rcp = new RCQueryPage();
+
+				return $rcp->doQuery( $offset, $limit );
+        }
+
+        function loadMessages() {
+                static $messagesLoaded = false;
+                global $wgMessageCache;
+                if ( $messagesLoaded ) return;
+                $messagesLoaded = true;
+
+                require( dirname( __FILE__ ) . '/NewPathwaysPage.i18n.php' );
+                foreach ( $allMessages as $lang => $langMessages ) {
+                        $wgMessageCache->addMessages( $langMessages, $lang );
+                }
+        }
+}
+
+class RCQueryPage extends QueryPage {
+
+	function getName() {
+		return "NewPathways";
+	}
+
+	function isExpensive() {
+		# page_counter is not indexed
+		return true;
+	}
+	function isSyndicated() { return false; }
+
+	function getSQL() {
+		$dbr =& wfGetDB( DB_SLAVE );
+		$page = $dbr->tableName( 'page');
+		$recentchanges = $dbr->tableName( 'recentchanges');
+
+		return
+			"SELECT 'Newpathwaypages' as type,
+			        page_namespace as namespace,
+			        page_title as title,
+				rc_user as user_id,
+				rc_user_text as utext,
+				rc_timestamp as value
+			FROM $page, $recentchanges
+			WHERE page_title=rc_title AND rc_new=1 AND page_namespace=".NS_PATHWAY." AND page_is_redirect=0";
+	}
+
+	function formatResult( $skin, $result ) {
+		global $wgLang, $wgContLang, $wgUser;
+		$title = Title::makeTitle( $result->namespace, $result->title );
+		$link = $skin->makeKnownLinkObj( $title, htmlspecialchars( $wgContLang->convert( $title->getBaseText() ) ) );
+		$nv = "created ". $wgLang->timeanddate($result->value) . " by " . $wgUser->getSkin()->userlink($result->user_id, $result->utext);
+		return wfSpecialList($link, $nv);
+	}
+}
+?>
Index: trunk/wikipathways/wpi/extensions/NewPathwaysPage/NewPathwaysPage.i18n.php
===================================================================
--- trunk/wikipathways/wpi/extensions/NewPathwaysPage/NewPathwaysPage.i18n.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/NewPathwaysPage/NewPathwaysPage.i18n.php	(revision 1110)
@@ -0,0 +1,7 @@
+<?php
+$allMessages = array(
+        'en' => array( 
+                'newpathwayspage' => 'New Pathways'
+        )
+);
+?>
\ No newline at end of file
Index: trunk/wikipathways/wpi/extensions/NewPathwaysPage/NewPathwaysPage.php
===================================================================
--- trunk/wikipathways/wpi/extensions/NewPathwaysPage/NewPathwaysPage.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/NewPathwaysPage/NewPathwaysPage.php	(revision 1110)
@@ -0,0 +1,15 @@
+<?php
+# Not a valid entry point, skip unless MEDIAWIKI is defined
+if (!defined('MEDIAWIKI')) {
+        echo <<<EOT
+To install NewPathwaysPage, put the following line in LocalSettings.php:
+require_once( "$IP/extensions/NewPathwaysPage/NewPathwaysPage.php" );
+EOT;
+        exit( 1 );
+}
+
+$wgAutoloadClasses['NewPathwaysPage'] = dirname(__FILE__) . '/NewPathwaysPage_body.php';
+$wgSpecialPages['NewPathwaysPage'] = 'NewPathwaysPage';
+$wgHooks['LoadAllMessages'][] = 'NewPathwaysPage::loadMessages';
+
+?>
\ No newline at end of file
Index: trunk/wikipathways/wpi/extensions/siteStats.php
===================================================================
--- trunk/wikipathways/wpi/extensions/siteStats.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/siteStats.php	(revision 1110)
@@ -0,0 +1,68 @@
+<?php
+
+require_once("wpi/wpi.php");
+
+/*
+Statistics for main page
+- how many pathways	{{PAGESINNS:NS_PATHWAY}}
+- how many organisms
+- how many pathways per organism
+*/
+
+#### DEFINE EXTENSION
+# Define a setup function
+$wgExtensionFunctions[] = 'wfSiteStats';
+# Add a hook to initialise the magic word
+$wgHooks['LanguageGetMagic'][]  = 'wfSiteStats_Magic';
+
+function wfSiteStats() {
+        global $wgParser;
+        # Set a function hook associating the "example" magic word with our function
+        $wgParser->setFunctionHook( 'siteStats', 'getSiteStats' );
+}
+
+function wfSiteStats_Magic( &$magicWords, $langCode ) {
+        # Add the magic word
+        # The first array element is case sensitive, in this case it is not case sensitive
+        # All remaining elements are synonyms for our parser function
+        $magicWords['siteStats'] = array( 0, 'siteStats' );
+        # unless we return true, other parser functions extensions won't get loaded.
+        return true;
+}
+
+function getSiteStats( &$parser, $tableAttr ) {
+	$output = "* There are '''{{PAGESINNS:" . NS_PATHWAY . "}}''' pathways";
+	$table = <<<EOD
+
+* Number of pathways per species:
+{| align="center" $tableAttr
+EOD;
+	foreach(Pathway::getAvailableSpecies() as $species) {
+		$nr = howManyPathways($species);
+		$table .= <<<EOD
+
+|-align="left"
+|$species:
+|'''$nr'''
+EOD;
+	}
+	$table .= "\n|}";
+	$output .= $table;
+	$output .= "\n* There are '''{{NUMBEROFUSERS}}''' registered users";
+	return $output;
+}
+
+function howManyPathways($species) {
+	$dbr =& wfGetDB(DB_SLAVE);
+	//Fetch number of pathways for this species
+	$res = $dbr->query("SELECT COUNT(*) FROM page WHERE page_namespace=" . NS_PATHWAY . " AND page_title LIKE '$species%' AND page_is_redirect = 0");
+	$row = $dbr->fetchRow($res);
+	$dbr->freeResult($res);
+	return $row[0];
+}
+
+function getSpecies() {
+	return Pathway::getAvailableSpecies();
+}
+
+?>
Index: trunk/wikipathways/wpi/extensions/watchPathways.php
===================================================================
--- trunk/wikipathways/wpi/extensions/watchPathways.php	(revision 0)
+++ trunk/wikipathways/wpi/extensions/watchPathways.php	(revision 1110)
@@ -0,0 +1,26 @@
+<?php
+require_once("wpi/wpi.php");
+/* 
+Also watche image page on watching pathway page
+*/
+
+$wgHooks['WatchArticleComplete'][] = 'watchPathway';
+$wgHooks['UnWatchArticleComplete'][] = 'unwatchPathway';
+
+function watchPathway($user, $article) {
+	$title = $article->getTitle();
+	$pathway = Pathway::newFromTitle($title);
+	//Also watch GPML image page
+	$gpml = $pathway->getFileTitle(FILETYPE_GPML);
+	$user->addWatch($gpml);
+	return true;
+}
+
+function unwatchPathway($user, $article) {
+	$title = $article->getTitle();
+	$pathway = new Pathway($title);
+	//Also unwatch GPML image page
+	$gpml = $pathway->getFileTitle(FILETYPE_GPML);
+	$user->removeWatch($gpml);
+	return true;
+}
Index: trunk/wikipathways/wpi/maintenance/uploadPathways.pl
===================================================================
--- trunk/wikipathways/wpi/maintenance/uploadPathways.pl	(revision 0)
+++ trunk/wikipathways/wpi/maintenance/uploadPathways.pl	(revision 1110)
@@ -0,0 +1,382 @@
+#!/usr/bin/perl
+
+## Create pathways on WikiPathways
+## For every pathway this script:
+##      - uploads the pathway image
+##      - uploads the GPML file
+##      - uploads the MAPP file
+##      - creates a wiki page
+## Category tags will be assigned to each page
+
+# The input is a file in the following format
+#
+# What you write                Explanation
+#----------------------------------------------------------------------------
+# @[[Category:Metabolism]]    	This text is appended to every description (use it for categories).
+# >Hs_apoptosis	                Name of the pathway (without file extension), following the GenMAPP naming conventions
+#
+# The "@" line is optional, and must be in one line. It can
+# occur multiple times in a single file and are only valid until they
+# are changed.
+#
+# To set the wiki account information, you need to create a file wiki.cfg in the script directory
+# containing 2 lines:
+# user=USERNAME
+# password=PASSWORD
+
+package main;
+use warnings;
+use strict;
+use Getopt::Long;
+use IO::File;
+
+my $usage =
+"USAGE:
+perl uploadPathways.pl directory [pathwaylist] [ovrFiles] [ovrPages]
+	- directory: 
+		the directory containing the pathway list and pathway files:
+	- image files: 
+		.jpg files located in directory/img
+	- genmapp files: 
+		.mapp files located in directory/mapp
+	- gpml files: 
+		.gpml files located in directory/gpml
+	- pathwaylist: 
+		the file that contains the list of pathways and
+		optional text that will be appended to the wiki pages (default: pathways.txt)
+	- ovrFiles: 
+		optional parameter to specify whether the uploaded files have to be overwritten when a file
+		with the same name already exists on the wiki
+	-ovrPages: 
+		optional parameter to specify whether the pathway pages have to be overwritten when page
+		with the same name already exists on the wiki
+
+	Both the pathway names in the pathway list and the pathway files must be named according to the convention:
+	SpeciesCode_PathwayName ([A-Z][a-z]_.*), e.g. Hs_apoptosis.
+
+	To set the wiki account information, you need to create a file wiki.cfg in the script directory
+	containing 2 lines:
+		user=USERNAME
+		password=PASSWORD\n";
+
+#The URL pointing to the wiki index.php
+my $wiki_php = "http://localhost/wikipathways/index.php"; #Tryout wiki
+#my $wiki_php = "http://blog.bigcat.unimaas.nl/wikipathways/index.php";
+
+#Read configuration options
+my $config = readconfig("wiki.cfg");
+
+#The username and password to use for the wiki
+my $user = $config->{"user"};
+my $pass = $config->{"password"};
+
+my $dir;
+my $pathwayList;
+my $ovrFiles;
+my $ovrPages;
+
+#Command line arguments
+my $result = GetOptions (
+	"directory=s" => \$dir,
+	"pathwaylist=s" => \$pathwayList,
+	"ovrFiles=s" => \$ovrFiles,
+	"ovrPages=s" => \$ovrPages,
+);
+chdir $dir or die "Can't change to directory: $dir\n$usage";
+
+if(!$pathwayList) {
+        $pathwayList = "pathways.txt";
+}
+
+#Pathway file types to upload
+my @fileType = (
+        {var => "imagePage", directory=>"img", extension=>"svg", addCategories=>1},
+        {var => "gpmlPage", directory=>"gpml", extension=>"gpml"},
+        {var => "mappPage", directory=>"mapp", extension=>"mapp"},
+);
+
+#Mappings from 2 character species codes to species names
+my %species = (
+        "Mm" => "Mouse",
+        "Hs" => "Human",
+	"Rn" => "Rat",
+	"Sc" => "Yeast", #TODO: complete species list
+);
+
+
+my $wiki = MediaWiki->new($wiki_php);
+
+$wiki->connect($user, $pass);
+
+my %pathways = parsePathwayList($pathwayList);
+
+foreach my $pathway (keys %pathways) {
+        print "Processing pathway $pathway\n";
+        my ($name, $species) = parsePathwayName($pathway);
+        if(!defined $species) {
+                print "!! Couldn't find pathway species, make sure the filename starts with
+                        the two character species code, followed by an underscore\n";
+        }
+        my $pagename = "$species:$name";
+        my $pagetext = "<!-- DON'T MODIFY THIS PART OF THE PAGE, IT IS AUTOMATICALLY GENERATED -->\n";
+
+        ## Add the page template
+        $pagetext .= "{{Template:PathwayPage";
+        foreach (@fileType) {
+                my %type = %{ $_ };
+                $pagetext .= "|$type{var}=Image:$pathway.$type{extension}";
+        }
+        $pagetext .= "}}\n";
+
+        $pagetext .= "<!-- YOU CAN MODIFY THE PAGE FROM HERE -->\n\n";
+
+        # Add text parsed from pathway list
+        $pagetext .= $pathways{$pathway}."\n"."[[Category:$species|{{PAGENAME}}]]\n";
+        $pagetext .=
+"<!-- You can add this pathway to a category by adding '[[Category:CategoryName]]' to the end of this
+page, where 'CategoryName' is the category you want to add the pathway to -->\n";
+
+        print "\tCreating wiki-page $pagename\n";
+        $wiki->setPageContent($pagename, $pagetext, { overwrite=>$ovrPages });
+        print "\tUploading pathway files\n";
+        uploadPathwayFiles($pathway, $pagename, $pathways{$pathway});
+}
+
+sub parsePathwayName {
+        my $pathway = shift;
+        $pathway =~ /^([A-Z][a-z])_(.*)$/;
+        ($2, $species{$1})
+}
+
+sub getSpeciesCode {
+        my $pathway = shift;
+        $pathway =~ /^([A-Z][a-z]) /;
+        $1;
+}
+
+
+sub parsePathwayList {
+        my $listFile = shift;
+
+        my %pathways;
+
+        open(PATHWAYLIST,"<$listFile")
+                or die "!! Could not find pathway list at $listFile.\n$usage";
+
+        my $text = "";
+        while(<PATHWAYLIST>) {
+                my $line = $_;
+                chomp($line);
+                if($line =~ m/^@/) {
+                        $line =~ s/^@//;
+                        $text = $line;
+                }
+                elsif($line =~ m/^>/) {
+                        $line =~ s/^>//;
+                        $pathways{$line} = $text;
+                }
+        }
+        %pathways;
+}
+
+sub uploadPathwayFiles {
+        my $pathway = shift;
+        my $pathwayPage = shift;
+        my $description = shift;
+        foreach (@fileType) {
+                my %type = %{ $_ };
+                my $pwLink = "$type{extension} file for [[$pathwayPage]]";
+
+                my ($dir, $ext) = ($type{directory}, $type{extension});
+
+                my $file = "$pathway.$ext";
+
+                print "\t\tProcessing file $file\n";
+                ## Check if file extists
+                if(-e "$dir/$file") {
+                        # Only add description parsed from pathway list to file types with addCategories set
+                        my $descr = "$pwLink\n";
+                        if($type{addCategories}) {
+                                print "\t> Adding description: $description\n";
+                                $descr .= $description;
+                        }
+                        $wiki->uploadFile("$dir/$file",$descr,{ wikiname=>$file, ignoreWarnings=>$ovrFiles });
+			$wiki->setFileDescription($file,$descr, { overwrite=>$ovrFiles }); #Description not overwritten by uploading, so do it manually
+                } else {
+                        print "!! Skipped file: $file does not exist\n";
+                }
+        }
+}
+
+sub readconfig {
+    my $file = shift;
+    my %params;
+    my $fh= IO::File->new($file, "r") or die "$file: $!";
+    while (<$fh>) {
+        s/\s+$//;
+        if (/(\w+)\s*=\s*(.*)/) {
+            my ($k, $v)= ($1, $2);
+            $params{$k}= $v;
+        }
+    }
+    $fh->close();
+    return \%params;
+}
+
+package MediaWiki;
+use WWW::Mechanize;
+use Encode qw(encode);
+
+sub new {
+        my $class= shift;
+        my $php = shift;
+        my $self= bless {
+                php=> $php,
+                browser=> LWP::UserAgent->new(),
+                mech=>WWW::Mechanize->new()
+        }, $class;
+
+    return $self;
+}
+
+sub connect() {
+        my $self = shift;
+        my $username = shift;
+        my $password = shift;
+
+        my $mech = $self->{mech};
+        my $php = $self->{php};
+
+        $mech->get ("$php?title=Special:Userlogin");
+        $mech->submit_form(
+               form_name => 'userlogin',
+               fields      => 
+                                {
+                                wpName  => $username,
+                                wpPassword  => $password,
+                                }
+            );
+}
+  
+sub uploadFile {
+        my $self = shift;
+        my $file = shift;
+        my $descr = shift;
+	my $wikiname;
+	my $ignoreWarnings;
+	
+	my $options_ref = shift();
+	
+	if($options_ref) {
+		my %options = %{ $options_ref };
+		$ignoreWarnings = $options{ignoreWarnings};
+		$wikiname = $options{wikiname};
+	}
+
+        my $mech = $self->{mech};
+        my $php = $self->{php};
+
+        
+        print "Uploading $file. Description:\n";
+        print $descr."\n" . "-" x 75 . "\n";
+
+        my $eckey=encode('utf8',$file);
+         if($eckey ne $file) {
+                symlink("$file","$eckey");
+        }
+        $mech->get("$php?title=Special:Upload");
+		my $content = $mech->content;
+		if($mech->content =~ m/Not logged in/) {
+			print "Upload failed, user not logged in!";
+			return;
+		}
+        my $response = $mech->submit_form(
+        button => 'wpUpload',
+        fields  => {
+          wpUploadFile=>["$eckey"],
+          wpDestFile=>"$wikiname",
+          wpUploadDescription=>encode('utf8',$descr),
+          wpIgnoreWarning=>$ignoreWarnings?'true':undef
+  	});
+  	if($response->as_string =~ m%<h2>Upload warning</h2>%) {
+          print "Upload failed! Possibly the file already exists and you didn't specify the 'overwrite' option\n";
+  	} else {
+          print "Uploaded successfully.\n";
+  	} ## TODO: validate response properly
+}
+
+sub getPageContent {
+        my $self = shift;
+        my $page = shift;
+
+        my $mech = $self->{mech};
+        my $php = $self->{php};
+
+        $mech->get("$php?title=$page&action=edit");
+        $mech->content =~ /<textarea .*?>(.*?)<\/textarea>/gs;
+        $1;
+}
+
+sub setPageContent {
+        my $self = shift;
+        my $page = shift;
+        my $text = shift;
+        
+	my $append;
+	my $overwrite;
+	
+	my $options_ref = shift();
+	
+	if($options_ref) {
+		my %options = %{ $options_ref };
+		$append = $options{append};
+		$overwrite = $options{overwrite};
+	}
+        my $mech = $self->{mech};
+        my $php = $self->{php};
+
+        $mech->get("$php?title=$page&action=edit");
+	
+	$mech->content =~ /<textarea .*?>(.*?)<\/textarea>/gs;
+	
+	my $content = $1;
+	chomp($content);
+	if($content ne "") { #page exists
+		if ($append) {
+			print "\t> Page already exists, appending to existing page content\n";
+			$text = "$1\n$text";
+		} elsif (!$overwrite) {
+			print "\t> Page already exists, skipping (set option 'overwrite' or 'append' if you want to modify existing pages)\n";
+			return;
+		} else {
+			print "\t> Page already exists, overwriting existing page content\n";
+		}
+	}
+
+        $mech->submit_form(
+                form_name => 'editform',
+                fields => {
+                        wpTextbox1 => $text
+        });
+        ##TODO: validate response
+}
+
+sub setFileDescription {
+        my $self = shift;
+        my $filepage = shift;
+        my $descr = shift;
+        
+	my $append;
+	my $overwrite;
+	
+	my $options_ref = shift();
+
+        my $mech = $self->{mech};
+        my $php = $self->{php};
+
+        if(!($filepage =~ m/^Image:/)) {
+                $filepage = "Image:$filepage";
+        }
+        $self->setPageContent($filepage, $descr, $options_ref);
+        ##TODO: validate response
+}

Property changes on: trunk/wikipathways/wpi/maintenance/uploadPathways.pl
___________________________________________________________________
Name: svn:executable
   + *

Index: trunk/wikipathways/wpi/maintenance/files.txt
===================================================================
--- trunk/wikipathways/wpi/maintenance/files.txt	(revision 0)
+++ trunk/wikipathways/wpi/maintenance/files.txt	(revision 1110)
@@ -0,0 +1,83 @@
+@[[Category:Mouse]] [[Category:Cellular Process]]
+>Mm_Apoptosis.jpg
+>Mm_Cell_Cycle_KEGG.jpg
+>Mm_DNA_replication_Reactome.jpg
+>Mm_Fas_Pathway_and_Stress_Induction_of_HSP_Regulation_Biocarta.jpg
+>Mm_Focal_adhesion_KEGG.jpg
+>Mm_G13_Signaling_Pathway.jpg
+>Mm_G1_to_S_cell_cycle_Reactome.jpg
+>Mm_G_Protein_Signaling.jpg
+>Mm_HSP70_and_Apoptosis.jpg
+>Mm_Insulin_Signaling.jpg
+>Mm_Integrin-mediated_cell_adhesion_KEGG.jpg
+>Mm_MAPK_Cascade.jpg
+>Mm_MAPK_signaling_pathway_KEGG.jpg
+>Mm_mRNA_processing_binding_Reactome.jpg
+>Mm_Notch_signaling_KEGG.jpg
+>Mm_Ovarian_Infertility_Genes.jpg
+>Mm_p38_MAPK_signaling_pathway.jpg
+>Mm_Regulation_of_Actin_Cytoskeleton_KEGG.jpg
+>Mm_RNA_transcription_Reactome.jpg
+>Mm_S1P_Signaling.jpg
+>Mm_Signaling_of_Hepatocyte_Growth_Factor_Receptor_Biocarta.jpg
+>Mm_TGF_Beta_Signaling_Pathway.jpg
+>Mm_Translation_Factors.jpg
+>Mm_Wnt_Signaling.jpg
+@[[Category:Mouse]] [[Category:Metabolic Process]]
+>Mm_Acetylcholine_Synthesis.jpg
+>Mm_Alanine_and_aspartate_metabolism_KEGG.jpg
+>Mm_Biogenic_Amine_Synthesis.jpg
+>Mm_Cholesterol_Biosynthesis.jpg
+>Mm_Eicosanoid_Synthesis.jpg
+>Mm_Electron_Transport_Chain.jpg
+>Mm_Fatty_Acid_Beta_Oxidation_1_BiGCaT.jpg
+>Mm_Fatty_Acid_Beta_Oxidation_2_BiGCaT.jpg
+>Mm_Fatty_Acid_Beta_Oxidation_3_BiGCaT.jpg
+>Mm_Fatty_Acid_Beta_Oxidation_Meta_BiGCaT.jpg
+>Mm_Fatty_Acid_Synthesis_BiGCaT.jpg
+>Mm_Glucocorticoid_Mineralocorticoid_Metabolism.jpg
+>Mm_Gluthation_Metabolism_KEGG.jpg
+>Mm_Glycogen_Metabolism.jpg
+>Mm_Glycolysis_and_Gluconeogenesis.jpg
+>Mm_Heme_Biosynthesis.jpg
+>Mm_Krebs-TCA_Cycle.jpg
+>Mm_Mitochondrial_fatty_acid_betaoxidation.jpg
+>Mm_Nuclear_receptors_in_lipid_metabolism_and_toxicity.jpg
+>Mm_Nucleotide_Metabolism.jpg
+>Mm_Pentose_Phosphate_Pathway.jpg
+>Mm_Prostaglandin_synthesis_regulation.jpg
+>Mm_Statin_Pathway_PharmGKB.jpg
+>Mm_Steroid_Biosynthesis.jpg
+>Mm_Synthesis_and_Degradation_of_Ketone_Bodies_KEGG.jpg
+>Mm_Triacylglyceride_Synthesis_BiGCaT.jpg
+>Mm_Tryptophane_Metabolism_KEGG.jpg
+>Mm_Unsaturated_Fatty_Acid_Beta_Oxidation_BiGCaT.jpg
+>Mm_Urea_cycle_and_metabolism_of_amino_groups_KEGG.jpg
+@[[Category:Mouse]] [[Category:Physiological Process]]
+>Mm_ACE-Inhibitor_pathway_PharmGKB.jpg
+>Mm_Adipogenesis.jpg
+>Mm_Blood_Clotting_Cascade.jpg
+>Mm_Calcium_regulation_in_cardiac_cells.jpg
+>Mm_Circadian_Exercise.jpg
+>Mm_Complement_Activation_Classical.jpg
+>Mm_Complement_and_Coagulation_Cascades_KEGG.jpg
+>Mm_Cytokines_and_Inflammatory_Response_Biocarta.jpg
+>Mm_Hypertrophy_model.jpg
+>Mm_Inflammatory_Response_Pathway.jpg
+>Mm_Irinotecan_pathway_PharmGKB.jpg
+>Mm_Oxidative_Stress.jpg
+>Mm_Proteasome_Degradation.jpg
+>Mm_Smooth_muscle_contraction.jpg
+>Mm_Striated_muscle_contraction.jpg
+@[[Category:Mouse]] [[Category:Molecular Function]]
+>Mm_GPCRDB_Class_A_Rhodopsin-like.jpg
+>Mm_GPCRDB_Class_B_Secretin-like.jpg
+>Mm_GPCRDB_Class_C_Metabotropic_glutamate_pheromone.jpg
+>Mm_GPCRDB_Other.jpg
+>Mm_Matrix_Metalloproteinases.jpg
+>Mm_Monoamine_GPCRs.jpg
+>Mm_Nuclear_Receptors.jpg
+>Mm_Nucleotide_GPCRs.jpg
+>Mm_Peptide_GPCRs.jpg
+>Mm_Ribosomal_Proteins.jpg
+>Mm_Small_ligand_GPCRs.jpg
Index: trunk/wikipathways/wpi/maintenance/gpmlToPageTransition.php
===================================================================
--- trunk/wikipathways/wpi/maintenance/gpmlToPageTransition.php	(revision 0)
+++ trunk/wikipathways/wpi/maintenance/gpmlToPageTransition.php	(revision 1110)
@@ -0,0 +1,100 @@
+<?php
+
+$dir = getcwd();
+chdir("../"); //Ugly, but we need to change to the MediaWiki install dir to include these files, otherwise we'll get an error
+require_once('wpi.php');
+chdir($dir);
+
+/*****
+
+V Create GPML namespace
+
+* Maintainance script to transfer all pathway file contents to GPML pages
+* How to transfer history?
+  * Iterate over all file history and subsequentiall edit
+  * Skip bot edits (except if it's the current)
+* Update braces (manually make list of pathways to skip)
+
+****/
+
+//Iterate over all GPML 'Image' files
+set_time_limit(0);
+
+$dbr =& wfGetDB(DB_SLAVE);
+
+$res = $dbr->query("SELECT img_name, img_description FROM image WHERE img_name LIKE '%.gpml'");
+while( $row = $dbr->fetchRow( $res )) {
+	$img = $row[0];
+	$img_description = $row[1];
+
+	/* TEST */	
+	//if($img != "Hs_IL-5_NetPath_17.gpml") continue;
+	/* TEST */
+
+	echo "Processing: $img<BR>";
+
+	//Test if pathway exists for this file
+	try {
+		$pathway = Pathway::newFromFileTitle($img);
+		$title = $pathway->getTitleObject();
+		$article = new Article($title);
+		if( !$article->exists()) throw new Exception("Description page does not exist");
+	} catch(Exception $e) {
+		echo "Not a pathway: $e";
+		continue;
+	}
+	
+	//Create the new article for the GPML data
+	$title = Title::newFromText($pathway->getTitleObject()->getText(), NS_GPML);
+	$article = new Article($title);
+	
+	//Iterate over file history
+	$res_hist = $dbr->query("SELECT oi_name, oi_archive_name, oi_description FROM oldimage WHERE oi_name = '$img'");
+	while( $histrow = $dbr->fetchRow( $res_hist ) ) {
+		$oi_archive_name = $histrow[1];
+		$oi_description = $histrow[2];
+
+		//Exclude 'gpml file for [[%'
+		//Exclude 'test'
+		if(	ereg("gpml file for \[\[.*", $oi_description) ||
+			ereg("test", $oi_description) ) {
+			continue;
+		}
+
+		echo "->$oi_archive_name; $oi_description<BR>";
+		
+		echo "->-> transfer to {$title->getFullURL()}<BR>";
+		try {
+			transferGpmlFile($article, $img, $oi_archive_name, $oi_description, true);
+		} catch (Exception $e) {
+			echo "Exception: $e\n";
+		}	
+	}
+	//Transfer the current version
+	transferGpmlFile($article, $img, $img, $img_description, false);
+	cleanup($img);
+}
+
+function transferGpmlFile($toArticle, $img, $fileName, $description, $archive = false) {
+	//Get the GPML file contents
+	if($archive) {
+		$fileName = wfImageArchiveDir($img) . "/$fileName";
+	} else {
+		$fileName = wfImageDir($img) . "/$fileName";
+	}
+	$gpml = file_get_contents($fileName);
+	
+	if(!$gpml) throw new Exception("Unable to read file contents for $fileName");
+
+	//Update article
+	$succ =  $toArticle->doEdit($gpml, $description);
+	if(!$succ) throw new Exception("Unable to create new GPML page for $fileName");
+}
+
+//Do this after succesful transfer
+function cleanup($img) {
+	$title = Title::newFromText($img, NS_IMAGE);
+	$img = new Image($title);
+	$img->delete("cleanup");
+	Pathway::deleteArticle($title, "cleanup");
+}

Property changes on: trunk/wikipathways/wpi/maintenance/gpmlToPageTransition.php
___________________________________________________________________
Name: svn:executable
   + *

Index: trunk/wikipathways/wpi/maintenance/wiki_upload.pl
===================================================================
--- trunk/wikipathways/wpi/maintenance/wiki_upload.pl	(revision 0)
+++ trunk/wikipathways/wpi/maintenance/wiki_upload.pl	(revision 1110)
@@ -0,0 +1,371 @@
+#!perl -w
+use strict;
+
+# this script takes pairs of filename, description as parameters, and
+# uploads them to the wiki.
+#
+# example:
+# perl wiki-upload.pl image.jpg "first image" image2.jpg "second image"
+#
+# you need to create a file c:\local\etc\wiki.cfg
+# containing 2 lines:
+# user=USERNAME
+# pass=PASSWORD
+#
+# copied from: http://morganreport.org/mediawiki/index.php?title=Upload_perl_script
+#   - Martijn
+#
+#####################################
+#   some included support nodules
+package WebServer;
+use strict;
+use warnings;
+use HTTP::Request::Common qw(POST GET);
+use LWP::UserAgent;
+use HTTP::Cookies;
+
+use List::Util qw(first);
+
+sub new {
+    my ($class, $baseurl)= @_;
+
+    my $ua= LWP::UserAgent->new(agent=>'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7) Gecko/20040501');
+    $ua->cookie_jar(HTTP::Cookies->new(hide_cookie2=>1));
+    $ua->env_proxy();
+
+    return bless {
+        ua=>$ua,
+        baseurl=>$baseurl,
+    }, $class;
+}
+sub clearcookies {
+    my $self= shift;
+
+    $self->{ua}->cookie_jar(HTTP::Cookies->new(hide_cookie2=>1));
+}
+# almost interface compatible with httpost
+#   - optional hashref with parameters is merged with parameters.
+#
+# httpget("/some.cgi", key1=>123, key2=>455);
+# httpget("/some.cgi", { urlkey1=>999 }, key1=>123, key2=>455);
+#
+sub httpget {
+    my $self= shift;
+    my $path= shift;
+
+    my $query;
+    if (@_) {
+        $query= shift;
+        if (ref $query ne "HASH") {
+            unshift @_, $query;
+            $query=undef;
+        }
+    }
+    my %params= @_;
+
+    my $uri= URI->new($self->{baseurl});
+    $uri->path($path);
+    $uri->query_form($query?%$query:(), %params);
+    my $rq= GET $uri;
+
+    # todo: get rid of 'TE' header, and 'Connection'-TE flag. and 'Cookie2' header
+    $rq->header(
+        'User-Agent'=> 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7) Gecko/20040501',
+        'Accept'=> ($path =~ /\.aspx|\.htm/ 
+            ? 'text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5'
+            : $path =~ /\.css/
+            ? 'text/css,*/*;q=0.1'
+            : '*/*') ,
+        'Accept-Language'=> 'en-us,en;q=0.5',
+        #'Accept-Encoding'=> 'gzip,deflate',
+        'Accept-Charset'=> 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',
+    );
+    #print "request:\n", $rq->as_string, "\n";
+    #warn "network access disabled\n";
+    #return;
+    my $rp= $self->{ua}->request($rq) or die "httperror: $@\n";
+
+    return $rp->content;
+}
+
+# can be called in several ways:
+# httppost("/some.cgi", key1=>123, key2=>455);
+#   -> just form values
+# httppost("/some.cgi", { urlkey1=>999 }, key1=>123, key2=>455);
+#   -> both url and form params
+# httppost("/some.cgi", key1=>123, key2=>455, file1=>["filename"]);
+#   -> form-data file upload
+sub httppost {
+    my $self= shift;
+    my $path= shift;
+
+    my $query;
+    if (@_) {
+        $query= shift;
+        if (ref $query ne "HASH") {
+            unshift @_, $query;
+            $query=undef;
+        }
+    }
+    my %params= @_;
+
+    my $useformdata= grep { defined ref $_ && ref $_ eq "ARRAY" } values %params;
+
+    my $uri= URI->new($self->{baseurl});
+    $uri->path($path);
+    $uri->query_form(%$query) if ($query);
+    my $rq;
+    if ( $useformdata ) {
+        $rq = POST $uri, Content_Type=>"form-data", Content=>[ %params ];
+    }
+    else {
+        $rq = POST $uri, [ %params ];
+    }
+
+    # -- for http uploads : 
+    # ( Content_Type=>"form-data", Content=>[ %params ]);
+    $rq->header(
+        'User-Agent'=> 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7) Gecko/20040501',
+        'Accept'=> 'text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5',
+        'Accept-Language'=> 'en-us,en;q=0.5',
+        #'Accept-Encoding'=> 'gzip,deflate',
+        'Accept-Charset'=> 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',
+    );
+    #print "request:\n", $rq->as_string, "\n";
+    #warn "network access disabled\n";
+    #return;
+    my $rp= $self->{ua}->request($rq) or die "httperror: $@\n";
+
+    #print $rp->status_line, "\n";
+    #print $rp->headers->as_string();
+
+    return $rp->content;
+}
+
+sub httprequest {
+    my ($self, $method, @params)= @_;
+    if (lc($method) eq "get") {
+        return $self->httpget(@params);
+    }
+    elsif (lc($method) eq "post") {
+        return $self->httppost(@params);
+    }
+    else {
+        die "invalid http request method '$method'\n";
+    }
+}
+
+
+
+package MediaWiki;
+use strict;
+use warnings;
+use HTML::TreeBuilder;
+
+sub new {
+    my $class= shift;
+
+    my $self= bless {
+        server=> WebServer->new("http://morganreport.org"),
+        url=> "/mediawiki/index.php",
+    }, $class;
+
+    return $self;
+}
+sub post {
+    my ($self, @params)= @_;
+    $self->{server}->httppost($self->{url}, @params);
+}
+sub get {
+    my ($self, @params)= @_;
+    if (!$self->{loggedin}) {
+        $self->login();
+    }
+    $self->{server}->httpget($self->{url}, @params);
+}
+sub cachedget {
+    my ($self, @params)= @_;
+
+    my $filename= encodeurlasfile(@params);
+
+    if (-e $filename) {
+        return readfile($filename);
+    }
+
+    my $data= $self->get(@params);
+    savefile($filename, $data);
+    return $data;
+}
+sub DESTROY {
+    my $self= shift;
+}
+########################################################################
+
+
+sub getwikisource {
+    my ($self, $page)= @_;
+    my $xml= $self->post(
+        title=>'Special:Export', 
+        action=>'submit',
+        pages=>$page,
+        curonly=>'true',
+    );
+    if ($xml =~ /<text[^>]*>(.*?)<\/text>/s) {
+        return $1;
+    }
+    die "could not find <text> xml tag in\n$xml\n";
+}
+sub getcategoryitems {
+    my ($self, $page)= @_;
+    my $html= $self->get(
+        title=>$page,
+    );
+    my $tree = HTML::TreeBuilder->new();
+    $tree->parse($html);
+    $tree->eof();
+
+    my ($table)= $tree->look_down(
+        "_tag"=>"table",
+    ) or die "could not find category table for $page\n";
+
+    my @items;
+    for $a ($table->look_down("_tag", "a")) {
+        push @items, $a->as_text();
+    }
+    return @items;
+}
+sub uploadfile {
+    my ($self, $imgname, $imgdesc)= @_;
+    $imgname =~ s/\\/\//g;
+    ( my $imgdestname= $imgname ) =~ s/.*\///;
+
+    my $answer= $self->post(
+        { title=>'Special:Upload', },
+        wpUploadFile=>[$imgname],
+        wpDestFile=>$imgdestname,
+        wpUploadDescription=>$imgdesc,
+        wpUpload=>"Upload file",
+    );
+    
+    print $answer->content;
+}
+sub logout {
+    my $self= shift;
+    my $answer= $self->get(title=>'Special:Userlogout');
+    $self->{loggedin}= 0;
+    $self->{server}->clearcookies();
+}
+sub login {
+    my ($self, $username, $password)= @_;
+
+    my $answer= $self->post(
+        { action=>'submitlogin', title=>'Special:Userlogin' },
+        wpName => $username,
+        wpPassword => $password,
+        wpLoginattempt => 'Log in',
+    );
+    $self->{loggedin}= 1;
+}
+
+# title=>'Template:UpcomingTable'
+# action=>'submit'
+
+# text   wpSummary
+# flag   wpMinoredit 1
+# flag   wpWatchthis
+# button wpSave      Save page
+# button wpPreview   Show preview
+# button wpDiff      Show changes
+# hidden wpSection
+# hidden wpEdittime  20050730124636
+# hidden wpEditToken cd44d6f6003e41d1d44b9a79266a846f
+# text   wpTextbox1 
+
+sub geteditform {
+    my ($self, $page, $section)= @_;
+    my $answer= $self->get(
+        action=>'edit', 
+        title=>$page,
+        defined $section ? ( section=>$section ) : (),
+    );
+    my $tree = HTML::TreeBuilder->new();
+    $tree->parse($answer);
+    $tree->eof();
+
+    my ($formtag)= $tree->look_down(
+        "_tag"=>"form",
+        "name"=>"editform",
+    );
+    my @inputelements= $formtag->look_down(
+        "_tag"=>"input",
+        sub { $_[0]->attr('type') ne 'submit' && $_[0]->attr('type') ne 'radio' }
+    );
+    my @textelements= $formtag->look_down(
+        "_tag"=>"textarea",
+    );
+
+
+    my %form;
+    # not handling radio buttons yet.
+    for my $field (@inputelements) {
+        $form{$field->attr('name')}= $field->attr('value')
+    }
+    for my $field (@textelements) {
+        $form{$field->attr('name')}= $field->as_text;
+    }
+    return \%form;
+}
+sub saveeditform {
+    my ($self, $page, $form)= @_;
+    my $answer= $self->post(
+        { action=>'submit', title=>$page, },
+        wpSave=>"Save page",
+        %$form,
+    );
+}
+
+sub createpage {
+    my ($self, $page, $content)= @_;
+
+    my $f= $self->geteditform($page);
+    if ($f->{wpTextbox1}) {
+        print "----$page\n$f->{wpTextbox1}\n\n";
+    }
+    $f->{wpTextbox1}= $content;
+    print map { sprintf("%-20s= %s\n", $_, defined $f->{$_} ? "'$f->{$_}'":"<undef>") } keys %$f;
+    $self->saveeditform($page, $f);
+}
+
+package main;
+
+use strict;
+use warnings;
+use IO::File;
+$|=1;
+my $m= MediaWiki->new();
+
+if (@ARGV%2) {
+    die "expected an even nr of params\n";
+}
+my $config= readconfig();
+$m->login($config->{user}, $config->{pass});
+
+for (my $i=0 ; $i<@ARGV ; $i+=2) {
+    if (!-f $ARGV[$i]) {
+        die "file $ARGV[$i] not found\n";
+    }
+    $m->uploadfile($ARGV[$i], $ARGV[$i+1]);
+}
+sub readconfig {
+    my %params;
+    my $fh= IO::File->new("wiki.cfg", "r") or die "wiki.cfg: $!";
+    while (<$fh>) {
+        s/\s+$//;
+        if (/(\w+)\s*=\s*(.*)/) {
+            my ($k, $v)= ($1, $2);
+            $params{$k}= $v;
+        }
+    }
+    $fh->close();
+    return \%params;
+}
\ No newline at end of file
Index: trunk/wikipathways/wpi/maintenance/mwup.pl
===================================================================
--- trunk/wikipathways/wpi/maintenance/mwup.pl	(revision 0)
+++ trunk/wikipathways/wpi/maintenance/mwup.pl	(revision 1110)
@@ -0,0 +1,212 @@
+#!/usr/bin/perl
+# mwup.pl - MediaWiki file UPLOAD script
+#   by Kernigh - xkernigh AT netscape DOT net
+#   version 2006-05-01 - this script is in the public domain
+#
+# Derived from:
+# Upload script by Erik Mller - moeller AT scireview DOT de - public domain
+# Developed for the Wikimedia Commons
+#
+# Note: Before usage, create an account on the destination MediaWiki
+# for the bot. On Wikimedia Commons, the convention is
+# "File Upload Bot (Username)", for example, File Upload Bot (Kernigh).
+#
+# Set the username and password below:
+
+$username = "USERNAME";
+$password = "PASSWORD";
+
+# Set the pause in seconds after each upload
+$pause = 120;
+
+# List the wiki PHP scripts where you have the username/password pair
+%wiki_php = (
+  'wikipathways',           'http://blog.bigcat.unimaas.nl/pathwaywiki/index.php',
+);
+
+# Then run the script on the command line using
+#
+# $ perl mwup.pl wiki dirname
+#
+# where wiki is one of the wikis from the wiki_php list above,
+# and dirname/ is the name of a directory containing the files to
+# be uploaded, and a file named files.txt in the following format
+#
+# What you write                Explanation
+#----------------------------------------------------------------------------
+# @{{GFDL}} [[Category:Dog]]    This text is appended to every description.
+# Dog photo by Eloquence       This text is used when no description exists.
+# >Dog01.jpg                    Name of a file in the specified directory.
+# German shepherd dog           Description (can be multi-line).
+# >Dog02.jpg                    File without a description (use default)
+#
+# The "@" and "" lines are optional, and must be in one line. They can
+# occur multiple times in a single file and are only valid until they
+# are changed. As a consequence, description lines cannot start with "@"
+# or "".
+#
+# Don't edit below unless you know what you're doing.
+
+# We need these libraries. They should be part of a standard Perl
+# distribution.
+use LWP::Simple;
+use LWP::UserAgent;
+use HTTP::Request;
+use HTTP::Response;
+use HTTP::Cookies;
+use Encode qw(encode);
+use warnings;
+
+$ignore_login_error=0;
+$docstring="Please read mwup.pl for documentation.\n";
+my $wiki=$ARGV[0] or die  "Syntax: perl mwup.pl wiki directory\n$docstring";
+my $dir=$ARGV[1] or die "Syntax: perl mwup.pl wiki directory\n$docstring";
+
+# Find the wiki PHP script
+$cgi = $wiki_php{$wiki} or die "Unknown wiki: $wiki\n$docstring";
+
+# Make Unix style path
+$dir=~s|\\|/|gi;
+
+# Remove trailing slashes
+$sep=$/; $/="/"; chomp($dir); $/=$sep;
+
+# Now try to get the list of files
+open(FILELIST,"<$dir/files.txt")
+  or die "Could not find file list at $dir/files.txt.\n$docstring";
+
+
+$standard_text[0]="";
+$default_text[0]="";
+$stx=0; $dtx=0;
+while(<FILELIST>) {
+        $line=$_;
+        chomp($line);
+        if($line=~m/^@/) {
+                $line=~s/^@//;
+                $standard_text[$stx]=$line;
+                $stx++;
+                $stw=1;
+        }
+        elsif($line=~m/^/) {
+                $line=~s/^//;
+                $default_text[$dtx]=$line;
+                $dtx++;
+                $dtw=1;
+        }
+        elsif($line=~m/^>/) {
+                $line=~s/^>//;
+
+                # New file, but last one doesn't have a description yet -
+                # add current default.
+                if($currentfile) {
+                        # If there's been a change of the default or standard
+                        # text, we need to apply the old text to the previous
+                        # file, not the new one.
+                        $dx= $dtw? $dtx-2 : $dtx -1;
+                        $sx= $stw? $stx-2 : $stx -1;
+                        if(!$desc_added) {
+                                $file{$currentfile}.="\n".$default_text[$dx];
+                        }
+                        $file{$currentfile}.="\n\n".$standard_text[$sx];
+                }
+                # Abort the whole batch if this file doesn't exist.
+                if(!-e "$dir/$line") {
+                        die "Could not find $dir/$line. Uploading no files.\n"
+
+                }
+                $currentfile=$line;
+                $desc_added=0;
+                $dtw=0;$stw=0;
+        }else {
+                # If this is a header comment,
+                # we just ignore it. Otherwise
+                # it's a file description.
+                if($currentfile) {
+                        $file{$currentfile}.="\n".$line;
+                        $desc_added=1;
+                }
+        }
+}
+
+# Last file needs to be processed, too
+if($currentfile) {
+        $dx= $dtw? $dtx-2 : $dtx -1;
+        $sx= $stw? $stx-2 : $stx -1;
+        if(!$desc_added) {
+                $file{$currentfile}.="\n".$default_text[$dx];
+        }
+        $file{$currentfile}.="\n\n".$standard_text[$sx];
+}
+
+my $browser=LWP::UserAgent->new();
+  my @ns_headers = (
+   'User-Agent' => 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7) Gecko/20041107 Firefox/1.0',
+   'Accept' => 'image/gif, image/x-xbitmap, image/jpeg,
+        image/pjpeg, image/png, */*',
+   'Accept-Charset' => 'iso-8859-1,*,utf-8',
+   'Accept-Language' => 'en-US',
+  );
+
+$browser->cookie_jar( {} );
+
+$response=$browser->post("$cgi?title=Special:Userlogin&action=submitlogin",
+@ns_headers, Content=>[wpName=>$username,wpPassword=>$password,wpRemember=>"1",wpLoginAttempt=>"Log in"]);
+
+# After logging in, we should be redirected to another page.
+# If we aren't, something is wrong.
+#
+if($response->code!=302 && !$ignore_login_error) {
+        print
+"We weren't able to login. This could have the following causes:
+
+* The username ($username) or password may be incorrect.
+  Solution: Edit upload.pl and change them.
+* The MediaWiki software has been upgraded.
+  Solution: Go to (where?)
+  and get a new version of the upload script.
+* You are trying to hack this script for other wikis. The wiki you
+  are uploading to has cookie check disabled.
+  Solution: Try setting \$ignore_login_error to 1.
+
+Regardless, we will now try to write the output from the server to
+$dir/debug.txt....\n\n";
+        open(DEBUG,">$dir/debug.txt") or die "Could not write file.\n";
+        print DEBUG $response->as_string;
+        print
+"This seems to have worked. Take a look at the file for further information.\n";
+        close(DEBUG);
+        exit 1;
+}
+
+foreach $key(keys(%file)) {
+        sleep $pause;
+        print "Uploading $key to the wiki $wiki. Description:\n";
+        print $file{$key}."\n" . "-" x 75 . "\n";
+        uploadfile:
+        $eckey=encode('utf8',$key);
+        if($eckey ne $key) {
+                symlink("$key","$dir/$eckey");
+        }
+        $response=$browser->post("$cgi?title=Special:Upload",
+        @ns_headers,Content_Type=>'form-data',Content=>
+        [
+                wpUploadFile=>["$dir/$eckey"],
+                wpUploadDescription=>encode('utf8',$file{$key}),
+                wpUploadAffirm=>"1",
+                wpUpload=>"Upload file",
+                wpIgnoreWarning=>"1"
+        ]);
+        push @responses,$response->as_string;
+        if($response->code!=302 && $response->code!=200) {
+                print "Upload failed! Will try again. Output was:\n";
+                print $response->as_string;
+                goto uploadfile;
+        } else {
+                print "Uploaded successfully.\n";
+        }
+}
+
+print "Everything seems to be OK. Log will be written to $dir/debug.txt.\n";
+open(DEBUG,">$dir/debug.txt") or die "Could not write file.\n";
+print DEBUG @responses;
Index: trunk/wikipathways/wpi/maintenance/resetPathwayPages.php
===================================================================
--- trunk/wikipathways/wpi/maintenance/resetPathwayPages.php	(revision 0)
+++ trunk/wikipathways/wpi/maintenance/resetPathwayPages.php	(revision 1110)
@@ -0,0 +1,69 @@
+<?php
+
+$dir = getcwd();
+chdir("../"); //Ugly, but we need to change to the MediaWiki install dir to include these files, otherwise we'll get an error
+require_once('wpi.php');
+chdir($dir);
+
+set_time_limit(0);
+
+//Init
+$cats = readCategories("maintenance/pathways.txt");
+
+$dbr =& wfGetDB(DB_SLAVE);
+$res = $dbr->select( "page", array("page_title"), array("page_namespace" => NS_PATHWAY));
+$np = $dbr->numRows( $res );
+while( $row = $dbr->fetchRow( $res )) {
+	echo "Resetting $row[0]<br>";
+	$pathway = Pathway::newFromTitle($row[0]);
+	$title = $pathway->getTitleObject();
+	$revision = Revision::newFromTitle($title);
+	$article = new Article($title);
+
+	$imagePage = $pathway->getFileTitle(FILETYPE_IMG)->getFullText();
+	$gpmlPage = $pathway->getFileTitle(FILETYPE_GPML)->getFullText();
+	$categories = findCategories($pathway, $cats);
+	
+	$text = "{{subst:Template:NewPathwayPage|pathwayPage={{FULLPAGENAMEE}}|categories=$categories}}";
+	
+	if($article->doEdit($text, 'reset', EDIT_UPDATE | EDIT_FORCE_BOT)) {
+		echo "Reset to: $text<br>";
+	} else {
+		echo "UPDATE FAILED";
+	}+	$wgLoadBalancer->commitAll();
+
+	flush();
+	ob_flush();
+	
+}
+
+function findCategories($pathway, $categories) {+	//Add species category
+	$species = $pathway->species();
+	$cattext = "[[Category:$species|{{PAGENAME}}]]";
+
+	//Find categories from array
+	$custcat = $categories[$pathway->getFilePrefix()];
+	if($custcat) {
+		$cattext .= "$custcat\n";
+	}
+	return $cattext;
+}
+
+function readCategories($file) {
+	$lines = file($file);
+	$categories = array();
+	foreach($lines as $line) {
+		$line = trim($line);
+		if($line{0} == '@') {
+			$curcat = substr($line, 1);
+			echo "Found category: $curcat<br>";
+		} elseif ($line{0} == '>') {
+			$categories[substr($line, 1)] = $curcat;
+			echo "Added pathway: $line<br>";
+		}
+	}
+	return $categories;
+}
+?>
Index: trunk/wikipathways/wpi/maintenance/updatePathwayPages.php
===================================================================
--- trunk/wikipathways/wpi/maintenance/updatePathwayPages.php	(revision 0)
+++ trunk/wikipathways/wpi/maintenance/updatePathwayPages.php	(revision 1110)
@@ -0,0 +1,47 @@
+<?php
+
+$dir = getcwd();
+chdir("../"); //Ugly, but we need to change to the MediaWiki install dir to include these files, otherwise we'll get an error
+require_once('wpi.php');
+chdir($dir);
+
+set_time_limit(0);
+
+$dbr =& wfGetDB(DB_SLAVE);
+$res = $dbr->select( "page", array("page_title"), array("page_namespace" => NS_PATHWAY));
+$np = $dbr->numRows( $res );
+echo 'nrow: ' . $np . '<br>';
+$i = 0;
+while( $row = $dbr->fetchRow( $res )) {
+	// TESTER
+	//if(!ereg("Human:Sandbox", $row[0])) continue;
+	//if($i++ > 3) exit;
+	// END TESTER
+	
+	echo "Updating $row[0]<br>";
+	$pathway = Pathway::newFromTitle($row[0]);
+	$title = $pathway->getTitleObject();
+	$revision = Revision::newFromTitle($title);
+	$article = new Article($title);
+	$text = $revision->getText();
+	
+	$regex = "/\[\[Category:(.+?)\|\{\{.+?\}\}\]\]/";
+	
+	$imagePage = $pathway->getFileTitle(FILETYPE_IMG)->getFullText();
+	$gpmlPage = $pathway->getFileTitle(FILETYPE_GPML)->getFullText();
+	
+	echo '<I>' . $text . '</I><BR>';
+	$text = preg_replace($regex, "[[Category:\\1]]", $text);
+
+	if(!$_GET['doit']) {
+		echo $text . '<BR>';
+	} else {
+		if($article->doEdit($text, 'Updated template', EDIT_UPDATE | EDIT_FORCE_BOT)) {
+			echo "Updated to:<br>$text<br>";
+		} else {
+			echo "UPDATE FAILED";
+		}
+		$wgLoadBalancer->commitAll();
+	}
+}
+?>
Index: trunk/wikipathways/wpi/maintenance/updateSVG.php
===================================================================
--- trunk/wikipathways/wpi/maintenance/updateSVG.php	(revision 0)
+++ trunk/wikipathways/wpi/maintenance/updateSVG.php	(revision 1110)
@@ -0,0 +1,22 @@
+<?php
+
+$dir = getcwd();
+chdir("../"); //Ugly, but we need to change to the MediaWiki install dir to include these files, otherwise we'll get an error
+require_once('wpi.php');
+chdir($dir);
+
+$exts = array('.JPG', '.jpg'); //in case SQL server is case sensitive
+
+$dbr =& wfGetDB(DB_SLAVE);
+	$res = $dbr->select( "page", array("page_title"), array("page_namespace" => NS_PATHWAY));
+	$np = $dbr->numRows( $res );
+	while( $row = $dbr->fetchRow( $res )) {
+		echo "Updating $row[0]<br>";
+		$pathway = Pathway::newFromTitle($row[0]);
+		try {
+			$pathway->updateSVG();
+		} catch(Exception $e) {
+			echo "\tERROR: unable to update: $e<br>";
+		}
+	}
+?>
\ No newline at end of file
Index: trunk/wikipathways/wpi/maintenance/wikicopy.pl
===================================================================
--- trunk/wikipathways/wpi/maintenance/wikicopy.pl	(revision 0)
+++ trunk/wikipathways/wpi/maintenance/wikicopy.pl	(revision 1110)
@@ -0,0 +1,102 @@
+#!/usr/bin/perl
+
+#
+# This is a quick and dirty script that I wrote to copy the
+# textual contents of one mediawiki to another using the WWW::Mechanize
+# perl module.
+#
+# I've added it here because it is a demonstration of how to update
+# mediawiki through a perl script.
+#
+# This script doesn't copy images or other uploads, only text.
+# 
+
+use WWW::Mechanize;
+ 
+# one mechanize object to read from
+my $mech = WWW::Mechanize->new();
+
+# one mechanize object to write to
+my $mechout = WWW::Mechanize->new();
+
+# point the former to the old wiki (login page)
+$mech->get ("http://blog.bigcat.unimaas.nl/wiki/index.php?title=Special:Userlogin");
+
+# point the latter to the new wiki (login page)
+$mechout->get ("http://wiki.bigcat.unimaas.nl/index.php?title=Special:Userlogin");
+
+# log in
+$mech->submit_form(
+        form_name => 'userlogin',
+        fields      => 
+			{
+				wpName    	=> "Martijn",
+				wpPassword  => "***",
+			}
+    );
+
+$mechout->submit_form(
+        form_name => 'userlogin',
+        fields      => 
+			{
+				wpName    	=> "Martijn",
+				wpPassword  => "***",
+			}
+    );
+
+# read Special:Allpages from the old wiki
+$mech->get ("http://blog.bigcat.unimaas.nl/wiki/index.php/Special:Allpages");
+
+$mech->content =~ /<!-- start content -->(.*)<!-- end content -->/s;
+my $allpages = $1;
+
+# extract all url's
+while ($allpages =~ /<td><a href=\"(.*?)\" title=\"(.*?)\">(.*?)<\/a><\/td>/gs)
+{
+	# for each url, 
+	my $url = "http://blog.bigcat.unimaas.nl" . $1;
+	my $title = $2;
+	
+	# download it
+	$mech->get ($url);
+	
+	# simulate a click on "edit"
+	$mech->follow_link ( text => "Edit" );
+
+#~ print "-" x 40, "\n";
+#~ print $mech->content;
+#~ print "-" x 40, "\n";
+	
+	# grab the contents from the textarea
+	$mech->content =~ /<textarea .*?>(.*?)<\/textarea>/gs;
+	my $wiki_content = $1;
+
+	# create a new page on the target in edit mode:
+	my $target_url = $url; 
+	$target_url =~ s#http://blog.bigcat.unimaas.nl/wiki/index.php/(.*)#http://wiki.bigcat.unimaas.nl/index.php?title=$1&action=edit#;
+	$mechout->get ($target_url);
+	
+	# html entity encoding. 
+	# This is incomplete but good enough for the original purpose of the script
+	$wiki_content =~ s/&lt;/</sg;
+	$wiki_content =~ s/&gt;/>/sg;
+	$wiki_content =~ s/&quot;/"/sg;
+
+	# submit the new content
+	$mechout->submit_form 
+	(
+		form_name => 'editform',
+		fields => {
+			wpTextbox1 => $wiki_content
+		}
+	);
+	
+	print "Done: $title\n";
+		
+}
+
+#~ $mech->get ("http://blog.bigcat.unimaas.nl/wiki/index.php?title=Hsqldb_database_schemas&action=edit");
+
+
+# wait for enter key
+<STDIN>;

Property changes on: trunk/wikipathways/wpi/maintenance/wikicopy.pl
___________________________________________________________________
Name: svn:executable
   + *

Index: trunk/wikipathways/wpi/maintenance/createPathwayPages.pl
===================================================================
--- trunk/wikipathways/wpi/maintenance/createPathwayPages.pl	(revision 0)
+++ trunk/wikipathways/wpi/maintenance/createPathwayPages.pl	(revision 1110)
@@ -0,0 +1,138 @@
+#!/usr/bin/perl
+
+# This script creates a pathway page for all pathway images on the wiki
+#
+# Usage:
+# perl createPathwayPages.pl [overwrite]
+#
+# Including the overwrite option will cause all existing pages to be overwritten
+#
+# you need to create a file c:\local\etc\wiki.cfg
+# containing 2 lines:
+# user=USERNAME
+# pass=PASSWORD
+#
+# - Thomas
+
+use strict;
+use warnings;
+
+use WWW::Mechanize;
+use IO::File;
+
+my $overwrite = 0;
+if(@ARGV) {
+	$overwrite = shift @ARGV eq "overwrite";
+}
+
+print "> Existing pages will " . ($overwrite ? "" : "not ") . "be overwritten\n";
+
+# The url of the wiki
+my $wiki_url = "http://blog.bigcat.unimaas.nl/pathwaywiki";
+
+# The organism codes from the pathway files
+my %organisms = (
+	Hs => "Human",
+	Sc => "Yeast",
+	Mm => "Mouse",
+	Rn => "Rat",
+	);
+
+# mechanize object for wiki
+my $mech = WWW::Mechanize->new();
+
+# point to the wiki
+$mech->get ("$wiki_url/index.php?title=Special:Userlogin");
+
+#login
+my $config= readconfig();
+$mech->submit_form(
+        form_name => 'userlogin',
+        fields      => 
+			{
+				wpName    	=> $config->{user},
+				wpPassword  => $config->{pass},
+			}
+    );
+
+# read images Special:Allpages from the old wiki
+$mech->get ("$wiki_url/index.php?title=Special%3AAllpages&from=&namespace=6");
+
+$mech->content =~ /<!-- start content -->(.*)<!-- end content -->/s;
+my $allpages = $1;
+
+# extract all image url's
+while ($allpages =~ /<td><a href=\"(.*?)\" title=\"(.*?)\">(.*?)<\/a><\/td>/gs) {
+	print "Processing image: $2\n";
+	
+	my $title = $2;
+	
+	my $code = getSpeciesCode($title);
+	if(defined $code) {
+		my $page = imgpage2pwpage($title, $code);
+		if(defined $page) {
+   		print "Creating page $page\n";
+   			
+   		my $target_url = $wiki_url . "/index.php?title=$page&action=edit";
+   		$mech->get ($target_url);
+   		
+   		$page =~ m/^[\w|\s]*:([\w|\s]*)/;
+   		my $category = "Category:$organisms{$code}|$1";
+   		# grab the contents from the textarea
+   		$mech->content =~ /<textarea .*?>(.*?)<\/textarea>/gs;
+   		my $page_content = $1;
+   		
+   		chomp($page_content);
+   		if($page_content eq "" || $overwrite) {
+   			# submit the new content
+   			$mech->submit_form(
+   				form_name => 'editform',
+   				fields => {
+   					wpTextbox1 => "[[$title]]\n[[$category]]"
+   				}
+   			);
+   		} else {
+   			print("\t!Page already exists!\n");
+   		}
+   	}
+	}
+}
+
+sub imgpage2pwpage {
+	my $imgpage = shift;
+	my $code = shift;
+	
+	my $species = $organisms{$code};
+  if(defined $species) {
+	  	 $imgpage =~ s/Image:$code /$species:/;
+	  	 $imgpage =~ s/\.\w*$//;
+	  	 return $imgpage;
+	  } else {
+	  	print "Could not find organism for image $imgpage\n"; 
+		}
+	undef;
+}
+
+sub getSpeciesCode {
+	my $imgpage = shift;
+	
+	if ($imgpage =~ /^Image:([A-Z][a-z]) /) {
+	  return $1;
+	}
+	print "Could not find organism code for image $imgpage\n";
+	undef;
+}
+
+sub readconfig {
+    my %params;
+    my $fh= IO::File->new("wiki.cfg", "r") or die "wiki.cfg: $!";
+    while (<$fh>) {
+        s/\s+$//;
+        if (/(\w+)\s*=\s*(.*)/) {
+            my ($k, $v)= ($1, $2);
+            $params{$k}= $v;
+        }
+    }
+    $fh->close();
+    return \%params;
+}
\ No newline at end of file
Index: trunk/wikipathways/wpi/maintenance/deleteJPGs.php
===================================================================
--- trunk/wikipathways/wpi/maintenance/deleteJPGs.php	(revision 0)
+++ trunk/wikipathways/wpi/maintenance/deleteJPGs.php	(revision 1110)
@@ -0,0 +1,41 @@
+<?php
+
+$dir = getcwd();
+chdir("../../");
+#require_once( '.StartProfiler.php' );
+require_once ( 'includes/WebStart.php');
+require_once( 'includes/Wiki.php' );
+chdir($dir);
+
+$exts = array('.JPG', '.jpg'); //in case SQL server is case sensitive
+
+
+foreach($exts as $ext) {
+	deleteByExtension($ext);
+}
+
+function deleteByExtension($ext) {
+	$dbr =& wfGetDB(DB_SLAVE);
+	$res = $dbr->select( "page", array("page_namespace, page_title"), "page_title LIKE '%$ext'" );
+	$np = $dbr->numRows( $res );
+	echo("Number of pages found for $ext: $nr<BR>");
+
+	while( $row = $dbr->fetchRow( $res )) {
+		$ns = $row[0];
+		$pt = $row[1];
+		$title = Title::makeTitle($ns, $pt);
+
+		if($ns == NS_IMAGE) {
+			$img = new Image($title);
+			$status = $img->delete("removed jpgs");
+		}
+		$art = new Article($title);
+		$status = $art->doDeleteArticle("removed jpgs");
+
+		echo("Removing image $pt: $status<BR>");
+	}
+	$dbr->freeResult( $res );
+}
+
+$wgLoadBalancer->commitAll();
+?>
Index: trunk/wikipathways/wpi/maintenance/generatePathwayList.pl
===================================================================
--- trunk/wikipathways/wpi/maintenance/generatePathwayList.pl	(revision 0)
+++ trunk/wikipathways/wpi/maintenance/generatePathwayList.pl	(revision 1110)
@@ -0,0 +1,40 @@
+#!/usr/bin/perl
+use strict;
+use warnings;
+use File::Find;
+
+my %categories = (
+	'physiological_process-GenMAPP' => "Physiological Process",
+	'molecular_function-GenMAPP' => "Molecular Function",
+	'metabolic_process-GenMAPP' => "Metabolic Process",
+	'cellular_process-GenMAPP' => "Cellular Process",
+);
+
+my $dir = shift @ARGV;
+my $out = shift @ARGV;
+
+open OUT, ">$out" or die "Can't open $out";
+
+find(\&wanted, $dir);
+
+my $last_dir = " ";
+
+sub wanted {
+	if(m/.mapp$/) {
+		my $dir = getBottomDir($File::Find::dir);
+		if($dir ne $last_dir) {
+			$last_dir = $dir;
+			chomp($dir);
+			print $categories{$dir};
+			print OUT '@'."[[Category:$categories{$dir}|{{PAGENAME}}]]\n";		
+		}
+		s/.mapp$//;
+		print OUT ">$_\n";
+	}
+}
+
+sub getBottomDir {
+	my $dir = shift;
+	$dir =~ m|/([^/]*)$|;
+	$1;
+}

Property changes on: trunk/wikipathways/wpi/maintenance/generatePathwayList.pl
___________________________________________________________________
Name: svn:executable
   + *

Index: trunk/wikipathways/wpi/sitemap/runSiteMap.sh
===================================================================
--- trunk/wikipathways/wpi/sitemap/runSiteMap.sh	(revision 0)
+++ trunk/wikipathways/wpi/sitemap/runSiteMap.sh	(revision 1110)
@@ -0,0 +1,19 @@
+#!/bin/sh
+
+cd /var/www/wikipathways/wpi/sitemap
+
+# Set the permissions for createSiteMap.php to enable access over http
+echo "Setting permissions of createSiteMap.php to 777"
+chmod 777 createSiteMap.php
+
+# Generate new sitemap
+echo "Generating sitemap"
+wget -O /var/www/wikipathways/sitemap.xml http://www.wikipathways.org/wpi/sitemap/createSiteMap.php
+
+# Set the correct permissions for sitemap.xml
+echo "Setting permissions of sitemap.xml to 777"
+chmod 777 /var/www/wikipathwayssitemap.xml
+
+# Restore permissions
+echo "Restoring permissions of createSiteMap.php"
+chmod 700 createSiteMap.php

Property changes on: trunk/wikipathways/wpi/sitemap/runSiteMap.sh
___________________________________________________________________
Name: svn:executable
   + *

Index: trunk/wikipathways/wpi/sitemap/createSiteMap.php
===================================================================
--- trunk/wikipathways/wpi/sitemap/createSiteMap.php	(revision 0)
+++ trunk/wikipathways/wpi/sitemap/createSiteMap.php	(revision 1110)
@@ -0,0 +1,128 @@
+<?php
+# (TK) Modified from:
+# -----------------------------------------------------
+# MediaWiki - Google Sitemaps generation. v0.3
+# 
+# A page that'll generate valid Google Sitemaps code
+# from the current MediaWiki installation.
+# v0.3: Small changes to fix others situations
+# v0.2: Updated for MediaWiki 1.5.x
+# v0.1: First attempt for MediaWiki 1.4.x
+#
+# See http://www.thinklemon.com/wiki/MediaWiki:Google_Sitemaps
+#
+# TODO: Further refinements like caching...
+# -----------------------------------------------------
+
+$dir = getcwd();
+chdir("/var/www/wikipathways/wpi");
+require_once("wpi.php");
+chdir($dir);
+
+# -----------------------------------------------------
+# Send XML header, tell agents this is XML.
+# -----------------------------------------------------
+
+header("Content-Type: application/xml; charset=UTF-8");
+
+# -----------------------------------------------------
+# Send xml-prolog
+# -----------------------------------------------------
+
+echo '<'.'?xml version="1.0" encoding="utf-8" ?'.">\n"; 
+
+# -----------------------------------------------------
+# Start connection
+# -----------------------------------------------------
+
+$connWikiDB = mysql_pconnect($wgDBserver, $wgDBuser, $wgDBpassword) 
+	or trigger_error(mysql_error(),E_USER_ERROR); 
+mysql_select_db($wgDBname, $connWikiDB);
+
+# -----------------------------------------------------
+# Build query
+# Skipping redirects and MediaWiki namespace
+# -----------------------------------------------------
+
+$namespaces = array(NS_PATHWAY => 1, NS_HELP => 0.8, NS_MAIN => 0.5, NS_PATHWAY_TALK => 0.3);
+$namespaceString = implode(', ', array_keys($namespaces));
+$query_rsPages = "SELECT page_namespace, page_title, page_touched ".
+	"FROM ".$wgDBprefix."page ".
+	"WHERE (page_is_redirect = 0 AND page_namespace IN ($namespaceString)) ".
+	"ORDER BY page_touched DESC";
+
+# -----------------------------------------------------
+# Fetch the data from the DB
+# -----------------------------------------------------
+
+$rsPages = mysql_query($query_rsPages, $connWikiDB) or die(mysql_error());
+# Fetch the array of pages
+$row_rsPages = mysql_fetch_assoc($rsPages);
+$totalRows_rsPages = mysql_num_rows($rsPages);
+
+# -----------------------------------------------------
+# Start output
+# -----------------------------------------------------
+error_reporting(E_ALL);
+?>
+<!-- MediaWiki - Google Sitemaps - v0.3 -->
+<!-- <?php echo $totalRows_rsPages ?> wikipages found. -->
+<!-- Created on <?php echo fnTimestampToIso(time()); ?> -->
+<urlset xmlns="http://www.google.com/schemas/sitemap/0.84">
+<?php 
+
+do { 
+	$nPriority = 0.1;
+	$ns = $row_rsPages['page_namespace'];
+	$title = Title::makeTitle($ns, $row_rsPages['page_title']);
+
+	//Use latest modification of both GPML and Pathway pages	
+	if($ns == NS_PATHWAY) {
+		$pathway = Pathway::newFromTitle($title);
+		$mod = $pathway->getGpmlModificationTime();
+		$row_rsPages['page_touched'] = max($mod, $row_rsPages['page_touched']);
+	}
+
+	$sPageName = $title->getFullUrl();
+	$nPriority = $namespaces[$ns];
+
+# -----------------------------------------------------
+# Start output
+# -----------------------------------------------------
+
+?>
+	<url>
+		<loc><?php echo fnXmlEncode( $sPageName ) ?></loc>
+		<lastmod><?php echo fnTimestampToIso($row_rsPages['page_touched']); ?></lastmod>
+		<changefreq>daily</changefreq>
+		<priority><?php echo $nPriority ?></priority>
+	</url>
+<?php } while ($row_rsPages = mysql_fetch_assoc($rsPages)); ?>
+</urlset>
+<?php
+# -----------------------------------------------------
+# Clear Connection
+# -----------------------------------------------------
+
+mysql_free_result($rsPages);
+
+# -----------------------------------------------------
+# General functions
+# -----------------------------------------------------
+
+// Convert timestamp to ISO format
+function fnTimestampToIso($ts) {
+	# $ts is a MediaWiki Timestamp (TS_MW)
+	# ISO-standard timestamp (YYYY-MM-DDTHH:MM:SS+00:00)
+
+	return gmdate( 'Y-m-d\TH:i:s\+00:00', wfTimestamp( TS_UNIX, $ts ) );
+}
+
+// Convert string to XML safe encoding
+function fnXmlEncode( $string ) {
+	$string = str_replace( "\r\n", "\n", $string );
+	$string = preg_replace( '/[\x00-\x08\x0b\x0c\x0e-\x1f]/', '', $string );
+	return htmlspecialchars( $string );
+}
+
+?>

Property changes on: trunk/wikipathways/wpi/sitemap/createSiteMap.php
___________________________________________________________________
Name: svn:executable
   + *

Index: trunk/wikipathways/wpi/wpi.php
===================================================================
--- trunk/wikipathways/wpi/wpi.php	(revision 0)
+++ trunk/wikipathways/wpi/wpi.php	(revision 1110)
@@ -0,0 +1,680 @@
+<?php
+require_once('globals.php');
+//Initialize MediaWiki
+set_include_path(get_include_path().PATH_SEPARATOR.realpath('../includes').PATH_SEPARATOR.realpath('../').PATH_SEPARATOR);
+$dir = getcwd();
+chdir("../"); //Ugly, but we need to change to the MediaWiki install dir to include these files, otherwise we'll get an error
+require_once ( 'WebStart.php');
+require_once( 'Wiki.php' );
+chdir($dir);
+
+//Parse HTTP request (only if script is directly called!)
+if(realpath($_SERVER['SCRIPT_FILENAME']) == realpath(__FILE__)) {
+$action = $_GET['action'];
+switch($action) {
+	case 'launchPathVisio':
+		$pathway = Pathway::newFromTitle($_GET['pwTitle']);
+		$ignore = $_GET['ignoreWarning'];
+		launchPathVisio($pathway, $ignore);
+		break;
+	case 'downloadFile':
+		downloadFile($_GET['type'], $_GET['pwTitle']);
+		break;
+	case 'revert':
+		revert($_GET['pwTitle'], $_GET['oldId']);
+		break;
+	case 'new':
+		$pathway = new Pathway($_GET['pwName'], $_GET['pwSpecies'], false);
+		$ignore = $_GET['ignoreWarning'];
+		launchPathVisio($pathway, $ignore, true);
+		break;
+	case 'delete':
+		delete($_GET['pwTitle']);
+		break;
+	}
+}
+
+function delete($title) {
+	global $wgUser;
+	$pathway = Pathway::newFromTitle($_GET['pwTitle']);
+	if($wgUser->isAllowed('delete')) {
+		$pathway = Pathway::newFromTitle($_GET['pwTitle']);
+		$pathway->delete();
+		echo "<h1>Deleted</h1>";
+		echo "<p>Pathway $title was deleted, go back to <a href=http://{$_SERVER['HTTP_HOST']}>wikipathways</a>";
+	} else {
+		echo "<h1>Error</h1>";
+		echo "<p>Pathway $title is not deleted, you have no delete permissions</a>";
+		$wgOut->permissionRequired( 'delete' );
+	}
+	exit;
+}
+
+function revert($pwTitle, $oldId) {
+	$pathway = Pathway::newFromTitle($pwTitle);
+	$pathway->revert($oldId);
+	//Redirect to old page
+	$url = $pathway->getTitleObject()->getFullURL();
+	header("Location: $url");
+	exit;
+}
+
+function launchPathVisio($pathway, $ignore = null, $new = false) {
+	global $wgUser;
+	
+	if(!$new) {
+		$gpml = $pathway->getGpml();
+		if(!$gpml) {
+			throw new Exception("GPML does not exist");
+		}
+	}
+	
+	$webstart = file_get_contents("bin/pathvisio_wikipathways.jnlp");
+	$arg .= createJnlpArg("-rpcUrl", "http://" . $_SERVER['HTTP_HOST'] . "/wpi/wpi_rpc.php");
+	$arg .= createJnlpArg("-pwName", $pathway->name());
+	$arg .= createJnlpArg("-pwSpecies", $pathway->species());
+	if($new) {
+		$arg .= createJnlpArg("-pwUrl", $pathway->getTitleObject()->getFullURL());
+	} else {
+		$arg .= createJnlpArg("-pwUrl", $pathway->getFileURL(FILETYPE_GPML));
+	}
+	foreach (array_keys($_COOKIE) as $key) {
+		$arg .= createJnlpArg("-c", $key . "=" . $_COOKIE[$key]);
+	} 
+	if($wgUser && $wgUser->isLoggedIn()) {
+		$arg .= createJnlpArg("-user", $wgUser->getRealName());
+	}
+	if($new) {
+		$arg .= createJnlpArg("-new", "1");
+	}
+	$webstart = str_replace("<!--ARG-->", $arg, $webstart);
+
+	$msg = null;
+	if( $wgUser->isLoggedIn() ) {
+		if( $wgUser->isBlocked() ) {
+			$msg = "Warning: your user account is blocked!";
+		}
+	} else {
+		$msg = "Warning: you are not logged in! You will not be able to save modifications to WikiPathways.org.";
+	}
+	if($msg && !$ignore) { //If $msg is not null, then we have an error
+		$name = $pathway->name();
+		$url = $pathway->getFullURL();
+		$title = $pathway->getTitleObject()->getPartialURL();
+		$jnlp = $wpiScript . "?action=launchPathVisio&pwTitle=$title&ignoreWarning=1";
+		$script = 
+<<<JS
+<html>
+<body>
+<p>Back to <a href={$url}>{$name}</a></p>
+<script type="text/javascript">
+var view = confirm("{$msg} You will not be able to save modifications to WikiPathways.org.\\n\\nDo you still want to open the pathway?");
+if(view) {
+window.location="{$jnlp}";
+} else {
+history.go(-1);
+}
+</script>
+</body>
+</html>
+JS;
+		echo($script);
+		exit;
+	}
+	sendWebstart($webstart, $pathway->name());//This exits script
+}
+
+function sendWebstart($webstart, $tmpname) {
+	ob_start();
+	ob_clean();
+	$os = getClientOs();
+	if($os == 'linux') { //return shell script that sets MOZILLA_FIVE_HOME and opens webstart
+		header("Content-type: application/x-shellscript");
+		header("Content-Disposition: attachment; filename=\"PathVisio.sh\"");
+		echo "#!/bin/sh\n";
+		echo "export MOZILLA_FIVE_HOME=/usr/lib/firefox\n";
+		echo "LD_LIBRARY_PATH=/usr/lib/firefox:$LD_LIBRARY_PATH\n";
+		echo 'javaws "'. getJnlpURL($webstart, $tmpname) . '"';
+	} else { //return webstart file directly
+		header("Content-type: application/x-java-jnlp-file");
+		header("Content-Disposition: attachment; filename=\"PathVisio.jnlp\"");
+		echo $webstart;
+	}
+	exit;
+}
+
+function getJnlpURL($webstart, $tmpname) {
+	$wsFile = tempnam(getcwd() . "/tmp",$tmpname);
+	writeFile($wsFile, $webstart);
+	return 'http://' . $_SERVER['HTTP_HOST'] . '/wpi/tmp/' . basename($wsFile);
+}
+
+function createJnlpArg($flag, $value) {
+	//return "<argument>" . $flag . ' "' . $value . '"' . "</argument>\n";
+	if(!$flag || !$value) return '';
+	return "<argument>" . htmlspecialchars($flag) . "</argument>\n<argument>" . htmlspecialchars($value) . "</argument>\n";
+}
+
+function downloadFile($fileType, $pwTitle) {
+	ob_start();
+	$pathway = Pathway::newFromTitle($pwTitle);
+	$file = $pathway->getFileLocation($fileType);
+	$fn = $pathway->getFileName($fileType);
+	
+	ob_clean();
+	switch($fileType) {
+		case FILETYPE_GPML:
+			header("Content-type: text/xml");
+			break;
+		case FILETYPE_IMG:
+			header("Content-type: image/svg+xml");
+			break;
+		case FILETYPE_PNG:
+			header("Content-type: image/png");
+			break;
+	}
+	header("Cache-Control: must-revalidate, post-check=0, pre-check=0");
+	header("Content-Disposition: attachment; filename=\"$fn\"");
+	header("Content-Length: " . filesize($file));
+	set_time_limit(0);
+	@readfile($file);
+	exit();
+}
+
+function getClientOs() {
+	$regex = array(
+		'windows' => '([^dar]win[dows]*)[\s]?([0-9a-z]*)[\w\s]?([a-z0-9.]*)',
+		'mac' => '(68[k0]{1,3})|(ppc mac os x)|([p\S]{1,5}pc)|(darwin)',
+		'linux' => 'x11|inux');
+	$ua = $_SERVER['HTTP_USER_AGENT'];
+	foreach (array_keys($regex) as $os) {
+		if(eregi($regex[$os], $ua)) return $os;
+	}	
+}
+ 
+$spName2Code = array('Human' => 'Hs', 'Rat' => 'Rn', 'Mouse' => 'Mm');//TODO: complete
+
+function toGlobalLink($localLink) {
+	if($wgScriptPath && $wgScriptPath != '') {
+		$wgScriptPath = "$wgScriptPath/";
+	}
+	return urlencode("http://" . $_SERVER['HTTP_HOST'] . "$wgScriptPath$localLink");
+}
+
+class Pathway {
+	private static $spName2Code = array('Human' => 'Hs', 'Rat' => 'Rn', 'Mouse' => 'Mm');
+	private static $spCode2Name; //TODO: complete species
+	
+	private $file_ext = array(FILETYPE_IMG => 'svg', FILETYPE_GPML => 'gpml', FILETYPE_MAPP => 'mapp', FILETYPE_PNG => 'png');
+	
+	private $pwName;
+	private $pwSpecies;
+
+	function __construct($name, $species, $updateCache = false) {
+		wfDebug("Creating pathway: $name, $species\n");
+		if(!$name) throw new Exception("name argument missing in constructor for Pathway");
+		if(!$species) throw new Exception("species argument missing in constructor for Pathway");
+		
+		$this->pwName = $name;
+		$this->pwSpecies = $species;
+		if($updateCache) $this->updateCache();
+	}
+		
+	public static function speciesFromCode($code) {
+		if(!Pathway::$spCode2Name) {
+			foreach(array_keys(Pathway::$spName2Code) as $name) {
+				Pathway::$spCode2Name[Pathway::$spName2Code[$name]] = $name;
+			}
+		}
+		return Pathway::$spCode2Name[$code];
+	}
+	
+	public static function codeFromSpecies($species) {
+		return Pathway::$spName2Code[$species];
+	}
+	
+	public function newFromTitle($title) {
+		if($title instanceof Title) {
+			$title = $title->getFullText();
+		}
+		
+		$name = Pathway::nameFromTitle($title);
+		$species = Pathway::speciesFromTitle($title);
+		$code = Pathway::$spName2Code[$species]; //Check whether this is a valid species
+		if($name && $code) {
+			return new Pathway($name, $species);
+		} else {
+		
+	throw new Exception("Couldn't parse pathway article title: $title");
+		}
+	}
+	
+	public function newFromFileTitle($title) {
+		if($title instanceof Title) {
+			$title = $title->getText();
+		}
+		//"Hs_testpathway.ext"
+		if(ereg("^([A-Z][a-z])_(.+)\.[A-Za-z]{3,4}$", $title, $regs)) {
+			$species = Pathway::speciesFromCode($regs[1]);
+			$name = $regs[2];
+		}
+		if(!$name || !$species) throw new Exception("Couldn't parse file title: $title");
+		return new Pathway($name, $species);
+	}
+	
+	public function getFullURL() {
+		return $this->getTitleObject()->getFullURL();
+	}
+	
+	public function getTitleObject() {
+		//wfDebug("TITLE OBJECT: $this->species():$this->name()\n");
+		return Title::newFromText($this->species() . ':' . $this->name(), NS_PATHWAY);
+	}
+	
+	public static function getAvailableSpecies() {
+		return array_keys(Pathway::$spName2Code);
+	}
+	
+	private static function nameFromTitle($title) {
+		$parts = explode(':', $title);
+
+		if(count($parts) < 2) {
+			throw new Exception("Invalid pathway article title: $title");
+		}
+		return array_pop($parts);
+	}
+
+	private static function speciesFromTitle($title) {
+		$parts = explode(':', $title);
+
+		if(count($parts) < 2) {
+			throw new Exception("Invalid pathway article title: $title");
+		}
+		$species = array_slice($parts, -2, 1);
+		return array_pop($species);
+	}
+
+	public function name($name = NULL) {
+		if($name) {
+			$this->pwName = $name;
+		}
+		return $this->pwName;
+	}
+	
+	public function getName($textForm = true) {
+		return Pathway::nameFromTitle($this->getTitleObject()->getText());
+	}
+	
+	public function species($species = NULL) {
+		if($species) {
+			$this->pwSpecies = $species;
+		}
+		return $this->pwSpecies;
+	}
+	
+	public function getSpeciesCode() {
+		return Pathway::$spName2Code[$this->pwSpecies];
+	}
+
+	public function getGpml() {
+		$gpmlTitle = $this->getFileTitle(FILETYPE_GPML);
+		$gpmlRef = Revision::newFromTitle($gpmlTitle);
+		
+		return $gpmlRef == NULL ? "no gpml" : $gpmlRef->getText();
+	}
+
+	public function getFileName($fileType) {
+		if($fileType == FILETYPE_GPML) {
+			return $this->getFilePrefix() . '.' . $this->file_ext[$fileType];
+		} else {
+			return $this->getFileTitle($fileType)->getDBKey();
+		}
+	}
+	
+	public function getFileLocation($fileType, $updateCache = true) {
+		if($updateCache) { //Make sure to have up to date version
+			$this->updateCache($fileType);	
+		}
+		$fn = $this->getFileName($fileType);
+		return wfImageDir( $fn ) . "/$fn";
+	}
+	
+	public function getFileURL($fileType, $updateCache = true) {
+		if($updateCache) {
+			$this->updateCache($fileType);
+		}
+		return "http://" . $_SERVER['HTTP_HOST'] . Image::imageURL($this->getFileName($fileType));
+	}
+	
+	public function getFileTitle($fileType) {
+		switch($fileType) {
+			case FILETYPE_GPML:
+				$title = Title::newFromText($this->getTitleObject()->getText(), NS_GPML);			
+				break;
+			default:
+				$prefix = $this->getFilePrefix();
+				$title = Title::newFromText( "$prefix." . $this->file_ext[$fileType], NS_IMAGE );
+				if(!$title) {
+					throw new Exception("Invalid file title for pathway " + $fileName);
+				}
+				break;
+		}
+		return $title;
+	}
+
+	public function getFilePrefix() {
+		$prefix = $this->getSpeciesCode() . "_" . $this->pwName;
+		/*
+		 * Filter out illegal characters, and try to make a legible name
+		 * out of it. We'll strip some silently that Title would die on.
+		 */
+		$filtered = preg_replace ( "/[^".Title::legalChars()."]|:/", '-', $prefix );
+		$title = Title::newFromText( $filtered, NS_IMAGE );
+		if(!$title) {
+			throw new Exception("Invalid file title for pathway " + $fileName);
+		}
+		return $title->getDBKey();
+	}
+
+	public function getImageTitle() {
+		return $this->getFileTitle(FILETYPE_IMG);
+	}
+
+	public function updatePathway($gpmlData, $description) {
+		$this->saveGpml($gpmlData, $description);
+	}
+
+	public function revert($oldId) {
+		global $wgUser, $wgLang;
+		$rev = Revision::newFromId($oldId);
+		$gpml = $rev->getText();
+		if($gpml) {
+			$usr = $wgUser->getSkin()->userLink($wgUser->getId(), $wgUser->getName());
+			$date = $wgLang->timeanddate( $rev->getTimestamp(), true );
+			$this->updatePathway($gpml, "Reverted to version '$date' by $usr");
+		} else {
+			throw new Exception("Unable to get gpml content");
+		}
+	}
+	
+	private function saveImage($gpmlFile, $description) {
+		$imgName = $this->getFileName(FILETYPE_IMG);
+
+		# Convert gpml to svg
+		$gpmlFile = realpath($gpmlFile);
+
+		$basePath = dirname(realpath(__FILE__));
+		$imgFile = $basePath . '/tmp/' . $imgName;
+		$cmd = "java -jar $basePath/bin/pathvisio_convert.jar $gpmlFile $imgFile 2>&1";
+		wfDebug($cmd);
+		exec($cmd, $output, $status);
+		
+		foreach ($output as $line) {
+			$msg .= $line . "\n";
+		}
+		wfDebug("Converting to SVG:\nStatus:$status\nMessage:$msg");
+		if($status != 0 ) {
+			throw new Exception("Unable to convert to SVG:\nStatus:$status\nMessage:$msg");
+		}
+		# Upload svg file to wiki
+		return Pathway::saveFileToWiki($imgFile, $imgName, $description);
+	}
+
+	private function newPathwayArticle($gpmlData) {		
+		//Create description page
+		$title = $this->getTitleObject();
+		$article = new Article($title);
+		$species = $this->species();
+		return $article->doEdit('{{subst:Template:NewPathwayPage|categories=[[Category:'.$species.']]}}', "Created new pathway", EDIT_NEW);
+	}
+
+	public function delete() {
+		global $wgLoadBalancer;
+		wfDebug("Deleting pathway" . $this->getTitleObject()->getFullText() . "\n");
+		$reason = 'Deleted pathway';
+		$title = $this->getTitleObject();
+		Pathway::deleteArticle($title, $reason);
+		//Clean up GPML and SVG pages
+		$title = $this->getFileTitle(FILETYPE_GPML);
+		Pathway::deleteArticle($title, $reason);
+		$this->clearCache(null, true);
+		$wgLoadBalancer->commitAll();
+	}
+
+	private function deleteImagePage($reason) {
+		global $wgLoadBalancer;
+		$title = $this->getFileTitle(FILETYPE_IMG);
+		Pathway::deleteArticle($title, $reason);
+		$img = new Image($title);
+		$img->delete($reason);
+		$wgLoadBalancer->commitAll();
+	}
+
+	public static function deleteArticle($title, $reason='not specified') {
+		global $wgUser, $wgLoadBalancer;
+		
+		$article = new Article($title);
+		
+		if (wfRunHooks('ArticleDelete', array(&$this, &$wgUser, &$reason))) {
+			$article->doDeleteArticle($reason);
+			$wgLoadBalancer->commitAll();
+			wfRunHooks('ArticleDeleteComplete', array(&$this, &$wgUser, $reason));
+		}
+	}
+
+	private function saveGpml($gpmlData, $description) {
+		global $wgLoadBalancer;
+		$gpmlTitle = $this->getFileTitle(FILETYPE_GPML);
+		$gpmlArticle = new Article($gpmlTitle);		
+		
+		$new = !$gpmlArticle->exists();
+
+		$succ = true;
+		$succ =  $gpmlArticle->doEdit($gpmlData, $description);
+		$wgLoadBalancer->commitAll();
+		$this->updateCache();
+			
+		if($new) $succ = $this->newPathwayArticle();
+		
+		return $succ;
+	}
+	
+	private function saveImageCache() {
+		$file = $this->getFileLocation(FILETYPE_GPML);
+		$this->saveImage($file, "Updated SVG cache");
+	}
+	
+	private function saveGpmlCache() {
+		$gpml = $this->getGpml();
+		$file = $this->getFileLocation(FILETYPE_GPML, false);
+		writeFile($file, $gpml);
+	}
+	
+	private function savePngCache() {
+		global $wgSVGConverters, $wgSVGConverter, $wgSVGConverterPath;
+		
+		$input = $this->getFileLocation(FILETYPE_IMG);
+		$output = $this->getFileLocation(FILETYPE_PNG, false);
+		
+		$width = 1000;
+		$retval = 0;
+		if(isset($wgSVGConverters[$wgSVGConverter])) {
+			$cmd = str_replace( //TODO: calculate proper height for rsvg
+				array( '$path/', '$width', '$input', '$output' ),
+				array( $wgSVGConverterPath ? wfEscapeShellArg( "$wgSVGConverterPath/" ) : "",
+				intval( $width ),
+				wfEscapeShellArg( $input ),
+				wfEscapeShellArg( $output ) ),
+				$wgSVGConverters[$wgSVGConverter] ) . " 2>&1";
+			$err = wfShellExec( $cmd, $retval );
+			if($retval != 0 || !file_exists($output)) {
+				throw new Exception("Unable to convert to png: $err\nCommand: $cmd");
+			}
+		} else {
+			throw new Exception("Unable to convert to png, no SVG rasterizer found");
+		}
+		$ex = file_exists($output);
+		wfDebug("PNG CACHE SAVED: $output, $ex;\n");
+	}
+		
+	public function updateCache($fileType = null) {
+		wfDebug("updateCache called for filetype $fileType\n");
+		if(!$fileType) { //Update all
+			$this->updateCache(FILETYPE_GPML);
+			$this->updateCache(FILETYPE_PNG);
+			$this->updateCache(FILETYPE_IMG);
+			return;
+		}
+		if($this->isOutOfDate($fileType)) {
+			wfDebug("\t->Updating cached file for $fileType\n");
+			switch($fileType) {
+			case FILETYPE_PNG:
+				$this->savePngCache();
+				break;
+			case FILETYPE_GPML:
+				$this->saveGpmlCache();
+				break;
+			case FILETYPE_IMG:
+
+				$this->saveImageCache();
+			}
+		}
+	}
+	
+	public function clearCache($fileType = null, $forceImagePage=false) {
+		if($forceImagePage) { //Only delete the image file when explicitly asked for!
+			$this->deleteImagePage("Clearing cache");
+		}
+		if(!$fileType) { //Update all
+			$this->clearCache(FILETYPE_PNG);
+			$this->clearCache(FILETYPE_GPML);
+		} else {
+			unlink($this->getFileLocation($fileType, false)); //Delete the cached file
+		}
+	}
+
+	//Check if the cached version of the GPML data derived file is out of date
+	private function isOutOfDate($fileType) {		
+		wfDebug("isOutOfDate for $fileType\n");
+		
+		$gpmlTitle = $this->getFileTitle(FILETYPE_GPML);
+		$gpmlRev = Revision::newFromTitle($gpmlTitle);
+		if($gpmlRev) {
+			$gpmlDate = $gpmlRev->getTimestamp();
+		} else {
+			$gpmlDate = -1;
+		}
+		
+		$file = $this->getFileLocation($fileType, false);
+
+		if(file_exists($file)) {
+			$fmt = wfTimestamp(TS_MW, filemtime($file));
+			wfDebug("\tFile exists, cache: $fmt, gpml: $gpmlDate\n");
+			return  $fmt < $gpmlDate;
+		} else { //No cached version yet, so definitely out of date
+			wfDebug("\tFile doesn't exist\n");
+			return true;
+		}
+	}
+	
+	public function getGpmlModificationTime() {
+		$gpmlTitle = $this->getFileTitle(FILETYPE_GPML);
+		$gpmlRev = Revision::newFromTitle($gpmlTitle);
+		if($gpmlRev) {
+			$gpmlDate = $gpmlRev->getTimestamp();
+		} else {
+			throw new Exception("No GPML page");
+		}
+		return $gpmlDate;
+	}
+
+	## Based on SpecialUploadForm.php
+	## Assumes $saveName is already checked to be a valid Title
+	//TODO: run hooks
+	static function saveFileToWiki( $fileName, $saveName, $description ) {
+		global $wgLoadBalancer, $wgUser;
+				
+		wfDebug("========= UPLOADING FILE FOR WIKIPATHWAYS ==========\n");
+		wfDebug("=== IN: $fileName\n=== OUT: $saveName\n");		
+		# Check permissions
+		if( $wgUser->isLoggedIn() ) {
+			if( !$wgUser->isAllowed( 'upload' ) ) {
+				throw new Exception( "User has no permission to upload" );
+			}
+		} else {
+			//Print out http headers (for debugging)
+			$hds = $_SERVER;
+			wfDebug("REQUEST HEADERS\n");
+			foreach (array_keys($hds) as $key) {
+				$out .= $key . "=" . $hds[$key] . "\n";
+			}
+			throw new Exception( "You are not logged on, please log in or create an account first" );
+		}
+
+		# Check blocks
+		if( $wgUser->isBlocked() ) {
+			throw new Exception( "User is blocked" );
+		}
+
+		if( wfReadOnly() ) {
+			throw new Exception( "Page is read-only" );
+		}
+
+		# Move the file to the proper directory
+		$dest = wfImageDir( $saveName );
+		$archive = wfImageArchiveDir( $saveName );
+		if ( !is_dir( $dest ) ) wfMkdirParents( $dest );
+		if ( !is_dir( $archive ) ) wfMkdirParents( $archive );
+
+		$toFile = "{$dest}/{$saveName}";
+		if( is_file( $toFile) ) {
+			$oldVersion = gmdate( 'YmdHis' ) . "!{$saveName}";
+			$success = rename($toFile, "{$archive}/{$oldVersion}");
+			if(!$success) {
+				throw new Exception( 
+					"Unable to rename file $olddVersion to {$archive}/{$oldVersion}" );
+			}
+		}
+		$success = rename($fileName, $toFile);
+		if(!$success) {
+			throw new Exception( "Unable to rename file $fileName to $toFile" );
+		}
+		chmod($toFile, 0644);
+		
+		# Update the image page
+		$img = Image::newFromName( $saveName );
+		$success = $img->recordUpload( $oldVersion,
+			                           $description,
+			                           wfMsgHtml( 'license' ),
+			                           "", //Copyright
+			                           $fileName,
+			                           FALSE ); //Watchthis
+		if(!$success) {
+			throw new Exception( "Couldn't create description page" );
+		}
+
+		$wgLoadBalancer->commitAll();
+		return $toFile; # return the saved file
+	}
+}
+
+function writeFile($filename, $data) {
+	$handle = fopen($filename, 'w');
+	if(!$handle) {
+		throw new Exception ("Couldn't open file $filename");
+	}
+	if(fwrite($handle, $data) === FALSE) {
+		throw new Exception ("Couldn't write file $filename");
+	}
+	if(fclose($handle) === FALSE) {
+		throw new Exception ("Couln't close file $filename");
+	}
+}
+
+function tag($name, $text, $attributes = array()) {
+	foreach(array_keys($attributes) as $key) {
+		if($value = $attributes[$key])$attr .= $key . '="' . $value . '" ';
+	}
+	return "<$name $attr>$text</$name>";
+}
+?>

Property changes on: trunk/wikipathways/wpi/wpi.php
___________________________________________________________________
Name: svn:executable
   + *

Index: trunk/wikipathways/wpi/includes/xmlrpc_wrappers.inc
===================================================================
--- trunk/wikipathways/wpi/includes/xmlrpc_wrappers.inc	(revision 0)
+++ trunk/wikipathways/wpi/includes/xmlrpc_wrappers.inc	(revision 1110)
@@ -0,0 +1,818 @@
+<?php
+/**
+ * PHP-XMLRPC "wrapper" functions
+ * Generate stubs to transparently access xmlrpc methods as php functions and viceversa
+ *
+ * @version $Id: xmlrpc_wrappers.inc,v 1.10 2006/09/01 21:49:19 ggiunta Exp $
+ * @copyright G. Giunta (C) 2006
+ * @author Gaetano Giunta
+ *
+ * @todo separate introspection from code generation for func-2-method wrapping
+ * @todo use some better templating system from code generation?
+ * @todo implement method wrapping with preservation of php objs in calls
+ * @todo when wrapping methods without obj rebuilding, use return_type = 'phpvals' (faster)
+ * @todo implement self-parsing of php code for PHP <= 4
+ */
+
+	// requires: xmlrpc.inc
+
+	/**
+	* Given a string defining a php type or phpxmlrpc type (loosely defined: strings
+	* accepted come from javadoc blocks), return corresponding phpxmlrpc type.
+	* NB: for php 'resource' types returns empty string, since resources cannot be serialized;
+	* for php class names returns 'struct', since php objects can be serialized as xmlrpc structs
+	* @param string $phptype
+	* @return string
+	*/
+	function php_2_xmlrpc_type($phptype)
+	{
+		switch(strtolower($phptype))
+		{
+			case 'string':
+				return $GLOBALS['xmlrpcString'];
+			case 'integer':
+			case $GLOBALS['xmlrpcInt']: // 'int'
+			case $GLOBALS['xmlrpcI4']:
+				return $GLOBALS['xmlrpcInt'];
+			case 'double':
+				return $GLOBALS['xmlrpcDouble'];
+			case 'boolean':
+				return $GLOBALS['xmlrpcBoolean'];
+			case 'array':
+				return $GLOBALS['xmlrpcArray'];
+			case 'object':
+				return $GLOBALS['xmlrpcStruct'];
+			case $GLOBALS['xmlrpcBase64']:
+			case $GLOBALS['xmlrpcStruct']:
+				return strtolower($phptype);
+			case 'resource':
+				return '';
+			default:
+				if(class_exists($phptype))
+				{
+					return $GLOBALS['xmlrpcStruct'];
+				}
+				else
+				{
+					// unknown: might be any 'extended' xmlrpc type
+					return $GLOBALS['xmlrpcValue'];
+				}
+		}
+	}
+
+	/**
+	* Given a string defining a phpxmlrpc type return corresponding php type.
+	* @param string $xmlrpctype
+	* @return string
+	*/
+	function xmlrpc_2_php_type($xmlrpctype)
+	{
+		switch(strtolower($xmlrpctype))
+		{
+			case 'base64':
+			case 'datetime.iso8601':
+			case 'string':
+				return $GLOBALS['xmlrpcString'];
+			case 'int':
+			case 'i4':
+				return 'integer';
+			case 'struct':
+			case 'array':
+				return 'array';
+			case 'double':
+				return 'float';
+			case 'undefined':
+				return 'mixed';
+			case 'boolean':
+			case 'null':
+			default:
+				// unknown: might be any xmlrpc type
+				return strtolower($xmlrpctype);
+		}
+	}
+
+	/**
+	* Given a user-defined PHP function, create a PHP 'wrapper' function that can
+	* be exposed as xmlrpc method from an xmlrpc_server object and called from remote
+	* clients (as well as its corresponding signature info).
+	*
+	* Since php is a typeless language, to infer types of input and output parameters,
+	* it relies on parsing the javadoc-style comment block associated with the given
+	* function. Usage of xmlrpc native types (such as datetime.dateTime.iso8601 and base64)
+	* in the @param tag is also allowed, if you need the php function to receive/send
+	* data in that particular format (note that base64 encoding/decoding is transparently
+	* carried out by the lib, while datetime vals are passed around as strings)
+	*
+	* Known limitations:
+	* - requires PHP 5.0.3 +
+	* - only works for user-defined functions, not for PHP internal functions
+	*   (reflection does not support retrieving number/type of params for those)
+	* - functions returning php objects will generate special xmlrpc responses:
+	*   when the xmlrpc decoding of those responses is carried out by this same lib, using
+	*   the appropriate param in php_xmlrpc_decode, the php objects will be rebuilt.
+	*   In short: php objects can be serialized, too (except for their resource members),
+	*   using this function.
+	*   Other libs might choke on the very same xml that will be generated in this case
+	*   (i.e. it has a nonstandard attribute on struct element tags)
+	* - usage of javadoc @param tags using param names in a different order from the
+	*   function prototype is not considered valid (to be fixed?)
+	*
+	* Note that since rel. 2.0RC3 the preferred method to have the server call 'standard'
+	* php functions (ie. functions not expecting a single xmlrpcmsg obj as parameter)
+	* is by making use of the functions_parameters_type class member.
+	*
+	* @param string $funcname the name of the PHP user function to be exposed as xmlrpc method; array($obj, 'methodname') might be ok too, in the future...
+	* @param string $newfuncname (optional) name for function to be created
+	* @param array $extra_options (optional) array of options for conversion. valid values include:
+	*        bool  return_source when true, php code w. function definition will be returned, not evaluated
+	*        bool  encode_php_objs let php objects be sent to server using the 'improved' xmlrpc notation, so server can deserialize them as php objects
+	*        bool  decode_php_objs --- WARNING !!! possible security hazard. only use it with trusted servers ---
+	*        bool  suppress_warnings  remove from produced xml any runtime warnings due to the php function being invoked
+	* @return false on error, or an array containing the name of the new php function,
+	*         its signature and docs, to be used in the server dispatch map
+	*
+	* @todo decide how to deal with params passed by ref: bomb out or allow?
+	* @todo finish using javadoc info to build method sig if all params are named but out of order
+	* @todo add a check for params of 'resource' type
+	* @todo add some trigger_errors / error_log when returning false?
+	* @todo what to do when the PHP function returns NULL? we are currently an empty string value...
+	* @todo add an option to suppress php warnings in invocation of user function, similar to server debug level 3?
+	*/
+	function wrap_php_function($funcname, $newfuncname='', $extra_options=array())
+	{
+		$buildit = isset($extra_options['return_source']) ? !($extra_options['return_source']) : true;
+		$prefix = isset($extra_options['prefix']) ? $extra_options['prefix'] : 'xmlrpc';
+		$encode_php_objects = isset($extra_options['encode_php_objs']) ? (bool)$extra_options['encode_php_objs'] : false;
+		$decode_php_objects = isset($extra_options['decode_php_objs']) ? (bool)$extra_options['decode_php_objs'] : false;
+		$catch_warnings = isset($extra_options['suppress_warnings']) && $extra_options['suppress_warnings'] ? '@' : '';
+
+		if(version_compare(phpversion(), '5.0.3') == -1)
+		{
+			// up to php 5.0.3 some useful reflection methods were missing
+			error_log('XML-RPC: cannot not wrap php functions unless running php version bigger than 5.0.3');
+			return false;
+		}
+		if((is_array($funcname) && !method_exists($funcname[0], $funcname[1])) || !function_exists($funcname))
+		{
+			error_log('XML-RPC: function to be wrapped is not defined: '.$funcname);
+			return false;
+		}
+		else
+		{
+			// determine name of new php function
+			if($newfuncname == '')
+			{
+				if(is_array($funcname))
+				{
+					$xmlrpcfuncname = "{$prefix}_".implode('_', $funcname);
+				}
+				else
+				{
+					$xmlrpcfuncname = "{$prefix}_$funcname";
+				}
+			}
+			else
+			{
+				$xmlrpcfuncname = $newfuncname;
+			}
+			while($buildit && function_exists($xmlrpcfuncname))
+			{
+				$xmlrpcfuncname .= 'x';
+			}
+
+			// start to introspect PHP code
+			$func =& new ReflectionFunction($funcname);
+			if($func->isInternal())
+			{
+				// Note: from PHP 5.1.0 onward, we will possibly be able to use invokeargs
+				// instead of getparameters to fully reflect internal php functions ?
+				error_log('XML-RPC: function to be wrapped is internal: '.$funcname);
+				return false;
+			}
+
+			// retrieve parameter names, types and description from javadoc comments
+
+			// function description
+			$desc = '';
+			// type of return val: by default 'any'
+			$returns = $GLOBALS['xmlrpcValue'];
+			// desc of return val
+			$returnsDocs = '';
+			// type + name of function parameters
+			$paramDocs = array();
+
+			$docs = $func->getDocComment();
+			if($docs != '')
+			{
+				$docs = explode("\n", $docs);
+				$i = 0;
+				foreach($docs as $doc)
+				{
+					$doc = trim($doc, " \r\t/*");
+					if(strlen($doc) && strpos($doc, '@') !== 0 && !$i)
+					{
+						if($desc)
+						{
+							$desc .= "\n";
+						}
+						$desc .= $doc;
+					}
+					elseif(strpos($doc, '@param') === 0)
+					{
+						// syntax: @param type [$name] desc
+						if(preg_match('/@param\s+(\S+)(\s+\$\S+)?\s+(.+)/', $doc, $matches))
+						{
+							if(strpos($matches[1], '|'))
+							{
+								//$paramDocs[$i]['type'] = explode('|', $matches[1]);
+								$paramDocs[$i]['type'] = 'mixed';
+							}
+							else
+							{
+								$paramDocs[$i]['type'] = $matches[1];
+							}
+							$paramDocs[$i]['name'] = trim($matches[2]);
+							$paramDocs[$i]['doc'] = $matches[3];
+						}
+						$i++;
+					}
+					elseif(strpos($doc, '@return') === 0)
+					{
+						// syntax: @return type desc
+						//$returns = preg_split('/\s+/', $doc);
+						if(preg_match('/@return\s+(\S+)\s+(.+)/', $doc, $matches))
+						{
+							$returns = php_2_xmlrpc_type($matches[1]);
+							if(isset($matches[2]))
+							{
+								$returnsDocs = $matches[2];
+							}
+						}
+					}
+				}
+			}
+
+			// execute introspection of actual function prototype
+			$params = array();
+			$i = 0;
+			foreach($func->getParameters() as $paramobj)
+			{
+				$params[$i] = array();
+				$params[$i]['name'] = '$'.$paramobj->getName();
+				$params[$i]['isoptional'] = $paramobj->isOptional();
+				$i++;
+			}
+
+
+			// start  building of PHP code to be eval'd
+			$innercode = '';
+			$i = 0;
+			$parsvariations = array();
+			$pars = array();
+			$pnum = count($params);
+			foreach($params as $param)
+			{
+				if (isset($paramDocs[$i]['name']) && $paramDocs[$i]['name'] && strtolower($paramDocs[$i]['name']) != strtolower($param['name']))
+				{
+					// param name from phpdoc info does not match param definition!
+					$paramDocs[$i]['type'] = 'mixed';
+				}
+
+				if($param['isoptional'])
+				{
+					// this particular parameter is optional. save as valid previous list of parameters
+					$innercode .= "if (\$paramcount > $i) {\n";
+					$parsvariations[] = $pars;
+				}
+				$innercode .= "\$p$i = \$msg->getParam($i);\n";
+				if ($decode_php_objects)
+				{
+					$innercode .= "if (\$p{$i}->kindOf() == 'scalar') \$p$i = \$p{$i}->scalarval(); else \$p$i = php_{$prefix}_decode(\$p$i, array('decode_php_objs'));\n";
+				}
+				else
+				{
+					$innercode .= "if (\$p{$i}->kindOf() == 'scalar') \$p$i = \$p{$i}->scalarval(); else \$p$i = php_{$prefix}_decode(\$p$i);\n";
+				}
+
+				$pars[] = "\$p$i";
+				$i++;
+				if($param['isoptional'])
+				{
+					$innercode .= "}\n";
+				}
+				if($i == $pnum)
+				{
+					// last allowed parameters combination
+					$parsvariations[] = $pars;
+				}
+			}
+
+			$sigs = array();
+			$psigs = array();
+			if(count($parsvariations) == 0)
+			{
+				// only known good synopsis = no parameters
+				$parsvariations[] = array();
+				$minpars = 0;
+			}
+			else
+			{
+				$minpars = count($parsvariations[0]);
+			}
+
+			if($minpars)
+			{
+				// add to code the check for min params number
+				// NB: this check needs to be done BEFORE decoding param values
+				$innercode = "\$paramcount = \$msg->getNumParams();\n" .
+				"if (\$paramcount < $minpars) return new {$prefix}resp(0, {$GLOBALS['xmlrpcerr']['incorrect_params']}, '{$GLOBALS['xmlrpcstr']['incorrect_params']}');\n" . $innercode;
+			}
+			else
+			{
+				$innercode = "\$paramcount = \$msg->getNumParams();\n" . $innercode;
+			}
+
+			$innercode .= "\$np = false;\n";
+			foreach($parsvariations as $pars)
+			{
+				$innercode .= "if (\$paramcount == " . count($pars) . ") \$retval = {$catch_warnings}$funcname(" . implode(',', $pars) . "); else\n";
+				// build a 'generic' signature (only use an appropriate return type)
+				$sig = array($returns);
+				$psig = array($returnsDocs);
+				for($i=0; $i < count($pars); $i++)
+				{
+					if (isset($paramDocs[$i]['type']))
+					{
+						$sig[] = php_2_xmlrpc_type($paramDocs[$i]['type']);
+					}
+					else
+					{
+						$sig[] = $GLOBALS['xmlrpcValue'];
+					}
+					$psig[] = isset($paramDocs[$i]['doc']) ? $paramDocs[$i]['doc'] : '';
+				}
+				$sigs[] = $sig;
+				$psigs[] = $psig;
+			}
+			$innercode .= "\$np = true;\n";
+			$innercode .= "if (\$np) return new {$prefix}resp(0, {$GLOBALS['xmlrpcerr']['incorrect_params']}, '{$GLOBALS['xmlrpcstr']['incorrect_params']}'); else {\n";
+			//$innercode .= "if (\$_xmlrpcs_error_occurred) return new xmlrpcresp(0, $GLOBALS['xmlrpcerr']user, \$_xmlrpcs_error_occurred); else\n";
+			$innercode .= "if (is_a(\$retval, '{$prefix}resp')) return \$retval; else\n";
+			if($returns == $GLOBALS['xmlrpcDateTime'] || $returns == $GLOBALS['xmlrpcBase64'])
+			{
+				$innercode .= "return new {$prefix}resp(new {$prefix}val(\$retval, '$returns'));";
+			}
+			else
+			{
+				if ($encode_php_objects)
+					$innercode .= "return new {$prefix}resp(php_{$prefix}_encode(\$retval, array('encode_php_objs')));\n";
+				else
+					$innercode .= "return new {$prefix}resp(php_{$prefix}_encode(\$retval));\n";
+			}
+			// shall we exclude functions returning by ref?
+			// if($func->returnsReference())
+			// 	return false;
+			$code = "function $xmlrpcfuncname(\$msg) {\n" . $innercode . "}\n}";
+			//print_r($code);
+			if ($buildit)
+			{
+				$allOK = 0;
+				eval($code.'$allOK=1;');
+				// alternative
+				//$xmlrpcfuncname = create_function('$m', $innercode);
+
+				if(!$allOK)
+				{
+					error_log('XML-RPC: could not create function '.$xmlrpcfuncname.' to wrap php function '.$funcname);
+					return false;
+				}
+			}
+
+			/// @todo examine if $paramDocs matches $parsvariations and build array for
+			/// usage as method signature, plus put together a nice string for docs
+
+			$ret = array('function' => $xmlrpcfuncname, 'signature' => $sigs, 'docstring' => $desc, 'signature_docs' => $psigs, 'source' => $code);
+			return $ret;
+		}
+	}
+
+	/**
+	* Given an xmlrpc client and a method name, register a php wrapper function
+	* that will call it and return results using native php types for both
+	* params and results. The generated php function will return an xmlrpcresp
+	* oject for failed xmlrpc calls
+	*
+	* Known limitations:
+	* - server must support system.methodsignature for the wanted xmlrpc method
+	* - for methods that expose many signatures, only one can be picked (we
+	*   could in priciple check if signatures differ only by number of params
+	*   and not by type, but it would be more complication than we can spare time)
+	* - nested xmlrpc params: the caller of the generated php function has to
+	*   encode on its own the params passed to the php function if these are structs
+	*   or arrays whose (sub)members include values of type datetime or base64
+	*
+	* Notes: the connection properties of the given client will be copied
+	* and reused for the connection used during the call to the generated
+	* php function.
+	* Calling the generated php function 'might' be slow: a new xmlrpc client
+	* is created on every invocation and an xmlrpc-connection opened+closed.
+	* An extra 'debug' param is appended to param list of xmlrpc method, useful
+	* for debugging purposes.
+	*
+	* @param xmlrpc_client $client     an xmlrpc client set up correctly to communicate with target server
+	* @param string        $methodname the xmlrpc method to be mapped to a php function
+	* @param array         $extra_options array of options that specify conversion details. valid ptions include
+	*        integer       signum      the index of the method signature to use in mapping (if method exposes many sigs)
+	*        integer       timeout     timeout (in secs) to be used when executing function/calling remote method
+	*        string        protocol    'http' (default), 'http11' or 'https'
+	*        string        new_function_name the name of php function to create. If unsepcified, lib will pick an appropriate name
+	*        string        return_source if true return php code w. function definition instead fo function name
+	*        bool          encode_php_objs let php objects be sent to server using the 'improved' xmlrpc notation, so server can deserialize them as php objects
+	*        bool          decode_php_objs --- WARNING !!! possible security hazard. only use it with trusted servers ---
+	*        mixed         return_on_fault a php value to be returned when the xmlrpc call fails/returns a fault response (by default the xmlrpcresp object is returned in this case). If a string is used, '%faultCode%' and '%faultString%' tokens will be substituted with actual error values
+	*        bool          debug        set it to 1 or 2 to see debug results of querying server for method synopsis
+	* @return string                   the name of the generated php function (or false) - OR AN ARRAY...
+	*/
+	function wrap_xmlrpc_method($client, $methodname, $extra_options=0, $timeout=0, $protocol='', $newfuncname='')
+	{
+		// mind numbing: let caller use sane calling convention (as per javadoc, 3 params),
+		// OR the 2.0 calling convention (no ptions) - we really love backward compat, don't we?
+		if (!is_array($extra_options))
+		{
+			$signum = $extra_options;
+			$extra_options = array();
+		}
+		else
+		{
+			$signum = isset($extra_options['signum']) ? (int)$extra_options['signum'] : 0;
+			$timeout = isset($extra_options['timeout']) ? (int)$extra_options['timeout'] : 0;
+			$protocol = isset($extra_options['protocol']) ? $extra_options['protocol'] : '';
+			$newfuncname = isset($extra_options['new_function_name']) ? $extra_options['new_function_name'] : '';
+		}
+		//$encode_php_objects = in_array('encode_php_objects', $extra_options);
+		//$verbatim_client_copy = in_array('simple_client_copy', $extra_options) ? 1 :
+		//	in_array('build_class_code', $extra_options) ? 2 : 0;
+
+		$encode_php_objects = isset($extra_options['encode_php_objs']) ? (bool)$extra_options['encode_php_objs'] : false;
+		$decode_php_objects = isset($extra_options['decode_php_objs']) ? (bool)$extra_options['decode_php_objs'] : false;
+		$simple_client_copy = isset($extra_options['simple_client_copy']) ? (int)($extra_options['simple_client_copy']) : 0;
+		$buildit = isset($extra_options['return_source']) ? !($extra_options['return_source']) : true;
+		$prefix = isset($extra_options['prefix']) ? $extra_options['prefix'] : 'xmlrpc';
+		if (isset($extra_options['return_on_fault']))
+		{
+			$decode_fault = true;
+			$fault_response = $extra_options['return_on_fault'];
+		}
+		else
+		{
+			$decode_fault = false;
+			$fault_response = '';
+		}
+		$debug = isset($extra_options['debug']) ? ($extra_options['debug']) : 0;
+
+		$msgclass = $prefix.'msg';
+		$valclass = $prefix.'val';
+		$decodefunc = 'php_'.$prefix.'_decode';
+
+		$msg =& new $msgclass('system.methodSignature');
+		$msg->addparam(new $valclass($methodname));
+		$client->setDebug($debug);
+		$response =& $client->send($msg, $timeout, $protocol);
+		if($response->faultCode())
+		{
+			error_log('XML-RPC: could not retrieve method signature from remote server for method '.$methodname);
+			return false;
+		}
+		else
+		{
+			$msig = $response->value();
+			if ($client->return_type != 'phpvals')
+			{
+				$msig = $decodefunc($msig);
+			}
+			if(!is_array($msig) || count($msig) <= $signum)
+			{
+				error_log('XML-RPC: could not retrieve method signature nr.'.$signum.' from remote server for method '.$methodname);
+				return false;
+			}
+			else
+			{
+				// pick a suitable name for the new function, avoiding collisions
+				if($newfuncname != '')
+				{
+					$xmlrpcfuncname = $newfuncname;
+				}
+				else
+				{
+					// take care to insure that methodname is translated to valid
+					// php function name
+					$xmlrpcfuncname = $prefix.'_'.preg_replace(array('/\./', '/[^a-zA-Z0-9_\x7f-\xff]/'),
+						array('_', ''), $methodname);
+				}
+				while($buildit && function_exists($xmlrpcfuncname))
+				{
+					$xmlrpcfuncname .= 'x';
+				}
+
+				$msig = $msig[$signum];
+				$mdesc = '';
+				// if in 'offline' mode, get method description too.
+				// in online mode, favour speed of operation
+				if(!$buildit)
+				{
+					$msg =& new $msgclass('system.methodHelp');
+					$msg->addparam(new $valclass($methodname));
+					$response =& $client->send($msg, $timeout, $protocol);
+					if (!$response->faultCode())
+					{
+						$mdesc = $response->value();
+						if ($client->return_type != 'phpvals')
+						{
+							$mdesc = $mdesc->scalarval();
+						}
+					}
+				}
+
+				$results = build_remote_method_wrapper_code($client, $methodname,
+					$xmlrpcfuncname, $msig, $mdesc, $timeout, $protocol, $simple_client_copy,
+					$prefix, $decode_php_objects, $encode_php_objects, $decode_fault,
+					$fault_response);
+
+				//print_r($code);
+				if ($buildit)
+				{
+					$allOK = 0;
+					eval($results['source'].'$allOK=1;');
+					// alternative
+					//$xmlrpcfuncname = create_function('$m', $innercode);
+					if($allOK)
+					{
+						return $xmlrpcfuncname;
+					}
+					else
+					{
+						error_log('XML-RPC: could not create function '.$xmlrpcfuncname.' to wrap remote method '.$methodname);
+						return false;
+					}
+				}
+				else
+				{
+					$results['function'] = $xmlrpcfuncname;
+					return $results;
+				}
+			}
+		}
+	}
+
+	/**
+	* Similar to wrap_xmlrpc_method, but will generate a php class that wraps
+	* all xmlrpc methods exposed by the remote server as own methods.
+	* For more details see wrap_xmlrpc_method.
+	* @param xmlrpc_client $client the client obj all set to query the desired server
+	* @param array $extra_options list of options for wrapped code
+	* @return mixed false on error, the name of the created class if all ok or an array with code, class name and comments (if the appropriatevoption is set in extra_options)
+	*/
+	function wrap_xmlrpc_server($client, $extra_options=array())
+	{
+		$methodfilter = isset($extra_options['method_filter']) ? $extra_options['method_filter'] : '';
+		$signum = isset($extra_options['signum']) ? (int)$extra_options['signum'] : 0;
+		$timeout = isset($extra_options['timeout']) ? (int)$extra_options['timeout'] : 0;
+		$protocol = isset($extra_options['protocol']) ? $extra_options['protocol'] : '';
+		$newclassname = isset($extra_options['new_class_name']) ? $extra_options['new_class_name'] : '';
+		$encode_php_objects = isset($extra_options['encode_php_objs']) ? (bool)$extra_options['encode_php_objs'] : false;
+		$decode_php_objects = isset($extra_options['decode_php_objs']) ? (bool)$extra_options['decode_php_objs'] : false;
+		$verbatim_client_copy = isset($extra_options['simple_client_copy']) ? !($extra_options['simple_client_copy']) : true;
+		$buildit = isset($extra_options['return_source']) ? !($extra_options['return_source']) : true;
+		$prefix = isset($extra_options['prefix']) ? $extra_options['prefix'] : 'xmlrpc';
+
+		$msgclass = $prefix.'msg';
+		//$valclass = $prefix.'val';
+		$decodefunc = 'php_'.$prefix.'_decode';
+
+		$msg =& new $msgclass('system.listMethods');
+		$response =& $client->send($msg, $timeout, $protocol);
+		if($response->faultCode())
+		{
+			error_log('XML-RPC: could not retrieve method list from remote server');
+			return false;
+		}
+		else
+		{
+			$mlist = $response->value();
+			if ($client->return_type != 'phpvals')
+			{
+				$mlist = $decodefunc($mlist);
+			}
+			if(!is_array($mlist) || !count($mlist))
+			{
+				error_log('XML-RPC: could not retrieve meaningful method list from remote server');
+				return false;
+			}
+			else
+			{
+				// pick a suitable name for the new function, avoiding collisions
+				if($newclassname != '')
+				{
+					$xmlrpcclassname = $newclassname;
+				}
+				else
+				{
+					$xmlrpcclassname = $prefix.'_'.preg_replace(array('/\./', '/[^a-zA-Z0-9_\x7f-\xff]/'),
+						array('_', ''), $client->server).'_client';
+				}
+				while($buildit && class_exists($xmlrpcclassname))
+				{
+					$xmlrpcclassname .= 'x';
+				}
+
+				/// @todo add function setdebug() to new class, to enable/disable debugging
+				$source = "class $xmlrpcclassname\n{\nvar \$client;\n\n";
+				$source .= "function $xmlrpcclassname()\n{\n";
+				$source .= build_client_wrapper_code($client, $verbatim_client_copy, $prefix);
+				$source .= "\$this->client =& \$client;\n}\n\n";
+				$opts = array('simple_client_copy' => 2, 'return_source' => true,
+					'timeout' => $timeout, 'protocol' => $protocol,
+					'encode_php_objs' => $encode_php_objects, 'prefix' => $prefix,
+					'decode_php_objs' => $decode_php_objects
+					);
+				/// @todo build javadoc for class definition, too
+				foreach($mlist as $mname)
+				{
+					if ($methodfilter == '' || preg_match($methodfilter, $mname))
+					{
+						$opts['new_function_name'] = preg_replace(array('/\./', '/[^a-zA-Z0-9_\x7f-\xff]/'),
+							array('_', ''), $mname);
+						$methodwrap = wrap_xmlrpc_method($client, $mname, $opts);
+						if ($methodwrap)
+						{
+							if (!$buildit)
+							{
+								$source .= $methodwrap['docstring'];
+							}
+							$source .= $methodwrap['source']."\n";
+						}
+						else
+						{
+							error_log('XML-RPC: will not create class method to wrap remote method '.$mname);
+						}
+					}
+				}
+				$source .= "}\n";
+				if ($buildit)
+				{
+					$allOK = 0;
+					eval($source.'$allOK=1;');
+					// alternative
+					//$xmlrpcfuncname = create_function('$m', $innercode);
+					if($allOK)
+					{
+						return $xmlrpcclassname;
+					}
+					else
+					{
+						error_log('XML-RPC: could not create class '.$xmlrpcclassname.' to wrap remote server '.$client->server);
+						return false;
+					}
+				}
+				else
+				{
+					return array('class' => $xmlrpcclassname, 'code' => $source, 'docstring' => '');
+				}
+			}
+		}
+	}
+
+	/**
+	* Given the necessary info, build php code that creates a new function to
+	* invoke a remote xmlrpc method.
+	* Take care that no full checking of input parameters is done to ensure that
+	* valid php code is emitted.
+	* Note: real spaghetti code follows...
+	* @access private
+	*/
+	function build_remote_method_wrapper_code($client, $methodname, $xmlrpcfuncname,
+		$msig, $mdesc='', $timeout=0, $protocol='', $client_copy_mode=0, $prefix='xmlrpc',
+		$decode_php_objects=false, $encode_php_objects=false, $decode_fault=false,
+		$fault_response='')
+	{
+		$code = "function $xmlrpcfuncname (";
+		if ($client_copy_mode < 2)
+		{
+			// client copy mode 0 or 1 == partial / full client copy in emitted code
+			$innercode = build_client_wrapper_code($client, $client_copy_mode, $prefix);
+			$innercode .= "\$client->setDebug(\$debug);\n";
+			$this_ = '';
+		}
+		else
+		{
+			// client copy mode 2 == no client copy in emitted code
+			$innercode = '';
+			$this_ = 'this->';
+		}
+		$innercode .= "\$msg =& new {$prefix}msg('$methodname');\n";
+
+		if ($mdesc != '')
+		{
+			// take care that PHP comment is not terminated unwillingly by method description
+			$mdesc = "/**\n* ".str_replace('*/', '* /', $mdesc)."\n";
+		}
+		else
+		{
+			$mdesc = "/**\nFunction $xmlrpcfuncname\n";
+		}
+
+		// param parsing
+		$plist = array();
+		$pcount = count($msig);
+		for($i = 1; $i < $pcount; $i++)
+		{
+			$plist[] = "\$p$i";
+			$ptype = $msig[$i];
+			if($ptype == 'i4' || $ptype == 'int' || $ptype == 'boolean' || $ptype == 'double' ||
+				$ptype == 'string' || $ptype == 'dateTime.iso8601' || $ptype == 'base64' || $ptype == 'null')
+			{
+				// only build directly xmlrpcvals when type is known and scalar
+				$innercode .= "\$p$i =& new {$prefix}val(\$p$i, '$ptype');\n";
+			}
+			else
+			{
+				if ($encode_php_objects)
+				{
+					$innercode .= "\$p$i =& php_{$prefix}_encode(\$p$i, array('encode_php_objs'));\n";
+				}
+				else
+				{
+					$innercode .= "\$p$i =& php_{$prefix}_encode(\$p$i);\n";
+				}
+			}
+			$innercode .= "\$msg->addparam(\$p$i);\n";
+			$mdesc .= '* @param '.xmlrpc_2_php_type($ptype)." \$p$i\n";
+		}
+		if ($client_copy_mode < 2)
+		{
+			$plist[] = '$debug=0';
+			$mdesc .= "* @param int \$debug when 1 (or 2) will enable debugging of the underlying {$prefix} call (defaults to 0)\n";
+		}
+		$plist = implode(', ', $plist);
+		$mdesc .= '* @return '.xmlrpc_2_php_type($msig[0])." (or an {$prefix}resp obj instance if call fails)\n*/\n";
+
+		$innercode .= "\$res =& \${$this_}client->send(\$msg, $timeout, '$protocol');\n";
+		if ($decode_fault)
+		{
+			if (is_string($fault_response) && ((strpos($fault_response, '%faultCode%') !== false) || (strpos($fault_response, '%faultString%') !== false)))
+			{
+				$respcode = "str_replace(array('%faultCode%', '%faultString%'), array(\$res->faultCode(), \$res->faultString()), '".str_replace("'", "''", $fault_response)."')";
+			}
+			else
+			{
+				$respcode = var_export($fault_response, true);
+			}
+		}
+		else
+		{
+			$respcode = '$res';
+		}
+		if ($decode_php_objects)
+		{
+			$innercode .= "if (\$res->faultcode()) return $respcode; else return php_{$prefix}_decode(\$res->value(), array('decode_php_objs'));";
+		}
+		else
+		{
+			$innercode .= "if (\$res->faultcode()) return $respcode; else return php_{$prefix}_decode(\$res->value());";
+		}
+
+		$code = $code . $plist. ") {\n" . $innercode . "\n}\n";
+
+		return array('source' => $code, 'docstring' => $mdesc);
+	}
+
+	/**
+	* Given necessary info, generate php code that will rebuild a client object
+	* Take care that no full checking of input parameters is done to ensure that
+	* valid php code is emitted.
+	* @access private
+	*/
+	function build_client_wrapper_code($client, $verbatim_client_copy, $prefix='xmlrpc')
+	{
+		$code = "\$client =& new {$prefix}_client('".str_replace("'", "\'", $client->path).
+			"', '" . str_replace("'", "\'", $client->server) . "', $client->port);\n";
+
+		// copy all client fields to the client that will be generated runtime
+		// (this provides for future expansion or subclassing of client obj)
+		if ($verbatim_client_copy)
+		{
+			foreach($client as $fld => $val)
+			{
+				if($fld != 'debug' && $fld != 'return_type')
+				{
+					$val = var_export($val, true);
+					$code .= "\$client->$fld = $val;\n";
+				}
+			}
+		}
+		// only make sure that client always returns the correct data type
+		$code .= "\$client->return_type = '{$prefix}vals';\n";
+		//$code .= "\$client->setDebug(\$debug);\n";
+		return $code;
+	}
+?>
\ No newline at end of file

Property changes on: trunk/wikipathways/wpi/includes/xmlrpc_wrappers.inc
___________________________________________________________________
Name: svn:executable
   + *

Index: trunk/wikipathways/wpi/includes/xmlrpcs.inc
===================================================================
--- trunk/wikipathways/wpi/includes/xmlrpcs.inc	(revision 0)
+++ trunk/wikipathways/wpi/includes/xmlrpcs.inc	(revision 1110)
@@ -0,0 +1,1172 @@
+<?php
+// by Edd Dumbill (C) 1999-2002
+// <edd@usefulinc.com>
+// $Id: xmlrpcs.inc,v 1.66 2006/09/17 21:25:06 ggiunta Exp $
+
+// Copyright (c) 1999,2000,2002 Edd Dumbill.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+//
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//
+//    * Redistributions in binary form must reproduce the above
+//      copyright notice, this list of conditions and the following
+//      disclaimer in the documentation and/or other materials provided
+//      with the distribution.
+//
+//    * Neither the name of the "XML-RPC for PHP" nor the names of its
+//      contributors may be used to endorse or promote products derived
+//      from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+// REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+// OF THE POSSIBILITY OF SUCH DAMAGE.
+
+	// XML RPC Server class
+	// requires: xmlrpc.inc
+
+	$GLOBALS['xmlrpcs_capabilities'] = array(
+		// xmlrpc spec: always supported
+		'xmlrpc' => new xmlrpcval(array(
+			'specUrl' => new xmlrpcval('http://www.xmlrpc.com/spec', 'string'),
+			'specVersion' => new xmlrpcval(1, 'int')
+		), 'struct'),
+		// if we support system.xxx functions, we always support multicall, too...
+		// Note that, as of 2006/09/17, the following URL does not respond anymore
+		'system.multicall' => new xmlrpcval(array(
+			'specUrl' => new xmlrpcval('http://www.xmlrpc.com/discuss/msgReader$1208', 'string'),
+			'specVersion' => new xmlrpcval(1, 'int')
+		), 'struct'),
+		// introspection: version 2! we support 'mixed', too
+		'introspection' => new xmlrpcval(array(
+			'specUrl' => new xmlrpcval('http://phpxmlrpc.sourceforge.net/doc-2/ch10.html', 'string'),
+			'specVersion' => new xmlrpcval(2, 'int')
+		), 'struct')
+	);
+
+	/* Functions that implement system.XXX methods of xmlrpc servers */
+	$_xmlrpcs_getCapabilities_sig=array(array($GLOBALS['xmlrpcStruct']));
+	$_xmlrpcs_getCapabilities_doc='This method lists all the capabilites that the XML-RPC server has: the (more or less standard) extensions to the xmlrpc spec that it adheres to';
+	$_xmlrpcs_getCapabilities_sdoc=array(array('list of capabilities, described as structs with a version number and url for the spec'));
+	function _xmlrpcs_getCapabilities($server, $m=null)
+	{
+		$outAr = $GLOBALS['xmlrpcs_capabilities'];
+		// NIL extension
+		if ($GLOBALS['xmlrpc_null_extension']) {
+			$outAr['nil'] = new xmlrpcval(array(
+				'specUrl' => new xmlrpcval('http://www.ontosys.com/xml-rpc/extensions.php', 'string'),
+				'specVersion' => new xmlrpcval(1, 'int')
+			), 'struct');
+		}
+		return new xmlrpcresp(new xmlrpcval($outAr, 'struct'));
+	}
+
+	// listMethods: signature was either a string, or nothing.
+	// The useless string variant has been removed
+	$_xmlrpcs_listMethods_sig=array(array($GLOBALS['xmlrpcArray']));
+	$_xmlrpcs_listMethods_doc='This method lists all the methods that the XML-RPC server knows how to dispatch';
+	$_xmlrpcs_listMethods_sdoc=array(array('list of method names'));
+	function _xmlrpcs_listMethods($server, $m=null) // if called in plain php values mode, second param is missing
+	{
+
+		$outAr=array();
+		foreach($server->dmap as $key => $val)
+		{
+			$outAr[]=&new xmlrpcval($key, 'string');
+		}
+		if($server->allow_system_funcs)
+		{
+			foreach($GLOBALS['_xmlrpcs_dmap'] as $key => $val)
+			{
+				$outAr[]=&new xmlrpcval($key, 'string');
+			}
+		}
+		return new xmlrpcresp(new xmlrpcval($outAr, 'array'));
+	}
+
+	$_xmlrpcs_methodSignature_sig=array(array($GLOBALS['xmlrpcArray'], $GLOBALS['xmlrpcString']));
+	$_xmlrpcs_methodSignature_doc='Returns an array of known signatures (an array of arrays) for the method name passed. If no signatures are known, returns a none-array (test for type != array to detect missing signature)';
+	$_xmlrpcs_methodSignature_sdoc=array(array('list of known signatures, each sig being an array of xmlrpc type names', 'name of method to be described'));
+	function _xmlrpcs_methodSignature($server, $m)
+	{
+		// let accept as parameter both an xmlrpcval or string
+		if (is_object($m))
+		{
+			$methName=$m->getParam(0);
+			$methName=$methName->scalarval();
+		}
+		else
+		{
+			$methName=$m;
+		}
+		if(strpos($methName, "system.") === 0)
+		{
+			$dmap=$GLOBALS['_xmlrpcs_dmap']; $sysCall=1;
+		}
+		else
+		{
+			$dmap=$server->dmap; $sysCall=0;
+		}
+		if(isset($dmap[$methName]))
+		{
+			if(isset($dmap[$methName]['signature']))
+			{
+				$sigs=array();
+				foreach($dmap[$methName]['signature'] as $inSig)
+				{
+					$cursig=array();
+					foreach($inSig as $sig)
+					{
+						$cursig[]=&new xmlrpcval($sig, 'string');
+					}
+					$sigs[]=&new xmlrpcval($cursig, 'array');
+				}
+				$r=&new xmlrpcresp(new xmlrpcval($sigs, 'array'));
+			}
+			else
+			{
+				// NB: according to the official docs, we should be returning a
+				// "none-array" here, which means not-an-array
+				$r=&new xmlrpcresp(new xmlrpcval('undef', 'string'));
+			}
+		}
+		else
+		{
+			$r=&new xmlrpcresp(0,$GLOBALS['xmlrpcerr']['introspect_unknown'], $GLOBALS['xmlrpcstr']['introspect_unknown']);
+		}
+		return $r;
+	}
+
+	$_xmlrpcs_methodHelp_sig=array(array($GLOBALS['xmlrpcString'], $GLOBALS['xmlrpcString']));
+	$_xmlrpcs_methodHelp_doc='Returns help text if defined for the method passed, otherwise returns an empty string';
+	$_xmlrpcs_methodHelp_sdoc=array(array('method description', 'name of the method to be described'));
+	function _xmlrpcs_methodHelp($server, $m)
+	{
+		// let accept as parameter both an xmlrpcval or string
+		if (is_object($m))
+		{
+			$methName=$m->getParam(0);
+			$methName=$methName->scalarval();
+		}
+		else
+		{
+			$methName=$m;
+		}
+		if(strpos($methName, "system.") === 0)
+		{
+			$dmap=$GLOBALS['_xmlrpcs_dmap']; $sysCall=1;
+		}
+		else
+		{
+			$dmap=$server->dmap; $sysCall=0;
+		}
+		if(isset($dmap[$methName]))
+		{
+			if(isset($dmap[$methName]['docstring']))
+			{
+				$r=&new xmlrpcresp(new xmlrpcval($dmap[$methName]['docstring']), 'string');
+			}
+			else
+			{
+				$r=&new xmlrpcresp(new xmlrpcval('', 'string'));
+			}
+		}
+		else
+		{
+			$r=&new xmlrpcresp(0, $GLOBALS['xmlrpcerr']['introspect_unknown'], $GLOBALS['xmlrpcstr']['introspect_unknown']);
+		}
+		return $r;
+	}
+
+	$_xmlrpcs_multicall_sig = array(array($GLOBALS['xmlrpcArray'], $GLOBALS['xmlrpcArray']));
+	$_xmlrpcs_multicall_doc = 'Boxcar multiple RPC calls in one request. See http://www.xmlrpc.com/discuss/msgReader$1208 for details';
+	$_xmlrpcs_multicall_sdoc = array(array('list of response structs, where each struct has the usual members', 'list of calls, with each call being represented as a struct, with members "methodname" and "params"'));
+	function _xmlrpcs_multicall_error($err)
+	{
+		if(is_string($err))
+		{
+			$str = $GLOBALS['xmlrpcstr']["multicall_${err}"];
+			$code = $GLOBALS['xmlrpcerr']["multicall_${err}"];
+		}
+		else
+		{
+			$code = $err->faultCode();
+			$str = $err->faultString();
+		}
+		$struct = array();
+		$struct['faultCode'] =& new xmlrpcval($code, 'int');
+		$struct['faultString'] =& new xmlrpcval($str, 'string');
+		return new xmlrpcval($struct, 'struct');
+	}
+
+	function _xmlrpcs_multicall_do_call($server, $call)
+	{
+		if($call->kindOf() != 'struct')
+		{
+			return _xmlrpcs_multicall_error('notstruct');
+		}
+		$methName = @$call->structmem('methodName');
+		if(!$methName)
+		{
+			return _xmlrpcs_multicall_error('nomethod');
+		}
+		if($methName->kindOf() != 'scalar' || $methName->scalartyp() != 'string')
+		{
+			return _xmlrpcs_multicall_error('notstring');
+		}
+		if($methName->scalarval() == 'system.multicall')
+		{
+			return _xmlrpcs_multicall_error('recursion');
+		}
+
+		$params = @$call->structmem('params');
+		if(!$params)
+		{
+			return _xmlrpcs_multicall_error('noparams');
+		}
+		if($params->kindOf() != 'array')
+		{
+			return _xmlrpcs_multicall_error('notarray');
+		}
+		$numParams = $params->arraysize();
+
+		$msg =& new xmlrpcmsg($methName->scalarval());
+		for($i = 0; $i < $numParams; $i++)
+		{
+			if(!$msg->addParam($params->arraymem($i)))
+			{
+				$i++;
+				return _xmlrpcs_multicall_error(new xmlrpcresp(0,
+					$GLOBALS['xmlrpcerr']['incorrect_params'],
+					$GLOBALS['xmlrpcstr']['incorrect_params'] . ": probable xml error in param " . $i));
+			}
+		}
+
+		$result = $server->execute($msg);
+
+		if($result->faultCode() != 0)
+		{
+			return _xmlrpcs_multicall_error($result);		// Method returned fault.
+		}
+
+		return new xmlrpcval(array($result->value()), 'array');
+	}
+
+	function _xmlrpcs_multicall_do_call_phpvals($server, $call)
+	{
+		if(!is_array($call))
+		{
+			return _xmlrpcs_multicall_error('notstruct');
+		}
+		if(!array_key_exists('methodName', $call))
+		{
+			return _xmlrpcs_multicall_error('nomethod');
+		}
+		if (!is_string($call['methodName']))
+		{
+			return _xmlrpcs_multicall_error('notstring');
+		}
+		if($call['methodName'] == 'system.multicall')
+		{
+			return _xmlrpcs_multicall_error('recursion');
+		}
+		if(!array_key_exists('params', $call))
+		{
+			return _xmlrpcs_multicall_error('noparams');
+		}
+		if(!is_array($call['params']))
+		{
+			return _xmlrpcs_multicall_error('notarray');
+		}
+
+		// this is a real dirty and simplistic hack, since we might have received a
+		// base64 or datetime values, but they will be listed as strings here...
+		$numParams = count($call['params']);
+		$pt = array();
+		foreach($call['params'] as $val)
+			$pt[] = php_2_xmlrpc_type(gettype($val));
+
+		$result = $server->execute($call['methodName'], $call['params'], $pt);
+
+		if($result->faultCode() != 0)
+		{
+			return _xmlrpcs_multicall_error($result);		// Method returned fault.
+		}
+
+		return new xmlrpcval(array($result->value()), 'array');
+	}
+
+	function _xmlrpcs_multicall($server, $m)
+	{
+		$result = array();
+		// let accept a plain list of php parameters, beside a single xmlrpc msg object
+		if (is_object($m))
+		{
+			$calls = $m->getParam(0);
+			$numCalls = $calls->arraysize();
+			for($i = 0; $i < $numCalls; $i++)
+			{
+				$call = $calls->arraymem($i);
+				$result[$i] = _xmlrpcs_multicall_do_call($server, $call);
+			}
+		}
+		else
+		{
+			$numCalls=count($m);
+			for($i = 0; $i < $numCalls; $i++)
+			{
+				$result[$i] = _xmlrpcs_multicall_do_call_phpvals($server, $m[$i]);
+			}
+		}
+
+		return new xmlrpcresp(new xmlrpcval($result, 'array'));
+	}
+
+	$GLOBALS['_xmlrpcs_dmap']=array(
+		'system.listMethods' => array(
+			'function' => '_xmlrpcs_listMethods',
+			'signature' => $_xmlrpcs_listMethods_sig,
+			'docstring' => $_xmlrpcs_listMethods_doc,
+			'signature_docs' => $_xmlrpcs_listMethods_sdoc),
+		'system.methodHelp' => array(
+			'function' => '_xmlrpcs_methodHelp',
+			'signature' => $_xmlrpcs_methodHelp_sig,
+			'docstring' => $_xmlrpcs_methodHelp_doc,
+			'signature_docs' => $_xmlrpcs_methodHelp_sdoc),
+		'system.methodSignature' => array(
+			'function' => '_xmlrpcs_methodSignature',
+			'signature' => $_xmlrpcs_methodSignature_sig,
+			'docstring' => $_xmlrpcs_methodSignature_doc,
+			'signature_docs' => $_xmlrpcs_methodSignature_sdoc),
+		'system.multicall' => array(
+			'function' => '_xmlrpcs_multicall',
+			'signature' => $_xmlrpcs_multicall_sig,
+			'docstring' => $_xmlrpcs_multicall_doc,
+			'signature_docs' => $_xmlrpcs_multicall_sdoc),
+		'system.getCapabilities' => array(
+			'function' => '_xmlrpcs_getCapabilities',
+			'signature' => $_xmlrpcs_getCapabilities_sig,
+			'docstring' => $_xmlrpcs_getCapabilities_doc,
+			'signature_docs' => $_xmlrpcs_getCapabilities_sdoc)
+	);
+
+	$GLOBALS['_xmlrpcs_occurred_errors'] = '';
+	$GLOBALS['_xmlrpcs_prev_ehandler'] = '';
+	/**
+	* Error handler used to track errors that occur during server-side execution of PHP code.
+	* This allows to report back to the client whether an internal error has occurred or not
+	* using an xmlrpc response object, instead of letting the client deal with the html junk
+	* that a PHP execution error on the server generally entails.
+	*
+	* NB: in fact a user defined error handler can only handle WARNING, NOTICE and USER_* errors.
+	*
+	*/
+	function _xmlrpcs_errorHandler($errcode, $errstring, $filename=null, $lineno=null, $context=null)
+	{
+		// obey the @ protocol
+		if (error_reporting() == 0)
+			return;
+
+		//if($errcode != E_NOTICE && $errcode != E_WARNING && $errcode != E_USER_NOTICE && $errcode != E_USER_WARNING)
+		if($errcode != 2048) // do not use E_STRICT by name, since on PHP 4 it will not be defined
+		{
+			$GLOBALS['_xmlrpcs_occurred_errors'] = $GLOBALS['_xmlrpcs_occurred_errors'] . $errstring . "\n";
+		}
+		// Try to avoid as much as possible disruption to the previous error handling
+		// mechanism in place
+		if($GLOBALS['_xmlrpcs_prev_ehandler'] == '')
+		{
+			// The previous error handler was the default: all we should do is log error
+			// to the default error log (if level high enough)
+			if(ini_get('log_errors') && (intval(ini_get('error_reporting')) & $errcode))
+			{
+				error_log($errstring);
+			}
+		}
+		else
+		{
+			// Pass control on to previous error handler, trying to avoid loops...
+			if($GLOBALS['_xmlrpcs_prev_ehandler'] != '_xmlrpcs_errorHandler')
+			{
+				// NB: this code will NOT work on php < 4.0.2: only 2 params were used for error handlers
+				if(is_array($GLOBALS['_xmlrpcs_prev_ehandler']))
+				{
+					$GLOBALS['_xmlrpcs_prev_ehandler'][0]->$GLOBALS['_xmlrpcs_prev_ehandler'][1]($errcode, $errstring, $filename, $lineno, $context);
+				}
+				else
+				{
+					$GLOBALS['_xmlrpcs_prev_ehandler']($errcode, $errstring, $filename, $lineno, $context);
+				}
+			}
+		}
+	}
+
+	$GLOBALS['_xmlrpc_debuginfo']='';
+
+	/**
+	* Add a string to the debug info that can be later seralized by the server
+	* as part of the response message.
+	* Note that for best compatbility, the debug string should be encoded using
+	* the $GLOBALS['xmlrpc_internalencoding'] character set.
+	* @param string $m
+	* @access public
+	*/
+	function xmlrpc_debugmsg($m)
+	{
+		$GLOBALS['_xmlrpc_debuginfo'] .= $m . "\n";
+	}
+
+	class xmlrpc_server
+	{
+		/// array defining php functions exposed as xmlrpc methods by this server
+		var $dmap=array();
+		/**
+		* Defines how functions in dmap will be invokde: either using an xmlrpc msg object
+		* or plain php values.
+		* valid strings are 'xmlrpcvals', 'phpvals' or 'epivals'
+		*/
+		var $functions_parameters_type='xmlrpcvals';
+		/// controls wether the server is going to echo debugging messages back to the client as comments in response body. valid values: 0,1,2,3
+		var $debug = 1;
+		/**
+		* When set to true, it will enable HTTP compression of the response, in case
+		* the client has declared its support for compression in the request.
+		*/
+		var $compress_response = false;
+		/**
+		* List of http compression methods accepted by the server for requests.
+		* NB: PHP supports deflate, gzip compressions out of the box if compiled w. zlib
+		*/
+		var $accepted_compression = array();
+		/// shall we serve calls to system.* methods?
+		var $allow_system_funcs = true;
+		/// list of charset encodings natively accepted for requests
+		var $accepted_charset_encodings = array();
+		/**
+		* charset encoding to be used for response.
+		* NB: if we can, we will convert the generated response from internal_encoding to the intended one.
+		* can be: a supported xml encoding (only UTF-8 and ISO-8859-1 at present, unless mbstring is enabled),
+		* null (leave unspecified in response, convert output stream to US_ASCII),
+		* 'default' (use xmlrpc library default as specified in xmlrpc.inc, convert output stream if needed),
+		* or 'auto' (use client-specified charset encoding or same as request if request headers do not specify it (unless request is US-ASCII: then use library default anyway).
+		* NB: pretty dangerous if you accept every charset and do not have mbstring enabled)
+		*/
+		var $response_charset_encoding = '';
+		/// storage for internal debug info
+		var $debug_info = '';
+		/// extra data passed at runtime to method handling functions. Used only by EPI layer
+		var $user_data = null;
+
+		/**
+		* @param array $dispmap the dispatch map withd efinition of exposed services
+		* @param boolean $servicenow set to false to prevent the server from runnung upon construction
+		*/
+		function xmlrpc_server($dispMap=null, $serviceNow=true)
+		{
+			// if ZLIB is enabled, let the server by default accept compressed requests,
+			// and compress responses sent to clients that support them
+			if(function_exists('gzinflate'))
+			{
+				$this->accepted_compression = array('gzip', 'deflate');
+				$this->compress_response = true;
+			}
+
+			// by default the xml parser can support these 3 charset encodings
+			$this->accepted_charset_encodings = array('UTF-8', 'ISO-8859-1', 'US-ASCII');
+
+			// dispMap is a dispatch array of methods
+			// mapped to function names and signatures
+			// if a method
+			// doesn't appear in the map then an unknown
+			// method error is generated
+			/* milosch - changed to make passing dispMap optional.
+			 * instead, you can use the class add_to_map() function
+			 * to add functions manually (borrowed from SOAPX4)
+			 */
+			if($dispMap)
+			{
+				$this->dmap = $dispMap;
+				if($serviceNow)
+				{
+					$this->service();
+				}
+			}
+		}
+
+		/**
+		* Set debug level of server.
+		* @param integer $in debug lvl: determines info added to xmlrpc responses (as xml comments)
+		* 0 = no debug info,
+		* 1 = msgs set from user with debugmsg(),
+		* 2 = add complete xmlrpc request (headers and body),
+		* 3 = add also all processing warnings happened during method processing
+		* (NB: this involves setting a custom error handler, and might interfere
+		* with the standard processing of the php function exposed as method. In
+		* particular, triggering an USER_ERROR level error will not halt script
+		* execution anymore, but just end up logged in the xmlrpc response)
+		* Note that info added at elevel 2 and 3 will be base64 encoded
+		* @access public
+		*/
+		function setDebug($in)
+		{
+			$this->debug=$in;
+		}
+
+		/**
+		* Return a string with the serialized representation of all debug info
+		* @param string $charset_encoding the target charset encoding for the serialization
+		* @return string an XML comment (or two)
+		*/
+		function serializeDebug($charset_encoding='')
+		{
+			// Tough encoding problem: which internal charset should we assume for debug info?
+			// It might contain a copy of raw data received from client, ie with unknown encoding,
+			// intermixed with php generated data and user generated data...
+			// so we split it: system debug is base 64 encoded,
+			// user debug info should be encoded by the end user using the INTERNAL_ENCODING
+			$out = '';
+			if ($this->debug_info != '')
+			{
+				$out .= "<!-- SERVER DEBUG INFO (BASE64 ENCODED):\n".base64_encode($this->debug_info)."\n-->\n";
+			}
+			if($GLOBALS['_xmlrpc_debuginfo']!='')
+			{
+
+				$out .= "<!-- DEBUG INFO:\n" . xmlrpc_encode_entitites(str_replace('--', '_-', $GLOBALS['_xmlrpc_debuginfo']), $GLOBALS['xmlrpc_internalencoding'], $charset_encoding) . "\n-->\n";
+				// NB: a better solution MIGHT be to use CDATA, but we need to insert it
+				// into return payload AFTER the beginning tag
+				//$out .= "<![CDATA[ DEBUG INFO:\n\n" . str_replace(']]>', ']_]_>', $GLOBALS['_xmlrpc_debuginfo']) . "\n]]>\n";
+			}
+			return $out;
+		}
+
+		/**
+		* Execute the xmlrpc request, printing the response
+		* @param string $data the request body. If null, the http POST request will be examined
+		* @return xmlrpcresp the response object (usually not used by caller...)
+		* @access public
+		*/
+		function service($data=null, $return_payload=false)
+		{
+			if ($data === null)
+			{
+				$data = isset($GLOBALS['HTTP_RAW_POST_DATA']) ? $GLOBALS['HTTP_RAW_POST_DATA'] : '';
+			}
+			$raw_data = $data;
+
+			// reset internal debug info
+			$this->debug_info = '';
+
+			// Echo back what we received, before parsing it
+			if($this->debug > 1)
+			{
+				$this->debugmsg("+++GOT+++\n" . $data . "\n+++END+++");
+			}
+
+			$r = $this->parseRequestHeaders($data, $req_charset, $resp_charset, $resp_encoding);
+			if (!$r)
+			{
+				$r=$this->parseRequest($data, $req_charset);
+			}
+
+			// save full body of request into response, for more debugging usages
+			$r->raw_data = $raw_data;
+
+			if($this->debug > 2 && $GLOBALS['_xmlrpcs_occurred_errors'])
+			{
+				$this->debugmsg("+++PROCESSING ERRORS AND WARNINGS+++\n" .
+					$GLOBALS['_xmlrpcs_occurred_errors'] . "+++END+++");
+			}
+
+			$payload=$this->xml_header($resp_charset);
+			if($this->debug > 0)
+			{
+				$payload = $payload . $this->serializeDebug($resp_charset);
+			}
+
+			// G. Giunta 2006-01-27: do not create response serialization if it has
+			// already happened. Helps building json magic
+			if (empty($r->payload))
+			{
+				$r->serialize($resp_charset);
+			}
+			$payload = $payload . $r->payload;
+
+			if ($return_payload)
+			{
+				return $payload;
+			}
+
+			// if we get a warning/error that has output some text before here, then we cannot
+			// add a new header. We cannot say we are sending xml, either...
+			if(!headers_sent())
+			{
+				header('Content-Type: '.$r->content_type);
+				// we do not know if client actually told us an accepted charset, but if he did
+				// we have to tell him what we did
+				header("Vary: Accept-Charset");
+
+				// http compression of output: only
+				// if we can do it, and we want to do it, and client asked us to,
+				// and php ini settings do not force it already
+				$php_no_self_compress = ini_get('zlib.output_compression') == '' && (ini_get('output_handler') != 'ob_gzhandler');
+				if($this->compress_response && function_exists('gzencode') && $resp_encoding != ''
+					&& $php_no_self_compress)
+				{
+					if(strpos($resp_encoding, 'gzip') !== false)
+					{
+						$payload = gzencode($payload);
+						header("Content-Encoding: gzip");
+						header("Vary: Accept-Encoding");
+					}
+					elseif (strpos($resp_encoding, 'deflate') !== false)
+					{
+						$payload = gzcompress($payload);
+						header("Content-Encoding: deflate");
+						header("Vary: Accept-Encoding");
+					}
+				}
+
+				// do not ouput content-length header if php is compressing output for us:
+				// it will mess up measurements
+				if($php_no_self_compress)
+				{
+					header('Content-Length: ' . (int)strlen($payload));
+				}
+			}
+			else
+			{
+				error_log('XML-RPC: xmlrpc_server::service: http headers already sent before response is fully generated. Check for php warning or error messages');
+			}
+
+			print $payload;
+
+			// return request, in case subclasses want it
+			return $r;
+		}
+
+		/**
+		* Add a method to the dispatch map
+		* @param string $methodname the name with which the method will be made available
+		* @param string $function the php function that will get invoked
+		* @param array $sig the array of valid method signatures
+		* @param string $doc method documentation
+		* @access public
+		*/
+		function add_to_map($methodname,$function,$sig=null,$doc='')
+		{
+			$this->dmap[$methodname] = array(
+				'function'	=> $function,
+				'docstring' => $doc
+			);
+			if ($sig)
+			{
+				$this->dmap[$methodname]['signature'] = $sig;
+			}
+		}
+
+		/**
+		* Verify type and number of parameters received against a list of known signatures
+		* @param array $in array of either xmlrpcval objects or xmlrpc type definitions
+		* @param array $sig array of known signatures to match against
+		* @access private
+		*/
+		function verifySignature($in, $sig)
+		{
+			// check each possible signature in turn
+			if (is_object($in))
+			{
+				$numParams = $in->getNumParams();
+			}
+			else
+			{
+				$numParams = count($in);
+			}
+			foreach($sig as $cursig)
+			{
+				if(count($cursig)==$numParams+1)
+				{
+					$itsOK=1;
+					for($n=0; $n<$numParams; $n++)
+					{
+						if (is_object($in))
+						{
+							$p=$in->getParam($n);
+							if($p->kindOf() == 'scalar')
+							{
+								$pt=$p->scalartyp();
+							}
+							else
+							{
+								$pt=$p->kindOf();
+							}
+						}
+						else
+						{
+							$pt= $in[$n] == 'i4' ? 'int' : $in[$n]; // dispatch maps never use i4...
+						}
+
+						// param index is $n+1, as first member of sig is return type
+						if($pt != $cursig[$n+1] && $cursig[$n+1] != $GLOBALS['xmlrpcValue'])
+						{
+							$itsOK=0;
+							$pno=$n+1;
+							$wanted=$cursig[$n+1];
+							$got=$pt;
+							break;
+						}
+					}
+					if($itsOK)
+					{
+						return array(1,'');
+					}
+				}
+			}
+			if(isset($wanted))
+			{
+				return array(0, "Wanted ${wanted}, got ${got} at param ${pno}");
+			}
+			else
+			{
+				return array(0, "No method signature matches number of parameters");
+			}
+		}
+
+		/**
+		* Parse http headers received along with xmlrpc request. If needed, inflate request
+		* @return null on success or an xmlrpcresp
+		* @access private
+		*/
+		function parseRequestHeaders(&$data, &$req_encoding, &$resp_encoding, &$resp_compression)
+		{
+			// Play nice to PHP 4.0.x: superglobals were not yet invented...
+			if(!isset($_SERVER))
+			{
+				$_SERVER = $GLOBALS['HTTP_SERVER_VARS'];
+			}
+
+			if($this->debug > 1)
+			{
+				if(function_exists('getallheaders'))
+				{
+					$this->debugmsg(''); // empty line
+					foreach(getallheaders() as $name => $val)
+					{
+						$this->debugmsg("HEADER: $name: $val");
+					}
+				}
+
+			}
+
+			if(isset($_SERVER['HTTP_CONTENT_ENCODING']))
+			{
+				$content_encoding = str_replace('x-', '', $_SERVER['HTTP_CONTENT_ENCODING']);
+			}
+			else
+			{
+				$content_encoding = '';
+			}
+
+			// check if request body has been compressed and decompress it
+			if($content_encoding != '' && strlen($data))
+			{
+				if($content_encoding == 'deflate' || $content_encoding == 'gzip')
+				{
+					// if decoding works, use it. else assume data wasn't gzencoded
+					if(function_exists('gzinflate') && in_array($content_encoding, $this->accepted_compression))
+					{
+						if($content_encoding == 'deflate' && $degzdata = @gzuncompress($data))
+						{
+							$data = $degzdata;
+							if($this->debug > 1)
+							{
+								$this->debugmsg("\n+++INFLATED REQUEST+++[".strlen($data)." chars]+++\n" . $data . "\n+++END+++");
+							}
+						}
+						elseif($content_encoding == 'gzip' && $degzdata = @gzinflate(substr($data, 10)))
+						{
+							$data = $degzdata;
+							if($this->debug > 1)
+								$this->debugmsg("+++INFLATED REQUEST+++[".strlen($data)." chars]+++\n" . $data . "\n+++END+++");
+						}
+						else
+						{
+							$r =& new xmlrpcresp(0, $GLOBALS['xmlrpcerr']['server_decompress_fail'], $GLOBALS['xmlrpcstr']['server_decompress_fail']);
+							return $r;
+						}
+					}
+					else
+					{
+						//error_log('The server sent deflated data. Your php install must have the Zlib extension compiled in to support this.');
+						$r =& new xmlrpcresp(0, $GLOBALS['xmlrpcerr']['server_cannot_decompress'], $GLOBALS['xmlrpcstr']['server_cannot_decompress']);
+						return $r;
+					}
+				}
+			}
+
+			// check if client specified accepted charsets, and if we know how to fulfill
+			// the request
+			if ($this->response_charset_encoding == 'auto')
+			{
+				$resp_encoding = '';
+				if (isset($_SERVER['HTTP_ACCEPT_CHARSET']))
+				{
+					// here we should check if we can match the client-requested encoding
+					// with the encodings we know we can generate.
+					/// @todo we should parse q=0.x preferences instead of getting first charset specified...
+					$client_accepted_charsets = explode(',', strtoupper($_SERVER['HTTP_ACCEPT_CHARSET']));
+					// Give preference to internal encoding
+					$known_charsets = array($this->internal_encoding, 'UTF-8', 'ISO-8859-1', 'US-ASCII');
+					foreach ($known_charsets as $charset)
+					{
+						foreach ($client_accepted_charsets as $accepted)
+							if (strpos($accepted, $charset) === 0)
+							{
+								$resp_encoding = $charset;
+								break;
+							}
+						if ($resp_encoding)
+							break;
+					}
+				}
+			}
+			else
+			{
+				$resp_encoding = $this->response_charset_encoding;
+			}
+
+			if (isset($_SERVER['HTTP_ACCEPT_ENCODING']))
+			{
+				$resp_compression = $_SERVER['HTTP_ACCEPT_ENCODING'];
+			}
+			else
+			{
+				$resp_compression = '';
+			}
+
+			// 'guestimate' request encoding
+			/// @todo check if mbstring is enabled and automagic input conversion is on: it might mingle with this check???
+			$req_encoding = guess_encoding(isset($_SERVER['CONTENT_TYPE']) ? $_SERVER['CONTENT_TYPE'] : '',
+				$data);
+
+			return null;
+		}
+
+		/**
+		* Parse an xml chunk containing an xmlrpc request and execute the corresponding
+		* php function registered with the server
+		* @param string $data the xml request
+		* @param string $req_encoding (optional) the charset encoding of the xml request
+		* @return xmlrpcresp
+		* @access private
+		*/
+		function parseRequest($data, $req_encoding='')
+		{
+			// 2005/05/07 commented and moved into caller function code
+			//if($data=='')
+			//{
+			//	$data=$GLOBALS['HTTP_RAW_POST_DATA'];
+			//}
+
+			// G. Giunta 2005/02/13: we do NOT expect to receive html entities
+			// so we do not try to convert them into xml character entities
+			//$data = xmlrpc_html_entity_xlate($data);
+
+			$GLOBALS['_xh']=array();
+			$GLOBALS['_xh']['ac']='';
+			$GLOBALS['_xh']['stack']=array();
+			$GLOBALS['_xh']['valuestack'] = array();
+			$GLOBALS['_xh']['params']=array();
+			$GLOBALS['_xh']['pt']=array();
+			$GLOBALS['_xh']['isf']=0;
+			$GLOBALS['_xh']['isf_reason']='';
+			$GLOBALS['_xh']['method']=false; // so we can check later if we got a methodname or not
+			$GLOBALS['_xh']['rt']='';
+
+			// decompose incoming XML into request structure
+			if ($req_encoding != '')
+			{
+				if (!in_array($req_encoding, array('UTF-8', 'ISO-8859-1', 'US-ASCII')))
+				// the following code might be better for mb_string enabled installs, but
+				// makes the lib about 200% slower...
+				//if (!is_valid_charset($req_encoding, array('UTF-8', 'ISO-8859-1', 'US-ASCII')))
+				{
+					error_log('XML-RPC: xmlrpc_server::parseRequest: invalid charset encoding of received request: '.$req_encoding);
+					$req_encoding = $GLOBALS['xmlrpc_defencoding'];
+				}
+				/// @BUG this will fail on PHP 5 if charset is not specified in the xml prologue,
+				// the encoding is not UTF8 and there are non-ascii chars in the text...
+				$parser = xml_parser_create($req_encoding);
+			}
+			else
+			{
+				$parser = xml_parser_create();
+			}
+
+			xml_parser_set_option($parser, XML_OPTION_CASE_FOLDING, true);
+			// G. Giunta 2005/02/13: PHP internally uses ISO-8859-1, so we have to tell
+			// the xml parser to give us back data in the expected charset
+			xml_parser_set_option($parser, XML_OPTION_TARGET_ENCODING, $GLOBALS['xmlrpc_internalencoding']);
+
+			if ($this->functions_parameters_type != 'xmlrpcvals')
+				xml_set_element_handler($parser, 'xmlrpc_se', 'xmlrpc_ee_fast');
+			else
+				xml_set_element_handler($parser, 'xmlrpc_se', 'xmlrpc_ee');
+			xml_set_character_data_handler($parser, 'xmlrpc_cd');
+			xml_set_default_handler($parser, 'xmlrpc_dh');
+			if(!xml_parse($parser, $data, 1))
+			{
+				// return XML error as a faultCode
+				$r=&new xmlrpcresp(0,
+				$GLOBALS['xmlrpcerrxml']+xml_get_error_code($parser),
+				sprintf('XML error: %s at line %d, column %d',
+					xml_error_string(xml_get_error_code($parser)),
+					xml_get_current_line_number($parser), xml_get_current_column_number($parser)));
+				xml_parser_free($parser);
+			}
+			elseif ($GLOBALS['_xh']['isf'])
+			{
+				xml_parser_free($parser);
+				$r=&new xmlrpcresp(0,
+					$GLOBALS['xmlrpcerr']['invalid_request'],
+					$GLOBALS['xmlrpcstr']['invalid_request'] . ' ' . $GLOBALS['_xh']['isf_reason']);
+			}
+			else
+			{
+				xml_parser_free($parser);
+				if ($this->functions_parameters_type != 'xmlrpcvals')
+				{
+					if($this->debug > 1)
+					{
+						$this->debugmsg("\n+++PARSED+++\n".var_export($GLOBALS['_xh']['params'], true)."\n+++END+++");
+					}
+					$r = $this->execute($GLOBALS['_xh']['method'], $GLOBALS['_xh']['params'], $GLOBALS['_xh']['pt']);
+				}
+				else
+				{
+					// build an xmlrpcmsg object with data parsed from xml
+					$m=&new xmlrpcmsg($GLOBALS['_xh']['method']);
+					// now add parameters in
+					for($i=0; $i<count($GLOBALS['_xh']['params']); $i++)
+					{
+						$m->addParam($GLOBALS['_xh']['params'][$i]);
+					}
+
+					if($this->debug > 1)
+					{
+						$this->debugmsg("\n+++PARSED+++\n".var_export($m, true)."\n+++END+++");
+					}
+
+					$r = $this->execute($m);
+				}
+			}
+			return $r;
+		}
+
+		/**
+		* Execute a method invoked by the client, checking parameters used
+		* @param mixed $m either an xmlrpcmsg obj or a method name
+		* @param array $params array with method parameters as php types (if m is method name only)
+		* @param array $paramtypes array with xmlrpc types of method parameters (if m is method name only)
+		* @return xmlrpcresp
+		* @access private
+		*/
+		function execute($m, $params=null, $paramtypes=null)
+		{
+			if (is_object($m))
+			{
+				$methName = $m->method();
+			}
+			else
+			{
+				$methName = $m;
+			}
+			$sysCall = $this->allow_system_funcs && (strpos($methName, "system.") === 0);
+			$dmap = $sysCall ? $GLOBALS['_xmlrpcs_dmap'] : $this->dmap;
+
+			if(!isset($dmap[$methName]['function']))
+			{
+				// No such method
+				return new xmlrpcresp(0,
+					$GLOBALS['xmlrpcerr']['unknown_method'],
+					$GLOBALS['xmlrpcstr']['unknown_method']);
+			}
+
+			// Check signature
+			if(isset($dmap[$methName]['signature']))
+			{
+				$sig = $dmap[$methName]['signature'];
+				if (is_object($m))
+				{
+					list($ok, $errstr) = $this->verifySignature($m, $sig);
+				}
+				else
+				{
+					list($ok, $errstr) = $this->verifySignature($paramtypes, $sig);
+				}
+				if(!$ok)
+				{
+					// Didn't match.
+					return new xmlrpcresp(
+						0,
+						$GLOBALS['xmlrpcerr']['incorrect_params'],
+						$GLOBALS['xmlrpcstr']['incorrect_params'] . ": ${errstr}"
+					);
+				}
+			}
+
+			$func = $dmap[$methName]['function'];
+			// let the 'class::function' syntax be accepted in dispatch maps
+			if(is_string($func) && strpos($func, '::'))
+			{
+				$func = explode('::', $func);
+			}
+			// verify that function to be invoked is in fact callable
+			if(!is_callable($func))
+			{
+				error_log("XML-RPC: xmlrpc_server::execute: function $func registered as method handler is not callable");
+				return new xmlrpcresp(
+					0,
+					$GLOBALS['xmlrpcerr']['server_error'],
+					$GLOBALS['xmlrpcstr']['server_error'] . ": no function matches method"
+				);
+			}
+
+			// If debug level is 3, we should catch all errors generated during
+			// processing of user function, and log them as part of response
+			if($this->debug > 2)
+			{
+				$GLOBALS['_xmlrpcs_prev_ehandler'] = set_error_handler('_xmlrpcs_errorHandler');
+			}
+			if (is_object($m))
+			{
+				if($sysCall)
+				{
+					$r = call_user_func($func, $this, $m);
+				}
+				else
+				{
+					$r = call_user_func($func, $m);
+				}
+				if (!is_a($r, 'xmlrpcresp'))
+				{
+					error_log("XML-RPC: xmlrpc_server::execute: function $func registered as method handler does not return an xmlrpcresp object");
+					if (is_a($r, 'xmlrpcval'))
+					{
+						$r =& new xmlrpcresp($r);
+					}
+					else
+					{
+						$r =& new xmlrpcresp(
+							0,
+							$GLOBALS['xmlrpcerr']['server_error'],
+							$GLOBALS['xmlrpcstr']['server_error'] . ": function does not return xmlrpcresp object"
+						);
+					}
+				}
+			}
+			else
+			{
+				// call a 'plain php' function
+				if($sysCall)
+				{
+					array_unshift($params, $this);
+					$r = call_user_func_array($func, $params);
+				}
+				else
+				{
+					// 3rd API convention for method-handling functions: EPI-style
+					if ($this->functions_parameters_type == 'epivals')
+					{
+						$r = call_user_func_array($func, array($methName, $params, $this->user_data));
+						// mimic EPI behaviour: if we get an array that looks like an error, make it
+						// an eror response
+						if (is_array($r) && array_key_exists('faultCode', $r) && array_key_exists('faultString', $r))
+						{
+							$r =& new xmlrpcresp(0, (integer)$r['faultCode'], (string)$r['faultString']);
+						}
+						else
+						{
+							// functions using EPI api should NOT return resp objects,
+							// so make sure we encode the return type correctly
+							$r =& new xmlrpcresp(php_xmlrpc_encode($r, array('extension_api')));
+						}
+					}
+					else
+					{
+						$r = call_user_func_array($func, $params);
+					}
+				}
+				// the return type can be either an xmlrpcresp object or a plain php value...
+				if (!is_a($r, 'xmlrpcresp'))
+				{
+					// what should we assume here about automatic encoding of datetimes
+					// and php classes instances???
+					$r =& new xmlrpcresp(php_xmlrpc_encode($r, array('auto_dates')));
+				}
+			}
+			if($this->debug > 2)
+			{
+				// note: restore the error handler we found before calling the
+				// user func, even if it has been changed inside the func itself
+				if($GLOBALS['_xmlrpcs_prev_ehandler'])
+				{
+					set_error_handler($GLOBALS['_xmlrpcs_prev_ehandler']);
+				}
+				else
+				{
+					restore_error_handler();
+				}
+			}
+			return $r;
+		}
+
+		/**
+		* add a string to the 'internal debug message' (separate from 'user debug message')
+		* @param string $strings
+		* @access private
+		*/
+		function debugmsg($string)
+		{
+			$this->debug_info .= $string."\n";
+		}
+
+		/**
+		* @access private
+		*/
+		function xml_header($charset_encoding='')
+		{
+			if ($charset_encoding != '')
+			{
+				return "<?xml version=\"1.0\" encoding=\"$charset_encoding\"?" . ">\n";
+			}
+			else
+			{
+				return "<?xml version=\"1.0\"?" . ">\n";
+			}
+		}
+
+		/**
+		* A debugging routine: just echoes back the input packet as a string value
+		* DEPRECATED!
+		*/
+		function echoInput()
+		{
+			$r=&new xmlrpcresp(new xmlrpcval( "'Aha said I: '" . $GLOBALS['HTTP_RAW_POST_DATA'], 'string'));
+			print $r->serialize();
+		}
+	}
+?>
\ No newline at end of file

Property changes on: trunk/wikipathways/wpi/includes/xmlrpcs.inc
___________________________________________________________________
Name: svn:executable
   + *

Index: trunk/wikipathways/wpi/includes/xmlrpc.inc
===================================================================
--- trunk/wikipathways/wpi/includes/xmlrpc.inc	(revision 0)
+++ trunk/wikipathways/wpi/includes/xmlrpc.inc	(revision 1110)
@@ -0,0 +1,3640 @@
+<?php
+// by Edd Dumbill (C) 1999-2002
+// <edd@usefulinc.com>
+// $Id: xmlrpc.inc,v 1.157 2007/02/04 23:12:56 ggiunta Exp $
+
+// Copyright (c) 1999,2000,2002 Edd Dumbill.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+//
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//
+//    * Redistributions in binary form must reproduce the above
+//      copyright notice, this list of conditions and the following
+//      disclaimer in the documentation and/or other materials provided
+//      with the distribution.
+//
+//    * Neither the name of the "XML-RPC for PHP" nor the names of its
+//      contributors may be used to endorse or promote products derived
+//      from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+// REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+// OF THE POSSIBILITY OF SUCH DAMAGE.
+
+	if(!function_exists('xml_parser_create'))
+	{
+		// For PHP 4 onward, XML functionality is always compiled-in on windows:
+		// no more need to dl-open it. It might have been compiled out on *nix...
+		if(strtoupper(substr(PHP_OS, 0, 3) != 'WIN'))
+		{
+			dl('xml.so');
+		}
+	}
+
+	// Try to be backward compat with php < 4.2 (are we not being nice ?)
+	$phpversion = phpversion();
+	if($phpversion[0] == '4' && $phpversion[2] < 2)
+	{
+		// give an opportunity to user to specify where to include other files from
+		if(!defined('PHP_XMLRPC_COMPAT_DIR'))
+		{
+			define('PHP_XMLRPC_COMPAT_DIR',dirname(__FILE__).'/compat/');
+		}
+		if($phpversion[2] == '0')
+		{
+			if($phpversion[4] < 6)
+			{
+				include(PHP_XMLRPC_COMPAT_DIR.'is_callable.php');
+			}
+			include(PHP_XMLRPC_COMPAT_DIR.'is_scalar.php');
+			include(PHP_XMLRPC_COMPAT_DIR.'array_key_exists.php');
+			include(PHP_XMLRPC_COMPAT_DIR.'version_compare.php');
+		}
+		include(PHP_XMLRPC_COMPAT_DIR.'var_export.php');
+		include(PHP_XMLRPC_COMPAT_DIR.'is_a.php');
+	}
+
+	// G. Giunta 2005/01/29: declare global these variables,
+	// so that xmlrpc.inc will work even if included from within a function
+	// Milosch: 2005/08/07 - explicitly request these via $GLOBALS where used.
+	$GLOBALS['xmlrpcI4']='i4';
+	$GLOBALS['xmlrpcInt']='int';
+	$GLOBALS['xmlrpcBoolean']='boolean';
+	$GLOBALS['xmlrpcDouble']='double';
+	$GLOBALS['xmlrpcString']='string';
+	$GLOBALS['xmlrpcDateTime']='dateTime.iso8601';
+	$GLOBALS['xmlrpcBase64']='base64';
+	$GLOBALS['xmlrpcArray']='array';
+	$GLOBALS['xmlrpcStruct']='struct';
+	$GLOBALS['xmlrpcValue']='undefined';
+
+	$GLOBALS['xmlrpcTypes']=array(
+		$GLOBALS['xmlrpcI4']       => 1,
+		$GLOBALS['xmlrpcInt']      => 1,
+		$GLOBALS['xmlrpcBoolean']  => 1,
+		$GLOBALS['xmlrpcString']   => 1,
+		$GLOBALS['xmlrpcDouble']   => 1,
+		$GLOBALS['xmlrpcDateTime'] => 1,
+		$GLOBALS['xmlrpcBase64']   => 1,
+		$GLOBALS['xmlrpcArray']    => 2,
+		$GLOBALS['xmlrpcStruct']   => 3
+	);
+
+	$GLOBALS['xmlrpc_valid_parents'] = array(
+		'VALUE' => array('MEMBER', 'DATA', 'PARAM', 'FAULT'),
+		'BOOLEAN' => array('VALUE'),
+		'I4' => array('VALUE'),
+		'INT' => array('VALUE'),
+		'STRING' => array('VALUE'),
+		'DOUBLE' => array('VALUE'),
+		'DATETIME.ISO8601' => array('VALUE'),
+		'BASE64' => array('VALUE'),
+		'MEMBER' => array('STRUCT'),
+		'NAME' => array('MEMBER'),
+		'DATA' => array('ARRAY'),
+		'ARRAY' => array('VALUE'),
+		'STRUCT' => array('VALUE'),
+		'PARAM' => array('PARAMS'),
+		'METHODNAME' => array('METHODCALL'),
+		'PARAMS' => array('METHODCALL', 'METHODRESPONSE'),
+		'FAULT' => array('METHODRESPONSE'),
+		'NIL' => array('VALUE') // only used when extension activated
+	);
+
+	// define extra types for supporting NULL (useful for json or <NIL/>)
+	$GLOBALS['xmlrpcNull']='null';
+	$GLOBALS['xmlrpcTypes']['null']=1;
+
+	// Not in use anymore since 2.0. Shall we remove it?
+	/// @deprecated
+	$GLOBALS['xmlEntities']=array(
+		'amp'  => '&',
+		'quot' => '"',
+		'lt'   => '<',
+		'gt'   => '>',
+		'apos' => "'"
+	);
+
+	// tables used for transcoding different charsets into us-ascii xml
+
+	$GLOBALS['xml_iso88591_Entities']=array();
+	$GLOBALS['xml_iso88591_Entities']['in'] = array();
+	$GLOBALS['xml_iso88591_Entities']['out'] = array();
+	for ($i = 0; $i < 32; $i++)
+	{
+		$GLOBALS['xml_iso88591_Entities']['in'][] = chr($i);
+		$GLOBALS['xml_iso88591_Entities']['out'][] = '&#'.$i.';';
+	}
+	for ($i = 160; $i < 256; $i++)
+	{
+		$GLOBALS['xml_iso88591_Entities']['in'][] = chr($i);
+		$GLOBALS['xml_iso88591_Entities']['out'][] = '&#'.$i.';';
+	}
+
+	/// @todo add to iso table the characters from cp_1252 range, i.e. 128 to 159.
+	/// These will NOT be present in true ISO-8859-1, but will save the unwary
+	/// windows user from sending junk.
+/*
+$cp1252_to_xmlent =
+  array(
+   '\x80'=>'&#x20AC;', '\x81'=>'?', '\x82'=>'&#x201A;', '\x83'=>'&#x0192;',
+   '\x84'=>'&#x201E;', '\x85'=>'&#x2026;', '\x86'=>'&#x2020;', \x87'=>'&#x2021;',
+   '\x88'=>'&#x02C6;', '\x89'=>'&#x2030;', '\x8A'=>'&#x0160;', '\x8B'=>'&#x2039;',
+   '\x8C'=>'&#x0152;', '\x8D'=>'?', '\x8E'=>'&#x017D;', '\x8F'=>'?',
+   '\x90'=>'?', '\x91'=>'&#x2018;', '\x92'=>'&#x2019;', '\x93'=>'&#x201C;',
+   '\x94'=>'&#x201D;', '\x95'=>'&#x2022;', '\x96'=>'&#x2013;', '\x97'=>'&#x2014;',
+   '\x98'=>'&#x02DC;', '\x99'=>'&#x2122;', '\x9A'=>'&#x0161;', '\x9B'=>'&#x203A;',
+   '\x9C'=>'&#x0153;', '\x9D'=>'?', '\x9E'=>'&#x017E;', '\x9F'=>'&#x0178;'
+  );
+*/
+
+	$GLOBALS['xmlrpcerr']['unknown_method']=1;
+	$GLOBALS['xmlrpcstr']['unknown_method']='Unknown method';
+	$GLOBALS['xmlrpcerr']['invalid_return']=2;
+	$GLOBALS['xmlrpcstr']['invalid_return']='Invalid return payload: enable debugging to examine incoming payload';
+	$GLOBALS['xmlrpcerr']['incorrect_params']=3;
+	$GLOBALS['xmlrpcstr']['incorrect_params']='Incorrect parameters passed to method';
+	$GLOBALS['xmlrpcerr']['introspect_unknown']=4;
+	$GLOBALS['xmlrpcstr']['introspect_unknown']="Can't introspect: method unknown";
+	$GLOBALS['xmlrpcerr']['http_error']=5;
+	$GLOBALS['xmlrpcstr']['http_error']="Didn't receive 200 OK from remote server.";
+	$GLOBALS['xmlrpcerr']['no_data']=6;
+	$GLOBALS['xmlrpcstr']['no_data']='No data received from server.';
+	$GLOBALS['xmlrpcerr']['no_ssl']=7;
+	$GLOBALS['xmlrpcstr']['no_ssl']='No SSL support compiled in.';
+	$GLOBALS['xmlrpcerr']['curl_fail']=8;
+	$GLOBALS['xmlrpcstr']['curl_fail']='CURL error';
+	$GLOBALS['xmlrpcerr']['invalid_request']=15;
+	$GLOBALS['xmlrpcstr']['invalid_request']='Invalid request payload';
+	$GLOBALS['xmlrpcerr']['no_curl']=16;
+	$GLOBALS['xmlrpcstr']['no_curl']='No CURL support compiled in.';
+	$GLOBALS['xmlrpcerr']['server_error']=17;
+	$GLOBALS['xmlrpcstr']['server_error']='Internal server error';
+	$GLOBALS['xmlrpcerr']['multicall_error']=18;
+	$GLOBALS['xmlrpcstr']['multicall_error']='Received from server invalid multicall response';
+
+	$GLOBALS['xmlrpcerr']['multicall_notstruct'] = 9;
+	$GLOBALS['xmlrpcstr']['multicall_notstruct'] = 'system.multicall expected struct';
+	$GLOBALS['xmlrpcerr']['multicall_nomethod']  = 10;
+	$GLOBALS['xmlrpcstr']['multicall_nomethod']  = 'missing methodName';
+	$GLOBALS['xmlrpcerr']['multicall_notstring'] = 11;
+	$GLOBALS['xmlrpcstr']['multicall_notstring'] = 'methodName is not a string';
+	$GLOBALS['xmlrpcerr']['multicall_recursion'] = 12;
+	$GLOBALS['xmlrpcstr']['multicall_recursion'] = 'recursive system.multicall forbidden';
+	$GLOBALS['xmlrpcerr']['multicall_noparams']  = 13;
+	$GLOBALS['xmlrpcstr']['multicall_noparams']  = 'missing params';
+	$GLOBALS['xmlrpcerr']['multicall_notarray']  = 14;
+	$GLOBALS['xmlrpcstr']['multicall_notarray']  = 'params is not an array';
+
+	$GLOBALS['xmlrpcerr']['cannot_decompress']=103;
+	$GLOBALS['xmlrpcstr']['cannot_decompress']='Received from server compressed HTTP and cannot decompress';
+	$GLOBALS['xmlrpcerr']['decompress_fail']=104;
+	$GLOBALS['xmlrpcstr']['decompress_fail']='Received from server invalid compressed HTTP';
+	$GLOBALS['xmlrpcerr']['dechunk_fail']=105;
+	$GLOBALS['xmlrpcstr']['dechunk_fail']='Received from server invalid chunked HTTP';
+	$GLOBALS['xmlrpcerr']['server_cannot_decompress']=106;
+	$GLOBALS['xmlrpcstr']['server_cannot_decompress']='Received from client compressed HTTP request and cannot decompress';
+	$GLOBALS['xmlrpcerr']['server_decompress_fail']=107;
+	$GLOBALS['xmlrpcstr']['server_decompress_fail']='Received from client invalid compressed HTTP request';
+
+	// The charset encoding used by the server for received messages and
+	// by the client for received responses when received charset cannot be determined
+	// or is not supported
+	$GLOBALS['xmlrpc_defencoding']='UTF-8';
+
+	// The encoding used internally by PHP.
+	// String values received as xml will be converted to this, and php strings will be converted to xml
+	// as if having been coded with this
+	$GLOBALS['xmlrpc_internalencoding']='ISO-8859-1';
+
+	$GLOBALS['xmlrpcName']='XML-RPC for PHP';
+	$GLOBALS['xmlrpcVersion']='2.1';
+
+	// let user errors start at 800
+	$GLOBALS['xmlrpcerruser']=800;
+	// let XML parse errors start at 100
+	$GLOBALS['xmlrpcerrxml']=100;
+
+	// formulate backslashes for escaping regexp
+	// Not in use anymore since 2.0. Shall we remove it?
+	/// @deprecated
+	$GLOBALS['xmlrpc_backslash']=chr(92).chr(92);
+
+	// set to TRUE to enable correct decoding of <NIL/> values
+	$GLOBALS['xmlrpc_null_extension']=false;
+
+	// used to store state during parsing
+	// quick explanation of components:
+	//   ac - used to accumulate values
+	//   isf - used to indicate a parsing fault (2) or xmlrpcresp fault (1)
+	//   isf_reason - used for storing xmlrpcresp fault string
+	//   lv - used to indicate "looking for a value": implements
+	//        the logic to allow values with no types to be strings
+	//   params - used to store parameters in method calls
+	//   method - used to store method name
+	//   stack - array with genealogy of xml elements names:
+	//           used to validate nesting of xmlrpc elements
+	$GLOBALS['_xh']=null;
+
+	/**
+	* Convert a string to the correct XML representation in a target charset
+	* To help correct communication of non-ascii chars inside strings, regardless
+	* of the charset used when sending requests, parsing them, sending responses
+	* and parsing responses, an option is to convert all non-ascii chars present in the message
+	* into their equivalent 'charset entity'. Charset entities enumerated this way
+	* are independent of the charset encoding used to transmit them, and all XML
+	* parsers are bound to understand them.
+	* Note that in the std case we are not sending a charset encoding mime type
+	* along with http headers, so we are bound by RFC 3023 to emit strict us-ascii.
+	*
+	* @todo do a bit of basic benchmarking (strtr vs. str_replace)
+	* @todo	make usage of iconv() or recode_string() or mb_string() where available
+	*/
+	function xmlrpc_encode_entitites($data, $src_encoding='', $dest_encoding='')
+	{
+		if ($src_encoding == '')
+		{
+			// lame, but we know no better...
+			$src_encoding = $GLOBALS['xmlrpc_internalencoding'];
+		}
+
+		switch(strtoupper($src_encoding.'_'.$dest_encoding))
+		{
+			case 'ISO-8859-1_':
+			case 'ISO-8859-1_US-ASCII':
+				$escaped_data = str_replace(array('&', '"', "'", '<', '>'), array('&amp;', '&quot;', '&apos;', '&lt;', '&gt;'), $data);
+				$escaped_data = str_replace($GLOBALS['xml_iso88591_Entities']['in'], $GLOBALS['xml_iso88591_Entities']['out'], $escaped_data);
+				break;
+			case 'ISO-8859-1_UTF-8':
+				$escaped_data = str_replace(array('&', '"', "'", '<', '>'), array('&amp;', '&quot;', '&apos;', '&lt;', '&gt;'), $data);
+				$escaped_data = utf8_encode($escaped_data);
+				break;
+			case 'ISO-8859-1_ISO-8859-1':
+			case 'US-ASCII_US-ASCII':
+			case 'US-ASCII_UTF-8':
+			case 'US-ASCII_':
+			case 'US-ASCII_ISO-8859-1':
+			case 'UTF-8_UTF-8':
+				$escaped_data = str_replace(array('&', '"', "'", '<', '>'), array('&amp;', '&quot;', '&apos;', '&lt;', '&gt;'), $data);
+				break;
+			case 'UTF-8_':
+			case 'UTF-8_US-ASCII':
+			case 'UTF-8_ISO-8859-1':
+	// NB: this will choke on invalid UTF-8, going most likely beyond EOF
+	$escaped_data = '';
+	// be kind to users creating string xmlrpcvals out of different php types
+	$data = (string) $data;
+	$ns = strlen ($data);
+	for ($nn = 0; $nn < $ns; $nn++)
+	{
+		$ch = $data[$nn];
+		$ii = ord($ch);
+		//1 7 0bbbbbbb (127)
+		if ($ii < 128)
+		{
+			/// @todo shall we replace this with a (supposedly) faster str_replace?
+			switch($ii){
+				case 34:
+					$escaped_data .= '&quot;';
+					break;
+				case 38:
+					$escaped_data .= '&amp;';
+					break;
+				case 39:
+					$escaped_data .= '&apos;';
+					break;
+				case 60:
+					$escaped_data .= '&lt;';
+					break;
+				case 62:
+					$escaped_data .= '&gt;';
+					break;
+				default:
+					$escaped_data .= $ch;
+			} // switch
+		}
+		//2 11 110bbbbb 10bbbbbb (2047)
+		else if ($ii>>5 == 6)
+		{
+			$b1 = ($ii & 31);
+			$ii = ord($data[$nn+1]);
+			$b2 = ($ii & 63);
+			$ii = ($b1 * 64) + $b2;
+			$ent = sprintf ('&#%d;', $ii);
+			$escaped_data .= $ent;
+			$nn += 1;
+		}
+		//3 16 1110bbbb 10bbbbbb 10bbbbbb
+		else if ($ii>>4 == 14)
+		{
+			$b1 = ($ii & 31);
+			$ii = ord($data[$nn+1]);
+			$b2 = ($ii & 63);
+			$ii = ord($data[$nn+2]);
+			$b3 = ($ii & 63);
+			$ii = ((($b1 * 64) + $b2) * 64) + $b3;
+			$ent = sprintf ('&#%d;', $ii);
+			$escaped_data .= $ent;
+			$nn += 2;
+		}
+		//4 21 11110bbb 10bbbbbb 10bbbbbb 10bbbbbb
+		else if ($ii>>3 == 30)
+		{
+			$b1 = ($ii & 31);
+			$ii = ord($data[$nn+1]);
+			$b2 = ($ii & 63);
+			$ii = ord($data[$nn+2]);
+			$b3 = ($ii & 63);
+			$ii = ord($data[$nn+3]);
+			$b4 = ($ii & 63);
+			$ii = ((((($b1 * 64) + $b2) * 64) + $b3) * 64) + $b4;
+			$ent = sprintf ('&#%d;', $ii);
+			$escaped_data .= $ent;
+			$nn += 3;
+		}
+	}
+				break;
+			default:
+				$escaped_data = '';
+				error_log("Converting from $src_encoding to $dest_encoding: not supported...");
+		}
+		return $escaped_data;
+	}
+
+	/// xml parser handler function for opening element tags
+	function xmlrpc_se($parser, $name, $attrs, $accept_single_vals=false)
+	{
+		// if invalid xmlrpc already detected, skip all processing
+		if ($GLOBALS['_xh']['isf'] < 2)
+		{
+			// check for correct element nesting
+			// top level element can only be of 2 types
+			/// @todo optimization creep: save this check into a bool variable, instead of using count() every time:
+			///       there is only a single top level element in xml anyway
+			if (count($GLOBALS['_xh']['stack']) == 0)
+			{
+				if ($name != 'METHODRESPONSE' && $name != 'METHODCALL' && (
+					$name != 'VALUE' && !$accept_single_vals))
+				{
+					$GLOBALS['_xh']['isf'] = 2;
+					$GLOBALS['_xh']['isf_reason'] = 'missing top level xmlrpc element';
+					return;
+				}
+				else
+				{
+					$GLOBALS['_xh']['rt'] = strtolower($name);
+				}
+			}
+			else
+			{
+				// not top level element: see if parent is OK
+				$parent = end($GLOBALS['_xh']['stack']);
+				if (!array_key_exists($name, $GLOBALS['xmlrpc_valid_parents']) || !in_array($parent, $GLOBALS['xmlrpc_valid_parents'][$name]))
+				{
+					$GLOBALS['_xh']['isf'] = 2;
+					$GLOBALS['_xh']['isf_reason'] = "xmlrpc element $name cannot be child of $parent";
+					return;
+				}
+			}
+
+			switch($name)
+			{
+				// optimize for speed switch cases: most common cases first
+				case 'VALUE':
+					/// @todo we could check for 2 VALUE elements inside a MEMBER or PARAM element
+					$GLOBALS['_xh']['vt']='value'; // indicator: no value found yet
+					$GLOBALS['_xh']['ac']='';
+					$GLOBALS['_xh']['lv']=1;
+					$GLOBALS['_xh']['php_class']=null;
+					break;
+				case 'I4':
+				case 'INT':
+				case 'STRING':
+				case 'BOOLEAN':
+				case 'DOUBLE':
+				case 'DATETIME.ISO8601':
+				case 'BASE64':
+					if ($GLOBALS['_xh']['vt']!='value')
+					{
+						//two data elements inside a value: an error occurred!
+						$GLOBALS['_xh']['isf'] = 2;
+						$GLOBALS['_xh']['isf_reason'] = "$name element following a {$GLOBALS['_xh']['vt']} element inside a single value";
+						return;
+					}
+					$GLOBALS['_xh']['ac']=''; // reset the accumulator
+					break;
+				case 'STRUCT':
+				case 'ARRAY':
+					if ($GLOBALS['_xh']['vt']!='value')
+					{
+						//two data elements inside a value: an error occurred!
+						$GLOBALS['_xh']['isf'] = 2;
+						$GLOBALS['_xh']['isf_reason'] = "$name element following a {$GLOBALS['_xh']['vt']} element inside a single value";
+						return;
+					}
+					// create an empty array to hold child values, and push it onto appropriate stack
+					$cur_val = array();
+					$cur_val['values'] = array();
+					$cur_val['type'] = $name;
+					// check for out-of-band information to rebuild php objs
+					// and in case it is found, save it
+					if (@isset($attrs['PHP_CLASS']))
+					{
+						$cur_val['php_class'] = $attrs['PHP_CLASS'];
+					}
+					$GLOBALS['_xh']['valuestack'][] = $cur_val;
+					$GLOBALS['_xh']['vt']='data'; // be prepared for a data element next
+					break;
+				case 'DATA':
+					if ($GLOBALS['_xh']['vt']!='data')
+					{
+						//two data elements inside a value: an error occurred!
+						$GLOBALS['_xh']['isf'] = 2;
+						$GLOBALS['_xh']['isf_reason'] = "found two data elements inside an array element";
+						return;
+					}
+				case 'METHODCALL':
+				case 'METHODRESPONSE':
+				case 'PARAMS':
+					// valid elements that add little to processing
+					break;
+				case 'METHODNAME':
+				case 'NAME':
+					/// @todo we could check for 2 NAME elements inside a MEMBER element
+					$GLOBALS['_xh']['ac']='';
+					break;
+				case 'FAULT':
+					$GLOBALS['_xh']['isf']=1;
+					break;
+				case 'MEMBER':
+					$GLOBALS['_xh']['valuestack'][count($GLOBALS['_xh']['valuestack'])-1]['name']=''; // set member name to null, in case we do not find in the xml later on
+					//$GLOBALS['_xh']['ac']='';
+					// Drop trough intentionally
+				case 'PARAM':
+					// clear value type, so we can check later if no value has been passed for this param/member
+					$GLOBALS['_xh']['vt']=null;
+					break;
+				case 'NIL':
+					if ($GLOBALS['xmlrpc_null_extension'])
+					{
+						if ($GLOBALS['_xh']['vt']!='value')
+						{
+							//two data elements inside a value: an error occurred!
+							$GLOBALS['_xh']['isf'] = 2;
+							$GLOBALS['_xh']['isf_reason'] = "$name element following a {$GLOBALS['_xh']['vt']} element inside a single value";
+							return;
+						}
+						$GLOBALS['_xh']['ac']=''; // reset the accumulator
+						break;
+					}
+					// we do not support the <NIL/> extension, so
+					// drop through intentionally
+				default:
+					/// INVALID ELEMENT: RAISE ISF so that it is later recognized!!!
+					$GLOBALS['_xh']['isf'] = 2;
+					$GLOBALS['_xh']['isf_reason'] = "found not-xmlrpc xml element $name";
+					break;
+			}
+
+			// Save current element name to stack, to validate nesting
+			$GLOBALS['_xh']['stack'][] = $name;
+
+			/// @todo optimization creep: move this inside the big switch() above
+			if($name!='VALUE')
+			{
+				$GLOBALS['_xh']['lv']=0;
+			}
+		}
+	}
+
+	/// Used in decoding xml chunks that might represent single xmlrpc values
+	function xmlrpc_se_any($parser, $name, $attrs)
+	{
+		xmlrpc_se($parser, $name, $attrs, true);
+	}
+
+	/// xml parser handler function for close element tags
+	function xmlrpc_ee($parser, $name, $rebuild_xmlrpcvals = true)
+	{
+		if ($GLOBALS['_xh']['isf'] < 2)
+		{
+			// push this element name from stack
+			// NB: if XML validates, correct opening/closing is guaranteed and
+			// we do not have to check for $name == $curr_elem.
+			// we also checked for proper nesting at start of elements...
+			$curr_elem = array_pop($GLOBALS['_xh']['stack']);
+
+			switch($name)
+			{
+				case 'VALUE':
+					// This if() detects if no scalar was inside <VALUE></VALUE>
+					if ($GLOBALS['_xh']['vt']=='value')
+					{
+						$GLOBALS['_xh']['value']=$GLOBALS['_xh']['ac'];
+						$GLOBALS['_xh']['vt']=$GLOBALS['xmlrpcString'];
+					}
+
+					if ($rebuild_xmlrpcvals)
+					{
+						// build the xmlrpc val out of the data received, and substitute it
+						$temp =& new xmlrpcval($GLOBALS['_xh']['value'], $GLOBALS['_xh']['vt']);
+						// in case we got info about underlying php class, save it
+						// in the object we're rebuilding
+						if (isset($GLOBALS['_xh']['php_class']))
+							$temp->_php_class = $GLOBALS['_xh']['php_class'];
+						// check if we are inside an array or struct:
+						// if value just built is inside an array, let's move it into array on the stack
+						$vscount = count($GLOBALS['_xh']['valuestack']);
+						if ($vscount && $GLOBALS['_xh']['valuestack'][$vscount-1]['type']=='ARRAY')
+						{
+							$GLOBALS['_xh']['valuestack'][$vscount-1]['values'][] = $temp;
+						}
+						else
+						{
+							$GLOBALS['_xh']['value'] = $temp;
+						}
+					}
+					else
+					{
+						/// @todo this needs to treat correctly php-serialized objects,
+						/// since std deserializing is done by php_xmlrpc_decode,
+						/// which we will not be calling...
+						if (isset($GLOBALS['_xh']['php_class']))
+						{
+						}
+
+						// check if we are inside an array or struct:
+						// if value just built is inside an array, let's move it into array on the stack
+						$vscount = count($GLOBALS['_xh']['valuestack']);
+						if ($vscount && $GLOBALS['_xh']['valuestack'][$vscount-1]['type']=='ARRAY')
+						{
+							$GLOBALS['_xh']['valuestack'][$vscount-1]['values'][] = $GLOBALS['_xh']['value'];
+						}
+					}
+					break;
+				case 'BOOLEAN':
+				case 'I4':
+				case 'INT':
+				case 'STRING':
+				case 'DOUBLE':
+				case 'DATETIME.ISO8601':
+				case 'BASE64':
+					$GLOBALS['_xh']['vt']=strtolower($name);
+        			/// @todo: optimization creep - remove the if/elseif cycle below
+                    /// since the case() in which we are already did that
+					if ($name=='STRING')
+					{
+						$GLOBALS['_xh']['value']=$GLOBALS['_xh']['ac'];
+					}
+					elseif ($name=='DATETIME.ISO8601')
+					{
+						if (!preg_match('/^[0-9]{8}T[0-9]{2}:[0-9]{2}:[0-9]{2}$/', $GLOBALS['_xh']['ac']))
+						{
+							error_log('XML-RPC: invalid value received in DATETIME: '.$GLOBALS['_xh']['ac']);
+						}
+						$GLOBALS['_xh']['vt']=$GLOBALS['xmlrpcDateTime'];
+						$GLOBALS['_xh']['value']=$GLOBALS['_xh']['ac'];
+					}
+					elseif ($name=='BASE64')
+					{
+						/// @todo check for failure of base64 decoding / catch warnings
+						$GLOBALS['_xh']['value']=base64_decode($GLOBALS['_xh']['ac']);
+					}
+					elseif ($name=='BOOLEAN')
+					{
+						// special case here: we translate boolean 1 or 0 into PHP
+						// constants true or false.
+						// Strings 'true' and 'false' are accepted, even though the
+						// spec never mentions them (see eg. Blogger api docs)
+						// NB: this simple checks helps a lot sanitizing input, ie no
+						// security problems around here
+						if ($GLOBALS['_xh']['ac']=='1' || strcasecmp($GLOBALS['_xh']['ac'], 'true') == 0)
+						{
+							$GLOBALS['_xh']['value']=true;
+						}
+						else
+						{
+							// log if receiveing something strange, even though we set the value to false anyway
+							if ($GLOBALS['_xh']['ac']!='0' && strcasecmp($_xh[$parser]['ac'], 'false') != 0)
+								error_log('XML-RPC: invalid value received in BOOLEAN: '.$GLOBALS['_xh']['ac']);
+							$GLOBALS['_xh']['value']=false;
+						}
+					}
+					elseif ($name=='DOUBLE')
+					{
+						// we have a DOUBLE
+						// we must check that only 0123456789-.<space> are characters here
+						if (!preg_match('/^[+-]?[eE0123456789 \t.]+$/', $GLOBALS['_xh']['ac']))
+						{
+							/// @todo: find a better way of throwing an error
+							// than this!
+							error_log('XML-RPC: non numeric value received in DOUBLE: '.$GLOBALS['_xh']['ac']);
+							$GLOBALS['_xh']['value']='ERROR_NON_NUMERIC_FOUND';
+						}
+						else
+						{
+							// it's ok, add it on
+							$GLOBALS['_xh']['value']=(double)$GLOBALS['_xh']['ac'];
+						}
+					}
+					else
+					{
+						// we have an I4/INT
+						// we must check that only 0123456789-<space> are characters here
+						if (!preg_match('/^[+-]?[0123456789 \t]+$/', $GLOBALS['_xh']['ac']))
+						{
+							/// @todo find a better way of throwing an error
+							// than this!
+							error_log('XML-RPC: non numeric value received in INT: '.$GLOBALS['_xh']['ac']);
+							$GLOBALS['_xh']['value']='ERROR_NON_NUMERIC_FOUND';
+						}
+						else
+						{
+							// it's ok, add it on
+							$GLOBALS['_xh']['value']=(int)$GLOBALS['_xh']['ac'];
+						}
+					}
+					//$GLOBALS['_xh']['ac']=''; // is this necessary?
+					$GLOBALS['_xh']['lv']=3; // indicate we've found a value
+					break;
+				case 'NAME':
+					$GLOBALS['_xh']['valuestack'][count($GLOBALS['_xh']['valuestack'])-1]['name'] = $GLOBALS['_xh']['ac'];
+					break;
+				case 'MEMBER':
+					//$GLOBALS['_xh']['ac']=''; // is this necessary?
+					// add to array in the stack the last element built,
+					// unless no VALUE was found
+					if ($GLOBALS['_xh']['vt'])
+					{
+						$vscount = count($GLOBALS['_xh']['valuestack']);
+						$GLOBALS['_xh']['valuestack'][$vscount-1]['values'][$GLOBALS['_xh']['valuestack'][$vscount-1]['name']] = $GLOBALS['_xh']['value'];
+					} else
+						error_log('XML-RPC: missing VALUE inside STRUCT in received xml');
+					break;
+				case 'DATA':
+					//$GLOBALS['_xh']['ac']=''; // is this necessary?
+					$GLOBALS['_xh']['vt']=null; // reset this to check for 2 data elements in a row - even if they're empty
+					break;
+				case 'STRUCT':
+				case 'ARRAY':
+					// fetch out of stack array of values, and promote it to current value
+					$curr_val = array_pop($GLOBALS['_xh']['valuestack']);
+					$GLOBALS['_xh']['value'] = $curr_val['values'];
+					$GLOBALS['_xh']['vt']=strtolower($name);
+					if (isset($curr_val['php_class']))
+					{
+						$GLOBALS['_xh']['php_class'] = $curr_val['php_class'];
+					}
+					break;
+				case 'PARAM':
+					// add to array of params the current value,
+					// unless no VALUE was found
+					if ($GLOBALS['_xh']['vt'])
+					{
+						$GLOBALS['_xh']['params'][]=$GLOBALS['_xh']['value'];
+						$GLOBALS['_xh']['pt'][]=$GLOBALS['_xh']['vt'];
+					}
+					else
+						error_log('XML-RPC: missing VALUE inside PARAM in received xml');
+					break;
+				case 'METHODNAME':
+					$GLOBALS['_xh']['method']=preg_replace('/^[\n\r\t ]+/', '', $GLOBALS['_xh']['ac']);
+					break;
+				case 'NIL':
+					if ($GLOBALS['xmlrpc_null_extension'])
+					{
+						$GLOBALS['_xh']['vt']='null';
+						$GLOBALS['_xh']['value']=null;
+						$GLOBALS['_xh']['lv']=3;
+						break;
+					}
+					// drop through intentionally if nil extension not enabled
+				case 'PARAMS':
+				case 'FAULT':
+				case 'METHODCALL':
+				case 'METHORESPONSE':
+					break;
+				default:
+					// End of INVALID ELEMENT!
+					// shall we add an assert here for unreachable code???
+					break;
+			}
+		}
+	}
+
+	/// Used in decoding xmlrpc requests/responses without rebuilding xmlrpc values
+	function xmlrpc_ee_fast($parser, $name)
+	{
+		xmlrpc_ee($parser, $name, false);
+	}
+
+	/// xml parser handler function for character data
+	function xmlrpc_cd($parser, $data)
+	{
+		// skip processing if xml fault already detected
+		if ($GLOBALS['_xh']['isf'] < 2)
+		{
+			// "lookforvalue==3" means that we've found an entire value
+			// and should discard any further character data
+			if($GLOBALS['_xh']['lv']!=3)
+			{
+				// G. Giunta 2006-08-23: useless change of 'lv' from 1 to 2
+				//if($GLOBALS['_xh']['lv']==1)
+				//{
+					// if we've found text and we're just in a <value> then
+					// say we've found a value
+					//$GLOBALS['_xh']['lv']=2;
+				//}
+				// we always initialize the accumulator before starting parsing, anyway...
+				//if(!@isset($GLOBALS['_xh']['ac']))
+				//{
+				//	$GLOBALS['_xh']['ac'] = '';
+				//}
+				$GLOBALS['_xh']['ac'].=$data;
+			}
+		}
+	}
+
+	/// xml parser handler function for 'other stuff', ie. not char data or
+	/// element start/end tag. In fact it only gets called on unknown entities...
+	function xmlrpc_dh($parser, $data)
+	{
+		// skip processing if xml fault already detected
+		if ($GLOBALS['_xh']['isf'] < 2)
+		{
+			if(substr($data, 0, 1) == '&' && substr($data, -1, 1) == ';')
+			{
+				// G. Giunta 2006-08-25: useless change of 'lv' from 1 to 2
+				//if($GLOBALS['_xh']['lv']==1)
+				//{
+				//	$GLOBALS['_xh']['lv']=2;
+				//}
+				$GLOBALS['_xh']['ac'].=$data;
+			}
+		}
+		return true;
+	}
+
+	class xmlrpc_client
+	{
+		var $path;
+		var $server;
+		var $port=0;
+		var $method='http';
+		var $errno;
+		var $errstr;
+		var $debug=0;
+		var $username='';
+		var $password='';
+		var $authtype=1;
+		var $cert='';
+		var $certpass='';
+		var $cacert='';
+		var $cacertdir='';
+		var $key='';
+		var $keypass='';
+		var $verifypeer=true;
+		var $verifyhost=1;
+		var $no_multicall=false;
+		var $proxy='';
+		var $proxyport=0;
+		var $proxy_user='';
+		var $proxy_pass='';
+		var $proxy_authtype=1;
+		var $cookies=array();
+		/**
+		* List of http compression methods accepted by the client for responses.
+		* NB: PHP supports deflate, gzip compressions out of the box if compiled w. zlib
+		*
+		* NNB: you can set it to any non-empty array for HTTP11 and HTTPS, since
+		* in those cases it will be up to CURL to decide the compression methods
+		* it supports. You might check for the presence of 'zlib' in the output of
+		* curl_version() to determine wheter compression is supported or not
+		*/
+		var $accepted_compression = array();
+		/**
+		* Name of compression scheme to be used for sending requests.
+		* Either null, gzip or deflate
+		*/
+		var $request_compression = '';
+		/**
+		* CURL handle: used for keep-alive connections (PHP 4.3.8 up, see:
+		* http://curl.haxx.se/docs/faq.html#7.3)
+		*/
+		var $xmlrpc_curl_handle = null;
+		/// Wheter to use persistent connections for http 1.1 and https
+		var $keepalive = false;
+		/// Charset encodings that can be decoded without problems by the client
+		var $accepted_charset_encodings = array();
+		/// Charset encoding to be used in serializing request. NULL = use ASCII
+		var $request_charset_encoding = '';
+		/**
+		* Decides the content of xmlrpcresp objects returned by calls to send()
+		* valid strings are 'xmlrpcvals', 'phpvals' or 'xml'
+		*/
+		var $return_type = 'xmlrpcvals';
+
+		/**
+		* @param string $path either the complete server URL or the PATH part of the xmlrc server URL, e.g. /xmlrpc/server.php
+		* @param string $server the server name / ip address
+		* @param integer $port the port the server is listening on, defaults to 80 or 443 depending on protocol used
+		* @param string $method the http protocol variant: defaults to 'http', 'https' and 'http11' can be used if CURL is installed
+		*/
+		function xmlrpc_client($path, $server='', $port='', $method='')
+		{
+			// allow user to specify all params in $path
+			if($server == '' and $port == '' and $method == '')
+			{
+				$parts = parse_url($path);
+				$server = $parts['host'];
+				$path = $parts['path'];
+				if(isset($parts['query']))
+				{
+					$path .= '?'.$parts['query'];
+				}
+				if(isset($parts['fragment']))
+				{
+					$path .= '#'.$parts['fragment'];
+				}
+				if(isset($parts['port']))
+				{
+					$port = $parts['port'];
+				}
+				if(isset($parts['scheme']))
+				{
+					$method = $parts['scheme'];
+				}
+				if(isset($parts['user']))
+				{
+					$this->username = $parts['user'];
+				}
+				if(isset($parts['pass']))
+				{
+					$this->password = $parts['pass'];
+				}
+			}
+			if($path == '' || $path[0] != '/')
+			{
+				$this->path='/'.$path;
+			}
+			else
+			{
+				$this->path=$path;
+			}
+			$this->server=$server;
+			if($port != '')
+			{
+				$this->port=$port;
+			}
+			if($method != '')
+			{
+				$this->method=$method;
+			}
+
+			// if ZLIB is enabled, let the client by default accept compressed responses
+			if(function_exists('gzinflate') || (
+				function_exists('curl_init') && (($info = curl_version()) &&
+				((is_string($info) && strpos($info, 'zlib') !== null) || isset($info['libz_version'])))
+			))
+			{
+				$this->accepted_compression = array('gzip', 'deflate');
+			}
+
+			// keepalives: enabled by default ONLY for PHP >= 4.3.8
+			// (see http://curl.haxx.se/docs/faq.html#7.3)
+			if(version_compare(phpversion(), '4.3.8') >= 0)
+			{
+				$this->keepalive = true;
+			}
+
+			// by default the xml parser can support these 3 charset encodings
+			$this->accepted_charset_encodings = array('UTF-8', 'ISO-8859-1', 'US-ASCII');
+		}
+
+		/**
+		* Enables/disables the echoing to screen of the xmlrpc responses received
+		* @param integer $debug values 0, 1 and 2 are supported (2 = echo sent msg too, before received response)
+		* @access public
+		*/
+		function setDebug($in)
+		{
+			$this->debug=$in;
+		}
+
+		/**
+		* Add some http BASIC AUTH credentials, used by the client to authenticate
+		* @param string $u username
+		* @param string $p password
+		* @param integer $t auth type. See curl_setopt man page for supported auth types. Defaults to CURLAUTH_BASIC (basic auth)
+		* @access public
+		*/
+		function setCredentials($u, $p, $t=1)
+		{
+			$this->username=$u;
+			$this->password=$p;
+			$this->authtype=$t;
+		}
+
+		/**
+		* Add a client-side https certificate
+		* @param string $cert
+		* @param string $certpass
+		* @access public
+		*/
+		function setCertificate($cert, $certpass)
+		{
+			$this->cert = $cert;
+			$this->certpass = $certpass;
+		}
+
+		/**
+		* Add a CA certificate to verify server with (see man page about
+		* CURLOPT_CAINFO for more details
+		* @param string $cacert certificate file name (or dir holding certificates)
+		* @param bool $is_dir set to true to indicate cacert is a dir. defaults to false
+		* @access public
+		*/
+		function setCaCertificate($cacert, $is_dir=false)
+		{
+			if ($is_dir)
+			{
+				$this->cacert = $cacert;
+			}
+			else
+			{
+				$this->cacertdir = $cacert;
+			}
+		}
+
+		/**
+		* Set attributes for SSL communication: private SSL key
+		* @param string $key The name of a file containing a private SSL key
+		* @param string $keypass The secret password needed to use the private SSL key
+		* @access public
+		* NB: does not work in older php/curl installs
+		* Thanks to Daniel Convissor
+		*/
+		function setKey($key, $keypass)
+		{
+			$this->key = $key;
+			$this->keypass = $keypass;
+		}
+
+		/**
+		* Set attributes for SSL communication: verify server certificate
+		* @param bool $i enable/disable verification of peer certificate
+		* @access public
+		*/
+		function setSSLVerifyPeer($i)
+		{
+			$this->verifypeer = $i;
+		}
+
+		/**
+		* Set attributes for SSL communication: verify match of server cert w. hostname
+		* @param int $i
+		* @access public
+		*/
+		function setSSLVerifyHost($i)
+		{
+			$this->verifyhost = $i;
+		}
+
+		/**
+		* Set proxy info
+		* @param string $proxyhost
+		* @param string $proxyport Defaults to 8080 for HTTP and 443 for HTTPS
+		* @param string $proxyusername Leave blank if proxy has public access
+		* @param string $proxypassword Leave blank if proxy has public access
+		* @param int $proxyauthtype set to constant CURLAUTH_NTLM to use NTLM auth with proxy
+		* @access public
+		*/
+		function setProxy($proxyhost, $proxyport, $proxyusername = '', $proxypassword = '', $proxyauthtype = 1)
+		{
+			$this->proxy = $proxyhost;
+			$this->proxyport = $proxyport;
+			$this->proxy_user = $proxyusername;
+			$this->proxy_pass = $proxypassword;
+			$this->proxy_authtype = $proxyauthtype;
+		}
+
+		/**
+		* Enables/disables reception of compressed xmlrpc responses.
+		* Note that enabling reception of compressed responses merely adds some standard
+		* http headers to xmlrpc requests. It is up to the xmlrpc server to return
+		* compressed responses when receiving such requests.
+		* @param string $compmethod either 'gzip', 'deflate', 'any' or ''
+		* @access public
+		*/
+		function setAcceptedCompression($compmethod)
+		{
+			if ($compmethod == 'any')
+				$this->accepted_compression = array('gzip', 'deflate');
+			else
+				$this->accepted_compression = array($compmethod);
+		}
+
+		/**
+		* Enables/disables http compression of xmlrpc request.
+		* Take care when sending compressed requests: servers might not support them
+		* (and automatic fallback to uncompressed requests is not yet implemented)
+		* @param string $compmethod either 'gzip', 'deflate' or ''
+		* @access public
+		*/
+		function setRequestCompression($compmethod)
+		{
+			$this->request_compression = $compmethod;
+		}
+
+		/**
+		* Adds a cookie to list of cookies that will be sent to server.
+		* NB: setting any param but name and value will turn the cookie into a 'version 1' cookie:
+		* do not do it unless you know what you are doing
+		* @param string $name
+		* @param string $value
+		* @param string $path
+		* @param string $domain
+		* @param int $port
+		* @access public
+		*
+		* @todo check correctness of urlencoding cookie value (copied from php way of doing it...)
+		*/
+		function setCookie($name, $value='', $path='', $domain='', $port=null)
+		{
+			$this->cookies[$name]['value'] = urlencode($value);
+			if ($path || $domain || $port)
+			{
+				$this->cookies[$name]['path'] = $path;
+				$this->cookies[$name]['domain'] = $domain;
+				$this->cookies[$name]['port'] = $port;
+				$this->cookies[$name]['version'] = 1;
+			}
+			else
+			{
+				$this->cookies[$name]['version'] = 0;
+			}
+		}
+
+		/**
+		* Send an xmlrpc request
+		* @param mixed $msg The message object, or an array of messages for using multicall, or the complete xml representation of a request
+		* @param integer $timeout Connection timeout, in seconds, If unspecified, a platform specific timeout will apply
+		* @param string $method if left unspecified, the http protocol chosen during creation of the object will be used
+		* @return xmlrpcresp
+		* @access public
+		*/
+		function& send($msg, $timeout=0, $method='')
+		{
+			// if user deos not specify http protocol, use native method of this client
+			// (i.e. method set during call to constructor)
+			if($method == '')
+			{
+				$method = $this->method;
+			}
+
+			if(is_array($msg))
+			{
+				// $msg is an array of xmlrpcmsg's
+				$r = $this->multicall($msg, $timeout, $method);
+				return $r;
+			}
+			elseif(is_string($msg))
+			{
+				$n =& new xmlrpcmsg('');
+				$n->payload = $msg;
+				$msg = $n;
+			}
+
+			// where msg is an xmlrpcmsg
+			$msg->debug=$this->debug;
+
+			if($method == 'https')
+			{
+				$r =& $this->sendPayloadHTTPS(
+					$msg,
+					$this->server,
+					$this->port,
+					$timeout,
+					$this->username,
+					$this->password,
+					$this->authtype,
+					$this->cert,
+					$this->certpass,
+					$this->cacert,
+					$this->cacertdir,
+					$this->proxy,
+					$this->proxyport,
+					$this->proxy_user,
+					$this->proxy_pass,
+					$this->proxy_authtype,
+					$this->keepalive,
+					$this->key,
+					$this->keypass
+				);
+			}
+			elseif($method == 'http11')
+			{
+				$r =& $this->sendPayloadCURL(
+					$msg,
+					$this->server,
+					$this->port,
+					$timeout,
+					$this->username,
+					$this->password,
+					$this->authtype,
+					null,
+					null,
+					null,
+					null,
+					$this->proxy,
+					$this->proxyport,
+					$this->proxy_user,
+					$this->proxy_pass,
+					$this->proxy_authtype,
+					'http',
+					$this->keepalive
+				);
+			}
+			else
+			{
+				$r =& $this->sendPayloadHTTP10(
+					$msg,
+					$this->server,
+					$this->port,
+					$timeout,
+					$this->username,
+					$this->password,
+					$this->authtype,
+					$this->proxy,
+					$this->proxyport,
+					$this->proxy_user,
+					$this->proxy_pass,
+					$this->proxy_authtype
+				);
+			}
+
+			return $r;
+		}
+
+		/**
+		* @access private
+		*/
+		function &sendPayloadHTTP10($msg, $server, $port, $timeout=0,
+			$username='', $password='', $authtype=1, $proxyhost='',
+			$proxyport=0, $proxyusername='', $proxypassword='', $proxyauthtype=1)
+		{
+			if($port==0)
+			{
+				$port=80;
+			}
+
+			// Only create the payload if it was not created previously
+			if(empty($msg->payload))
+			{
+				$msg->createPayload($this->request_charset_encoding);
+			}
+
+			$payload = $msg->payload;
+			// Deflate request body and set appropriate request headers
+			if(function_exists('gzdeflate') && ($this->request_compression == 'gzip' || $this->request_compression == 'deflate'))
+			{
+				if($this->request_compression == 'gzip')
+				{
+					$a = @gzencode($payload);
+					if($a)
+					{
+						$payload = $a;
+						$encoding_hdr = "Content-Encoding: gzip\r\n";
+					}
+				}
+				else
+				{
+					$a = @gzcompress($payload);
+					if($a)
+					{
+						$payload = $a;
+						$encoding_hdr = "Content-Encoding: deflate\r\n";
+					}
+				}
+			}
+			else
+			{
+				$encoding_hdr = '';
+			}
+
+			// thanks to Grant Rauscher <grant7@firstworld.net> for this
+			$credentials='';
+			if($username!='')
+			{
+				$credentials='Authorization: Basic ' . base64_encode($username . ':' . $password) . "\r\n";
+				if ($authtype != 1)
+				{
+					error_log('XML-RPC: xmlrpc_client::send: warning. Only Basic auth is supported with HTTP 1.0');
+				}
+			}
+
+			$accepted_encoding = '';
+			if(is_array($this->accepted_compression) && count($this->accepted_compression))
+			{
+				$accepted_encoding = 'Accept-Encoding: ' . implode(', ', $this->accepted_compression) . "\r\n";
+			}
+
+			$proxy_credentials = '';
+			if($proxyhost)
+			{
+				if($proxyport == 0)
+				{
+					$proxyport = 8080;
+				}
+				$connectserver = $proxyhost;
+				$connectport = $proxyport;
+				$uri = 'http://'.$server.':'.$port.$this->path;
+				if($proxyusername != '')
+				{
+					if ($proxyauthtype != 1)
+					{
+						error_log('XML-RPC: xmlrpc_client::send: warning. Only Basic auth to proxy is supported with HTTP 1.0');
+					}
+					$proxy_credentials = 'Proxy-Authorization: Basic ' . base64_encode($proxyusername.':'.$proxypassword) . "\r\n";
+				}
+			}
+			else
+			{
+				$connectserver = $server;
+				$connectport = $port;
+				$uri = $this->path;
+			}
+
+			// Cookie generation, as per rfc2965 (version 1 cookies) or
+			// netscape's rules (version 0 cookies)
+			$cookieheader='';
+			foreach ($this->cookies as $name => $cookie)
+			{
+				if ($cookie['version'])
+				{
+					$cookieheader .= 'Cookie: $Version="' . $cookie['version'] . '"; ';
+					$cookieheader .= $name . '="' . $cookie['value'] . '";';
+					if ($cookie['path'])
+						$cookieheader .= ' $Path="' . $cookie['path'] . '";';
+					if ($cookie['domain'])
+						$cookieheader .= ' $Domain="' . $cookie['domain'] . '";';
+					if ($cookie['port'])
+						$cookieheader .= ' $Port="' . $cookie['domain'] . '";';
+					$cookieheader = substr($cookieheader, 0, -1) . "\r\n";
+				}
+				else
+				{
+					$cookieheader .= 'Cookie: ' . $name . '=' . $cookie['value'] . "\r\n";
+				}
+			}
+
+			$op= 'POST ' . $uri. " HTTP/1.0\r\n" .
+				'User-Agent: ' . $GLOBALS['xmlrpcName'] . ' ' . $GLOBALS['xmlrpcVersion'] . "\r\n" .
+				'Host: '. $server . ':' . $port . "\r\n" .
+				$credentials .
+				$proxy_credentials .
+				$accepted_encoding .
+				$encoding_hdr .
+				'Accept-Charset: ' . implode(',', $this->accepted_charset_encodings) . "\r\n" .
+				$cookieheader .
+				'Content-Type: ' . $msg->content_type . "\r\nContent-Length: " .
+				strlen($payload) . "\r\n\r\n" .
+				$payload;
+
+			if($this->debug > 1)
+			{
+				print "<PRE>\n---SENDING---\n" . htmlentities($op) . "\n---END---\n</PRE>";
+				// let the client see this now in case http times out...
+				flush();
+			}
+
+			if($timeout>0)
+			{
+				$fp=@fsockopen($connectserver, $connectport, $this->errno, $this->errstr, $timeout);
+			}
+			else
+			{
+				$fp=@fsockopen($connectserver, $connectport, $this->errno, $this->errstr);
+			}
+			if($fp)
+			{
+				if($timeout>0 && function_exists('stream_set_timeout'))
+				{
+					stream_set_timeout($fp, $timeout);
+				}
+			}
+			else
+			{
+				$this->errstr='Connect error: '.$this->errstr;
+				$r=&new xmlrpcresp(0, $GLOBALS['xmlrpcerr']['http_error'], $this->errstr . ' (' . $this->errno . ')');
+				return $r;
+			}
+
+			if(!fputs($fp, $op, strlen($op)))
+			{
+				$this->errstr='Write error';
+				$r=&new xmlrpcresp(0, $GLOBALS['xmlrpcerr']['http_error'], $this->errstr);
+				return $r;
+			}
+			else
+			{
+				// reset errno and errstr on succesful socket connection
+				$this->errstr = '';
+			}
+			// G. Giunta 2005/10/24: close socket before parsing.
+			// should yeld slightly better execution times, and make easier recursive calls (e.g. to follow http redirects)
+			$ipd='';
+			while($data=fread($fp, 32768))
+			{
+				// shall we check for $data === FALSE?
+				// as per the manual, it signals an error
+				$ipd.=$data;
+			}
+			fclose($fp);
+			$r =& $msg->parseResponse($ipd, false, $this->return_type);
+			return $r;
+
+		}
+
+		/**
+		* @access private
+		*/
+		function &sendPayloadHTTPS($msg, $server, $port, $timeout=0, $username='',
+			$password='', $authtype=1, $cert='',$certpass='', $cacert='', $cacertdir='',
+			$proxyhost='', $proxyport=0, $proxyusername='', $proxypassword='', $proxyauthtype=1,
+			$keepalive=false, $key='', $keypass='')
+		{
+			$r =& $this->sendPayloadCURL($msg, $server, $port, $timeout, $username,
+				$password, $authtype, $cert, $certpass, $cacert, $cacertdir, $proxyhost, $proxyport,
+				$proxyusername, $proxypassword, $proxyauthtype, 'https', $keepalive, $key, $keypass);
+			return $r;
+		}
+
+		/**
+		* Contributed by Justin Miller <justin@voxel.net>
+		* Requires curl to be built into PHP
+		* NB: CURL versions before 7.11.10 cannot use proxy to talk to https servers!
+		* @access private
+		*/
+		function &sendPayloadCURL($msg, $server, $port, $timeout=0, $username='',
+			$password='', $authtype=1, $cert='', $certpass='', $cacert='', $cacertdir='',
+			$proxyhost='', $proxyport=0, $proxyusername='', $proxypassword='', $proxyauthtype=1, $method='https',
+			$keepalive=false, $key='', $keypass='')
+		{
+			if(!function_exists('curl_init'))
+			{
+				$this->errstr='CURL unavailable on this install';
+				$r=&new xmlrpcresp(0, $GLOBALS['xmlrpcerr']['no_curl'], $GLOBALS['xmlrpcstr']['no_curl']);
+				return $r;
+			}
+			if($method == 'https')
+			{
+				if(($info = curl_version()) &&
+					((is_string($info) && strpos($info, 'OpenSSL') === null) || (is_array($info) && !isset($info['ssl_version']))))
+				{
+					$this->errstr='SSL unavailable on this install';
+					$r=&new xmlrpcresp(0, $GLOBALS['xmlrpcerr']['no_ssl'], $GLOBALS['xmlrpcstr']['no_ssl']);
+					return $r;
+				}
+			}
+
+			if($port == 0)
+			{
+				if($method == 'http')
+				{
+					$port = 80;
+				}
+				else
+				{
+					$port = 443;
+				}
+			}
+
+			// Only create the payload if it was not created previously
+			if(empty($msg->payload))
+			{
+				$msg->createPayload($this->request_charset_encoding);
+			}
+
+			// Deflate request body and set appropriate request headers
+			$payload = $msg->payload;
+			if(function_exists('gzdeflate') && ($this->request_compression == 'gzip' || $this->request_compression == 'deflate'))
+			{
+				if($this->request_compression == 'gzip')
+				{
+					$a = @gzencode($payload);
+					if($a)
+					{
+						$payload = $a;
+						$encoding_hdr = 'Content-Encoding: gzip';
+					}
+				}
+				else
+				{
+					$a = @gzcompress($payload);
+					if($a)
+					{
+						$payload = $a;
+						$encoding_hdr = 'Content-Encoding: deflate';
+					}
+				}
+			}
+			else
+			{
+				$encoding_hdr = '';
+			}
+
+			if($this->debug > 1)
+			{
+				print "<PRE>\n---SENDING---\n" . htmlentities($payload) . "\n---END---\n</PRE>";
+				// let the client see this now in case http times out...
+				flush();
+			}
+
+			if(!$keepalive || !$this->xmlrpc_curl_handle)
+			{
+				$curl = curl_init($method . '://' . $server . ':' . $port . $this->path);
+				if($keepalive)
+				{
+					$this->xmlrpc_curl_handle = $curl;
+				}
+			}
+			else
+			{
+				$curl = $this->xmlrpc_curl_handle;
+			}
+
+			// results into variable
+			curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);
+
+			if($this->debug)
+			{
+				curl_setopt($curl, CURLOPT_VERBOSE, 1);
+			}
+			curl_setopt($curl, CURLOPT_USERAGENT, $GLOBALS['xmlrpcName'].' '.$GLOBALS['xmlrpcVersion']);
+			// required for XMLRPC: post the data
+			curl_setopt($curl, CURLOPT_POST, 1);
+			// the data
+			curl_setopt($curl, CURLOPT_POSTFIELDS, $payload);
+
+			// return the header too
+			curl_setopt($curl, CURLOPT_HEADER, 1);
+
+			// will only work with PHP >= 5.0
+			// NB: if we set an empty string, CURL will add http header indicating
+			// ALL methods it is supporting. This is possibly a better option than
+			// letting the user tell what curl can / cannot do...
+			if(is_array($this->accepted_compression) && count($this->accepted_compression))
+			{
+				//curl_setopt($curl, CURLOPT_ENCODING, implode(',', $this->accepted_compression));
+				// empty string means 'any supported by CURL' (shall we catch errors in case CURLOPT_SSLKEY undefined ?)
+				if (count($this->accepted_compression) == 1)
+				{
+					curl_setopt($curl, CURLOPT_ENCODING, $this->accepted_compression[0]);
+				}
+				else
+					curl_setopt($curl, CURLOPT_ENCODING, '');
+			}
+			// extra headers
+			$headers = array('Content-Type: ' . $msg->content_type , 'Accept-Charset: ' . implode(',', $this->accepted_charset_encodings));
+			// if no keepalive is wanted, let the server know it in advance
+			if(!$keepalive)
+			{
+				$headers[] = 'Connection: close';
+			}
+			// request compression header
+			if($encoding_hdr)
+			{
+				$headers[] = $encoding_hdr;
+			}
+
+			curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);
+			// timeout is borked
+			if($timeout)
+			{
+				curl_setopt($curl, CURLOPT_TIMEOUT, $timeout == 1 ? 1 : $timeout - 1);
+			}
+
+			if($username && $password)
+			{
+				curl_setopt($curl, CURLOPT_USERPWD, $username.':'.$password);
+				if (defined('CURLOPT_HTTPAUTH'))
+				{
+					curl_setopt($curl, CURLOPT_HTTPAUTH, $authtype);
+				}
+				else if ($authtype != 1)
+				{
+					error_log('XML-RPC: xmlrpc_client::send: warning. Only Basic auth is supported by the current PHP/curl install');
+				}
+			}
+
+			if($method == 'https')
+			{
+				// set cert file
+				if($cert)
+				{
+					curl_setopt($curl, CURLOPT_SSLCERT, $cert);
+				}
+				// set cert password
+				if($certpass)
+				{
+					curl_setopt($curl, CURLOPT_SSLCERTPASSWD, $certpass);
+				}
+				// whether to verify remote host's cert
+				curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, $this->verifypeer);
+				// set ca certificates file/dir
+				if($cacert)
+				{
+					curl_setopt($curl, CURLOPT_CAINFO, $cacert);
+				}
+				if($cacertdir)
+				{
+					curl_setopt($curl, CURLOPT_CAPATH, $cacertdir);
+				}
+				// set key file (shall we catch errors in case CURLOPT_SSLKEY undefined ?)
+				if($key)
+				{
+					curl_setopt($curl, CURLOPT_SSLKEY, $key);
+				}
+				// set key password (shall we catch errors in case CURLOPT_SSLKEY undefined ?)
+				if($keypass)
+				{
+					curl_setopt($curl, CURLOPT_SSLKEYPASSWD, $keypass);
+				}
+				// whether to verify cert's common name (CN); 0 for no, 1 to verify that it exists, and 2 to verify that it matches the hostname used
+				curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, $this->verifyhost);
+			}
+
+			// proxy info
+			if($proxyhost)
+			{
+				if($proxyport == 0)
+				{
+					$proxyport = 8080; // NB: even for HTTPS, local connection is on port 8080
+				}
+				curl_setopt($curl, CURLOPT_PROXY,$proxyhost.':'.$proxyport);
+				//curl_setopt($curl, CURLOPT_PROXYPORT,$proxyport);
+				if($proxyusername)
+				{
+					curl_setopt($curl, CURLOPT_PROXYUSERPWD, $proxyusername.':'.$proxypassword);
+					if (defined('CURLOPT_PROXYAUTH'))
+					{
+						curl_setopt($curl, CURLOPT_PROXYAUTH, $proxyauthtype);
+					}
+					else if ($proxyauthtype != 1)
+					{
+						error_log('XML-RPC: xmlrpc_client::send: warning. Only Basic auth to proxy is supported by the current PHP/curl install');
+					}
+				}
+			}
+
+			// NB: should we build cookie http headers by hand rather than let CURL do it?
+			// the following code does not honour 'expires', 'path' and 'domain' cookie attributes
+			// set to clint obj the the user...
+			if (count($this->cookies))
+			{
+				$cookieheader = '';
+				foreach ($this->cookies as $name => $cookie)
+				{
+					$cookieheader .= $name . '=' . $cookie['value'] . ', ';
+				}
+				curl_setopt($curl, CURLOPT_COOKIE, substr($cookieheader, 0, -2));
+			}
+
+			$result = curl_exec($curl);
+
+			if(!$result)
+			{
+				$this->errstr='no response';
+				$resp=&new xmlrpcresp(0, $GLOBALS['xmlrpcerr']['curl_fail'], $GLOBALS['xmlrpcstr']['curl_fail']. ': '. curl_error($curl));
+				if(!$keepalive)
+				{
+					curl_close($curl);
+				}
+			}
+			else
+			{
+				if(!$keepalive)
+				{
+					curl_close($curl);
+				}
+				$resp =& $msg->parseResponse($result, true, $this->return_type);
+			}
+			return $resp;
+		}
+
+		/**
+		* Send an array of request messages and return an array of responses.
+		* Unless $this->no_multicall has been set to true, it will try first
+		* to use one single xmlrpc call to server method system.multicall, and
+		* revert to sending many successive calls in case of failure.
+		* This failure is also stored in $this->no_multicall for subsequent calls.
+		* Unfortunately, there is no server error code universally used to denote
+		* the fact that multicall is unsupported, so there is no way to reliably
+		* distinguish between that and a temporary failure.
+		* If you are sure that server supports multicall and do not want to
+		* fallback to using many single calls, set the fourth parameter to FALSE.
+		*
+		* NB: trying to shoehorn extra functionality into existing syntax has resulted
+		* in pretty much convoluted code...
+		*
+		* @param array $msgs an array of xmlrpcmsg objects
+		* @param integer $timeout connection timeout (in seconds)
+		* @param string $method the http protocol variant to be used
+		* @param boolean fallback When true, upon receiveing an error during multicall, multiple single calls will be attempted
+		* @return array
+		* @access public
+		*/
+		function multicall($msgs, $timeout=0, $method='', $fallback=true)
+		{
+			if ($method == '')
+			{
+				$method = $this->method;
+			}
+			if(!$this->no_multicall)
+			{
+				$results = $this->_try_multicall($msgs, $timeout, $method);
+				if(is_array($results))
+				{
+					// System.multicall succeeded
+					return $results;
+				}
+				else
+				{
+					// either system.multicall is unsupported by server,
+					// or call failed for some other reason.
+					if ($fallback)
+					{
+						// Don't try it next time...
+						$this->no_multicall = true;
+					}
+					else
+					{
+						if (is_a($results, 'xmlrpcresp'))
+						{
+							$result = $results;
+						}
+						else
+						{
+							$result =& new xmlrpcresp(0, $GLOBALS['xmlrpcerr']['multicall_error'], $GLOBALS['xmlrpcstr']['multicall_error']);
+						}
+					}
+				}
+			}
+			else
+			{
+				// override fallback, in case careless user tries to do two
+				// opposite things at the same time
+				$fallback = true;
+			}
+
+			$results = array();
+			if ($fallback)
+			{
+				// system.multicall is (probably) unsupported by server:
+				// emulate multicall via multiple requests
+				foreach($msgs as $msg)
+				{
+					$results[] =& $this->send($msg, $timeout, $method);
+				}
+			}
+			else
+			{
+				// user does NOT want to fallback on many single calls:
+				// since we should always return an array of responses,
+				// return an array with the same error repeated n times
+				foreach($msgs as $msg)
+				{
+					$results[] = $result;
+				}
+			}
+			return $results;
+		}
+
+		/**
+		* Attempt to boxcar $msgs via system.multicall.
+		* Returns either an array of xmlrpcreponses, an xmlrpc error response
+		* or false (when received response does not respect valid multicall syntax)
+		* @access private
+		*/
+		function _try_multicall($msgs, $timeout, $method)
+		{
+			// Construct multicall message
+			$calls = array();
+			foreach($msgs as $msg)
+			{
+				$call['methodName'] =& new xmlrpcval($msg->method(),'string');
+				$numParams = $msg->getNumParams();
+				$params = array();
+				for($i = 0; $i < $numParams; $i++)
+				{
+					$params[$i] = $msg->getParam($i);
+				}
+				$call['params'] =& new xmlrpcval($params, 'array');
+				$calls[] =& new xmlrpcval($call, 'struct');
+			}
+			$multicall =& new xmlrpcmsg('system.multicall');
+			$multicall->addParam(new xmlrpcval($calls, 'array'));
+
+			// Attempt RPC call
+			$result =& $this->send($multicall, $timeout, $method);
+
+			if($result->faultCode() != 0)
+			{
+				// call to system.multicall failed
+				return $result;
+			}
+
+			// Unpack responses.
+			$rets = $result->value();
+
+			if ($this->return_type == 'xml')
+			{
+					return $rets;
+			}
+			else if ($this->return_type == 'phpvals')
+			{
+				///@todo test this code branch...
+				$rets = $result->value();
+				if(!is_array($rets))
+				{
+					return false;		// bad return type from system.multicall
+				}
+				$numRets = count($rets);
+				if($numRets != count($msgs))
+				{
+					return false;		// wrong number of return values.
+				}
+
+				$response = array();
+				for($i = 0; $i < $numRets; $i++)
+				{
+					$val = $rets[$i];
+					if (!is_array($val)) {
+						return false;
+					}
+					switch(count($val))
+					{
+						case 1:
+							if(!isset($val[0]))
+							{
+								return false;		// Bad value
+							}
+							// Normal return value
+							$response[$i] =& new xmlrpcresp($val[0], 0, '', 'phpvals');
+							break;
+						case 2:
+							///	@todo remove usage of @: it is apparently quite slow
+							$code = @$val['faultCode'];
+							if(!is_int($code))
+							{
+								return false;
+							}
+							$str = @$val['faultString'];
+							if(!is_string($str))
+							{
+								return false;
+							}
+							$response[$i] =& new xmlrpcresp(0, $code, $str);
+							break;
+						default:
+							return false;
+					}
+				}
+				return $response;
+			}
+			else // return type == 'xmlrpcvals'
+			{
+				$rets = $result->value();
+				if($rets->kindOf() != 'array')
+				{
+					return false;		// bad return type from system.multicall
+				}
+				$numRets = $rets->arraysize();
+				if($numRets != count($msgs))
+				{
+					return false;		// wrong number of return values.
+				}
+
+				$response = array();
+				for($i = 0; $i < $numRets; $i++)
+				{
+					$val = $rets->arraymem($i);
+					switch($val->kindOf())
+					{
+						case 'array':
+							if($val->arraysize() != 1)
+							{
+								return false;		// Bad value
+							}
+							// Normal return value
+							$response[$i] =& new xmlrpcresp($val->arraymem(0));
+							break;
+						case 'struct':
+							$code = $val->structmem('faultCode');
+							if($code->kindOf() != 'scalar' || $code->scalartyp() != 'int')
+							{
+								return false;
+							}
+							$str = $val->structmem('faultString');
+							if($str->kindOf() != 'scalar' || $str->scalartyp() != 'string')
+							{
+								return false;
+							}
+							$response[$i] =& new xmlrpcresp(0, $code->scalarval(), $str->scalarval());
+							break;
+						default:
+							return false;
+					}
+				}
+				return $response;
+			}
+		}
+	} // end class xmlrpc_client
+
+	class xmlrpcresp
+	{
+		var $val = 0;
+		var $valtyp;
+		var $errno = 0;
+		var $errstr = '';
+		var $payload;
+		var $hdrs = array();
+		var $_cookies = array();
+		var $content_type = 'text/xml';
+		var $raw_data = '';
+
+		/**
+		* @param mixed $val either an xmlrpcval obj, a php value or the xml serialization of an xmlrpcval (a string)
+		* @param integer $fcode set it to anything but 0 to create an error response
+		* @param string $fstr the error string, in case of an error response
+		* @param string $valtyp either 'xmlrpcvals', 'phpvals' or 'xml'
+		*
+		* @todo add check that $val / $fcode / $fstr is of correct type???
+		* NB: as of now we do not do it, since it might be either an xmlrpcval or a plain
+		* php val, or a complete xml chunk, depending on usage of xmlrpc_client::send() inside which creator is called...
+		*/
+		function xmlrpcresp($val, $fcode = 0, $fstr = '', $valtyp='')
+		{
+			if($fcode != 0)
+			{
+				// error response
+				$this->errno = $fcode;
+				$this->errstr = $fstr;
+				//$this->errstr = htmlspecialchars($fstr); // XXX: encoding probably shouldn't be done here; fix later.
+			}
+			else
+			{
+				// successful response
+				$this->val = $val;
+				if ($valtyp == '')
+				{
+					// user did not declare type of response value: try to guess it
+					if (is_object($this->val) && is_a($this->val, 'xmlrpcval'))
+					{
+						$this->valtyp = 'xmlrpcvals';
+					}
+					else if (is_string($this->val))
+					{
+						$this->valtyp = 'xml';
+
+					}
+					else
+					{
+						$this->valtyp = 'phpvals';
+					}
+				}
+				else
+				{
+					// user declares type of resp value: believe him
+					$this->valtyp = $valtyp;
+				}
+			}
+		}
+
+		/**
+		* Returns the error code of the response.
+		* @return integer the error code of this response (0 for not-error responses)
+		* @access public
+		*/
+		function faultCode()
+		{
+			return $this->errno;
+		}
+
+		/**
+		* Returns the error code of the response.
+		* @return string the error string of this response ('' for not-error responses)
+		* @access public
+		*/
+		function faultString()
+		{
+			return $this->errstr;
+		}
+
+		/**
+		* Returns the value received by the server.
+		* @return mixed the xmlrpcval object returned by the server. Might be an xml string or php value if the response has been created by specially configured xmlrpc_client objects
+		* @access public
+		*/
+		function value()
+		{
+			return $this->val;
+		}
+
+		/**
+		* Returns an array with the cookies received from the server.
+		* Array has the form: $cookiename => array ('value' => $val, $attr1 => $val1, $attr2 = $val2, ...)
+		* with attributes being e.g. 'expires', 'path', domain'.
+		* NB: cookies sent as 'expired' by the server (i.e. with an expiry date in the past)
+		* are still present in the array. It is up to the user-defined code to decide
+		* how to use the received cookies, and wheter they have to be sent back with the next
+		* request to the server (using xmlrpc_client::setCookie) or not
+		* @return array array of cookies received from the server
+		* @access public
+		*/
+		function cookies()
+		{
+			return $this->_cookies;
+		}
+
+		/**
+		* Returns xml representation of the response. XML prologue not included
+		* @param string $charset_encoding the charset to be used for serialization. if null, US-ASCII is assumed
+		* @return string the xml representation of the response
+		* @access public
+		*/
+		function serialize($charset_encoding='')
+		{
+			if ($charset_encoding != '')
+				$this->content_type = 'text/xml; charset=' . $charset_encoding;
+			else
+				$this->content_type = 'text/xml';
+			$result = "<methodResponse>\n";
+			if($this->errno)
+			{
+				// G. Giunta 2005/2/13: let non-ASCII response messages be tolerated by clients
+				// by xml-encoding non ascii chars
+				$result .= "<fault>\n" .
+"<value>\n<struct><member><name>faultCode</name>\n<value><int>" . $this->errno .
+"</int></value>\n</member>\n<member>\n<name>faultString</name>\n<value><string>" .
+xmlrpc_encode_entitites($this->errstr, $GLOBALS['xmlrpc_internalencoding'], $charset_encoding) . "</string></value>\n</member>\n" .
+"</struct>\n</value>\n</fault>";
+			}
+			else
+			{
+				if(!is_object($this->val) || !is_a($this->val, 'xmlrpcval'))
+				{
+					if (is_string($this->val) && $this->valtyp == 'xml')
+					{
+						$result .= "<params>\n<param>\n" .
+							$this->val .
+							"</param>\n</params>";
+					}
+					else
+					{
+						/// @todo try to build something serializable?
+						die('cannot serialize xmlrpcresp objects whose content is native php values');
+					}
+				}
+				else
+				{
+					$result .= "<params>\n<param>\n" .
+						$this->val->serialize($charset_encoding) .
+						"</param>\n</params>";
+				}
+			}
+			$result .= "\n</methodResponse>";
+			$this->payload = $result;
+			return $result;
+		}
+	}
+
+	class xmlrpcmsg
+	{
+		var $payload;
+		var $methodname;
+		var $params=array();
+		var $debug=0;
+		var $content_type = 'text/xml';
+
+		/**
+		* @param string $meth the name of the method to invoke
+		* @param array $pars array of parameters to be paased to the method (xmlrpcval objects)
+		*/
+		function xmlrpcmsg($meth, $pars=0)
+		{
+			$this->methodname=$meth;
+			if(is_array($pars) && count($pars)>0)
+			{
+				for($i=0; $i<count($pars); $i++)
+				{
+					$this->addParam($pars[$i]);
+				}
+			}
+		}
+
+		/**
+		* @access private
+		*/
+		function xml_header($charset_encoding='')
+		{
+			if ($charset_encoding != '')
+			{
+				return "<?xml version=\"1.0\" encoding=\"$charset_encoding\" ?" . ">\n<methodCall>\n";
+			}
+			else
+			{
+				return "<?xml version=\"1.0\"?" . ">\n<methodCall>\n";
+			}
+		}
+
+		/**
+		* @access private
+		*/
+		function xml_footer()
+		{
+			return '</methodCall>';
+		}
+
+		/**
+		* @access private
+		*/
+		function kindOf()
+		{
+			return 'msg';
+		}
+
+		/**
+		* @access private
+		*/
+		function createPayload($charset_encoding='')
+		{
+			if ($charset_encoding != '')
+				$this->content_type = 'text/xml; charset=' . $charset_encoding;
+			else
+				$this->content_type = 'text/xml';
+			$this->payload=$this->xml_header($charset_encoding);
+			$this->payload.='<methodName>' . $this->methodname . "</methodName>\n";
+			$this->payload.="<params>\n";
+			for($i=0; $i<count($this->params); $i++)
+			{
+				$p=$this->params[$i];
+				$this->payload.="<param>\n" . $p->serialize($charset_encoding) .
+				"</param>\n";
+			}
+			$this->payload.="</params>\n";
+			$this->payload.=$this->xml_footer();
+		}
+
+		/**
+		* Gets/sets the xmlrpc method to be invoked
+		* @param string $meth the method to be set (leave empty not to set it)
+		* @return string the method that will be invoked
+		* @access public
+		*/
+		function method($meth='')
+		{
+			if($meth!='')
+			{
+				$this->methodname=$meth;
+			}
+			return $this->methodname;
+		}
+
+		/**
+		* Returns xml representation of the message. XML prologue included
+		* @return string the xml representation of the message, xml prologue included
+		* @access public
+		*/
+		function serialize($charset_encoding='')
+		{
+			$this->createPayload($charset_encoding);
+			return $this->payload;
+		}
+
+		/**
+		* Add a parameter to the list of parameters to be used upon method invocation
+		* @param xmlrpcval $par
+		* @return boolean false on failure
+		* @access public
+		*/
+		function addParam($par)
+		{
+			// add check: do not add to self params which are not xmlrpcvals
+			if(is_object($par) && is_a($par, 'xmlrpcval'))
+			{
+				$this->params[]=$par;
+				return true;
+			}
+			else
+			{
+				return false;
+			}
+		}
+
+		/**
+		* Returns the nth parameter in the message. The index zero-based.
+		* @param integer $i the index of the parameter to fetch (zero based)
+		* @return xmlrpcval the i-th parameter
+		* @access public
+		*/
+		function getParam($i) { return $this->params[$i]; }
+
+		/**
+		* Returns the number of parameters in the messge.
+		* @return integer the number of parameters currently set
+		* @access public
+		*/
+		function getNumParams() { return count($this->params); }
+
+		/**
+		* Given an open file handle, read all data available and parse it as axmlrpc response.
+		* NB: the file handle is not closed by this function.
+		* @access public
+		* @return xmlrpcresp
+		* @todo add 2nd & 3rd param to be passed to ParseResponse() ???
+		*/
+		function &parseResponseFile($fp)
+		{
+			$ipd='';
+			while($data=fread($fp, 32768))
+			{
+				$ipd.=$data;
+			}
+			//fclose($fp);
+			$r =& $this->parseResponse($ipd);
+			return $r;
+		}
+
+		/**
+		* Parses HTTP headers and separates them from data.
+		* @access private
+		*/
+		function &parseResponseHeaders(&$data, $headers_processed=false)
+		{
+				// Support "web-proxy-tunelling" connections for https through proxies
+				if(preg_match('/^HTTP\/1\.[0-1] 200 Connection established/', $data))
+				{
+					// Look for CR/LF or simple LF as line separator,
+					// (even though it is not valid http)
+					$pos = strpos($data,"\r\n\r\n");
+					if($pos || is_int($pos))
+					{
+						$bd = $pos+4;
+					}
+					else
+					{
+						$pos = strpos($data,"\n\n");
+						if($pos || is_int($pos))
+						{
+							$bd = $pos+2;
+						}
+						else
+						{
+							// No separation between response headers and body: fault?
+							$bd = 0;
+						}
+					}
+					if ($bd)
+					{
+						// this filters out all http headers from proxy.
+						// maybe we could take them into account, too?
+						$data = substr($data, $bd);
+					}
+					else
+					{
+						error_log('XML-RPC: xmlrpcmsg::parseResponse: HTTPS via proxy error, tunnel connection possibly failed');
+						$r=&new xmlrpcresp(0, $GLOBALS['xmlrpcerr']['http_error'], $GLOBALS['xmlrpcstr']['http_error']. ' (HTTPS via proxy error, tunnel connection possibly failed)');
+						return $r;
+					}
+				}
+
+				// Strip HTTP 1.1 100 Continue header if present
+				while(preg_match('/^HTTP\/1\.1 1[0-9]{2} /', $data))
+				{
+					$pos = strpos($data, 'HTTP', 12);
+					// server sent a Continue header without any (valid) content following...
+					// give the client a chance to know it
+					if(!$pos && !is_int($pos)) // works fine in php 3, 4 and 5
+					{
+						break;
+					}
+					$data = substr($data, $pos);
+				}
+				if(!preg_match('/^HTTP\/[0-9.]+ 200 /', $data))
+				{
+					$errstr= substr($data, 0, strpos($data, "\n")-1);
+					error_log('XML-RPC: xmlrpcmsg::parseResponse: HTTP error, got response: ' .$errstr);
+					$r=&new xmlrpcresp(0, $GLOBALS['xmlrpcerr']['http_error'], $GLOBALS['xmlrpcstr']['http_error']. ' (' . $errstr . ')');
+					return $r;
+				}
+
+				$GLOBALS['_xh']['headers'] = array();
+				$GLOBALS['_xh']['cookies'] = array();
+
+				// be tolerant to usage of \n instead of \r\n to separate headers and data
+				// (even though it is not valid http)
+				$pos = strpos($data,"\r\n\r\n");
+				if($pos || is_int($pos))
+				{
+					$bd = $pos+4;
+				}
+				else
+				{
+					$pos = strpos($data,"\n\n");
+					if($pos || is_int($pos))
+					{
+						$bd = $pos+2;
+					}
+					else
+					{
+						// No separation between response headers and body: fault?
+						// we could take some action here instead of going on...
+						$bd = 0;
+					}
+				}
+				// be tolerant to line endings, and extra empty lines
+				$ar = split("\r?\n", trim(substr($data, 0, $pos)));
+				while(list(,$line) = @each($ar))
+				{
+					// take care of multi-line headers and cookies
+					$arr = explode(':',$line,2);
+					if(count($arr) > 1)
+					{
+						$header_name = strtolower(trim($arr[0]));
+						/// @todo some other headers (the ones that allow a CSV list of values)
+						/// do allow many values to be passed using multiple header lines.
+						/// We should add content to $GLOBALS['_xh']['headers'][$header_name]
+						/// instead of replacing it for those...
+						if ($header_name == 'set-cookie' || $header_name == 'set-cookie2')
+						{
+							if ($header_name == 'set-cookie2')
+							{
+								// version 2 cookies:
+								// there could be many cookies on one line, comma separated
+								$cookies = explode(',', $arr[1]);
+							}
+							else
+							{
+								$cookies = array($arr[1]);
+							}
+							foreach ($cookies as $cookie)
+							{
+								// glue together all received cookies, using a comma to separate them
+								// (same as php does with getallheaders())
+								if (isset($GLOBALS['_xh']['headers'][$header_name]))
+									$GLOBALS['_xh']['headers'][$header_name] .= ', ' . trim($cookie);
+								else
+									$GLOBALS['_xh']['headers'][$header_name] = trim($cookie);
+								// parse cookie attributes, in case user wants to correctly honour them
+								// feature creep: only allow rfc-compliant cookie attributes?
+								$cookie = explode(';', $cookie);
+								foreach ($cookie as $pos => $val)
+								{
+									$val = explode('=', $val, 2);
+									$tag = trim($val[0]);
+									$val = trim(@$val[1]);
+									/// @todo with version 1 cookies, we should strip leading and trailing " chars
+									if ($pos == 0)
+									{
+										$cookiename = $tag;
+										$GLOBALS['_xh']['cookies'][$tag] = array();
+										$GLOBALS['_xh']['cookies'][$cookiename]['value'] = urldecode($val);
+									}
+									else
+									{
+										$GLOBALS['_xh']['cookies'][$cookiename][$tag] = $val;
+									}
+								}
+							}
+						}
+						else
+						{
+							$GLOBALS['_xh']['headers'][$header_name] = trim($arr[1]);
+						}
+					}
+					elseif(isset($header_name))
+					{
+						///	@todo version1 cookies might span multiple lines, thus breaking the parsing above
+						$GLOBALS['_xh']['headers'][$header_name] .= ' ' . trim($line);
+					}
+				}
+
+				$data = substr($data, $bd);
+
+				if($this->debug && count($GLOBALS['_xh']['headers']))
+				{
+					print '<PRE>';
+					foreach($GLOBALS['_xh']['headers'] as $header => $value)
+					{
+						print htmlentities("HEADER: $header: $value\n");
+					}
+					foreach($GLOBALS['_xh']['cookies'] as $header => $value)
+					{
+						print htmlentities("COOKIE: $header={$value['value']}\n");
+					}
+					print "</PRE>\n";
+				}
+
+				// if CURL was used for the call, http headers have been processed,
+				// and dechunking + reinflating have been carried out
+				if(!$headers_processed)
+				{
+					// Decode chunked encoding sent by http 1.1 servers
+					if(isset($GLOBALS['_xh']['headers']['transfer-encoding']) && $GLOBALS['_xh']['headers']['transfer-encoding'] == 'chunked')
+					{
+						if(!$data = decode_chunked($data))
+						{
+							error_log('XML-RPC: xmlrpcmsg::parseResponse: errors occurred when trying to rebuild the chunked data received from server');
+							$r =& new xmlrpcresp(0, $GLOBALS['xmlrpcerr']['dechunk_fail'], $GLOBALS['xmlrpcstr']['dechunk_fail']);
+							return $r;
+						}
+					}
+
+					// Decode gzip-compressed stuff
+					// code shamelessly inspired from nusoap library by Dietrich Ayala
+					if(isset($GLOBALS['_xh']['headers']['content-encoding']))
+					{
+						$GLOBALS['_xh']['headers']['content-encoding'] = str_replace('x-', '', $GLOBALS['_xh']['headers']['content-encoding']);
+						if($GLOBALS['_xh']['headers']['content-encoding'] == 'deflate' || $GLOBALS['_xh']['headers']['content-encoding'] == 'gzip')
+						{
+							// if decoding works, use it. else assume data wasn't gzencoded
+							if(function_exists('gzinflate'))
+							{
+								if($GLOBALS['_xh']['headers']['content-encoding'] == 'deflate' && $degzdata = @gzuncompress($data))
+								{
+									$data = $degzdata;
+									if($this->debug)
+									print "<PRE>---INFLATED RESPONSE---[".strlen($data)." chars]---\n" . htmlentities($data) . "\n---END---</PRE>";
+								}
+								elseif($GLOBALS['_xh']['headers']['content-encoding'] == 'gzip' && $degzdata = @gzinflate(substr($data, 10)))
+								{
+									$data = $degzdata;
+									if($this->debug)
+									print "<PRE>---INFLATED RESPONSE---[".strlen($data)." chars]---\n" . htmlentities($data) . "\n---END---</PRE>";
+								}
+								else
+								{
+									error_log('XML-RPC: xmlrpcmsg::parseResponse: errors occurred when trying to decode the deflated data received from server');
+									$r =& new xmlrpcresp(0, $GLOBALS['xmlrpcerr']['decompress_fail'], $GLOBALS['xmlrpcstr']['decompress_fail']);
+									return $r;
+								}
+							}
+							else
+							{
+								error_log('XML-RPC: xmlrpcmsg::parseResponse: the server sent deflated data. Your php install must have the Zlib extension compiled in to support this.');
+								$r =& new xmlrpcresp(0, $GLOBALS['xmlrpcerr']['cannot_decompress'], $GLOBALS['xmlrpcstr']['cannot_decompress']);
+								return $r;
+							}
+						}
+					}
+				} // end of 'if needed, de-chunk, re-inflate response'
+
+				// real stupid hack to avoid PHP 4 complaining about returning NULL by ref
+				$r = null;
+				$r =& $r;
+				return $r;
+		}
+
+		/**
+		* Parse the xmlrpc response contained in the string $data and return an xmlrpcresp object.
+		* @param string $data the xmlrpc response, eventually including http headers
+		* @param bool $headers_processed when true prevents parsing HTTP headers for interpretation of content-encoding and consequent decoding
+		* @param string $return_type decides return type, i.e. content of response->value(). Either 'xmlrpcvals', 'xml' or 'phpvals'
+		* @return xmlrpcresp
+		* @access public
+		*/
+		function &parseResponse($data='', $headers_processed=false, $return_type='xmlrpcvals')
+		{
+			if($this->debug)
+			{
+				//by maHo, replaced htmlspecialchars with htmlentities
+				print "<PRE>---GOT---\n" . htmlentities($data) . "\n---END---\n</PRE>";
+			}
+
+			if($data == '')
+			{
+				error_log('XML-RPC: xmlrpcmsg::parseResponse: no response received from server.');
+				$r =& new xmlrpcresp(0, $GLOBALS['xmlrpcerr']['no_data'], $GLOBALS['xmlrpcstr']['no_data']);
+				return $r;
+			}
+
+			$GLOBALS['_xh']=array();
+
+			$raw_data = $data;
+			// parse the HTTP headers of the response, if present, and separate them from data
+			if(substr($data, 0, 4) == 'HTTP')
+			{
+				$r =& $this->parseResponseHeaders($data, $headers_processed);
+				if ($r)
+				{
+					// failed processing of HTTP response headers
+					// save into response obj the full payload received, for debugging
+					$r->raw_data = $data;
+					return $r;
+				}
+			}
+			else
+			{
+				$GLOBALS['_xh']['headers'] = array();
+				$GLOBALS['_xh']['cookies'] = array();
+			}
+
+			if($this->debug)
+			{
+				$start = strpos($data, '<!-- SERVER DEBUG INFO (BASE64 ENCODED):');
+				if ($start)
+				{
+					$start += strlen('<!-- SERVER DEBUG INFO (BASE64 ENCODED):');
+					$end = strpos($data, '-->', $start);
+					$comments = substr($data, $start, $end-$start);
+					print "<PRE>---SERVER DEBUG INFO (DECODED) ---\n\t".htmlentities(str_replace("\n", "\n\t", base64_decode($comments)))."\n---END---\n</PRE>";
+				}
+			}
+
+			// be tolerant of extra whitespace in response body
+			$data = trim($data);
+
+			/// @todo return an error msg if $data=='' ?
+
+			// be tolerant of junk after methodResponse (e.g. javascript ads automatically inserted by free hosts)
+			// idea from Luca Mariano <luca.mariano@email.it> originally in PEARified version of the lib
+			$bd = false;
+			// Poor man's version of strrpos for php 4...
+			$pos = strpos($data, '</methodResponse>');
+			while($pos || is_int($pos))
+			{
+				$bd = $pos+17;
+				$pos = strpos($data, '</methodResponse>', $bd);
+			}
+			if($bd)
+			{
+				$data = substr($data, 0, $bd);
+			}
+
+			// if user wants back raw xml, give it to him
+			if ($return_type == 'xml')
+			{
+				$r =& new xmlrpcresp($data, 0, '', 'xml');
+				$r->hdrs = $GLOBALS['_xh']['headers'];
+				$r->_cookies = $GLOBALS['_xh']['cookies'];
+				$r->raw_data = $raw_data;
+				return $r;
+			}
+
+			// try to 'guestimate' the character encoding of the received response
+			$resp_encoding = guess_encoding(@$GLOBALS['_xh']['headers']['content-type'], $data);
+
+			$GLOBALS['_xh']['ac']='';
+			//$GLOBALS['_xh']['qt']=''; //unused...
+			$GLOBALS['_xh']['stack'] = array();
+			$GLOBALS['_xh']['valuestack'] = array();
+			$GLOBALS['_xh']['isf']=0; // 0 = OK, 1 for xmlrpc fault responses, 2 = invalid xmlrpc
+			$GLOBALS['_xh']['isf_reason']='';
+			$GLOBALS['_xh']['rt']=''; // 'methodcall or 'methodresponse'
+
+			// if response charset encoding is not known / supported, try to use
+			// the default encoding and parse the xml anyway, but log a warning...
+			if (!in_array($resp_encoding, array('UTF-8', 'ISO-8859-1', 'US-ASCII')))
+			// the following code might be better for mb_string enabled installs, but
+			// makes the lib about 200% slower...
+			//if (!is_valid_charset($resp_encoding, array('UTF-8', 'ISO-8859-1', 'US-ASCII')))
+			{
+				error_log('XML-RPC: xmlrpcmsg::parseResponse: invalid charset encoding of received response: '.$resp_encoding);
+				$resp_encoding = $GLOBALS['xmlrpc_defencoding'];
+			}
+			$parser = xml_parser_create($resp_encoding);
+			xml_parser_set_option($parser, XML_OPTION_CASE_FOLDING, true);
+			// G. Giunta 2005/02/13: PHP internally uses ISO-8859-1, so we have to tell
+			// the xml parser to give us back data in the expected charset
+			xml_parser_set_option($parser, XML_OPTION_TARGET_ENCODING, $GLOBALS['xmlrpc_internalencoding']);
+
+			if ($return_type == 'phpvals')
+			{
+				xml_set_element_handler($parser, 'xmlrpc_se', 'xmlrpc_ee_fast');
+			}
+			else
+			{
+				xml_set_element_handler($parser, 'xmlrpc_se', 'xmlrpc_ee');
+			}
+
+			xml_set_character_data_handler($parser, 'xmlrpc_cd');
+			xml_set_default_handler($parser, 'xmlrpc_dh');
+
+			// first error check: xml not well formed
+			if(!xml_parse($parser, $data, count($data)))
+			{
+				// thanks to Peter Kocks <peter.kocks@baygate.com>
+				if((xml_get_current_line_number($parser)) == 1)
+				{
+					$errstr = 'XML error at line 1, check URL';
+				}
+				else
+				{
+					$errstr = sprintf('XML error: %s at line %d, column %d',
+						xml_error_string(xml_get_error_code($parser)),
+						xml_get_current_line_number($parser), xml_get_current_column_number($parser));
+				}
+				error_log($errstr);
+				$r=&new xmlrpcresp(0, $GLOBALS['xmlrpcerr']['invalid_return'], $GLOBALS['xmlrpcstr']['invalid_return'].' ('.$errstr.')');
+				xml_parser_free($parser);
+				if($this->debug)
+				{
+					print $errstr;
+				}
+				$r->hdrs = $GLOBALS['_xh']['headers'];
+				$r->_cookies = $GLOBALS['_xh']['cookies'];
+				$r->raw_data = $raw_data;
+				return $r;
+			}
+			xml_parser_free($parser);
+			// second error check: xml well formed but not xml-rpc compliant
+			if ($GLOBALS['_xh']['isf'] > 1)
+			{
+				if ($this->debug)
+				{
+					/// @todo echo something for user?
+				}
+
+				$r =& new xmlrpcresp(0, $GLOBALS['xmlrpcerr']['invalid_return'],
+				$GLOBALS['xmlrpcstr']['invalid_return'] . ' ' . $GLOBALS['_xh']['isf_reason']);
+			}
+			// third error check: parsing of the response has somehow gone boink.
+			// NB: shall we omit this check, since we trust the parsing code?
+			elseif ($return_type == 'xmlrpcvals' && !is_object($GLOBALS['_xh']['value']))
+			{
+				// something odd has happened
+				// and it's time to generate a client side error
+				// indicating something odd went on
+				$r=&new xmlrpcresp(0, $GLOBALS['xmlrpcerr']['invalid_return'],
+					$GLOBALS['xmlrpcstr']['invalid_return']);
+			}
+			else
+			{
+				if ($this->debug)
+				{
+					print "<PRE>---PARSED---\n";
+					// somehow htmlentities chokes on var_export, and some full html string...
+					//print htmlentitites(var_export($GLOBALS['_xh']['value'], true));
+					print htmlspecialchars(var_export($GLOBALS['_xh']['value'], true));
+					print "\n---END---</PRE>";
+				}
+
+				// note that using =& will raise an error if $GLOBALS['_xh']['st'] does not generate an object.
+				$v =& $GLOBALS['_xh']['value'];
+
+				if($GLOBALS['_xh']['isf'])
+				{
+					/// @todo we should test here if server sent an int and a string,
+					/// and/or coerce them into such...
+					if ($return_type == 'xmlrpcvals')
+					{
+						$errno_v = $v->structmem('faultCode');
+						$errstr_v = $v->structmem('faultString');
+						$errno = $errno_v->scalarval();
+						$errstr = $errstr_v->scalarval();
+					}
+					else
+					{
+						$errno = $v['faultCode'];
+						$errstr = $v['faultString'];
+					}
+
+					if($errno == 0)
+					{
+						// FAULT returned, errno needs to reflect that
+						$errno = -1;
+					}
+
+					$r =& new xmlrpcresp(0, $errno, $errstr);
+				}
+				else
+				{
+					$r=&new xmlrpcresp($v, 0, '', $return_type);
+				}
+			}
+
+			$r->hdrs = $GLOBALS['_xh']['headers'];
+			$r->_cookies = $GLOBALS['_xh']['cookies'];
+			$r->raw_data = $raw_data;
+			return $r;
+		}
+	}
+
+	class xmlrpcval
+	{
+		var $me=array();
+		var $mytype=0;
+		var $_php_class=null;
+
+		/**
+		* @param mixed $val
+		* @param string $type any valid xmlrpc type name (lowercase). If null, 'string' is assumed
+		*/
+		function xmlrpcval($val=-1, $type='')
+		{
+			/// @todo: optimization creep - do not call addXX, do it all inline.
+			/// downside: booleans will not be coerced anymore
+			if($val!==-1 || $type!='')
+			{
+				// optimization creep: inlined all work done by constructor
+				switch($type)
+				{
+					case '':
+						$this->mytype=1;
+						$this->me['string']=$val;
+						break;
+					case 'i4':
+					case 'int':
+					case 'double':
+					case 'string':
+					case 'boolean':
+					case 'dateTime.iso8601':
+					case 'base64':
+					case 'null':
+						$this->mytype=1;
+						$this->me[$type]=$val;
+						break;
+					case 'array':
+						$this->mytype=2;
+						$this->me['array']=$val;
+						break;
+					case 'struct':
+						$this->mytype=3;
+						$this->me['struct']=$val;
+						break;
+					default:
+						error_log("XML-RPC: xmlrpcval::xmlrpcval: not a known type ($type)");
+				}
+				/*if($type=='')
+				{
+					$type='string';
+				}
+				if($GLOBALS['xmlrpcTypes'][$type]==1)
+				{
+					$this->addScalar($val,$type);
+				}
+				elseif($GLOBALS['xmlrpcTypes'][$type]==2)
+				{
+					$this->addArray($val);
+				}
+				elseif($GLOBALS['xmlrpcTypes'][$type]==3)
+				{
+					$this->addStruct($val);
+				}*/
+			}
+		}
+
+		/**
+		* Add a single php value to an (unitialized) xmlrpcval
+		* @param mixed $val
+		* @param string $type
+		* @return int 1 or 0 on failure
+		*/
+		function addScalar($val, $type='string')
+		{
+			$typeof=@$GLOBALS['xmlrpcTypes'][$type];
+			if($typeof!=1)
+			{
+				error_log("XML-RPC: xmlrpcval::addScalar: not a scalar type ($type)");
+				return 0;
+			}
+
+			// coerce booleans into correct values
+			// NB: we should iether do it for datetimes, integers and doubles, too,
+			// or just plain remove this check, implemnted on booleans only...
+			if($type==$GLOBALS['xmlrpcBoolean'])
+			{
+				if(strcasecmp($val,'true')==0 || $val==1 || ($val==true && strcasecmp($val,'false')))
+				{
+					$val=true;
+				}
+				else
+				{
+					$val=false;
+				}
+			}
+
+			switch($this->mytype)
+			{
+				case 1:
+					error_log('XML-RPC: xmlrpcval::addScalar: scalar xmlrpcval can have only one value');
+					return 0;
+				case 3:
+					error_log('XML-RPC: xmlrpcval::addScalar: cannot add anonymous scalar to struct xmlrpcval');
+					return 0;
+				case 2:
+					// we're adding a scalar value to an array here
+					//$ar=$this->me['array'];
+					//$ar[]=&new xmlrpcval($val, $type);
+					//$this->me['array']=$ar;
+					// Faster (?) avoid all the costly array-copy-by-val done here...
+					$this->me['array'][]=&new xmlrpcval($val, $type);
+					return 1;
+				default:
+					// a scalar, so set the value and remember we're scalar
+					$this->me[$type]=$val;
+					$this->mytype=$typeof;
+					return 1;
+			}
+		}
+
+		/**
+		* Add an array of xmlrpcval objects to an xmlrpcval
+		* @param array $vals
+		* @return int 1 or 0 on failure
+		* @access public
+		*
+		* @todo add some checking for $vals to be an array of xmlrpcvals?
+		*/
+		function addArray($vals)
+		{
+			if($this->mytype==0)
+			{
+				$this->mytype=$GLOBALS['xmlrpcTypes']['array'];
+				$this->me['array']=$vals;
+				return 1;
+			}
+			elseif($this->mytype==2)
+			{
+				// we're adding to an array here
+				$this->me['array'] = array_merge($this->me['array'], $vals);
+				return 1;
+			}
+			else
+			{
+				error_log('XML-RPC: xmlrpcval::addArray: already initialized as a [' . $this->kindOf() . ']');
+				return 0;
+			}
+		}
+
+		/**
+		* Add an array of named xmlrpcval objects to an xmlrpcval
+		* @param array $vals
+		* @return int 1 or 0 on failure
+		* @access public
+		*
+		* @todo add some checking for $vals to be an array?
+		*/
+		function addStruct($vals)
+		{
+			if($this->mytype==0)
+			{
+				$this->mytype=$GLOBALS['xmlrpcTypes']['struct'];
+				$this->me['struct']=$vals;
+				return 1;
+			}
+			elseif($this->mytype==3)
+			{
+				// we're adding to a struct here
+				$this->me['struct'] = array_merge($this->me['struct'], $vals);
+				return 1;
+			}
+			else
+			{
+				error_log('XML-RPC: xmlrpcval::addStruct: already initialized as a [' . $this->kindOf() . ']');
+				return 0;
+			}
+		}
+
+		// poor man's version of print_r ???
+		// DEPRECATED!
+		function dump($ar)
+		{
+			foreach($ar as $key => $val)
+			{
+				echo "$key => $val<br />";
+				if($key == 'array')
+				{
+					while(list($key2, $val2) = each($val))
+					{
+						echo "-- $key2 => $val2<br />";
+					}
+				}
+			}
+		}
+
+		/**
+		* Returns a string containing "struct", "array" or "scalar" describing the base type of the value
+		* @return string
+		* @access public
+		*/
+		function kindOf()
+		{
+			switch($this->mytype)
+			{
+				case 3:
+					return 'struct';
+					break;
+				case 2:
+					return 'array';
+					break;
+				case 1:
+					return 'scalar';
+					break;
+				default:
+					return 'undef';
+			}
+		}
+
+		/**
+		* @access private
+		*/
+		function serializedata($typ, $val, $charset_encoding='')
+		{
+			$rs='';
+			switch(@$GLOBALS['xmlrpcTypes'][$typ])
+			{
+				case 1:
+					switch($typ)
+					{
+						case $GLOBALS['xmlrpcBase64']:
+							$rs.="<${typ}>" . base64_encode($val) . "</${typ}>";
+							break;
+						case $GLOBALS['xmlrpcBoolean']:
+							$rs.="<${typ}>" . ($val ? '1' : '0') . "</${typ}>";
+							break;
+						case $GLOBALS['xmlrpcString']:
+							// G. Giunta 2005/2/13: do NOT use htmlentities, since
+							// it will produce named html entities, which are invalid xml
+							$rs.="<${typ}>" . xmlrpc_encode_entitites($val, $GLOBALS['xmlrpc_internalencoding'], $charset_encoding). "</${typ}>";
+							break;
+						case $GLOBALS['xmlrpcInt']:
+						case $GLOBALS['xmlrpcI4']:
+							$rs.="<${typ}>".(int)$val."</${typ}>";
+							break;
+						case $GLOBALS['xmlrpcDouble']:
+							$rs.="<${typ}>".(double)$val."</${typ}>";
+							break;
+						case $GLOBALS['xmlrpcNull']:
+							$rs.="<nil/>";
+							break;
+						default:
+							// no standard type value should arrive here, but provide a possibility
+							// for xmlrpcvals of unknown type...
+							$rs.="<${typ}>${val}</${typ}>";
+					}
+					break;
+				case 3:
+					// struct
+					if ($this->_php_class)
+					{
+						$rs.='<struct php_class="' . $this->_php_class . "\">\n";
+					}
+					else
+					{
+						$rs.="<struct>\n";
+					}
+					foreach($val as $key2 => $val2)
+					{
+						$rs.='<member><name>'.xmlrpc_encode_entitites($key2, $GLOBALS['xmlrpc_internalencoding'], $charset_encoding)."</name>\n";
+						//$rs.=$this->serializeval($val2);
+						$rs.=$val2->serialize($charset_encoding);
+						$rs.="</member>\n";
+					}
+					$rs.='</struct>';
+					break;
+				case 2:
+					// array
+					$rs.="<array>\n<data>\n";
+					for($i=0; $i<count($val); $i++)
+					{
+						//$rs.=$this->serializeval($val[$i]);
+						$rs.=$val[$i]->serialize($charset_encoding);
+					}
+					$rs.="</data>\n</array>";
+					break;
+				default:
+					break;
+			}
+			return $rs;
+		}
+
+		/**
+		* Returns xml representation of the value. XML prologue not included
+		* @param string $charset_encoding the charset to be used for serialization. if null, US-ASCII is assumed
+		* @return string
+		* @access public
+		*/
+		function serialize($charset_encoding='')
+		{
+			// add check? slower, but helps to avoid recursion in serializing broken xmlrpcvals...
+			//if (is_object($o) && (get_class($o) == 'xmlrpcval' || is_subclass_of($o, 'xmlrpcval')))
+			//{
+				reset($this->me);
+				list($typ, $val) = each($this->me);
+				return '<value>' . $this->serializedata($typ, $val, $charset_encoding) . "</value>\n";
+			//}
+		}
+
+		// DEPRECATED
+		function serializeval($o)
+		{
+			// add check? slower, but helps to avoid recursion in serializing broken xmlrpcvals...
+			//if (is_object($o) && (get_class($o) == 'xmlrpcval' || is_subclass_of($o, 'xmlrpcval')))
+			//{
+				$ar=$o->me;
+				reset($ar);
+				list($typ, $val) = each($ar);
+				return '<value>' . $this->serializedata($typ, $val) . "</value>\n";
+			//}
+		}
+
+		/**
+		* Checks wheter a struct member with a given name is present.
+		* Works only on xmlrpcvals of type struct.
+		* @param string $m the name of the struct member to be looked up
+		* @return boolean
+		* @access public
+		*/
+		function structmemexists($m)
+		{
+			return array_key_exists($m, $this->me['struct']);
+		}
+
+		/**
+		* Returns the value of a given struct member (an xmlrpcval object in itself).
+		* Will raise a php warning if struct member of given name does not exist
+		* @param string $m the name of the struct member to be looked up
+		* @return xmlrpcval
+		* @access public
+		*/
+		function structmem($m)
+		{
+			return $this->me['struct'][$m];
+		}
+
+		/**
+		* Reset internal pointer for xmlrpcvals of type struct.
+		* @access public
+		*/
+		function structreset()
+		{
+			reset($this->me['struct']);
+		}
+
+		/**
+		* Return next member element for xmlrpcvals of type struct.
+		* @return xmlrpcval
+		* @access public
+		*/
+		function structeach()
+		{
+			return each($this->me['struct']);
+		}
+
+		// DEPRECATED! this code looks like it is very fragile and has not been fixed
+		// for a long long time. Shall we remove it for 2.0?
+		function getval()
+		{
+			// UNSTABLE
+			reset($this->me);
+			list($a,$b)=each($this->me);
+			// contributed by I Sofer, 2001-03-24
+			// add support for nested arrays to scalarval
+			// i've created a new method here, so as to
+			// preserve back compatibility
+
+			if(is_array($b))
+			{
+				@reset($b);
+				while(list($id,$cont) = @each($b))
+				{
+					$b[$id] = $cont->scalarval();
+				}
+			}
+
+			// add support for structures directly encoding php objects
+			if(is_object($b))
+			{
+				$t = get_object_vars($b);
+				@reset($t);
+				while(list($id,$cont) = @each($t))
+				{
+					$t[$id] = $cont->scalarval();
+				}
+				@reset($t);
+				while(list($id,$cont) = @each($t))
+				{
+					@$b->$id = $cont;
+				}
+			}
+			// end contrib
+			return $b;
+		}
+
+		/**
+		* Returns the value of a scalar xmlrpcval
+		* @return mixed
+		* @access public
+		*/
+		function scalarval()
+		{
+			reset($this->me);
+			list(,$b)=each($this->me);
+			return $b;
+		}
+
+		/**
+		* Returns the type of the xmlrpcval.
+		* For integers, 'int' is always returned in place of 'i4'
+		* @return string
+		* @access public
+		*/
+		function scalartyp()
+		{
+			reset($this->me);
+			list($a,)=each($this->me);
+			if($a==$GLOBALS['xmlrpcI4'])
+			{
+				$a=$GLOBALS['xmlrpcInt'];
+			}
+			return $a;
+		}
+
+		/**
+		* Returns the m-th member of an xmlrpcval of struct type
+		* @param integer $m the index of the value to be retrieved (zero based)
+		* @return xmlrpcval
+		* @access public
+		*/
+		function arraymem($m)
+		{
+			return $this->me['array'][$m];
+		}
+
+		/**
+		* Returns the number of members in an xmlrpcval of array type
+		* @return integer
+		* @access public
+		*/
+		function arraysize()
+		{
+			return count($this->me['array']);
+		}
+
+		/**
+		* Returns the number of members in an xmlrpcval of struct type
+		* @return integer
+		* @access public
+		*/
+		function structsize()
+		{
+			return count($this->me['struct']);
+		}
+	}
+
+
+	// date helpers
+
+	/**
+	* Given a timestamp, return the corresponding ISO8601 encoded string.
+	*
+	* Really, timezones ought to be supported
+	* but the XML-RPC spec says:
+	*
+	* "Don't assume a timezone. It should be specified by the server in its
+	* documentation what assumptions it makes about timezones."
+	*
+	* These routines always assume localtime unless
+	* $utc is set to 1, in which case UTC is assumed
+	* and an adjustment for locale is made when encoding
+	*
+	* @param int $timet (timestamp)
+	* @param int $utc (0 or 1)
+	* @return string
+	*/
+	function iso8601_encode($timet, $utc=0)
+	{
+		if(!$utc)
+		{
+			$t=strftime("%Y%m%dT%H:%M:%S", $timet);
+		}
+		else
+		{
+			if(function_exists('gmstrftime'))
+			{
+				// gmstrftime doesn't exist in some versions
+				// of PHP
+				$t=gmstrftime("%Y%m%dT%H:%M:%S", $timet);
+			}
+			else
+			{
+				$t=strftime("%Y%m%dT%H:%M:%S", $timet-date('Z'));
+			}
+		}
+		return $t;
+	}
+
+	/**
+	* Given an ISO8601 date string, return a timet in the localtime, or UTC
+	* @param string $idate
+	* @param int $utc either 0 or 1
+	* @return int (datetime)
+	*/
+	function iso8601_decode($idate, $utc=0)
+	{
+		$t=0;
+		if(preg_match('/([0-9]{4})([0-9]{2})([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})/', $idate, $regs))
+		{
+			if($utc)
+			{
+				$t=gmmktime($regs[4], $regs[5], $regs[6], $regs[2], $regs[3], $regs[1]);
+			}
+			else
+			{
+				$t=mktime($regs[4], $regs[5], $regs[6], $regs[2], $regs[3], $regs[1]);
+			}
+		}
+		return $t;
+	}
+
+	/**
+	* Takes an xmlrpc value in PHP xmlrpcval object format and translates it into native PHP types.
+	*
+	* Works with xmlrpc message objects as input, too.
+	*
+	* Given proper options parameter, can rebuild generic php object instances
+	* (provided those have been encoded to xmlrpc format using a corresponding
+	* option in php_xmlrpc_encode())
+	* PLEASE NOTE that rebuilding php objects involves calling their constructor function.
+	* This means that the remote communication end can decide which php code will
+	* get executed on your server, leaving the door possibly open to 'php-injection'
+	* style of attacks (provided you have some classes defined on your server that
+	* might wreak havoc if instances are built outside an appropriate context).
+	* Make sure you trust the remote server/client before eanbling this!
+	*
+	* @author Dan Libby (dan@libby.com)
+	*
+	* @param xmlrpcval $xmlrpc_val
+	* @param array $options if 'decode_php_objs' is set in the options array, xmlrpc structs can be decoded into php objects
+	* @return mixed
+	*/
+	function php_xmlrpc_decode($xmlrpc_val, $options=array())
+	{
+		switch($xmlrpc_val->kindOf())
+		{
+			case 'scalar':
+				if (in_array('extension_api', $options))
+				{
+					reset($xmlrpc_val->me);
+					list($typ,$val) = each($xmlrpc_val->me);
+					switch ($typ)
+					{
+						case 'dateTime.iso8601':
+							$xmlrpc_val->scalar = $val;
+							$xmlrpc_val->xmlrpc_type = 'datetime';
+							$xmlrpc_val->timestamp = iso8601_decode($val);
+							return $xmlrpc_val;
+						case 'base64':
+							$xmlrpc_val->scalar = $val;
+							$xmlrpc_val->type = $typ;
+							return $xmlrpc_val;
+						default:
+							return $xmlrpc_val->scalarval();
+					}
+				}
+				return $xmlrpc_val->scalarval();
+			case 'array':
+				$size = $xmlrpc_val->arraysize();
+				$arr = array();
+				for($i = 0; $i < $size; $i++)
+				{
+					$arr[] = php_xmlrpc_decode($xmlrpc_val->arraymem($i), $options);
+				}
+				return $arr;
+			case 'struct':
+				$xmlrpc_val->structreset();
+				// If user said so, try to rebuild php objects for specific struct vals.
+				/// @todo should we raise a warning for class not found?
+				// shall we check for proper subclass of xmlrpcval instead of
+				// presence of _php_class to detect what we can do?
+				if (in_array('decode_php_objs', $options) && $xmlrpc_val->_php_class != ''
+					&& class_exists($xmlrpc_val->_php_class))
+				{
+					$obj = @new $xmlrpc_val->_php_class;
+					while(list($key,$value)=$xmlrpc_val->structeach())
+					{
+						$obj->$key = php_xmlrpc_decode($value, $options);
+					}
+					return $obj;
+				}
+				else
+				{
+					$arr = array();
+					while(list($key,$value)=$xmlrpc_val->structeach())
+					{
+						$arr[$key] = php_xmlrpc_decode($value, $options);
+					}
+					return $arr;
+				}
+			case 'msg':
+				$paramcount = $xmlrpc_val->getNumParams();
+				$arr = array();
+				for($i = 0; $i < $paramcount; $i++)
+				{
+					$arr[] = php_xmlrpc_decode($xmlrpc_val->getParam($i));
+				}
+				return $arr;
+			}
+	}
+
+	// This constant left here only for historical reasons...
+	// it was used to decide if we have to define xmlrpc_encode on our own, but
+	// we do not do it anymore
+	if(function_exists('xmlrpc_decode'))
+	{
+		define('XMLRPC_EPI_ENABLED','1');
+	}
+	else
+	{
+		define('XMLRPC_EPI_ENABLED','0');
+	}
+
+	/**
+	* Takes native php types and encodes them into xmlrpc PHP object format.
+	* It will not re-encode xmlrpcval objects.
+	*
+	* Feature creep -- could support more types via optional type argument
+	* (string => datetime support has been added, ??? => base64 not yet)
+	*
+	* If given a proper options parameter, php object instances will be encoded
+	* into 'special' xmlrpc values, that can later be decoded into php objects
+	* by calling php_xmlrpc_decode() with a corresponding option
+	*
+	* @author Dan Libby (dan@libby.com)
+	*
+	* @param mixed $php_val the value to be converted into an xmlrpcval object
+	* @param array $options	can include 'encode_php_objs', 'auto_dates', 'null_extension' or 'extension_api'
+	* @return xmlrpcval
+	*/
+	function &php_xmlrpc_encode($php_val, $options=array())
+	{
+		$type = gettype($php_val);
+		switch($type)
+		{
+			case 'string':
+				if (in_array('auto_dates', $options) && preg_match('/^[0-9]{8}T[0-9]{2}:[0-9]{2}:[0-9]{2}$/', $php_val))
+					$xmlrpc_val =& new xmlrpcval($php_val, $GLOBALS['xmlrpcDateTime']);
+				else
+					$xmlrpc_val =& new xmlrpcval($php_val, $GLOBALS['xmlrpcString']);
+				break;
+			case 'integer':
+				$xmlrpc_val =& new xmlrpcval($php_val, $GLOBALS['xmlrpcInt']);
+				break;
+			case 'double':
+				$xmlrpc_val =& new xmlrpcval($php_val, $GLOBALS['xmlrpcDouble']);
+				break;
+				// <G_Giunta_2001-02-29>
+				// Add support for encoding/decoding of booleans, since they are supported in PHP
+			case 'boolean':
+				$xmlrpc_val =& new xmlrpcval($php_val, $GLOBALS['xmlrpcBoolean']);
+				break;
+				// </G_Giunta_2001-02-29>
+			case 'array':
+				// PHP arrays can be encoded to either xmlrpc structs or arrays,
+				// depending on wheter they are hashes or plain 0..n integer indexed
+				// A shorter one-liner would be
+				// $tmp = array_diff(array_keys($php_val), range(0, count($php_val)-1));
+				// but execution time skyrockets!
+				$j = 0;
+				$arr = array();
+				$ko = false;
+				foreach($php_val as $key => $val)
+				{
+					$arr[$key] =& php_xmlrpc_encode($val, $options);
+					if(!$ko && $key !== $j)
+					{
+						$ko = true;
+					}
+					$j++;
+				}
+				if($ko)
+				{
+					$xmlrpc_val =& new xmlrpcval($arr, $GLOBALS['xmlrpcStruct']);
+				}
+				else
+				{
+					$xmlrpc_val =& new xmlrpcval($arr, $GLOBALS['xmlrpcArray']);
+				}
+				break;
+			case 'object':
+				if(is_a($php_val, 'xmlrpcval'))
+				{
+					$xmlrpc_val = $php_val;
+				}
+				else
+				{
+					$arr = array();
+					while(list($k,$v) = each($php_val))
+					{
+						$arr[$k] = php_xmlrpc_encode($v, $options);
+					}
+					$xmlrpc_val =& new xmlrpcval($arr, $GLOBALS['xmlrpcStruct']);
+					if (in_array('encode_php_objs', $options))
+					{
+						// let's save original class name into xmlrpcval:
+						// might be useful later on...
+						$xmlrpc_val->_php_class = get_class($php_val);
+					}
+				}
+				break;
+			case 'NULL':
+				if (in_array('extension_api', $options))
+				{
+					$xmlrpc_val =& new xmlrpcval('', $GLOBALS['xmlrpcString']);
+				}
+				if (in_array('null_extension', $options))
+				{
+					$xmlrpc_val =& new xmlrpcval('', $GLOBALS['xmlrpcNull']);
+				}
+				else
+				{
+					$xmlrpc_val =& new xmlrpcval();
+				}
+				break;
+			case 'resource':
+				if (in_array('extension_api', $options))
+				{
+					$xmlrpc_val =& new xmlrpcval((int)$php_val, $GLOBALS['xmlrpcInt']);
+				}
+				else
+				{
+					$xmlrpc_val =& new xmlrpcval();
+				}
+			// catch "user function", "unknown type"
+			default:
+				// giancarlo pinerolo <ping@alt.it>
+				// it has to return
+				// an empty object in case, not a boolean.
+				$xmlrpc_val =& new xmlrpcval();
+				break;
+			}
+			return $xmlrpc_val;
+	}
+
+	/**
+	* Convert the xml representation of a method response, method request or single
+	* xmlrpc value into the appropriate object (a.k.a. deserialize)
+	* @param string $xml_val
+	* @param array $options
+	* @return mixed false on error, or an instance of either xmlrpcval, xmlrpcmsg or xmlrpcresp
+	*/
+	function php_xmlrpc_decode_xml($xml_val, $options=array())
+	{
+		$GLOBALS['_xh'] = array();
+		$GLOBALS['_xh']['ac'] = '';
+		$GLOBALS['_xh']['stack'] = array();
+		$GLOBALS['_xh']['valuestack'] = array();
+		$GLOBALS['_xh']['params'] = array();
+		$GLOBALS['_xh']['pt'] = array();
+		$GLOBALS['_xh']['isf'] = 0;
+		$GLOBALS['_xh']['isf_reason'] = '';
+		$GLOBALS['_xh']['method'] = false;
+		$GLOBALS['_xh']['rt'] = '';
+		/// @todo 'guestimate' encoding
+		$parser = xml_parser_create();
+		xml_parser_set_option($parser, XML_OPTION_CASE_FOLDING, true);
+		xml_parser_set_option($parser, XML_OPTION_TARGET_ENCODING, $GLOBALS['xmlrpc_internalencoding']);
+		xml_set_element_handler($parser, 'xmlrpc_se_any', 'xmlrpc_ee');
+		xml_set_character_data_handler($parser, 'xmlrpc_cd');
+		xml_set_default_handler($parser, 'xmlrpc_dh');
+		if(!xml_parse($parser, $xml_val, 1))
+		{
+			$errstr = sprintf('XML error: %s at line %d, column %d',
+						xml_error_string(xml_get_error_code($parser)),
+						xml_get_current_line_number($parser), xml_get_current_column_number($parser));
+			error_log($errstr);
+			xml_parser_free($parser);
+			return false;
+		}
+		xml_parser_free($parser);
+		if ($GLOBALS['_xh']['isf'] > 1) // test that $GLOBALS['_xh']['value'] is an obj, too???
+		{
+			error_log($GLOBALS['_xh']['isf_reason']);
+			return false;
+		}
+		switch ($GLOBALS['_xh']['rt'])
+		{
+			case 'methodresponse':
+				$v =& $GLOBALS['_xh']['value'];
+				if ($GLOBALS['_xh']['isf'] == 1)
+				{
+					$vc = $v->structmem('faultCode');
+					$vs = $v->structmem('faultString');
+					$r =& new xmlrpcresp(0, $vc->scalarval(), $vs->scalarval());
+				}
+				else
+				{
+					$r =& new xmlrpcresp($v);
+				}
+				return $r;
+			case 'methodcall':
+				$m =& new xmlrpcmsg($GLOBALS['_xh']['method']);
+				for($i=0; $i < count($GLOBALS['_xh']['params']); $i++)
+				{
+					$m->addParam($GLOBALS['_xh']['params'][$i]);
+				}
+				return $m;
+			case 'value':
+				return $GLOBALS['_xh']['value'];
+			default:
+				return false;
+		}
+	}
+
+	/**
+	* decode a string that is encoded w/ "chunked" transfer encoding
+	* as defined in rfc2068 par. 19.4.6
+	* code shamelessly stolen from nusoap library by Dietrich Ayala
+	*
+	* @param string $buffer the string to be decoded
+	* @return string
+	*/
+	function decode_chunked($buffer)
+	{
+		// length := 0
+		$length = 0;
+		$new = '';
+
+		// read chunk-size, chunk-extension (if any) and crlf
+		// get the position of the linebreak
+		$chunkend = strpos($buffer,"\r\n") + 2;
+		$temp = substr($buffer,0,$chunkend);
+		$chunk_size = hexdec( trim($temp) );
+		$chunkstart = $chunkend;
+		while($chunk_size > 0)
+		{
+			$chunkend = strpos($buffer, "\r\n", $chunkstart + $chunk_size);
+
+			// just in case we got a broken connection
+			if($chunkend == false)
+			{
+				$chunk = substr($buffer,$chunkstart);
+				// append chunk-data to entity-body
+				$new .= $chunk;
+				$length += strlen($chunk);
+				break;
+			}
+
+			// read chunk-data and crlf
+			$chunk = substr($buffer,$chunkstart,$chunkend-$chunkstart);
+			// append chunk-data to entity-body
+			$new .= $chunk;
+			// length := length + chunk-size
+			$length += strlen($chunk);
+			// read chunk-size and crlf
+			$chunkstart = $chunkend + 2;
+
+			$chunkend = strpos($buffer,"\r\n",$chunkstart)+2;
+			if($chunkend == false)
+			{
+				break; //just in case we got a broken connection
+			}
+			$temp = substr($buffer,$chunkstart,$chunkend-$chunkstart);
+			$chunk_size = hexdec( trim($temp) );
+			$chunkstart = $chunkend;
+		}
+		return $new;
+	}
+
+	/**
+	* xml charset encoding guessing helper function.
+	* Tries to determine the charset encoding of an XML chunk
+	* received over HTTP.
+	* NB: according to the spec (RFC 3023, if text/xml content-type is received over HTTP without a content-type,
+	* we SHOULD assume it is strictly US-ASCII. But we try to be more tolerant of unconforming (legacy?) clients/servers,
+	* which will be most probably using UTF-8 anyway...
+	*
+	* @param string $httpheaders the http Content-type header
+	* @param string $xmlchunk xml content buffer
+	* @param string $encoding_prefs comma separated list of character encodings to be used as default (when mb extension is enabled)
+	*
+	* @todo explore usage of mb_http_input(): does it detect http headers + post data? if so, use it instead of hand-detection!!!
+	*/
+	function guess_encoding($httpheader='', $xmlchunk='', $encoding_prefs=null)
+	{
+		// discussion: see http://www.yale.edu/pclt/encoding/
+		// 1 - test if encoding is specified in HTTP HEADERS
+
+		//Details:
+		// LWS:           (\13\10)?( |\t)+
+		// token:         (any char but excluded stuff)+
+		// header:        Content-type = ...; charset=value(; ...)*
+		//   where value is of type token, no LWS allowed between 'charset' and value
+		// Note: we do not check for invalid chars in VALUE:
+		//   this had better be done using pure ereg as below
+
+		/// @todo this test will pass if ANY header has charset specification, not only Content-Type. Fix it?
+		$matches = array();
+		if(preg_match('/;\s*charset=([^;]+)/i', $httpheader, $matches))
+		{
+			return strtoupper(trim($matches[1]));
+		}
+
+		// 2 - scan the first bytes of the data for a UTF-16 (or other) BOM pattern
+		//     (source: http://www.w3.org/TR/2000/REC-xml-20001006)
+		//     NOTE: actually, according to the spec, even if we find the BOM and determine
+		//     an encoding, we should check if there is an encoding specified
+		//     in the xml declaration, and verify if they match.
+		/// @todo implement check as described above?
+		/// @todo implement check for first bytes of string even without a BOM? (It sure looks harder than for cases WITH a BOM)
+		if(preg_match('/^(\x00\x00\xFE\xFF|\xFF\xFE\x00\x00|\x00\x00\xFF\xFE|\xFE\xFF\x00\x00)/', $xmlchunk))
+		{
+			return 'UCS-4';
+		}
+		elseif(preg_match('/^(\xFE\xFF|\xFF\xFE)/', $xmlchunk))
+		{
+			return 'UTF-16';
+		}
+		elseif(preg_match('/^(\xEF\xBB\xBF)/', $xmlchunk))
+		{
+			return 'UTF-8';
+		}
+
+		// 3 - test if encoding is specified in the xml declaration
+		// Details:
+		// SPACE:         (#x20 | #x9 | #xD | #xA)+ === [ \x9\xD\xA]+
+		// EQ:            SPACE?=SPACE? === [ \x9\xD\xA]*=[ \x9\xD\xA]*
+		if (preg_match('/^<\?xml\s+version\s*=\s*'. "((?:\"[a-zA-Z0-9_.:-]+\")|(?:'[a-zA-Z0-9_.:-]+'))".
+			'\s+encoding\s*=\s*' . "((?:\"[A-Za-z][A-Za-z0-9._-]*\")|(?:'[A-Za-z][A-Za-z0-9._-]*'))/",
+			$xmlchunk, $matches))
+		{
+			return strtoupper(substr($matches[2], 1, -1));
+		}
+
+		// 4 - if mbstring is available, let it do the guesswork
+		// NB: we favour finding an encoding that is compatible with what we can process
+		if(extension_loaded('mbstring'))
+		{
+			if($encoding_prefs)
+			{
+				$enc = mb_detect_encoding($xmlchunk, $encoding_prefs);
+			}
+			else
+			{
+				$enc = mb_detect_encoding($xmlchunk);
+			}
+			// NB: mb_detect likes to call it ascii, xml parser likes to call it US_ASCII...
+			// IANA also likes better US-ASCII, so go with it
+			if($enc == 'ASCII')
+			{
+				$enc = 'US-'.$enc;
+			}
+			return $enc;
+		}
+		else
+		{
+			// no encoding specified: as per HTTP1.1 assume it is iso-8859-1?
+			// Both RFC 2616 (HTTP 1.1) and 1945(http 1.0) clearly state that for text/xxx content types
+			// this should be the standard. And we should be getting text/xml as request and response.
+			// BUT we have to be backward compatible with the lib, which always used UTF-8 as default...
+			return $GLOBALS['xmlrpc_defencoding'];
+		}
+	}
+
+	/**
+	* Checks if a given charset encoding is present in a list of encodings or
+	* if it is a valid subset of any encoding in the list
+	* @param string $encoding charset to be tested
+	* @param mixed $validlist comma separated list of valid charsets (or array of charsets)
+	*/
+	function is_valid_charset($encoding, $validlist)
+	{
+		$charset_supersets = array(
+			'US-ASCII' => array ('ISO-8859-1', 'ISO-8859-2', 'ISO-8859-3', 'ISO-8859-4',
+				'ISO-8859-5', 'ISO-8859-6', 'ISO-8859-7', 'ISO-8859-8',
+				'ISO-8859-9', 'ISO-8859-10', 'ISO-8859-11', 'ISO-8859-12',
+				'ISO-8859-13', 'ISO-8859-14', 'ISO-8859-15', 'UTF-8',
+				'EUC-JP', 'EUC-', 'EUC-KR', 'EUC-CN')
+		);
+		if (is_string($validlist))
+			$validlist = explode(',', $validlist);
+		if (@in_array(strtoupper($encoding), $validlist))
+			return true;
+		else
+		{
+			if (array_key_exists($encoding, $charset_supersets))
+				foreach ($validlist as $allowed)
+					if (in_array($allowed, $charset_supersets[$encoding]))
+						return true;
+				return false;
+		}
+	}
+
+?>
\ No newline at end of file

Property changes on: trunk/wikipathways/wpi/includes/xmlrpc.inc
___________________________________________________________________
Name: svn:executable
   + *

Index: trunk/wikipathways/wpi/includes/zip.lib.php
===================================================================
--- trunk/wikipathways/wpi/includes/zip.lib.php	(revision 0)
+++ trunk/wikipathways/wpi/includes/zip.lib.php	(revision 1110)
@@ -0,0 +1,68 @@
+<?php
+// $Id: zip.lib.php 47 2005-09-15 02:55:27Z rhuk $
+//
+// The "GNU General Public License" (GPL) is available at
+// http://www.gnu.org/copyleft/gpl.html.
+//
+//  http://www.zend.com/codex.php?id=535&single=1
+//	By Eric Mueller <eric@themepark.com>
+//
+//	http://www.zend.com/codex.php?id=470&single=1
+//	by Denis125 <webmaster@atlant.ru>
+//
+//	A patch from Peter Listiak <mlady@users.sourceforge.net> for last modified
+//	date and time of the compressed file
+//
+//	Official ZIP file format: http://www.pkware.com/appnote.txt
+
+class zipfile {
+	var $datasec = array();
+	var $ctrl_dir = array();
+	var $eof_ctrl_dir = "\x50\x4b\x05\x06\x00\x00\x00\x00";
+	var $old_offset = 0;
+
+	function unix2DosTime($unixtime = 0) {
+		$timearray = ($unixtime == 0) ? getdate() : getdate($unixtime);
+		if ($timearray['year'] < 1980) {
+			$timearray['year']= 1980;
+			$timearray['mon'] = 1;
+			$timearray['mday']= 1;
+			$timearray['hours']	= 0;
+			$timearray['minutes'] = 0;
+			$timearray['seconds'] = 0;
+		}
+		return (($timearray['year'] - 1980) << 25) | ($timearray['mon'] << 21) | ($timearray['mday'] << 16) | ($timearray['hours'] << 11) | ($timearray['minutes'] << 5) | ($timearray['seconds'] >> 1);
+	}
+
+	function addFile($data, $name, $time = 0) {
+		$name = str_replace('\\', '/', $name);
+
+		$dtime= dechex($this->unix2DosTime($time));
+		$hexdtime = '\x' . $dtime[6] . $dtime[7] . '\x' . $dtime[4] . $dtime[5] . '\x' . $dtime[2] . $dtime[3] . '\x' . $dtime[0] . $dtime[1];
+		eval('$hexdtime = "' . $hexdtime . '";');
+
+		$fr = "\x50\x4b\x03\x04\x14\x00\x00\x00\x08\x00" . $hexdtime;
+
+		$unc_len = strlen($data);
+		$crc = crc32($data);
+		$zdata = gzcompress($data);
+		$zdata = substr(substr($zdata, 0, strlen($zdata) - 4), 2);
+		$c_len	= strlen($zdata);
+		$fr .= pack('V', $crc) . pack('V', $c_len) . pack('V', $unc_len) . pack('v', strlen($name)) . pack('v', 0) . $name . $zdata . pack('V', $crc) . pack('V', $c_len) . pack('V', $unc_len);
+
+		$this -> datasec[] = $fr;
+		$new_offset = strlen(implode('', $this->datasec));
+
+		$cdrec = "\x50\x4b\x01\x02\x00\x00\x14\x00\x00\x00\x08\x00" . $hexdtime . pack('V', $crc) . pack('V', $c_len) . pack('V', $unc_len) . pack('v', strlen($name)) . pack('v', 0) . pack('v', 0) . pack('v', 0) . pack('v', 0) . pack('V', 32) . pack('V', $this -> old_offset );
+		$this -> old_offset = $new_offset;
+		$cdrec .= $name;
+		$this -> ctrl_dir[] = $cdrec;
+	}
+
+	function file() {
+		$data = implode('', $this -> datasec);
+		$ctrldir = implode('', $this -> ctrl_dir);
+		return $data . $ctrldir . $this -> eof_ctrl_dir . pack('v', sizeof($this -> ctrl_dir)) .  pack('v', sizeof($this -> ctrl_dir)) .  pack('V', strlen($ctrldir)) . pack('V', strlen($data)) . "\x00\x00";
+	}
+}
+?>
Index: trunk/wikipathways/wpi/bin/pathvisio_wikipathways.jnlp
===================================================================
--- trunk/wikipathways/wpi/bin/pathvisio_wikipathways.jnlp	(revision 0)
+++ trunk/wikipathways/wpi/bin/pathvisio_wikipathways.jnlp	(revision 1110)
@@ -0,0 +1,63 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<jnlp codebase="http://www.wikipathways.org/wpi/bin/" href="pathvisio_wikipathways.jnlp">
+	<information>
+		 <title>PathVisio 1.0</title>
+		 <vendor>BiGCaT Bioinformatics, Maastricht University</vendor>
+		 <homepage href="index.html"/>
+		 <icon href="bigcateye.gif"/>
+		 <offline-allowed/>
+	</information>
+	<resources>
+		 <j2se version="1.5+"/>
+		 <jar href="pathvisio_v1.jar"/>
+		 <jar href="resources.jar"/>
+		<!-- <jar href="hsqldb.jar"/> -->
+		 <jar href="derby.jar"/>
+		 <jar href="BrowserLauncher.jar"/>
+		 <jar href="jdom.jar"/>
+		 <jar href="org.eclipse.core.commands.jar"/>
+		 <jar href="org.eclipse.equinox.common.jar"/>
+		 <jar href="org.eclipse.jface.jar"/>
+		 <jar href="org.eclipse.equinox.supplement.jar"/>
+		 <jar href="apache/commons-codec-1.3.jar"/>
+		 <jar href="apache/commons-httpclient-3.0.1.jar"/>
+		 <jar href="apache/commons-logging-1.1.jar"/>
+		 <jar href="apache/ws-commons-util-1.0.1.jar"/>
+		 <jar href="apache/xmlrpc-client-3.0.jar"/>
+		 <jar href="apache/xmlrpc-common-3.0.jar"/>
+		 <jar href="batik/batik-awt-util.jar"/>
+		 <jar href="batik/batik-bridge.jar"/>
+		 <jar href="batik/batik-css.jar"/>
+		 <jar href="batik/batik-dom.jar"/>
+		 <jar href="batik/batik-ext.jar"/>
+		 <jar href="batik/batik-extension.jar"/>
+		 <jar href="batik/batik-gvt.jar"/>
+		 <jar href="batik/batik-parser.jar"/>
+		 <jar href="batik/batik-script.jar"/>
+		 <jar href="batik/batik-svg-dom.jar"/>
+		 <jar href="batik/batik-svggen.jar"/>
+		 <jar href="batik/batik-transcoder.jar"/>
+		 <jar href="batik/batik-util.jar"/>
+		 <jar href="batik/batik-xml.jar"/>
+		 <jar href="batik/pdf-transcoder.jar"/>
+		 <jar href="batik/xml-apis.jar"/>
+	</resources>
+	<resources os="Windows">
+		<jar href="swt-win32.jar"/>
+		<nativelib href="swt-win32-lib.jar"/>	
+	</resources>
+	<resources os="Linux">
+		<jar href="swt-linux.jar"/>
+		<nativelib href="swt-linux-lib.jar"/>	
+	</resources>
+	<resources os="Mac OS X">
+		<jar href="swt-mac.jar"/>
+		<nativelib href="swt-mac-lib.jar"/>	
+	</resources>
+	<application-desc main-class="org.wikipathways.core.WikiPathways">
+		<!--ARG-->
+	</application-desc>
+	<security>
+		 <all-permissions/>
+	</security>
+</jnlp>
Index: trunk/wikipathways/wpi/crontab
===================================================================
--- trunk/wikipathways/wpi/crontab	(revision 0)
+++ trunk/wikipathways/wpi/crontab	(revision 1110)
@@ -0,0 +1,2 @@
+00 00 * * * /var/www/wikipathways/wpi/sitemap/runSiteMap.sh
+00 00 * * * rm /var/www/wikipathways/wpi/tmp/*
Index: trunk/wikipathways/wpi/globals.php
===================================================================
--- trunk/wikipathways/wpi/globals.php	(revision 0)
+++ trunk/wikipathways/wpi/globals.php	(revision 1110)
@@ -0,0 +1,33 @@
+<?php
+
+//File types
+define("FILETYPE_IMG", "svg");
+define("FILETYPE_GPML", "gpml");
+define("FILETYPE_MAPP", "mapp");
+define("FILETYPE_PNG", "png");
+
+//Script info
+$wpiScriptPath = 'wpi';
+$wpiScriptFile = 'wpi.php';
+$wpiScript = "$wpiScriptPath/$wpiScriptFile"; 
+$wpiTmpPath = "$wpiScriptPath/tmp";
+$wpiScriptURL =  "http://" . $_SERVER['HTTP_HOST'] . '/' . $wpiScript; //TODO: use these variables
+$wpiTmpURL = "http://" . $_SERVER['HTTP_HOST'] . '/' . $wpiTmpPath;
+
+$wpiScript = 'wpi.php'; //name of the wpi script
+$wpiPath = 'wpi'; //path containing wpi script relative to url
+$wpiTmpPath = 'tmp'; //temp path, relative to wpi path
+
+define("WPI_SCRIPT_PATH", realpath('.'));
+define("WPI_SCRIPT", realpath($wpiScriptFile));
+define("WPI_TMP_PATH", realpath($wpiTmpPath));
+define("WPI_URL",  "http://" . $_SERVER['HTTP_HOST'] . '/' . $wpiPath);
+define("WPI_SCRIPT_URL", WPI_URL . '/' . $wpiScriptFile);
+define("WPI_TMP_URL", WPI_URL . '/' . $wpiPath . '/' . $wpiTmpPath);
+
+//JS info
+define("JS_SRC_EDITAPPLET", "/wpi/js/editapplet.js");
+define("JS_SRC_RESIZE", "/wpi/js/resize.js");
+define("JS_SRC_PROTOTYPE", "/wpi/js/prototype.js");
+define("JS_SRC_APPLETOBJECT", "/wpi/js/appletobject.js");
+?>
Index: trunk/wikipathways/wpi/wpi_rpc.php
===================================================================
--- trunk/wikipathways/wpi/wpi_rpc.php	(revision 0)
+++ trunk/wikipathways/wpi/wpi_rpc.php	(revision 1110)
@@ -0,0 +1,49 @@
+<?php
+
+error_reporting(E_ERROR); //Supress warnings etc...will disrupt the rpc response
+
+//Load XML-RCP libraries
+require("includes/xmlrpc.inc");
+require("includes/xmlrpcs.inc");
+
+//Load WikiPathways Interface
+require("wpi.php");
+
+//Definition of functions
+$updatePathway_sig=array(array(
+							$xmlrpcBoolean, 
+							$xmlrpcString, $xmlrpcString, $xmlrpcString, $xmlrpcBase64
+						));
+
+$updatePathway_doc='updatePathway';
+
+//Definition of dispatch map
+$disp_map=array(     "WikiPathways.updatePathway" => 
+                           array("function" => "updatePathway",
+                           "signature" => $updatePathway_sig,
+                           "docstring" => $updatePathway_doc),
+);
+
+//Setup the XML-RPC server
+$s=new xmlrpc_server($disp_map,0);
+$s->functions_parameters_type = 'phpvals';
+//$s->setDebug(3);
+$s->service();
+
+//Functions
+function updatePathway($pwName, $pwSpecies, $description, $gpmlData64) {
+	global $xmlrpcerruser;
+	
+	$resp = TRUE;
+	try {
+		$pathway = new Pathway($pwName, $pwSpecies);
+		$gpmlData = base64_decode($gpmlData64);
+		$pathway->updatePathway($gpmlData, $description);
+	} catch(Exception $e) {
+		wfDebug("XML-RPC ERROR: $e");
+		$resp = new xmlrpcresp(0, $xmlrpcerruser, $e->getMessage());
+	}
+	ob_clean(); //Clean the output buffer, so nothing is printed before the xml response
+	return $resp;
+}
+?>

Property changes on: trunk/wikipathways/wpi/wpi_rpc.php
___________________________________________________________________
Name: svn:executable
   + *

Index: trunk/wikipathways/wpi/js/prototype.js
===================================================================
--- trunk/wikipathways/wpi/js/prototype.js	(revision 0)
+++ trunk/wikipathways/wpi/js/prototype.js	(revision 1110)
@@ -0,0 +1,3277 @@
+/*  Prototype JavaScript framework, version 1.5.1.1
+ *  (c) 2005-2007 Sam Stephenson
+ *
+ *  Prototype is freely distributable under the terms of an MIT-style license.
+ *  For details, see the Prototype web site: http://www.prototypejs.org/
+ *
+/*--------------------------------------------------------------------------*/
+
+var Prototype = {
+  Version: '1.5.1.1',
+
+  Browser: {
+    IE:     !!(window.attachEvent && !window.opera),
+    Opera:  !!window.opera,
+    WebKit: navigator.userAgent.indexOf('AppleWebKit/') > -1,
+    Gecko:  navigator.userAgent.indexOf('Gecko') > -1 && navigator.userAgent.indexOf('KHTML') == -1
+  },
+
+  BrowserFeatures: {
+    XPath: !!document.evaluate,
+    ElementExtensions: !!window.HTMLElement,
+    SpecificElementExtensions:
+      (document.createElement('div').__proto__ !==
+       document.createElement('form').__proto__)
+  },
+
+  ScriptFragment: '<script[^>]*>([\\S\\s]*?)<\/script>',
+  JSONFilter: /^\/\*-secure-([\s\S]*)\*\/\s*$/,
+
+  emptyFunction: function() { },
+  K: function(x) { return x }
+}
+
+var Class = {
+  create: function() {
+    return function() {
+      this.initialize.apply(this, arguments);
+    }
+  }
+}
+
+var Abstract = new Object();
+
+Object.extend = function(destination, source) {
+  for (var property in source) {
+    destination[property] = source[property];
+  }
+  return destination;
+}
+
+Object.extend(Object, {
+  inspect: function(object) {
+    try {
+      if (object === undefined) return 'undefined';
+      if (object === null) return 'null';
+      return object.inspect ? object.inspect() : object.toString();
+    } catch (e) {
+      if (e instanceof RangeError) return '...';
+      throw e;
+    }
+  },
+
+  toJSON: function(object) {
+    var type = typeof object;
+    switch(type) {
+      case 'undefined':
+      case 'function':
+      case 'unknown': return;
+      case 'boolean': return object.toString();
+    }
+    if (object === null) return 'null';
+    if (object.toJSON) return object.toJSON();
+    if (object.ownerDocument === document) return;
+    var results = [];
+    for (var property in object) {
+      var value = Object.toJSON(object[property]);
+      if (value !== undefined)
+        results.push(property.toJSON() + ': ' + value);
+    }
+    return '{' + results.join(', ') + '}';
+  },
+
+  keys: function(object) {
+    var keys = [];
+    for (var property in object)
+      keys.push(property);
+    return keys;
+  },
+
+  values: function(object) {
+    var values = [];
+    for (var property in object)
+      values.push(object[property]);
+    return values;
+  },
+
+  clone: function(object) {
+    return Object.extend({}, object);
+  }
+});
+
+Function.prototype.bind = function() {
+  var __method = this, args = $A(arguments), object = args.shift();
+  return function() {
+    return __method.apply(object, args.concat($A(arguments)));
+  }
+}
+
+Function.prototype.bindAsEventListener = function(object) {
+  var __method = this, args = $A(arguments), object = args.shift();
+  return function(event) {
+    return __method.apply(object, [event || window.event].concat(args));
+  }
+}
+
+Object.extend(Number.prototype, {
+  toColorPart: function() {
+    return this.toPaddedString(2, 16);
+  },
+
+  succ: function() {
+    return this + 1;
+  },
+
+  times: function(iterator) {
+    $R(0, this, true).each(iterator);
+    return this;
+  },
+
+  toPaddedString: function(length, radix) {
+    var string = this.toString(radix || 10);
+    return '0'.times(length - string.length) + string;
+  },
+
+  toJSON: function() {
+    return isFinite(this) ? this.toString() : 'null';
+  }
+});
+
+Date.prototype.toJSON = function() {
+  return '"' + this.getFullYear() + '-' +
+    (this.getMonth() + 1).toPaddedString(2) + '-' +
+    this.getDate().toPaddedString(2) + 'T' +
+    this.getHours().toPaddedString(2) + ':' +
+    this.getMinutes().toPaddedString(2) + ':' +
+    this.getSeconds().toPaddedString(2) + '"';
+};
+
+var Try = {
+  these: function() {
+    var returnValue;
+
+    for (var i = 0, length = arguments.length; i < length; i++) {
+      var lambda = arguments[i];
+      try {
+        returnValue = lambda();
+        break;
+      } catch (e) {}
+    }
+
+    return returnValue;
+  }
+}
+
+/*--------------------------------------------------------------------------*/
+
+var PeriodicalExecuter = Class.create();
+PeriodicalExecuter.prototype = {
+  initialize: function(callback, frequency) {
+    this.callback = callback;
+    this.frequency = frequency;
+    this.currentlyExecuting = false;
+
+    this.registerCallback();
+  },
+
+  registerCallback: function() {
+    this.timer = setInterval(this.onTimerEvent.bind(this), this.frequency * 1000);
+  },
+
+  stop: function() {
+    if (!this.timer) return;
+    clearInterval(this.timer);
+    this.timer = null;
+  },
+
+  onTimerEvent: function() {
+    if (!this.currentlyExecuting) {
+      try {
+        this.currentlyExecuting = true;
+        this.callback(this);
+      } finally {
+        this.currentlyExecuting = false;
+      }
+    }
+  }
+}
+Object.extend(String, {
+  interpret: function(value) {
+    return value == null ? '' : String(value);
+  },
+  specialChar: {
+    '\b': '\\b',
+    '\t': '\\t',
+    '\n': '\\n',
+    '\f': '\\f',
+    '\r': '\\r',
+    '\\': '\\\\'
+  }
+});
+
+Object.extend(String.prototype, {
+  gsub: function(pattern, replacement) {
+    var result = '', source = this, match;
+    replacement = arguments.callee.prepareReplacement(replacement);
+
+    while (source.length > 0) {
+      if (match = source.match(pattern)) {
+        result += source.slice(0, match.index);
+        result += String.interpret(replacement(match));
+        source  = source.slice(match.index + match[0].length);
+      } else {
+        result += source, source = '';
+      }
+    }
+    return result;
+  },
+
+  sub: function(pattern, replacement, count) {
+    replacement = this.gsub.prepareReplacement(replacement);
+    count = count === undefined ? 1 : count;
+
+    return this.gsub(pattern, function(match) {
+      if (--count < 0) return match[0];
+      return replacement(match);
+    });
+  },
+
+  scan: function(pattern, iterator) {
+    this.gsub(pattern, iterator);
+    return this;
+  },
+
+  truncate: function(length, truncation) {
+    length = length || 30;
+    truncation = truncation === undefined ? '...' : truncation;
+    return this.length > length ?
+      this.slice(0, length - truncation.length) + truncation : this;
+  },
+
+  strip: function() {
+    return this.replace(/^\s+/, '').replace(/\s+$/, '');
+  },
+
+  stripTags: function() {
+    return this.replace(/<\/?[^>]+>/gi, '');
+  },
+
+  stripScripts: function() {
+    return this.replace(new RegExp(Prototype.ScriptFragment, 'img'), '');
+  },
+
+  extractScripts: function() {
+    var matchAll = new RegExp(Prototype.ScriptFragment, 'img');
+    var matchOne = new RegExp(Prototype.ScriptFragment, 'im');
+    return (this.match(matchAll) || []).map(function(scriptTag) {
+      return (scriptTag.match(matchOne) || ['', ''])[1];
+    });
+  },
+
+  evalScripts: function() {
+    return this.extractScripts().map(function(script) { return eval(script) });
+  },
+
+  escapeHTML: function() {
+    var self = arguments.callee;
+    self.text.data = this;
+    return self.div.innerHTML;
+  },
+
+  unescapeHTML: function() {
+    var div = document.createElement('div');
+    div.innerHTML = this.stripTags();
+    return div.childNodes[0] ? (div.childNodes.length > 1 ?
+      $A(div.childNodes).inject('', function(memo, node) { return memo+node.nodeValue }) :
+      div.childNodes[0].nodeValue) : '';
+  },
+
+  toQueryParams: function(separator) {
+    var match = this.strip().match(/([^?#]*)(#.*)?$/);
+    if (!match) return {};
+
+    return match[1].split(separator || '&').inject({}, function(hash, pair) {
+      if ((pair = pair.split('='))[0]) {
+        var key = decodeURIComponent(pair.shift());
+        var value = pair.length > 1 ? pair.join('=') : pair[0];
+        if (value != undefined) value = decodeURIComponent(value);
+
+        if (key in hash) {
+          if (hash[key].constructor != Array) hash[key] = [hash[key]];
+          hash[key].push(value);
+        }
+        else hash[key] = value;
+      }
+      return hash;
+    });
+  },
+
+  toArray: function() {
+    return this.split('');
+  },
+
+  succ: function() {
+    return this.slice(0, this.length - 1) +
+      String.fromCharCode(this.charCodeAt(this.length - 1) + 1);
+  },
+
+  times: function(count) {
+    var result = '';
+    for (var i = 0; i < count; i++) result += this;
+    return result;
+  },
+
+  camelize: function() {
+    var parts = this.split('-'), len = parts.length;
+    if (len == 1) return parts[0];
+
+    var camelized = this.charAt(0) == '-'
+      ? parts[0].charAt(0).toUpperCase() + parts[0].substring(1)
+      : parts[0];
+
+    for (var i = 1; i < len; i++)
+      camelized += parts[i].charAt(0).toUpperCase() + parts[i].substring(1);
+
+    return camelized;
+  },
+
+  capitalize: function() {
+    return this.charAt(0).toUpperCase() + this.substring(1).toLowerCase();
+  },
+
+  underscore: function() {
+    return this.gsub(/::/, '/').gsub(/([A-Z]+)([A-Z][a-z])/,'#{1}_#{2}').gsub(/([a-z\d])([A-Z])/,'#{1}_#{2}').gsub(/-/,'_').toLowerCase();
+  },
+
+  dasherize: function() {
+    return this.gsub(/_/,'-');
+  },
+
+  inspect: function(useDoubleQuotes) {
+    var escapedString = this.gsub(/[\x00-\x1f\\]/, function(match) {
+      var character = String.specialChar[match[0]];
+      return character ? character : '\\u00' + match[0].charCodeAt().toPaddedString(2, 16);
+    });
+    if (useDoubleQuotes) return '"' + escapedString.replace(/"/g, '\\"') + '"';
+    return "'" + escapedString.replace(/'/g, '\\\'') + "'";
+  },
+
+  toJSON: function() {
+    return this.inspect(true);
+  },
+
+  unfilterJSON: function(filter) {
+    return this.sub(filter || Prototype.JSONFilter, '#{1}');
+  },
+
+  isJSON: function() {
+    var str = this.replace(/\\./g, '@').replace(/"[^"\\\n\r]*"/g, '');
+    return (/^[,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]*$/).test(str);
+  },
+
+  evalJSON: function(sanitize) {
+    var json = this.unfilterJSON();
+    try {
+      if (!sanitize || json.isJSON()) return eval('(' + json + ')');
+    } catch (e) { }
+    throw new SyntaxError('Badly formed JSON string: ' + this.inspect());
+  },
+
+  include: function(pattern) {
+    return this.indexOf(pattern) > -1;
+  },
+
+  startsWith: function(pattern) {
+    return this.indexOf(pattern) === 0;
+  },
+
+  endsWith: function(pattern) {
+    var d = this.length - pattern.length;
+    return d >= 0 && this.lastIndexOf(pattern) === d;
+  },
+
+  empty: function() {
+    return this == '';
+  },
+
+  blank: function() {
+    return /^\s*$/.test(this);
+  }
+});
+
+if (Prototype.Browser.WebKit || Prototype.Browser.IE) Object.extend(String.prototype, {
+  escapeHTML: function() {
+    return this.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
+  },
+  unescapeHTML: function() {
+    return this.replace(/&amp;/g,'&').replace(/&lt;/g,'<').replace(/&gt;/g,'>');
+  }
+});
+
+String.prototype.gsub.prepareReplacement = function(replacement) {
+  if (typeof replacement == 'function') return replacement;
+  var template = new Template(replacement);
+  return function(match) { return template.evaluate(match) };
+}
+
+String.prototype.parseQuery = String.prototype.toQueryParams;
+
+Object.extend(String.prototype.escapeHTML, {
+  div:  document.createElement('div'),
+  text: document.createTextNode('')
+});
+
+with (String.prototype.escapeHTML) div.appendChild(text);
+
+var Template = Class.create();
+Template.Pattern = /(^|.|\r|\n)(#\{(.*?)\})/;
+Template.prototype = {
+  initialize: function(template, pattern) {
+    this.template = template.toString();
+    this.pattern  = pattern || Template.Pattern;
+  },
+
+  evaluate: function(object) {
+    return this.template.gsub(this.pattern, function(match) {
+      var before = match[1];
+      if (before == '\\') return match[2];
+      return before + String.interpret(object[match[3]]);
+    });
+  }
+}
+
+var $break = {}, $continue = new Error('"throw $continue" is deprecated, use "return" instead');
+
+var Enumerable = {
+  each: function(iterator) {
+    var index = 0;
+    try {
+      this._each(function(value) {
+        iterator(value, index++);
+      });
+    } catch (e) {
+      if (e != $break) throw e;
+    }
+    return this;
+  },
+
+  eachSlice: function(number, iterator) {
+    var index = -number, slices = [], array = this.toArray();
+    while ((index += number) < array.length)
+      slices.push(array.slice(index, index+number));
+    return slices.map(iterator);
+  },
+
+  all: function(iterator) {
+    var result = true;
+    this.each(function(value, index) {
+      result = result && !!(iterator || Prototype.K)(value, index);
+      if (!result) throw $break;
+    });
+    return result;
+  },
+
+  any: function(iterator) {
+    var result = false;
+    this.each(function(value, index) {
+      if (result = !!(iterator || Prototype.K)(value, index))
+        throw $break;
+    });
+    return result;
+  },
+
+  collect: function(iterator) {
+    var results = [];
+    this.each(function(value, index) {
+      results.push((iterator || Prototype.K)(value, index));
+    });
+    return results;
+  },
+
+  detect: function(iterator) {
+    var result;
+    this.each(function(value, index) {
+      if (iterator(value, index)) {
+        result = value;
+        throw $break;
+      }
+    });
+    return result;
+  },
+
+  findAll: function(iterator) {
+    var results = [];
+    this.each(function(value, index) {
+      if (iterator(value, index))
+        results.push(value);
+    });
+    return results;
+  },
+
+  grep: function(pattern, iterator) {
+    var results = [];
+    this.each(function(value, index) {
+      var stringValue = value.toString();
+      if (stringValue.match(pattern))
+        results.push((iterator || Prototype.K)(value, index));
+    })
+    return results;
+  },
+
+  include: function(object) {
+    var found = false;
+    this.each(function(value) {
+      if (value == object) {
+        found = true;
+        throw $break;
+      }
+    });
+    return found;
+  },
+
+  inGroupsOf: function(number, fillWith) {
+    fillWith = fillWith === undefined ? null : fillWith;
+    return this.eachSlice(number, function(slice) {
+      while(slice.length < number) slice.push(fillWith);
+      return slice;
+    });
+  },
+
+  inject: function(memo, iterator) {
+    this.each(function(value, index) {
+      memo = iterator(memo, value, index);
+    });
+    return memo;
+  },
+
+  invoke: function(method) {
+    var args = $A(arguments).slice(1);
+    return this.map(function(value) {
+      return value[method].apply(value, args);
+    });
+  },
+
+  max: function(iterator) {
+    var result;
+    this.each(function(value, index) {
+      value = (iterator || Prototype.K)(value, index);
+      if (result == undefined || value >= result)
+        result = value;
+    });
+    return result;
+  },
+
+  min: function(iterator) {
+    var result;
+    this.each(function(value, index) {
+      value = (iterator || Prototype.K)(value, index);
+      if (result == undefined || value < result)
+        result = value;
+    });
+    return result;
+  },
+
+  partition: function(iterator) {
+    var trues = [], falses = [];
+    this.each(function(value, index) {
+      ((iterator || Prototype.K)(value, index) ?
+        trues : falses).push(value);
+    });
+    return [trues, falses];
+  },
+
+  pluck: function(property) {
+    var results = [];
+    this.each(function(value, index) {
+      results.push(value[property]);
+    });
+    return results;
+  },
+
+  reject: function(iterator) {
+    var results = [];
+    this.each(function(value, index) {
+      if (!iterator(value, index))
+        results.push(value);
+    });
+    return results;
+  },
+
+  sortBy: function(iterator) {
+    return this.map(function(value, index) {
+      return {value: value, criteria: iterator(value, index)};
+    }).sort(function(left, right) {
+      var a = left.criteria, b = right.criteria;
+      return a < b ? -1 : a > b ? 1 : 0;
+    }).pluck('value');
+  },
+
+  toArray: function() {
+    return this.map();
+  },
+
+  zip: function() {
+    var iterator = Prototype.K, args = $A(arguments);
+    if (typeof args.last() == 'function')
+      iterator = args.pop();
+
+    var collections = [this].concat(args).map($A);
+    return this.map(function(value, index) {
+      return iterator(collections.pluck(index));
+    });
+  },
+
+  size: function() {
+    return this.toArray().length;
+  },
+
+  inspect: function() {
+    return '#<Enumerable:' + this.toArray().inspect() + '>';
+  }
+}
+
+Object.extend(Enumerable, {
+  map:     Enumerable.collect,
+  find:    Enumerable.detect,
+  select:  Enumerable.findAll,
+  member:  Enumerable.include,
+  entries: Enumerable.toArray
+});
+var $A = Array.from = function(iterable) {
+  if (!iterable) return [];
+  if (iterable.toArray) {
+    return iterable.toArray();
+  } else {
+    var results = [];
+    for (var i = 0, length = iterable.length; i < length; i++)
+      results.push(iterable[i]);
+    return results;
+  }
+}
+
+if (Prototype.Browser.WebKit) {
+  $A = Array.from = function(iterable) {
+    if (!iterable) return [];
+    if (!(typeof iterable == 'function' && iterable == '[object NodeList]') &&
+      iterable.toArray) {
+      return iterable.toArray();
+    } else {
+      var results = [];
+      for (var i = 0, length = iterable.length; i < length; i++)
+        results.push(iterable[i]);
+      return results;
+    }
+  }
+}
+
+Object.extend(Array.prototype, Enumerable);
+
+if (!Array.prototype._reverse)
+  Array.prototype._reverse = Array.prototype.reverse;
+
+Object.extend(Array.prototype, {
+  _each: function(iterator) {
+    for (var i = 0, length = this.length; i < length; i++)
+      iterator(this[i]);
+  },
+
+  clear: function() {
+    this.length = 0;
+    return this;
+  },
+
+  first: function() {
+    return this[0];
+  },
+
+  last: function() {
+    return this[this.length - 1];
+  },
+
+  compact: function() {
+    return this.select(function(value) {
+      return value != null;
+    });
+  },
+
+  flatten: function() {
+    return this.inject([], function(array, value) {
+      return array.concat(value && value.constructor == Array ?
+        value.flatten() : [value]);
+    });
+  },
+
+  without: function() {
+    var values = $A(arguments);
+    return this.select(function(value) {
+      return !values.include(value);
+    });
+  },
+
+  indexOf: function(object) {
+    for (var i = 0, length = this.length; i < length; i++)
+      if (this[i] == object) return i;
+    return -1;
+  },
+
+  reverse: function(inline) {
+    return (inline !== false ? this : this.toArray())._reverse();
+  },
+
+  reduce: function() {
+    return this.length > 1 ? this : this[0];
+  },
+
+  uniq: function(sorted) {
+    return this.inject([], function(array, value, index) {
+      if (0 == index || (sorted ? array.last() != value : !array.include(value)))
+        array.push(value);
+      return array;
+    });
+  },
+
+  clone: function() {
+    return [].concat(this);
+  },
+
+  size: function() {
+    return this.length;
+  },
+
+  inspect: function() {
+    return '[' + this.map(Object.inspect).join(', ') + ']';
+  },
+
+  toJSON: function() {
+    var results = [];
+    this.each(function(object) {
+      var value = Object.toJSON(object);
+      if (value !== undefined) results.push(value);
+    });
+    return '[' + results.join(', ') + ']';
+  }
+});
+
+Array.prototype.toArray = Array.prototype.clone;
+
+function $w(string) {
+  string = string.strip();
+  return string ? string.split(/\s+/) : [];
+}
+
+if (Prototype.Browser.Opera){
+  Array.prototype.concat = function() {
+    var array = [];
+    for (var i = 0, length = this.length; i < length; i++) array.push(this[i]);
+    for (var i = 0, length = arguments.length; i < length; i++) {
+      if (arguments[i].constructor == Array) {
+        for (var j = 0, arrayLength = arguments[i].length; j < arrayLength; j++)
+          array.push(arguments[i][j]);
+      } else {
+        array.push(arguments[i]);
+      }
+    }
+    return array;
+  }
+}
+var Hash = function(object) {
+  if (object instanceof Hash) this.merge(object);
+  else Object.extend(this, object || {});
+};
+
+Object.extend(Hash, {
+  toQueryString: function(obj) {
+    var parts = [];
+    parts.add = arguments.callee.addPair;
+
+    this.prototype._each.call(obj, function(pair) {
+      if (!pair.key) return;
+      var value = pair.value;
+
+      if (value && typeof value == 'object') {
+        if (value.constructor == Array) value.each(function(value) {
+          parts.add(pair.key, value);
+        });
+        return;
+      }
+      parts.add(pair.key, value);
+    });
+
+    return parts.join('&');
+  },
+
+  toJSON: function(object) {
+    var results = [];
+    this.prototype._each.call(object, function(pair) {
+      var value = Object.toJSON(pair.value);
+      if (value !== undefined) results.push(pair.key.toJSON() + ': ' + value);
+    });
+    return '{' + results.join(', ') + '}';
+  }
+});
+
+Hash.toQueryString.addPair = function(key, value, prefix) {
+  key = encodeURIComponent(key);
+  if (value === undefined) this.push(key);
+  else this.push(key + '=' + (value == null ? '' : encodeURIComponent(value)));
+}
+
+Object.extend(Hash.prototype, Enumerable);
+Object.extend(Hash.prototype, {
+  _each: function(iterator) {
+    for (var key in this) {
+      var value = this[key];
+      if (value && value == Hash.prototype[key]) continue;
+
+      var pair = [key, value];
+      pair.key = key;
+      pair.value = value;
+      iterator(pair);
+    }
+  },
+
+  keys: function() {
+    return this.pluck('key');
+  },
+
+  values: function() {
+    return this.pluck('value');
+  },
+
+  merge: function(hash) {
+    return $H(hash).inject(this, function(mergedHash, pair) {
+      mergedHash[pair.key] = pair.value;
+      return mergedHash;
+    });
+  },
+
+  remove: function() {
+    var result;
+    for(var i = 0, length = arguments.length; i < length; i++) {
+      var value = this[arguments[i]];
+      if (value !== undefined){
+        if (result === undefined) result = value;
+        else {
+          if (result.constructor != Array) result = [result];
+          result.push(value)
+        }
+      }
+      delete this[arguments[i]];
+    }
+    return result;
+  },
+
+  toQueryString: function() {
+    return Hash.toQueryString(this);
+  },
+
+  inspect: function() {
+    return '#<Hash:{' + this.map(function(pair) {
+      return pair.map(Object.inspect).join(': ');
+    }).join(', ') + '}>';
+  },
+
+  toJSON: function() {
+    return Hash.toJSON(this);
+  }
+});
+
+function $H(object) {
+  if (object instanceof Hash) return object;
+  return new Hash(object);
+};
+
+// Safari iterates over shadowed properties
+if (function() {
+  var i = 0, Test = function(value) { this.key = value };
+  Test.prototype.key = 'foo';
+  for (var property in new Test('bar')) i++;
+  return i > 1;
+}()) Hash.prototype._each = function(iterator) {
+  var cache = [];
+  for (var key in this) {
+    var value = this[key];
+    if ((value && value == Hash.prototype[key]) || cache.include(key)) continue;
+    cache.push(key);
+    var pair = [key, value];
+    pair.key = key;
+    pair.value = value;
+    iterator(pair);
+  }
+};
+ObjectRange = Class.create();
+Object.extend(ObjectRange.prototype, Enumerable);
+Object.extend(ObjectRange.prototype, {
+  initialize: function(start, end, exclusive) {
+    this.start = start;
+    this.end = end;
+    this.exclusive = exclusive;
+  },
+
+  _each: function(iterator) {
+    var value = this.start;
+    while (this.include(value)) {
+      iterator(value);
+      value = value.succ();
+    }
+  },
+
+  include: function(value) {
+    if (value < this.start)
+      return false;
+    if (this.exclusive)
+      return value < this.end;
+    return value <= this.end;
+  }
+});
+
+var $R = function(start, end, exclusive) {
+  return new ObjectRange(start, end, exclusive);
+}
+
+var Ajax = {
+  getTransport: function() {
+    return Try.these(
+      function() {return new XMLHttpRequest()},
+      function() {return new ActiveXObject('Msxml2.XMLHTTP')},
+      function() {return new ActiveXObject('Microsoft.XMLHTTP')}
+    ) || false;
+  },
+
+  activeRequestCount: 0
+}
+
+Ajax.Responders = {
+  responders: [],
+
+  _each: function(iterator) {
+    this.responders._each(iterator);
+  },
+
+  register: function(responder) {
+    if (!this.include(responder))
+      this.responders.push(responder);
+  },
+
+  unregister: function(responder) {
+    this.responders = this.responders.without(responder);
+  },
+
+  dispatch: function(callback, request, transport, json) {
+    this.each(function(responder) {
+      if (typeof responder[callback] == 'function') {
+        try {
+          responder[callback].apply(responder, [request, transport, json]);
+        } catch (e) {}
+      }
+    });
+  }
+};
+
+Object.extend(Ajax.Responders, Enumerable);
+
+Ajax.Responders.register({
+  onCreate: function() {
+    Ajax.activeRequestCount++;
+  },
+  onComplete: function() {
+    Ajax.activeRequestCount--;
+  }
+});
+
+Ajax.Base = function() {};
+Ajax.Base.prototype = {
+  setOptions: function(options) {
+    this.options = {
+      method:       'post',
+      asynchronous: true,
+      contentType:  'application/x-www-form-urlencoded',
+      encoding:     'UTF-8',
+      parameters:   ''
+    }
+    Object.extend(this.options, options || {});
+
+    this.options.method = this.options.method.toLowerCase();
+    if (typeof this.options.parameters == 'string')
+      this.options.parameters = this.options.parameters.toQueryParams();
+  }
+}
+
+Ajax.Request = Class.create();
+Ajax.Request.Events =
+  ['Uninitialized', 'Loading', 'Loaded', 'Interactive', 'Complete'];
+
+Ajax.Request.prototype = Object.extend(new Ajax.Base(), {
+  _complete: false,
+
+  initialize: function(url, options) {
+    this.transport = Ajax.getTransport();
+    this.setOptions(options);
+    this.request(url);
+  },
+
+  request: function(url) {
+    this.url = url;
+    this.method = this.options.method;
+    var params = Object.clone(this.options.parameters);
+
+    if (!['get', 'post'].include(this.method)) {
+      // simulate other verbs over post
+      params['_method'] = this.method;
+      this.method = 'post';
+    }
+
+    this.parameters = params;
+
+    if (params = Hash.toQueryString(params)) {
+      // when GET, append parameters to URL
+      if (this.method == 'get')
+        this.url += (this.url.include('?') ? '&' : '?') + params;
+      else if (/Konqueror|Safari|KHTML/.test(navigator.userAgent))
+        params += '&_=';
+    }
+
+    try {
+      if (this.options.onCreate) this.options.onCreate(this.transport);
+      Ajax.Responders.dispatch('onCreate', this, this.transport);
+
+      this.transport.open(this.method.toUpperCase(), this.url,
+        this.options.asynchronous);
+
+      if (this.options.asynchronous)
+        setTimeout(function() { this.respondToReadyState(1) }.bind(this), 10);
+
+      this.transport.onreadystatechange = this.onStateChange.bind(this);
+      this.setRequestHeaders();
+
+      this.body = this.method == 'post' ? (this.options.postBody || params) : null;
+      this.transport.send(this.body);
+
+      /* Force Firefox to handle ready state 4 for synchronous requests */
+      if (!this.options.asynchronous && this.transport.overrideMimeType)
+        this.onStateChange();
+
+    }
+    catch (e) {
+      this.dispatchException(e);
+    }
+  },
+
+  onStateChange: function() {
+    var readyState = this.transport.readyState;
+    if (readyState > 1 && !((readyState == 4) && this._complete))
+      this.respondToReadyState(this.transport.readyState);
+  },
+
+  setRequestHeaders: function() {
+    var headers = {
+      'X-Requested-With': 'XMLHttpRequest',
+      'X-Prototype-Version': Prototype.Version,
+      'Accept': 'text/javascript, text/html, application/xml, text/xml, */*'
+    };
+
+    if (this.method == 'post') {
+      headers['Content-type'] = this.options.contentType +
+        (this.options.encoding ? '; charset=' + this.options.encoding : '');
+
+      /* Force "Connection: close" for older Mozilla browsers to work
+       * around a bug where XMLHttpRequest sends an incorrect
+       * Content-length header. See Mozilla Bugzilla #246651.
+       */
+      if (this.transport.overrideMimeType &&
+          (navigator.userAgent.match(/Gecko\/(\d{4})/) || [0,2005])[1] < 2005)
+            headers['Connection'] = 'close';
+    }
+
+    // user-defined headers
+    if (typeof this.options.requestHeaders == 'object') {
+      var extras = this.options.requestHeaders;
+
+      if (typeof extras.push == 'function')
+        for (var i = 0, length = extras.length; i < length; i += 2)
+          headers[extras[i]] = extras[i+1];
+      else
+        $H(extras).each(function(pair) { headers[pair.key] = pair.value });
+    }
+
+    for (var name in headers)
+      this.transport.setRequestHeader(name, headers[name]);
+  },
+
+  success: function() {
+    return !this.transport.status
+        || (this.transport.status >= 200 && this.transport.status < 300);
+  },
+
+  respondToReadyState: function(readyState) {
+    var state = Ajax.Request.Events[readyState];
+    var transport = this.transport, json = this.evalJSON();
+
+    if (state == 'Complete') {
+      try {
+        this._complete = true;
+        (this.options['on' + this.transport.status]
+         || this.options['on' + (this.success() ? 'Success' : 'Failure')]
+         || Prototype.emptyFunction)(transport, json);
+      } catch (e) {
+        this.dispatchException(e);
+      }
+
+      var contentType = this.getHeader('Content-type');
+      if (contentType && contentType.strip().
+        match(/^(text|application)\/(x-)?(java|ecma)script(;.*)?$/i))
+          this.evalResponse();
+    }
+
+    try {
+      (this.options['on' + state] || Prototype.emptyFunction)(transport, json);
+      Ajax.Responders.dispatch('on' + state, this, transport, json);
+    } catch (e) {
+      this.dispatchException(e);
+    }
+
+    if (state == 'Complete') {
+      // avoid memory leak in MSIE: clean up
+      this.transport.onreadystatechange = Prototype.emptyFunction;
+    }
+  },
+
+  getHeader: function(name) {
+    try {
+      return this.transport.getResponseHeader(name);
+    } catch (e) { return null }
+  },
+
+  evalJSON: function() {
+    try {
+      var json = this.getHeader('X-JSON');
+      return json ? json.evalJSON() : null;
+    } catch (e) { return null }
+  },
+
+  evalResponse: function() {
+    try {
+      return eval((this.transport.responseText || '').unfilterJSON());
+    } catch (e) {
+      this.dispatchException(e);
+    }
+  },
+
+  dispatchException: function(exception) {
+    (this.options.onException || Prototype.emptyFunction)(this, exception);
+    Ajax.Responders.dispatch('onException', this, exception);
+  }
+});
+
+Ajax.Updater = Class.create();
+
+Object.extend(Object.extend(Ajax.Updater.prototype, Ajax.Request.prototype), {
+  initialize: function(container, url, options) {
+    this.container = {
+      success: (container.success || container),
+      failure: (container.failure || (container.success ? null : container))
+    }
+
+    this.transport = Ajax.getTransport();
+    this.setOptions(options);
+
+    var onComplete = this.options.onComplete || Prototype.emptyFunction;
+    this.options.onComplete = (function(transport, param) {
+      this.updateContent();
+      onComplete(transport, param);
+    }).bind(this);
+
+    this.request(url);
+  },
+
+  updateContent: function() {
+    var receiver = this.container[this.success() ? 'success' : 'failure'];
+    var response = this.transport.responseText;
+
+    if (!this.options.evalScripts) response = response.stripScripts();
+
+    if (receiver = $(receiver)) {
+      if (this.options.insertion)
+        new this.options.insertion(receiver, response);
+      else
+        receiver.update(response);
+    }
+
+    if (this.success()) {
+      if (this.onComplete)
+        setTimeout(this.onComplete.bind(this), 10);
+    }
+  }
+});
+
+Ajax.PeriodicalUpdater = Class.create();
+Ajax.PeriodicalUpdater.prototype = Object.extend(new Ajax.Base(), {
+  initialize: function(container, url, options) {
+    this.setOptions(options);
+    this.onComplete = this.options.onComplete;
+
+    this.frequency = (this.options.frequency || 2);
+    this.decay = (this.options.decay || 1);
+
+    this.updater = {};
+    this.container = container;
+    this.url = url;
+
+    this.start();
+  },
+
+  start: function() {
+    this.options.onComplete = this.updateComplete.bind(this);
+    this.onTimerEvent();
+  },
+
+  stop: function() {
+    this.updater.options.onComplete = undefined;
+    clearTimeout(this.timer);
+    (this.onComplete || Prototype.emptyFunction).apply(this, arguments);
+  },
+
+  updateComplete: function(request) {
+    if (this.options.decay) {
+      this.decay = (request.responseText == this.lastText ?
+        this.decay * this.options.decay : 1);
+
+      this.lastText = request.responseText;
+    }
+    this.timer = setTimeout(this.onTimerEvent.bind(this),
+      this.decay * this.frequency * 1000);
+  },
+
+  onTimerEvent: function() {
+    this.updater = new Ajax.Updater(this.container, this.url, this.options);
+  }
+});
+function $(element) {
+  if (arguments.length > 1) {
+    for (var i = 0, elements = [], length = arguments.length; i < length; i++)
+      elements.push($(arguments[i]));
+    return elements;
+  }
+  if (typeof element == 'string')
+    element = document.getElementById(element);
+  return Element.extend(element);
+}
+
+if (Prototype.BrowserFeatures.XPath) {
+  document._getElementsByXPath = function(expression, parentElement) {
+    var results = [];
+    var query = document.evaluate(expression, $(parentElement) || document,
+      null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
+    for (var i = 0, length = query.snapshotLength; i < length; i++)
+      results.push(query.snapshotItem(i));
+    return results;
+  };
+
+  document.getElementsByClassName = function(className, parentElement) {
+    var q = ".//*[contains(concat(' ', @class, ' '), ' " + className + " ')]";
+    return document._getElementsByXPath(q, parentElement);
+  }
+
+} else document.getElementsByClassName = function(className, parentElement) {
+  var children = ($(parentElement) || document.body).getElementsByTagName('*');
+  var elements = [], child, pattern = new RegExp("(^|\\s)" + className + "(\\s|$)");
+  for (var i = 0, length = children.length; i < length; i++) {
+    child = children[i];
+    var elementClassName = child.className;
+    if (elementClassName.length == 0) continue;
+    if (elementClassName == className || elementClassName.match(pattern))
+      elements.push(Element.extend(child));
+  }
+  return elements;
+};
+
+/*--------------------------------------------------------------------------*/
+
+if (!window.Element) var Element = {};
+
+Element.extend = function(element) {
+  var F = Prototype.BrowserFeatures;
+  if (!element || !element.tagName || element.nodeType == 3 ||
+   element._extended || F.SpecificElementExtensions || element == window)
+    return element;
+
+  var methods = {}, tagName = element.tagName, cache = Element.extend.cache,
+   T = Element.Methods.ByTag;
+
+  // extend methods for all tags (Safari doesn't need this)
+  if (!F.ElementExtensions) {
+    Object.extend(methods, Element.Methods),
+    Object.extend(methods, Element.Methods.Simulated);
+  }
+
+  // extend methods for specific tags
+  if (T[tagName]) Object.extend(methods, T[tagName]);
+
+  for (var property in methods) {
+    var value = methods[property];
+    if (typeof value == 'function' && !(property in element))
+      element[property] = cache.findOrStore(value);
+  }
+
+  element._extended = Prototype.emptyFunction;
+  return element;
+};
+
+Element.extend.cache = {
+  findOrStore: function(value) {
+    return this[value] = this[value] || function() {
+      return value.apply(null, [this].concat($A(arguments)));
+    }
+  }
+};
+
+Element.Methods = {
+  visible: function(element) {
+    return $(element).style.display != 'none';
+  },
+
+  toggle: function(element) {
+    element = $(element);
+    Element[Element.visible(element) ? 'hide' : 'show'](element);
+    return element;
+  },
+
+  hide: function(element) {
+    $(element).style.display = 'none';
+    return element;
+  },
+
+  show: function(element) {
+    $(element).style.display = '';
+    return element;
+  },
+
+  remove: function(element) {
+    element = $(element);
+    element.parentNode.removeChild(element);
+    return element;
+  },
+
+  update: function(element, html) {
+    html = typeof html == 'undefined' ? '' : html.toString();
+    $(element).innerHTML = html.stripScripts();
+    setTimeout(function() {html.evalScripts()}, 10);
+    return element;
+  },
+
+  replace: function(element, html) {
+    element = $(element);
+    html = typeof html == 'undefined' ? '' : html.toString();
+    if (element.outerHTML) {
+      element.outerHTML = html.stripScripts();
+    } else {
+      var range = element.ownerDocument.createRange();
+      range.selectNodeContents(element);
+      element.parentNode.replaceChild(
+        range.createContextualFragment(html.stripScripts()), element);
+    }
+    setTimeout(function() {html.evalScripts()}, 10);
+    return element;
+  },
+
+  inspect: function(element) {
+    element = $(element);
+    var result = '<' + element.tagName.toLowerCase();
+    $H({'id': 'id', 'className': 'class'}).each(function(pair) {
+      var property = pair.first(), attribute = pair.last();
+      var value = (element[property] || '').toString();
+      if (value) result += ' ' + attribute + '=' + value.inspect(true);
+    });
+    return result + '>';
+  },
+
+  recursivelyCollect: function(element, property) {
+    element = $(element);
+    var elements = [];
+    while (element = element[property])
+      if (element.nodeType == 1)
+        elements.push(Element.extend(element));
+    return elements;
+  },
+
+  ancestors: function(element) {
+    return $(element).recursivelyCollect('parentNode');
+  },
+
+  descendants: function(element) {
+    return $A($(element).getElementsByTagName('*')).each(Element.extend);
+  },
+
+  firstDescendant: function(element) {
+    element = $(element).firstChild;
+    while (element && element.nodeType != 1) element = element.nextSibling;
+    return $(element);
+  },
+
+  immediateDescendants: function(element) {
+    if (!(element = $(element).firstChild)) return [];
+    while (element && element.nodeType != 1) element = element.nextSibling;
+    if (element) return [element].concat($(element).nextSiblings());
+    return [];
+  },
+
+  previousSiblings: function(element) {
+    return $(element).recursivelyCollect('previousSibling');
+  },
+
+  nextSiblings: function(element) {
+    return $(element).recursivelyCollect('nextSibling');
+  },
+
+  siblings: function(element) {
+    element = $(element);
+    return element.previousSiblings().reverse().concat(element.nextSiblings());
+  },
+
+  match: function(element, selector) {
+    if (typeof selector == 'string')
+      selector = new Selector(selector);
+    return selector.match($(element));
+  },
+
+  up: function(element, expression, index) {
+    element = $(element);
+    if (arguments.length == 1) return $(element.parentNode);
+    var ancestors = element.ancestors();
+    return expression ? Selector.findElement(ancestors, expression, index) :
+      ancestors[index || 0];
+  },
+
+  down: function(element, expression, index) {
+    element = $(element);
+    if (arguments.length == 1) return element.firstDescendant();
+    var descendants = element.descendants();
+    return expression ? Selector.findElement(descendants, expression, index) :
+      descendants[index || 0];
+  },
+
+  previous: function(element, expression, index) {
+    element = $(element);
+    if (arguments.length == 1) return $(Selector.handlers.previousElementSibling(element));
+    var previousSiblings = element.previousSiblings();
+    return expression ? Selector.findElement(previousSiblings, expression, index) :
+      previousSiblings[index || 0];
+  },
+
+  next: function(element, expression, index) {
+    element = $(element);
+    if (arguments.length == 1) return $(Selector.handlers.nextElementSibling(element));
+    var nextSiblings = element.nextSiblings();
+    return expression ? Selector.findElement(nextSiblings, expression, index) :
+      nextSiblings[index || 0];
+  },
+
+  getElementsBySelector: function() {
+    var args = $A(arguments), element = $(args.shift());
+    return Selector.findChildElements(element, args);
+  },
+
+  getElementsByClassName: function(element, className) {
+    return document.getElementsByClassName(className, element);
+  },
+
+  readAttribute: function(element, name) {
+    element = $(element);
+    if (Prototype.Browser.IE) {
+      if (!element.attributes) return null;
+      var t = Element._attributeTranslations;
+      if (t.values[name]) return t.values[name](element, name);
+      if (t.names[name])  name = t.names[name];
+      var attribute = element.attributes[name];
+      return attribute ? attribute.nodeValue : null;
+    }
+    return element.getAttribute(name);
+  },
+
+  getHeight: function(element) {
+    return $(element).getDimensions().height;
+  },
+
+  getWidth: function(element) {
+    return $(element).getDimensions().width;
+  },
+
+  classNames: function(element) {
+    return new Element.ClassNames(element);
+  },
+
+  hasClassName: function(element, className) {
+    if (!(element = $(element))) return;
+    var elementClassName = element.className;
+    if (elementClassName.length == 0) return false;
+    if (elementClassName == className ||
+        elementClassName.match(new RegExp("(^|\\s)" + className + "(\\s|$)")))
+      return true;
+    return false;
+  },
+
+  addClassName: function(element, className) {
+    if (!(element = $(element))) return;
+    Element.classNames(element).add(className);
+    return element;
+  },
+
+  removeClassName: function(element, className) {
+    if (!(element = $(element))) return;
+    Element.classNames(element).remove(className);
+    return element;
+  },
+
+  toggleClassName: function(element, className) {
+    if (!(element = $(element))) return;
+    Element.classNames(element)[element.hasClassName(className) ? 'remove' : 'add'](className);
+    return element;
+  },
+
+  observe: function() {
+    Event.observe.apply(Event, arguments);
+    return $A(arguments).first();
+  },
+
+  stopObserving: function() {
+    Event.stopObserving.apply(Event, arguments);
+    return $A(arguments).first();
+  },
+
+  // removes whitespace-only text node children
+  cleanWhitespace: function(element) {
+    element = $(element);
+    var node = element.firstChild;
+    while (node) {
+      var nextNode = node.nextSibling;
+      if (node.nodeType == 3 && !/\S/.test(node.nodeValue))
+        element.removeChild(node);
+      node = nextNode;
+    }
+    return element;
+  },
+
+  empty: function(element) {
+    return $(element).innerHTML.blank();
+  },
+
+  descendantOf: function(element, ancestor) {
+    element = $(element), ancestor = $(ancestor);
+    while (element = element.parentNode)
+      if (element == ancestor) return true;
+    return false;
+  },
+
+  scrollTo: function(element) {
+    element = $(element);
+    var pos = Position.cumulativeOffset(element);
+    window.scrollTo(pos[0], pos[1]);
+    return element;
+  },
+
+  getStyle: function(element, style) {
+    element = $(element);
+    style = style == 'float' ? 'cssFloat' : style.camelize();
+    var value = element.style[style];
+    if (!value) {
+      var css = document.defaultView.getComputedStyle(element, null);
+      value = css ? css[style] : null;
+    }
+    if (style == 'opacity') return value ? parseFloat(value) : 1.0;
+    return value == 'auto' ? null : value;
+  },
+
+  getOpacity: function(element) {
+    return $(element).getStyle('opacity');
+  },
+
+  setStyle: function(element, styles, camelized) {
+    element = $(element);
+    var elementStyle = element.style;
+
+    for (var property in styles)
+      if (property == 'opacity') element.setOpacity(styles[property])
+      else
+        elementStyle[(property == 'float' || property == 'cssFloat') ?
+          (elementStyle.styleFloat === undefined ? 'cssFloat' : 'styleFloat') :
+          (camelized ? property : property.camelize())] = styles[property];
+
+    return element;
+  },
+
+  setOpacity: function(element, value) {
+    element = $(element);
+    element.style.opacity = (value == 1 || value === '') ? '' :
+      (value < 0.00001) ? 0 : value;
+    return element;
+  },
+
+  getDimensions: function(element) {
+    element = $(element);
+    var display = $(element).getStyle('display');
+    if (display != 'none' && display != null) // Safari bug
+      return {width: element.offsetWidth, height: element.offsetHeight};
+
+    // All *Width and *Height properties give 0 on elements with display none,
+    // so enable the element temporarily
+    var els = element.style;
+    var originalVisibility = els.visibility;
+    var originalPosition = els.position;
+    var originalDisplay = els.display;
+    els.visibility = 'hidden';
+    els.position = 'absolute';
+    els.display = 'block';
+    var originalWidth = element.clientWidth;
+    var originalHeight = element.clientHeight;
+    els.display = originalDisplay;
+    els.position = originalPosition;
+    els.visibility = originalVisibility;
+    return {width: originalWidth, height: originalHeight};
+  },
+
+  makePositioned: function(element) {
+    element = $(element);
+    var pos = Element.getStyle(element, 'position');
+    if (pos == 'static' || !pos) {
+      element._madePositioned = true;
+      element.style.position = 'relative';
+      // Opera returns the offset relative to the positioning context, when an
+      // element is position relative but top and left have not been defined
+      if (window.opera) {
+        element.style.top = 0;
+        element.style.left = 0;
+      }
+    }
+    return element;
+  },
+
+  undoPositioned: function(element) {
+    element = $(element);
+    if (element._madePositioned) {
+      element._madePositioned = undefined;
+      element.style.position =
+        element.style.top =
+        element.style.left =
+        element.style.bottom =
+        element.style.right = '';
+    }
+    return element;
+  },
+
+  makeClipping: function(element) {
+    element = $(element);
+    if (element._overflow) return element;
+    element._overflow = element.style.overflow || 'auto';
+    if ((Element.getStyle(element, 'overflow') || 'visible') != 'hidden')
+      element.style.overflow = 'hidden';
+    return element;
+  },
+
+  undoClipping: function(element) {
+    element = $(element);
+    if (!element._overflow) return element;
+    element.style.overflow = element._overflow == 'auto' ? '' : element._overflow;
+    element._overflow = null;
+    return element;
+  }
+};
+
+Object.extend(Element.Methods, {
+  childOf: Element.Methods.descendantOf,
+  childElements: Element.Methods.immediateDescendants
+});
+
+if (Prototype.Browser.Opera) {
+  Element.Methods._getStyle = Element.Methods.getStyle;
+  Element.Methods.getStyle = function(element, style) {
+    switch(style) {
+      case 'left':
+      case 'top':
+      case 'right':
+      case 'bottom':
+        if (Element._getStyle(element, 'position') == 'static') return null;
+      default: return Element._getStyle(element, style);
+    }
+  };
+}
+else if (Prototype.Browser.IE) {
+  Element.Methods.getStyle = function(element, style) {
+    element = $(element);
+    style = (style == 'float' || style == 'cssFloat') ? 'styleFloat' : style.camelize();
+    var value = element.style[style];
+    if (!value && element.currentStyle) value = element.currentStyle[style];
+
+    if (style == 'opacity') {
+      if (value = (element.getStyle('filter') || '').match(/alpha\(opacity=(.*)\)/))
+        if (value[1]) return parseFloat(value[1]) / 100;
+      return 1.0;
+    }
+
+    if (value == 'auto') {
+      if ((style == 'width' || style == 'height') && (element.getStyle('display') != 'none'))
+        return element['offset'+style.capitalize()] + 'px';
+      return null;
+    }
+    return value;
+  };
+
+  Element.Methods.setOpacity = function(element, value) {
+    element = $(element);
+    var filter = element.getStyle('filter'), style = element.style;
+    if (value == 1 || value === '') {
+      style.filter = filter.replace(/alpha\([^\)]*\)/gi,'');
+      return element;
+    } else if (value < 0.00001) value = 0;
+    style.filter = filter.replace(/alpha\([^\)]*\)/gi, '') +
+      'alpha(opacity=' + (value * 100) + ')';
+    return element;
+  };
+
+  // IE is missing .innerHTML support for TABLE-related elements
+  Element.Methods.update = function(element, html) {
+    element = $(element);
+    html = typeof html == 'undefined' ? '' : html.toString();
+    var tagName = element.tagName.toUpperCase();
+    if (['THEAD','TBODY','TR','TD'].include(tagName)) {
+      var div = document.createElement('div');
+      switch (tagName) {
+        case 'THEAD':
+        case 'TBODY':
+          div.innerHTML = '<table><tbody>' +  html.stripScripts() + '</tbody></table>';
+          depth = 2;
+          break;
+        case 'TR':
+          div.innerHTML = '<table><tbody><tr>' +  html.stripScripts() + '</tr></tbody></table>';
+          depth = 3;
+          break;
+        case 'TD':
+          div.innerHTML = '<table><tbody><tr><td>' +  html.stripScripts() + '</td></tr></tbody></table>';
+          depth = 4;
+      }
+      $A(element.childNodes).each(function(node) { element.removeChild(node) });
+      depth.times(function() { div = div.firstChild });
+      $A(div.childNodes).each(function(node) { element.appendChild(node) });
+    } else {
+      element.innerHTML = html.stripScripts();
+    }
+    setTimeout(function() { html.evalScripts() }, 10);
+    return element;
+  }
+}
+else if (Prototype.Browser.Gecko) {
+  Element.Methods.setOpacity = function(element, value) {
+    element = $(element);
+    element.style.opacity = (value == 1) ? 0.999999 :
+      (value === '') ? '' : (value < 0.00001) ? 0 : value;
+    return element;
+  };
+}
+
+Element._attributeTranslations = {
+  names: {
+    colspan:   "colSpan",
+    rowspan:   "rowSpan",
+    valign:    "vAlign",
+    datetime:  "dateTime",
+    accesskey: "accessKey",
+    tabindex:  "tabIndex",
+    enctype:   "encType",
+    maxlength: "maxLength",
+    readonly:  "readOnly",
+    longdesc:  "longDesc"
+  },
+  values: {
+    _getAttr: function(element, attribute) {
+      return element.getAttribute(attribute, 2);
+    },
+    _flag: function(element, attribute) {
+      return $(element).hasAttribute(attribute) ? attribute : null;
+    },
+    style: function(element) {
+      return element.style.cssText.toLowerCase();
+    },
+    title: function(element) {
+      var node = element.getAttributeNode('title');
+      return node.specified ? node.nodeValue : null;
+    }
+  }
+};
+
+(function() {
+  Object.extend(this, {
+    href: this._getAttr,
+    src:  this._getAttr,
+    type: this._getAttr,
+    disabled: this._flag,
+    checked:  this._flag,
+    readonly: this._flag,
+    multiple: this._flag
+  });
+}).call(Element._attributeTranslations.values);
+
+Element.Methods.Simulated = {
+  hasAttribute: function(element, attribute) {
+    var t = Element._attributeTranslations, node;
+    attribute = t.names[attribute] || attribute;
+    node = $(element).getAttributeNode(attribute);
+    return node && node.specified;
+  }
+};
+
+Element.Methods.ByTag = {};
+
+Object.extend(Element, Element.Methods);
+
+if (!Prototype.BrowserFeatures.ElementExtensions &&
+ document.createElement('div').__proto__) {
+  window.HTMLElement = {};
+  window.HTMLElement.prototype = document.createElement('div').__proto__;
+  Prototype.BrowserFeatures.ElementExtensions = true;
+}
+
+Element.hasAttribute = function(element, attribute) {
+  if (element.hasAttribute) return element.hasAttribute(attribute);
+  return Element.Methods.Simulated.hasAttribute(element, attribute);
+};
+
+Element.addMethods = function(methods) {
+  var F = Prototype.BrowserFeatures, T = Element.Methods.ByTag;
+
+  if (!methods) {
+    Object.extend(Form, Form.Methods);
+    Object.extend(Form.Element, Form.Element.Methods);
+    Object.extend(Element.Methods.ByTag, {
+      "FORM":     Object.clone(Form.Methods),
+      "INPUT":    Object.clone(Form.Element.Methods),
+      "SELECT":   Object.clone(Form.Element.Methods),
+      "TEXTAREA": Object.clone(Form.Element.Methods)
+    });
+  }
+
+  if (arguments.length == 2) {
+    var tagName = methods;
+    methods = arguments[1];
+  }
+
+  if (!tagName) Object.extend(Element.Methods, methods || {});
+  else {
+    if (tagName.constructor == Array) tagName.each(extend);
+    else extend(tagName);
+  }
+
+  function extend(tagName) {
+    tagName = tagName.toUpperCase();
+    if (!Element.Methods.ByTag[tagName])
+      Element.Methods.ByTag[tagName] = {};
+    Object.extend(Element.Methods.ByTag[tagName], methods);
+  }
+
+  function copy(methods, destination, onlyIfAbsent) {
+    onlyIfAbsent = onlyIfAbsent || false;
+    var cache = Element.extend.cache;
+    for (var property in methods) {
+      var value = methods[property];
+      if (!onlyIfAbsent || !(property in destination))
+        destination[property] = cache.findOrStore(value);
+    }
+  }
+
+  function findDOMClass(tagName) {
+    var klass;
+    var trans = {
+      "OPTGROUP": "OptGroup", "TEXTAREA": "TextArea", "P": "Paragraph",
+      "FIELDSET": "FieldSet", "UL": "UList", "OL": "OList", "DL": "DList",
+      "DIR": "Directory", "H1": "Heading", "H2": "Heading", "H3": "Heading",
+      "H4": "Heading", "H5": "Heading", "H6": "Heading", "Q": "Quote",
+      "INS": "Mod", "DEL": "Mod", "A": "Anchor", "IMG": "Image", "CAPTION":
+      "TableCaption", "COL": "TableCol", "COLGROUP": "TableCol", "THEAD":
+      "TableSection", "TFOOT": "TableSection", "TBODY": "TableSection", "TR":
+      "TableRow", "TH": "TableCell", "TD": "TableCell", "FRAMESET":
+      "FrameSet", "IFRAME": "IFrame"
+    };
+    if (trans[tagName]) klass = 'HTML' + trans[tagName] + 'Element';
+    if (window[klass]) return window[klass];
+    klass = 'HTML' + tagName + 'Element';
+    if (window[klass]) return window[klass];
+    klass = 'HTML' + tagName.capitalize() + 'Element';
+    if (window[klass]) return window[klass];
+
+    window[klass] = {};
+    window[klass].prototype = document.createElement(tagName).__proto__;
+    return window[klass];
+  }
+
+  if (F.ElementExtensions) {
+    copy(Element.Methods, HTMLElement.prototype);
+    copy(Element.Methods.Simulated, HTMLElement.prototype, true);
+  }
+
+  if (F.SpecificElementExtensions) {
+    for (var tag in Element.Methods.ByTag) {
+      var klass = findDOMClass(tag);
+      if (typeof klass == "undefined") continue;
+      copy(T[tag], klass.prototype);
+    }
+  }
+
+  Object.extend(Element, Element.Methods);
+  delete Element.ByTag;
+};
+
+var Toggle = { display: Element.toggle };
+
+/*--------------------------------------------------------------------------*/
+
+Abstract.Insertion = function(adjacency) {
+  this.adjacency = adjacency;
+}
+
+Abstract.Insertion.prototype = {
+  initialize: function(element, content) {
+    this.element = $(element);
+    this.content = content.stripScripts();
+
+    if (this.adjacency && this.element.insertAdjacentHTML) {
+      try {
+        this.element.insertAdjacentHTML(this.adjacency, this.content);
+      } catch (e) {
+        var tagName = this.element.tagName.toUpperCase();
+        if (['TBODY', 'TR'].include(tagName)) {
+          this.insertContent(this.contentFromAnonymousTable());
+        } else {
+          throw e;
+        }
+      }
+    } else {
+      this.range = this.element.ownerDocument.createRange();
+      if (this.initializeRange) this.initializeRange();
+      this.insertContent([this.range.createContextualFragment(this.content)]);
+    }
+
+    setTimeout(function() {content.evalScripts()}, 10);
+  },
+
+  contentFromAnonymousTable: function() {
+    var div = document.createElement('div');
+    div.innerHTML = '<table><tbody>' + this.content + '</tbody></table>';
+    return $A(div.childNodes[0].childNodes[0].childNodes);
+  }
+}
+
+var Insertion = new Object();
+
+Insertion.Before = Class.create();
+Insertion.Before.prototype = Object.extend(new Abstract.Insertion('beforeBegin'), {
+  initializeRange: function() {
+    this.range.setStartBefore(this.element);
+  },
+
+  insertContent: function(fragments) {
+    fragments.each((function(fragment) {
+      this.element.parentNode.insertBefore(fragment, this.element);
+    }).bind(this));
+  }
+});
+
+Insertion.Top = Class.create();
+Insertion.Top.prototype = Object.extend(new Abstract.Insertion('afterBegin'), {
+  initializeRange: function() {
+    this.range.selectNodeContents(this.element);
+    this.range.collapse(true);
+  },
+
+  insertContent: function(fragments) {
+    fragments.reverse(false).each((function(fragment) {
+      this.element.insertBefore(fragment, this.element.firstChild);
+    }).bind(this));
+  }
+});
+
+Insertion.Bottom = Class.create();
+Insertion.Bottom.prototype = Object.extend(new Abstract.Insertion('beforeEnd'), {
+  initializeRange: function() {
+    this.range.selectNodeContents(this.element);
+    this.range.collapse(this.element);
+  },
+
+  insertContent: function(fragments) {
+    fragments.each((function(fragment) {
+      this.element.appendChild(fragment);
+    }).bind(this));
+  }
+});
+
+Insertion.After = Class.create();
+Insertion.After.prototype = Object.extend(new Abstract.Insertion('afterEnd'), {
+  initializeRange: function() {
+    this.range.setStartAfter(this.element);
+  },
+
+  insertContent: function(fragments) {
+    fragments.each((function(fragment) {
+      this.element.parentNode.insertBefore(fragment,
+        this.element.nextSibling);
+    }).bind(this));
+  }
+});
+
+/*--------------------------------------------------------------------------*/
+
+Element.ClassNames = Class.create();
+Element.ClassNames.prototype = {
+  initialize: function(element) {
+    this.element = $(element);
+  },
+
+  _each: function(iterator) {
+    this.element.className.split(/\s+/).select(function(name) {
+      return name.length > 0;
+    })._each(iterator);
+  },
+
+  set: function(className) {
+    this.element.className = className;
+  },
+
+  add: function(classNameToAdd) {
+    if (this.include(classNameToAdd)) return;
+    this.set($A(this).concat(classNameToAdd).join(' '));
+  },
+
+  remove: function(classNameToRemove) {
+    if (!this.include(classNameToRemove)) return;
+    this.set($A(this).without(classNameToRemove).join(' '));
+  },
+
+  toString: function() {
+    return $A(this).join(' ');
+  }
+};
+
+Object.extend(Element.ClassNames.prototype, Enumerable);
+/* Portions of the Selector class are derived from Jack Slocumâ€™s DomQuery,
+ * part of YUI-Ext version 0.40, distributed under the terms of an MIT-style
+ * license.  Please see http://www.yui-ext.com/ for more information. */
+
+var Selector = Class.create();
+
+Selector.prototype = {
+  initialize: function(expression) {
+    this.expression = expression.strip();
+    this.compileMatcher();
+  },
+
+  compileMatcher: function() {
+    // Selectors with namespaced attributes can't use the XPath version
+    if (Prototype.BrowserFeatures.XPath && !(/\[[\w-]*?:/).test(this.expression))
+      return this.compileXPathMatcher();
+
+    var e = this.expression, ps = Selector.patterns, h = Selector.handlers,
+        c = Selector.criteria, le, p, m;
+
+    if (Selector._cache[e]) {
+      this.matcher = Selector._cache[e]; return;
+    }
+    this.matcher = ["this.matcher = function(root) {",
+                    "var r = root, h = Selector.handlers, c = false, n;"];
+
+    while (e && le != e && (/\S/).test(e)) {
+      le = e;
+      for (var i in ps) {
+        p = ps[i];
+        if (m = e.match(p)) {
+          this.matcher.push(typeof c[i] == 'function' ? c[i](m) :
+    	      new Template(c[i]).evaluate(m));
+          e = e.replace(m[0], '');
+          break;
+        }
+      }
+    }
+
+    this.matcher.push("return h.unique(n);\n}");
+    eval(this.matcher.join('\n'));
+    Selector._cache[this.expression] = this.matcher;
+  },
+
+  compileXPathMatcher: function() {
+    var e = this.expression, ps = Selector.patterns,
+        x = Selector.xpath, le,  m;
+
+    if (Selector._cache[e]) {
+      this.xpath = Selector._cache[e]; return;
+    }
+
+    this.matcher = ['.//*'];
+    while (e && le != e && (/\S/).test(e)) {
+      le = e;
+      for (var i in ps) {
+        if (m = e.match(ps[i])) {
+          this.matcher.push(typeof x[i] == 'function' ? x[i](m) :
+            new Template(x[i]).evaluate(m));
+          e = e.replace(m[0], '');
+          break;
+        }
+      }
+    }
+
+    this.xpath = this.matcher.join('');
+    Selector._cache[this.expression] = this.xpath;
+  },
+
+  findElements: function(root) {
+    root = root || document;
+    if (this.xpath) return document._getElementsByXPath(this.xpath, root);
+    return this.matcher(root);
+  },
+
+  match: function(element) {
+    return this.findElements(document).include(element);
+  },
+
+  toString: function() {
+    return this.expression;
+  },
+
+  inspect: function() {
+    return "#<Selector:" + this.expression.inspect() + ">";
+  }
+};
+
+Object.extend(Selector, {
+  _cache: {},
+
+  xpath: {
+    descendant:   "//*",
+    child:        "/*",
+    adjacent:     "/following-sibling::*[1]",
+    laterSibling: '/following-sibling::*',
+    tagName:      function(m) {
+      if (m[1] == '*') return '';
+      return "[local-name()='" + m[1].toLowerCase() +
+             "' or local-name()='" + m[1].toUpperCase() + "']";
+    },
+    className:    "[contains(concat(' ', @class, ' '), ' #{1} ')]",
+    id:           "[@id='#{1}']",
+    attrPresence: "[@#{1}]",
+    attr: function(m) {
+      m[3] = m[5] || m[6];
+      return new Template(Selector.xpath.operators[m[2]]).evaluate(m);
+    },
+    pseudo: function(m) {
+      var h = Selector.xpath.pseudos[m[1]];
+      if (!h) return '';
+      if (typeof h === 'function') return h(m);
+      return new Template(Selector.xpath.pseudos[m[1]]).evaluate(m);
+    },
+    operators: {
+      '=':  "[@#{1}='#{3}']",
+      '!=': "[@#{1}!='#{3}']",
+      '^=': "[starts-with(@#{1}, '#{3}')]",
+      '$=': "[substring(@#{1}, (string-length(@#{1}) - string-length('#{3}') + 1))='#{3}']",
+      '*=': "[contains(@#{1}, '#{3}')]",
+      '~=': "[contains(concat(' ', @#{1}, ' '), ' #{3} ')]",
+      '|=': "[contains(concat('-', @#{1}, '-'), '-#{3}-')]"
+    },
+    pseudos: {
+      'first-child': '[not(preceding-sibling::*)]',
+      'last-child':  '[not(following-sibling::*)]',
+      'only-child':  '[not(preceding-sibling::* or following-sibling::*)]',
+      'empty':       "[count(*) = 0 and (count(text()) = 0 or translate(text(), ' \t\r\n', '') = '')]",
+      'checked':     "[@checked]",
+      'disabled':    "[@disabled]",
+      'enabled':     "[not(@disabled)]",
+      'not': function(m) {
+        var e = m[6], p = Selector.patterns,
+            x = Selector.xpath, le, m, v;
+
+        var exclusion = [];
+        while (e && le != e && (/\S/).test(e)) {
+          le = e;
+          for (var i in p) {
+            if (m = e.match(p[i])) {
+              v = typeof x[i] == 'function' ? x[i](m) : new Template(x[i]).evaluate(m);
+              exclusion.push("(" + v.substring(1, v.length - 1) + ")");
+              e = e.replace(m[0], '');
+              break;
+            }
+          }
+        }
+        return "[not(" + exclusion.join(" and ") + ")]";
+      },
+      'nth-child':      function(m) {
+        return Selector.xpath.pseudos.nth("(count(./preceding-sibling::*) + 1) ", m);
+      },
+      'nth-last-child': function(m) {
+        return Selector.xpath.pseudos.nth("(count(./following-sibling::*) + 1) ", m);
+      },
+      'nth-of-type':    function(m) {
+        return Selector.xpath.pseudos.nth("position() ", m);
+      },
+      'nth-last-of-type': function(m) {
+        return Selector.xpath.pseudos.nth("(last() + 1 - position()) ", m);
+      },
+      'first-of-type':  function(m) {
+        m[6] = "1"; return Selector.xpath.pseudos['nth-of-type'](m);
+      },
+      'last-of-type':   function(m) {
+        m[6] = "1"; return Selector.xpath.pseudos['nth-last-of-type'](m);
+      },
+      'only-of-type':   function(m) {
+        var p = Selector.xpath.pseudos; return p['first-of-type'](m) + p['last-of-type'](m);
+      },
+      nth: function(fragment, m) {
+        var mm, formula = m[6], predicate;
+        if (formula == 'even') formula = '2n+0';
+        if (formula == 'odd')  formula = '2n+1';
+        if (mm = formula.match(/^(\d+)$/)) // digit only
+          return '[' + fragment + "= " + mm[1] + ']';
+        if (mm = formula.match(/^(-?\d*)?n(([+-])(\d+))?/)) { // an+b
+          if (mm[1] == "-") mm[1] = -1;
+          var a = mm[1] ? Number(mm[1]) : 1;
+          var b = mm[2] ? Number(mm[2]) : 0;
+          predicate = "[((#{fragment} - #{b}) mod #{a} = 0) and " +
+          "((#{fragment} - #{b}) div #{a} >= 0)]";
+          return new Template(predicate).evaluate({
+            fragment: fragment, a: a, b: b });
+        }
+      }
+    }
+  },
+
+  criteria: {
+    tagName:      'n = h.tagName(n, r, "#{1}", c);   c = false;',
+    className:    'n = h.className(n, r, "#{1}", c); c = false;',
+    id:           'n = h.id(n, r, "#{1}", c);        c = false;',
+    attrPresence: 'n = h.attrPresence(n, r, "#{1}"); c = false;',
+    attr: function(m) {
+      m[3] = (m[5] || m[6]);
+      return new Template('n = h.attr(n, r, "#{1}", "#{3}", "#{2}"); c = false;').evaluate(m);
+    },
+    pseudo:       function(m) {
+      if (m[6]) m[6] = m[6].replace(/"/g, '\\"');
+      return new Template('n = h.pseudo(n, "#{1}", "#{6}", r, c); c = false;').evaluate(m);
+    },
+    descendant:   'c = "descendant";',
+    child:        'c = "child";',
+    adjacent:     'c = "adjacent";',
+    laterSibling: 'c = "laterSibling";'
+  },
+
+  patterns: {
+    // combinators must be listed first
+    // (and descendant needs to be last combinator)
+    laterSibling: /^\s*~\s*/,
+    child:        /^\s*>\s*/,
+    adjacent:     /^\s*\+\s*/,
+    descendant:   /^\s/,
+
+    // selectors follow
+    tagName:      /^\s*(\*|[\w\-]+)(\b|$)?/,
+    id:           /^#([\w\-\*]+)(\b|$)/,
+    className:    /^\.([\w\-\*]+)(\b|$)/,
+    pseudo:       /^:((first|last|nth|nth-last|only)(-child|-of-type)|empty|checked|(en|dis)abled|not)(\((.*?)\))?(\b|$|\s|(?=:))/,
+    attrPresence: /^\[([\w]+)\]/,
+    attr:         /\[((?:[\w-]*:)?[\w-]+)\s*(?:([!^$*~|]?=)\s*((['"])([^\]]*?)\4|([^'"][^\]]*?)))?\]/
+  },
+
+  handlers: {
+    // UTILITY FUNCTIONS
+    // joins two collections
+    concat: function(a, b) {
+      for (var i = 0, node; node = b[i]; i++)
+        a.push(node);
+      return a;
+    },
+
+    // marks an array of nodes for counting
+    mark: function(nodes) {
+      for (var i = 0, node; node = nodes[i]; i++)
+        node._counted = true;
+      return nodes;
+    },
+
+    unmark: function(nodes) {
+      for (var i = 0, node; node = nodes[i]; i++)
+        node._counted = undefined;
+      return nodes;
+    },
+
+    // mark each child node with its position (for nth calls)
+    // "ofType" flag indicates whether we're indexing for nth-of-type
+    // rather than nth-child
+    index: function(parentNode, reverse, ofType) {
+      parentNode._counted = true;
+      if (reverse) {
+        for (var nodes = parentNode.childNodes, i = nodes.length - 1, j = 1; i >= 0; i--) {
+          node = nodes[i];
+          if (node.nodeType == 1 && (!ofType || node._counted)) node.nodeIndex = j++;
+        }
+      } else {
+        for (var i = 0, j = 1, nodes = parentNode.childNodes; node = nodes[i]; i++)
+          if (node.nodeType == 1 && (!ofType || node._counted)) node.nodeIndex = j++;
+      }
+    },
+
+    // filters out duplicates and extends all nodes
+    unique: function(nodes) {
+      if (nodes.length == 0) return nodes;
+      var results = [], n;
+      for (var i = 0, l = nodes.length; i < l; i++)
+        if (!(n = nodes[i])._counted) {
+          n._counted = true;
+          results.push(Element.extend(n));
+        }
+      return Selector.handlers.unmark(results);
+    },
+
+    // COMBINATOR FUNCTIONS
+    descendant: function(nodes) {
+      var h = Selector.handlers;
+      for (var i = 0, results = [], node; node = nodes[i]; i++)
+        h.concat(results, node.getElementsByTagName('*'));
+      return results;
+    },
+
+    child: function(nodes) {
+      var h = Selector.handlers;
+      for (var i = 0, results = [], node; node = nodes[i]; i++) {
+        for (var j = 0, children = [], child; child = node.childNodes[j]; j++)
+          if (child.nodeType == 1 && child.tagName != '!') results.push(child);
+      }
+      return results;
+    },
+
+    adjacent: function(nodes) {
+      for (var i = 0, results = [], node; node = nodes[i]; i++) {
+        var next = this.nextElementSibling(node);
+        if (next) results.push(next);
+      }
+      return results;
+    },
+
+    laterSibling: function(nodes) {
+      var h = Selector.handlers;
+      for (var i = 0, results = [], node; node = nodes[i]; i++)
+        h.concat(results, Element.nextSiblings(node));
+      return results;
+    },
+
+    nextElementSibling: function(node) {
+      while (node = node.nextSibling)
+	      if (node.nodeType == 1) return node;
+      return null;
+    },
+
+    previousElementSibling: function(node) {
+      while (node = node.previousSibling)
+        if (node.nodeType == 1) return node;
+      return null;
+    },
+
+    // TOKEN FUNCTIONS
+    tagName: function(nodes, root, tagName, combinator) {
+      tagName = tagName.toUpperCase();
+      var results = [], h = Selector.handlers;
+      if (nodes) {
+        if (combinator) {
+          // fastlane for ordinary descendant combinators
+          if (combinator == "descendant") {
+            for (var i = 0, node; node = nodes[i]; i++)
+              h.concat(results, node.getElementsByTagName(tagName));
+            return results;
+          } else nodes = this[combinator](nodes);
+          if (tagName == "*") return nodes;
+        }
+        for (var i = 0, node; node = nodes[i]; i++)
+          if (node.tagName.toUpperCase() == tagName) results.push(node);
+        return results;
+      } else return root.getElementsByTagName(tagName);
+    },
+
+    id: function(nodes, root, id, combinator) {
+      var targetNode = $(id), h = Selector.handlers;
+      if (!nodes && root == document) return targetNode ? [targetNode] : [];
+      if (nodes) {
+        if (combinator) {
+          if (combinator == 'child') {
+            for (var i = 0, node; node = nodes[i]; i++)
+              if (targetNode.parentNode == node) return [targetNode];
+          } else if (combinator == 'descendant') {
+            for (var i = 0, node; node = nodes[i]; i++)
+              if (Element.descendantOf(targetNode, node)) return [targetNode];
+          } else if (combinator == 'adjacent') {
+            for (var i = 0, node; node = nodes[i]; i++)
+              if (Selector.handlers.previousElementSibling(targetNode) == node)
+                return [targetNode];
+          } else nodes = h[combinator](nodes);
+        }
+        for (var i = 0, node; node = nodes[i]; i++)
+          if (node == targetNode) return [targetNode];
+        return [];
+      }
+      return (targetNode && Element.descendantOf(targetNode, root)) ? [targetNode] : [];
+    },
+
+    className: function(nodes, root, className, combinator) {
+      if (nodes && combinator) nodes = this[combinator](nodes);
+      return Selector.handlers.byClassName(nodes, root, className);
+    },
+
+    byClassName: function(nodes, root, className) {
+      if (!nodes) nodes = Selector.handlers.descendant([root]);
+      var needle = ' ' + className + ' ';
+      for (var i = 0, results = [], node, nodeClassName; node = nodes[i]; i++) {
+        nodeClassName = node.className;
+        if (nodeClassName.length == 0) continue;
+        if (nodeClassName == className || (' ' + nodeClassName + ' ').include(needle))
+          results.push(node);
+      }
+      return results;
+    },
+
+    attrPresence: function(nodes, root, attr) {
+      var results = [];
+      for (var i = 0, node; node = nodes[i]; i++)
+        if (Element.hasAttribute(node, attr)) results.push(node);
+      return results;
+    },
+
+    attr: function(nodes, root, attr, value, operator) {
+      if (!nodes) nodes = root.getElementsByTagName("*");
+      var handler = Selector.operators[operator], results = [];
+      for (var i = 0, node; node = nodes[i]; i++) {
+        var nodeValue = Element.readAttribute(node, attr);
+        if (nodeValue === null) continue;
+        if (handler(nodeValue, value)) results.push(node);
+      }
+      return results;
+    },
+
+    pseudo: function(nodes, name, value, root, combinator) {
+      if (nodes && combinator) nodes = this[combinator](nodes);
+      if (!nodes) nodes = root.getElementsByTagName("*");
+      return Selector.pseudos[name](nodes, value, root);
+    }
+  },
+
+  pseudos: {
+    'first-child': function(nodes, value, root) {
+      for (var i = 0, results = [], node; node = nodes[i]; i++) {
+        if (Selector.handlers.previousElementSibling(node)) continue;
+          results.push(node);
+      }
+      return results;
+    },
+    'last-child': function(nodes, value, root) {
+      for (var i = 0, results = [], node; node = nodes[i]; i++) {
+        if (Selector.handlers.nextElementSibling(node)) continue;
+          results.push(node);
+      }
+      return results;
+    },
+    'only-child': function(nodes, value, root) {
+      var h = Selector.handlers;
+      for (var i = 0, results = [], node; node = nodes[i]; i++)
+        if (!h.previousElementSibling(node) && !h.nextElementSibling(node))
+          results.push(node);
+      return results;
+    },
+    'nth-child':        function(nodes, formula, root) {
+      return Selector.pseudos.nth(nodes, formula, root);
+    },
+    'nth-last-child':   function(nodes, formula, root) {
+      return Selector.pseudos.nth(nodes, formula, root, true);
+    },
+    'nth-of-type':      function(nodes, formula, root) {
+      return Selector.pseudos.nth(nodes, formula, root, false, true);
+    },
+    'nth-last-of-type': function(nodes, formula, root) {
+      return Selector.pseudos.nth(nodes, formula, root, true, true);
+    },
+    'first-of-type':    function(nodes, formula, root) {
+      return Selector.pseudos.nth(nodes, "1", root, false, true);
+    },
+    'last-of-type':     function(nodes, formula, root) {
+      return Selector.pseudos.nth(nodes, "1", root, true, true);
+    },
+    'only-of-type':     function(nodes, formula, root) {
+      var p = Selector.pseudos;
+      return p['last-of-type'](p['first-of-type'](nodes, formula, root), formula, root);
+    },
+
+    // handles the an+b logic
+    getIndices: function(a, b, total) {
+      if (a == 0) return b > 0 ? [b] : [];
+      return $R(1, total).inject([], function(memo, i) {
+        if (0 == (i - b) % a && (i - b) / a >= 0) memo.push(i);
+        return memo;
+      });
+    },
+
+    // handles nth(-last)-child, nth(-last)-of-type, and (first|last)-of-type
+    nth: function(nodes, formula, root, reverse, ofType) {
+      if (nodes.length == 0) return [];
+      if (formula == 'even') formula = '2n+0';
+      if (formula == 'odd')  formula = '2n+1';
+      var h = Selector.handlers, results = [], indexed = [], m;
+      h.mark(nodes);
+      for (var i = 0, node; node = nodes[i]; i++) {
+        if (!node.parentNode._counted) {
+          h.index(node.parentNode, reverse, ofType);
+          indexed.push(node.parentNode);
+        }
+      }
+      if (formula.match(/^\d+$/)) { // just a number
+        formula = Number(formula);
+        for (var i = 0, node; node = nodes[i]; i++)
+          if (node.nodeIndex == formula) results.push(node);
+      } else if (m = formula.match(/^(-?\d*)?n(([+-])(\d+))?/)) { // an+b
+        if (m[1] == "-") m[1] = -1;
+        var a = m[1] ? Number(m[1]) : 1;
+        var b = m[2] ? Number(m[2]) : 0;
+        var indices = Selector.pseudos.getIndices(a, b, nodes.length);
+        for (var i = 0, node, l = indices.length; node = nodes[i]; i++) {
+          for (var j = 0; j < l; j++)
+            if (node.nodeIndex == indices[j]) results.push(node);
+        }
+      }
+      h.unmark(nodes);
+      h.unmark(indexed);
+      return results;
+    },
+
+    'empty': function(nodes, value, root) {
+      for (var i = 0, results = [], node; node = nodes[i]; i++) {
+        // IE treats comments as element nodes
+        if (node.tagName == '!' || (node.firstChild && !node.innerHTML.match(/^\s*$/))) continue;
+        results.push(node);
+      }
+      return results;
+    },
+
+    'not': function(nodes, selector, root) {
+      var h = Selector.handlers, selectorType, m;
+      var exclusions = new Selector(selector).findElements(root);
+      h.mark(exclusions);
+      for (var i = 0, results = [], node; node = nodes[i]; i++)
+        if (!node._counted) results.push(node);
+      h.unmark(exclusions);
+      return results;
+    },
+
+    'enabled': function(nodes, value, root) {
+      for (var i = 0, results = [], node; node = nodes[i]; i++)
+        if (!node.disabled) results.push(node);
+      return results;
+    },
+
+    'disabled': function(nodes, value, root) {
+      for (var i = 0, results = [], node; node = nodes[i]; i++)
+        if (node.disabled) results.push(node);
+      return results;
+    },
+
+    'checked': function(nodes, value, root) {
+      for (var i = 0, results = [], node; node = nodes[i]; i++)
+        if (node.checked) results.push(node);
+      return results;
+    }
+  },
+
+  operators: {
+    '=':  function(nv, v) { return nv == v; },
+    '!=': function(nv, v) { return nv != v; },
+    '^=': function(nv, v) { return nv.startsWith(v); },
+    '$=': function(nv, v) { return nv.endsWith(v); },
+    '*=': function(nv, v) { return nv.include(v); },
+    '~=': function(nv, v) { return (' ' + nv + ' ').include(' ' + v + ' '); },
+    '|=': function(nv, v) { return ('-' + nv.toUpperCase() + '-').include('-' + v.toUpperCase() + '-'); }
+  },
+
+  matchElements: function(elements, expression) {
+    var matches = new Selector(expression).findElements(), h = Selector.handlers;
+    h.mark(matches);
+    for (var i = 0, results = [], element; element = elements[i]; i++)
+      if (element._counted) results.push(element);
+    h.unmark(matches);
+    return results;
+  },
+
+  findElement: function(elements, expression, index) {
+    if (typeof expression == 'number') {
+      index = expression; expression = false;
+    }
+    return Selector.matchElements(elements, expression || '*')[index || 0];
+  },
+
+  findChildElements: function(element, expressions) {
+    var exprs = expressions.join(','), expressions = [];
+    exprs.scan(/(([\w#:.~>+()\s-]+|\*|\[.*?\])+)\s*(,|$)/, function(m) {
+      expressions.push(m[1].strip());
+    });
+    var results = [], h = Selector.handlers;
+    for (var i = 0, l = expressions.length, selector; i < l; i++) {
+      selector = new Selector(expressions[i].strip());
+      h.concat(results, selector.findElements(element));
+    }
+    return (l > 1) ? h.unique(results) : results;
+  }
+});
+
+function $$() {
+  return Selector.findChildElements(document, $A(arguments));
+}
+var Form = {
+  reset: function(form) {
+    $(form).reset();
+    return form;
+  },
+
+  serializeElements: function(elements, getHash) {
+    var data = elements.inject({}, function(result, element) {
+      if (!element.disabled && element.name) {
+        var key = element.name, value = $(element).getValue();
+        if (value != null) {
+         	if (key in result) {
+            if (result[key].constructor != Array) result[key] = [result[key]];
+            result[key].push(value);
+          }
+          else result[key] = value;
+        }
+      }
+      return result;
+    });
+
+    return getHash ? data : Hash.toQueryString(data);
+  }
+};
+
+Form.Methods = {
+  serialize: function(form, getHash) {
+    return Form.serializeElements(Form.getElements(form), getHash);
+  },
+
+  getElements: function(form) {
+    return $A($(form).getElementsByTagName('*')).inject([],
+      function(elements, child) {
+        if (Form.Element.Serializers[child.tagName.toLowerCase()])
+          elements.push(Element.extend(child));
+        return elements;
+      }
+    );
+  },
+
+  getInputs: function(form, typeName, name) {
+    form = $(form);
+    var inputs = form.getElementsByTagName('input');
+
+    if (!typeName && !name) return $A(inputs).map(Element.extend);
+
+    for (var i = 0, matchingInputs = [], length = inputs.length; i < length; i++) {
+      var input = inputs[i];
+      if ((typeName && input.type != typeName) || (name && input.name != name))
+        continue;
+      matchingInputs.push(Element.extend(input));
+    }
+
+    return matchingInputs;
+  },
+
+  disable: function(form) {
+    form = $(form);
+    Form.getElements(form).invoke('disable');
+    return form;
+  },
+
+  enable: function(form) {
+    form = $(form);
+    Form.getElements(form).invoke('enable');
+    return form;
+  },
+
+  findFirstElement: function(form) {
+    return $(form).getElements().find(function(element) {
+      return element.type != 'hidden' && !element.disabled &&
+        ['input', 'select', 'textarea'].include(element.tagName.toLowerCase());
+    });
+  },
+
+  focusFirstElement: function(form) {
+    form = $(form);
+    form.findFirstElement().activate();
+    return form;
+  },
+
+  request: function(form, options) {
+    form = $(form), options = Object.clone(options || {});
+
+    var params = options.parameters;
+    options.parameters = form.serialize(true);
+
+    if (params) {
+      if (typeof params == 'string') params = params.toQueryParams();
+      Object.extend(options.parameters, params);
+    }
+
+    if (form.hasAttribute('method') && !options.method)
+      options.method = form.method;
+
+    return new Ajax.Request(form.readAttribute('action'), options);
+  }
+}
+
+/*--------------------------------------------------------------------------*/
+
+Form.Element = {
+  focus: function(element) {
+    $(element).focus();
+    return element;
+  },
+
+  select: function(element) {
+    $(element).select();
+    return element;
+  }
+}
+
+Form.Element.Methods = {
+  serialize: function(element) {
+    element = $(element);
+    if (!element.disabled && element.name) {
+      var value = element.getValue();
+      if (value != undefined) {
+        var pair = {};
+        pair[element.name] = value;
+        return Hash.toQueryString(pair);
+      }
+    }
+    return '';
+  },
+
+  getValue: function(element) {
+    element = $(element);
+    var method = element.tagName.toLowerCase();
+    return Form.Element.Serializers[method](element);
+  },
+
+  clear: function(element) {
+    $(element).value = '';
+    return element;
+  },
+
+  present: function(element) {
+    return $(element).value != '';
+  },
+
+  activate: function(element) {
+    element = $(element);
+    try {
+      element.focus();
+      if (element.select && (element.tagName.toLowerCase() != 'input' ||
+        !['button', 'reset', 'submit'].include(element.type)))
+        element.select();
+    } catch (e) {}
+    return element;
+  },
+
+  disable: function(element) {
+    element = $(element);
+    element.blur();
+    element.disabled = true;
+    return element;
+  },
+
+  enable: function(element) {
+    element = $(element);
+    element.disabled = false;
+    return element;
+  }
+}
+
+/*--------------------------------------------------------------------------*/
+
+var Field = Form.Element;
+var $F = Form.Element.Methods.getValue;
+
+/*--------------------------------------------------------------------------*/
+
+Form.Element.Serializers = {
+  input: function(element) {
+    switch (element.type.toLowerCase()) {
+      case 'checkbox':
+      case 'radio':
+        return Form.Element.Serializers.inputSelector(element);
+      default:
+        return Form.Element.Serializers.textarea(element);
+    }
+  },
+
+  inputSelector: function(element) {
+    return element.checked ? element.value : null;
+  },
+
+  textarea: function(element) {
+    return element.value;
+  },
+
+  select: function(element) {
+    return this[element.type == 'select-one' ?
+      'selectOne' : 'selectMany'](element);
+  },
+
+  selectOne: function(element) {
+    var index = element.selectedIndex;
+    return index >= 0 ? this.optionValue(element.options[index]) : null;
+  },
+
+  selectMany: function(element) {
+    var values, length = element.length;
+    if (!length) return null;
+
+    for (var i = 0, values = []; i < length; i++) {
+      var opt = element.options[i];
+      if (opt.selected) values.push(this.optionValue(opt));
+    }
+    return values;
+  },
+
+  optionValue: function(opt) {
+    // extend element because hasAttribute may not be native
+    return Element.extend(opt).hasAttribute('value') ? opt.value : opt.text;
+  }
+}
+
+/*--------------------------------------------------------------------------*/
+
+Abstract.TimedObserver = function() {}
+Abstract.TimedObserver.prototype = {
+  initialize: function(element, frequency, callback) {
+    this.frequency = frequency;
+    this.element   = $(element);
+    this.callback  = callback;
+
+    this.lastValue = this.getValue();
+    this.registerCallback();
+  },
+
+  registerCallback: function() {
+    setInterval(this.onTimerEvent.bind(this), this.frequency * 1000);
+  },
+
+  onTimerEvent: function() {
+    var value = this.getValue();
+    var changed = ('string' == typeof this.lastValue && 'string' == typeof value
+      ? this.lastValue != value : String(this.lastValue) != String(value));
+    if (changed) {
+      this.callback(this.element, value);
+      this.lastValue = value;
+    }
+  }
+}
+
+Form.Element.Observer = Class.create();
+Form.Element.Observer.prototype = Object.extend(new Abstract.TimedObserver(), {
+  getValue: function() {
+    return Form.Element.getValue(this.element);
+  }
+});
+
+Form.Observer = Class.create();
+Form.Observer.prototype = Object.extend(new Abstract.TimedObserver(), {
+  getValue: function() {
+    return Form.serialize(this.element);
+  }
+});
+
+/*--------------------------------------------------------------------------*/
+
+Abstract.EventObserver = function() {}
+Abstract.EventObserver.prototype = {
+  initialize: function(element, callback) {
+    this.element  = $(element);
+    this.callback = callback;
+
+    this.lastValue = this.getValue();
+    if (this.element.tagName.toLowerCase() == 'form')
+      this.registerFormCallbacks();
+    else
+      this.registerCallback(this.element);
+  },
+
+  onElementEvent: function() {
+    var value = this.getValue();
+    if (this.lastValue != value) {
+      this.callback(this.element, value);
+      this.lastValue = value;
+    }
+  },
+
+  registerFormCallbacks: function() {
+    Form.getElements(this.element).each(this.registerCallback.bind(this));
+  },
+
+  registerCallback: function(element) {
+    if (element.type) {
+      switch (element.type.toLowerCase()) {
+        case 'checkbox':
+        case 'radio':
+          Event.observe(element, 'click', this.onElementEvent.bind(this));
+          break;
+        default:
+          Event.observe(element, 'change', this.onElementEvent.bind(this));
+          break;
+      }
+    }
+  }
+}
+
+Form.Element.EventObserver = Class.create();
+Form.Element.EventObserver.prototype = Object.extend(new Abstract.EventObserver(), {
+  getValue: function() {
+    return Form.Element.getValue(this.element);
+  }
+});
+
+Form.EventObserver = Class.create();
+Form.EventObserver.prototype = Object.extend(new Abstract.EventObserver(), {
+  getValue: function() {
+    return Form.serialize(this.element);
+  }
+});
+if (!window.Event) {
+  var Event = new Object();
+}
+
+Object.extend(Event, {
+  KEY_BACKSPACE: 8,
+  KEY_TAB:       9,
+  KEY_RETURN:   13,
+  KEY_ESC:      27,
+  KEY_LEFT:     37,
+  KEY_UP:       38,
+  KEY_RIGHT:    39,
+  KEY_DOWN:     40,
+  KEY_DELETE:   46,
+  KEY_HOME:     36,
+  KEY_END:      35,
+  KEY_PAGEUP:   33,
+  KEY_PAGEDOWN: 34,
+
+  element: function(event) {
+    return $(event.target || event.srcElement);
+  },
+
+  isLeftClick: function(event) {
+    return (((event.which) && (event.which == 1)) ||
+            ((event.button) && (event.button == 1)));
+  },
+
+  pointerX: function(event) {
+    return event.pageX || (event.clientX +
+      (document.documentElement.scrollLeft || document.body.scrollLeft));
+  },
+
+  pointerY: function(event) {
+    return event.pageY || (event.clientY +
+      (document.documentElement.scrollTop || document.body.scrollTop));
+  },
+
+  stop: function(event) {
+    if (event.preventDefault) {
+      event.preventDefault();
+      event.stopPropagation();
+    } else {
+      event.returnValue = false;
+      event.cancelBubble = true;
+    }
+  },
+
+  // find the first node with the given tagName, starting from the
+  // node the event was triggered on; traverses the DOM upwards
+  findElement: function(event, tagName) {
+    var element = Event.element(event);
+    while (element.parentNode && (!element.tagName ||
+        (element.tagName.toUpperCase() != tagName.toUpperCase())))
+      element = element.parentNode;
+    return element;
+  },
+
+  observers: false,
+
+  _observeAndCache: function(element, name, observer, useCapture) {
+    if (!this.observers) this.observers = [];
+    if (element.addEventListener) {
+      this.observers.push([element, name, observer, useCapture]);
+      element.addEventListener(name, observer, useCapture);
+    } else if (element.attachEvent) {
+      this.observers.push([element, name, observer, useCapture]);
+      element.attachEvent('on' + name, observer);
+    }
+  },
+
+  unloadCache: function() {
+    if (!Event.observers) return;
+    for (var i = 0, length = Event.observers.length; i < length; i++) {
+      Event.stopObserving.apply(this, Event.observers[i]);
+      Event.observers[i][0] = null;
+    }
+    Event.observers = false;
+  },
+
+  observe: function(element, name, observer, useCapture) {
+    element = $(element);
+    useCapture = useCapture || false;
+
+    if (name == 'keypress' &&
+      (Prototype.Browser.WebKit || element.attachEvent))
+      name = 'keydown';
+
+    Event._observeAndCache(element, name, observer, useCapture);
+  },
+
+  stopObserving: function(element, name, observer, useCapture) {
+    element = $(element);
+    useCapture = useCapture || false;
+
+    if (name == 'keypress' &&
+        (Prototype.Browser.WebKit || element.attachEvent))
+      name = 'keydown';
+
+    if (element.removeEventListener) {
+      element.removeEventListener(name, observer, useCapture);
+    } else if (element.detachEvent) {
+      try {
+        element.detachEvent('on' + name, observer);
+      } catch (e) {}
+    }
+  }
+});
+
+/* prevent memory leaks in IE */
+if (Prototype.Browser.IE)
+  Event.observe(window, 'unload', Event.unloadCache, false);
+var Position = {
+  // set to true if needed, warning: firefox performance problems
+  // NOT neeeded for page scrolling, only if draggable contained in
+  // scrollable elements
+  includeScrollOffsets: false,
+
+  // must be called before calling withinIncludingScrolloffset, every time the
+  // page is scrolled
+  prepare: function() {
+    this.deltaX =  window.pageXOffset
+                || document.documentElement.scrollLeft
+                || document.body.scrollLeft
+                || 0;
+    this.deltaY =  window.pageYOffset
+                || document.documentElement.scrollTop
+                || document.body.scrollTop
+                || 0;
+  },
+
+  realOffset: function(element) {
+    var valueT = 0, valueL = 0;
+    do {
+      valueT += element.scrollTop  || 0;
+      valueL += element.scrollLeft || 0;
+      element = element.parentNode;
+    } while (element);
+    return [valueL, valueT];
+  },
+
+  cumulativeOffset: function(element) {
+    var valueT = 0, valueL = 0;
+    do {
+      valueT += element.offsetTop  || 0;
+      valueL += element.offsetLeft || 0;
+      element = element.offsetParent;
+    } while (element);
+    return [valueL, valueT];
+  },
+
+  positionedOffset: function(element) {
+    var valueT = 0, valueL = 0;
+    do {
+      valueT += element.offsetTop  || 0;
+      valueL += element.offsetLeft || 0;
+      element = element.offsetParent;
+      if (element) {
+        if(element.tagName=='BODY') break;
+        var p = Element.getStyle(element, 'position');
+        if (p == 'relative' || p == 'absolute') break;
+      }
+    } while (element);
+    return [valueL, valueT];
+  },
+
+  offsetParent: function(element) {
+    if (element.offsetParent) return element.offsetParent;
+    if (element == document.body) return element;
+
+    while ((element = element.parentNode) && element != document.body)
+      if (Element.getStyle(element, 'position') != 'static')
+        return element;
+
+    return document.body;
+  },
+
+  // caches x/y coordinate pair to use with overlap
+  within: function(element, x, y) {
+    if (this.includeScrollOffsets)
+      return this.withinIncludingScrolloffsets(element, x, y);
+    this.xcomp = x;
+    this.ycomp = y;
+    this.offset = this.cumulativeOffset(element);
+
+    return (y >= this.offset[1] &&
+            y <  this.offset[1] + element.offsetHeight &&
+            x >= this.offset[0] &&
+            x <  this.offset[0] + element.offsetWidth);
+  },
+
+  withinIncludingScrolloffsets: function(element, x, y) {
+    var offsetcache = this.realOffset(element);
+
+    this.xcomp = x + offsetcache[0] - this.deltaX;
+    this.ycomp = y + offsetcache[1] - this.deltaY;
+    this.offset = this.cumulativeOffset(element);
+
+    return (this.ycomp >= this.offset[1] &&
+            this.ycomp <  this.offset[1] + element.offsetHeight &&
+            this.xcomp >= this.offset[0] &&
+            this.xcomp <  this.offset[0] + element.offsetWidth);
+  },
+
+  // within must be called directly before
+  overlap: function(mode, element) {
+    if (!mode) return 0;
+    if (mode == 'vertical')
+      return ((this.offset[1] + element.offsetHeight) - this.ycomp) /
+        element.offsetHeight;
+    if (mode == 'horizontal')
+      return ((this.offset[0] + element.offsetWidth) - this.xcomp) /
+        element.offsetWidth;
+  },
+
+  page: function(forElement) {
+    var valueT = 0, valueL = 0;
+
+    var element = forElement;
+    do {
+      valueT += element.offsetTop  || 0;
+      valueL += element.offsetLeft || 0;
+
+      // Safari fix
+      if (element.offsetParent == document.body)
+        if (Element.getStyle(element,'position')=='absolute') break;
+
+    } while (element = element.offsetParent);
+
+    element = forElement;
+    do {
+      if (!window.opera || element.tagName=='BODY') {
+        valueT -= element.scrollTop  || 0;
+        valueL -= element.scrollLeft || 0;
+      }
+    } while (element = element.parentNode);
+
+    return [valueL, valueT];
+  },
+
+  clone: function(source, target) {
+    var options = Object.extend({
+      setLeft:    true,
+      setTop:     true,
+      setWidth:   true,
+      setHeight:  true,
+      offsetTop:  0,
+      offsetLeft: 0
+    }, arguments[2] || {})
+
+    // find page position of source
+    source = $(source);
+    var p = Position.page(source);
+
+    // find coordinate system to use
+    target = $(target);
+    var delta = [0, 0];
+    var parent = null;
+    // delta [0,0] will do fine with position: fixed elements,
+    // position:absolute needs offsetParent deltas
+    if (Element.getStyle(target,'position') == 'absolute') {
+      parent = Position.offsetParent(target);
+      delta = Position.page(parent);
+    }
+
+    // correct by body offsets (fixes Safari)
+    if (parent == document.body) {
+      delta[0] -= document.body.offsetLeft;
+      delta[1] -= document.body.offsetTop;
+    }
+
+    // set position
+    if(options.setLeft)   target.style.left  = (p[0] - delta[0] + options.offsetLeft) + 'px';
+    if(options.setTop)    target.style.top   = (p[1] - delta[1] + options.offsetTop) + 'px';
+    if(options.setWidth)  target.style.width = source.offsetWidth + 'px';
+    if(options.setHeight) target.style.height = source.offsetHeight + 'px';
+  },
+
+  absolutize: function(element) {
+    element = $(element);
+    if (element.style.position == 'absolute') return;
+    Position.prepare();
+
+    var offsets = Position.positionedOffset(element);
+    var top     = offsets[1];
+    var left    = offsets[0];
+    var width   = element.clientWidth;
+    var height  = element.clientHeight;
+
+    element._originalLeft   = left - parseFloat(element.style.left  || 0);
+    element._originalTop    = top  - parseFloat(element.style.top || 0);
+    element._originalWidth  = element.style.width;
+    element._originalHeight = element.style.height;
+
+    element.style.position = 'absolute';
+    element.style.top    = top + 'px';
+    element.style.left   = left + 'px';
+    element.style.width  = width + 'px';
+    element.style.height = height + 'px';
+  },
+
+  relativize: function(element) {
+    element = $(element);
+    if (element.style.position == 'relative') return;
+    Position.prepare();
+
+    element.style.position = 'relative';
+    var top  = parseFloat(element.style.top  || 0) - (element._originalTop || 0);
+    var left = parseFloat(element.style.left || 0) - (element._originalLeft || 0);
+
+    element.style.top    = top + 'px';
+    element.style.left   = left + 'px';
+    element.style.height = element._originalHeight;
+    element.style.width  = element._originalWidth;
+  }
+}
+
+// Safari returns margins on body which is incorrect if the child is absolutely
+// positioned.  For performance reasons, redefine Position.cumulativeOffset for
+// KHTML/WebKit only.
+if (Prototype.Browser.WebKit) {
+  Position.cumulativeOffset = function(element) {
+    var valueT = 0, valueL = 0;
+    do {
+      valueT += element.offsetTop  || 0;
+      valueL += element.offsetLeft || 0;
+      if (element.offsetParent == document.body)
+        if (Element.getStyle(element, 'position') == 'absolute') break;
+
+      element = element.offsetParent;
+    } while (element);
+
+    return [valueL, valueT];
+  }
+}
+
+Element.addMethods();
Index: trunk/wikipathways/wpi/js/editapplet.js
===================================================================
--- trunk/wikipathways/wpi/js/editapplet.js	(revision 0)
+++ trunk/wikipathways/wpi/js/editapplet.js	(revision 1110)
@@ -0,0 +1,199 @@
+var label_maximize = '<img src="/skins/common/images/magnify-clip.png" id="maximize"/>';
+var label_minimize = '<img src="/skins/common/images/magnify-clip.png" id="minimize"/>';
+var initial_applet_width = '500px';
+
+//Uses appletobject.js
+function doApplet(idImg, idApplet, keys, values) {
+	var image = document.getElementById(idImg);
+	
+	var w = getParentWidth(image);
+
+	image.style.width = w + 'px';
+	image.style.height = initial_applet_width;
+	//Clear all existing content
+	image.innerHTML = '';
+	image.setAttribute('class', 'thumbinner');
+
+	//First create a new div for the applet and add it to the idImg
+	appletDiv = document.createElement('div');
+	appletDiv.id = idApplet;
+	appletDiv.setAttribute('class', 'internal');
+	appletDiv.style.width = '100%';
+	appletDiv.style.height = '95%';
+	appletDiv.style.clear = 'both';
+	image.appendChild(appletDiv);
+		
+	//Create maximize div
+	maximize = document.createElement('div');
+	maximize.innerHTML = createMaximizeButton(idImg);
+	maximize.style.cssFloat = 'center';
+	maximize.style.marginBottom = '10px';
+
+	//Create resize hint
+	resize = document.createElement('div');
+	resize.innerHTML = '<img src="/skins/common/images/resize.png';
+	resize.style.position = 'absolute';
+	resize.style.bottom = '0';
+	resize.style.right = '0';
+	image.appendChild(resize);
+	image.appendChild(maximize);
+
+	var ao = new AppletObject(	'org.pathvisio.gui.wikipathways.AppletMain',
+				['/wpi/applet/wikipathways.jar'],
+				'100%', '100%', '1.5.0', 'false',
+				'/wpi/applet',
+				[],
+				AppletObjects.TAG_OBJECT );
+	if(keys != null && values != null) {
+		for(i=0; i < keys.length; i++) {
+					ao.addParam(keys[i], values[i]);
+		}
+	}
+	
+	new Resizeable(idImg, {bottom: 10, right: 10, left: 0, top: 0});
+
+	ao.preload( idApplet );
+}
+
+//Manually (doesn't work well, applet is started twice on firefox
+function replaceWithApplet(idImg, idApplet, keys, values) {
+	var image = document.getElementById(idImg);
+	var applet = createObjectElement(idApplet, keys, values);
+
+	image.setAttribute('class', 'thumbinner');
+
+	var w = getParentWidth(image);
+
+	image.style.width = w + 'px';
+	image.style.height = '500px';
+
+	new Resizeable(idImg, {bottom: 10, right: 10, left: 0, top: 0});
+	image.innerHTML = applet;
+}
+
+function getParentWidth(elm) {
+	var p = findEnclosingTable(elm);
+	return p.offsetWidth;	
+}
+
+function findEnclosingTable(elm) {
+	//find getWidth of enclosing element / table
+	var parent = elm.parentNode;
+	var nn = parent.nodeName.toLowerCase();
+	if(nn == 'td' || nn == 'tr' || nn == 'tbody') {
+		while(true) {
+			if(parent.parentNode == null || parent.nodeName.toLowerCase() == 'table') {
+				break;
+			} else {
+				parent = parent.parentNode;
+			}
+		}
+	}
+	if(parent.nodeName.toLowerCase() == 'table') return parent;
+	else return elm.parentNode; //Not in a table, just return the parent
+}
+
+function replaceElement(elmOld, elmNew) {
+	var p = elmOld.parentNode;
+	p.insertBefore(elmNew, elmOld);
+	p.removeChild(elmOld);
+}
+
+var maxImg = '/skins/common/images/magnify-clip.png';
+
+/* Maximize functions
+ * TODO: create maximizable class with prototype
+ */
+function createMaximizeButton(id) {
+	return('<img href="javascript:;" src="' + maxImg + "\" onclick=\"toggleMaximize(this, '" + id + "', 'maximize', '', '');\" />");
+}
+
+function toggleMaximize(button, id, action, oldWidth, oldHeight) {
+	var element = document.getElementById(id);
+	if(action == 'maximize') {
+		var oldWidth = element.offsetWidth;
+		var oldHeight = element.offsetHeight;
+		var parent = element.parentNode;
+		var left = parent.offsetLeft;
+		var top = parent.offsetTop;
+		while((parent = parent.parentNode) != document) { left += parent.offsetLeft; top += parent.offsetTop; }
+		var newWidth = getViewportWidth() - left;
+		var newHeight = getViewportHeight() - top;
+		element.style.width = newWidth + 'px';
+		element.style.height = newHeight + 'px';
+		button.setAttribute('onclick', 'toggleMaximize(this, "' + id + '", "restore", "' + oldWidth + 'px", "' + oldHeight + 'px");');
+	} else {
+		element.style.width = oldWidth;
+		element.style.height = oldHeight;
+		button.setAttribute('onclick', 'toggleMaximize(this, "' + id + '", "maximize", "", "");');
+	}
+}
+
+/** COPIED FROM Util v1.06:
+ * Copyright (c)2005-2007 Matt Kruse (javascripttoolbox.com)
+ * 
+ * Dual licensed under the MIT and GPL licenses. 
+ * This basically means you can use this code however you want for
+ * free, but don't claim to have written it yourself!
+ * Donations always accepted: http://www.JavascriptToolbox.com/donate/
+ * 
+ * Please do not link to the .js files on javascripttoolbox.com from
+ * your site. Copy the files locally to your server instead.
+ * 
+ */
+function getViewportWidth() {
+		if (document.documentElement && (!document.compatMode || document.compatMode=="CSS1Compat")) {
+			return document.documentElement.clientWidth;
+		}
+		else if (document.compatMode && document.body) {
+			return document.body.clientWidth;
+		}
+		return self.innerWidth;
+};
+function getViewportHeight() {
+		if (!window.opera && document.documentElement && (!document.compatMode || document.compatMode=="CSS1Compat")) {
+			return document.documentElement.clientHeight;
+		}
+		else if (document.compatMode && !window.opera && document.body) {
+			return document.body.clientHeight;
+		}
+		return self.innerHeight;
+};
+/** END COPIED **/
+
+
+function createObjectElement(id, keys, values) {
+	var tag = '<object classid="java:org.pathvisio.gui.wikipathways.AppletMain.class"'
+		+ ' TYPE="application/x-java-applet"'
+		+ ' ARCHIVE="wikipathways.jar"'
+		+ ' CODEBASE="/wpi/applet"'
+		+ ' WIDTH="100%"'
+		+ ' HEIGHT="100%"'
+		+ ' STANDBY="Loading applet..."'
+		+ ' >';
+	if(keys != null && values != null) {
+		for(var i = 0; i < keys.length; i++) {
+			tag += '<param  name="' + keys[i]  + '" ' + 
+				'value="' + values[i] + '" />';
+		}
+	}
+	tag += '</object>';
+		return tag;
+}
+
+function createAppletElement(id, keys, values) {
+	var tag = '<applet code="org.pathvisio.gui.wikipathways.AppletMain"'
+		+ 'ARCHIVE="wikipathways.jar"'
+		+ 'CODEBASE="/wpi/applet"'
+		+ 'WIDTH="100%"'
+		+ '"HEIGHT="100%"'
+		+ '>';
+	if(keys != null && values != null) {
+		for(var i = 0; i < keys.length; i++) {
+			tag += '<param  name="' + keys[i]  + '" ' + 
+				'value="' + values[i] + '" />';
+		}
+	}
+	tag += '</applet>';
+		return tag;
+}
Index: trunk/wikipathways/wpi/js/appletobject.js
===================================================================
--- trunk/wikipathways/wpi/js/appletobject.js	(revision 0)
+++ trunk/wikipathways/wpi/js/appletobject.js	(revision 1110)
@@ -0,0 +1,1439 @@
+/*
+ *  AppletObject
+ *
+ *  Florian Jenett, Stephen Williams, Aaron Steed
+ *
+ *  http://appletobject.org/
+ *
+ *  -----------------------------------------------------------
+ *
+ *	changed: 2007-05-24 07:36:41 - fjenett
+ *	version: 0.0.6
+ *
+ *  -----------------------------------------------------------
+ *
+ *    
+ *
+ *  ----------------------------------------------------------- */
+
+
+/**
+        getElement()
+        
+        return an DOMElement by ID
+ */
+ 
+var getElement = function (aID)
+{ 
+     return ((document.getElementById) ? document.getElementById(aID)
+                                      : document.all[aID]);
+};
+
+
+if ( !Array.prototype.push ) {
+/**
+        Array.push()
+        
+        win IE 5.01 fix,
+        push items onto an array, return new length
+ */
+Array.prototype.push = function() 
+{
+    for(var j = 0, n = arguments.length; j < n; ++j) {
+        this[this.length] = arguments[j];
+    }
+    return this.length;
+};
+};
+
+
+
+if ( !Array.prototype.shift ) {
+/**
+        Array.shift()
+        
+        win IE 5.01 fix,
+        remove and return first item in an array
+ */
+Array.prototype.shift = function ()
+{
+    if ( this.length == 0 ) return null;
+    var val = this[0];
+    var arr = [];
+    for ( var i= 0; i < this.length  ; i++) arr[i]  = this[i];
+    for ( var i= 0; i < this.length-1; i++) this[i] = arr[i+1];
+    this[this.length-1] = null;
+    return val;
+};
+};
+
+
+if ( !Array.prototype.concat ) {
+/**
+        Array.concat()
+        
+        win IE 5.01 fix,
+        append an array to another
+ */
+Array.prototype.concat = function ()
+{
+    for ( var i=0; i< arguments[0].length; i++ ) this[this.length+i] = arguments[0][i];
+};
+};
+
+
+if ( !Number.prototype.toFixed ) {
+/**
+        Number.toFixed()
+        
+        win IE 5.01 fix,
+        return a fixed length float for a number
+ */
+Number.prototype.toFixed = function ( fractionDigits )
+{
+   var fStr = this.toString();
+   var len = fStr.lastIndexOf('.') + fractionDigits + 1;
+   if ( len == fractionDigits ) return this;
+   return (1.0 * fStr.substring(0,len));
+};
+};
+
+//  Function.prototype.bind , $A
+//  taken from:
+/*--------------------------------------------------------------------------*/
+/*  Prototype JavaScript framework, version 1.5.0_rc2
+ *  (c) 2005-2007 Sam Stephenson
+ *
+ *  Prototype is freely distributable under the terms of an MIT-style license.
+ *  For details, see the Prototype web site: http://prototype.conio.net/
+ */
+/*--------------------------------------------------------------------------*/
+
+/**
+        Function.bind()
+        
+        bind a function to an object
+        from: Prototype JavaScript framework, version 1.5.0_rc2
+ */
+
+Function.prototype.bind = function()
+{  
+  var __method = this, args = $A(arguments), object = args.shift();
+  return function() {
+    return __method.apply(object, args.concat(arguments));
+  };
+};
+
+/**
+        $A
+        
+        return an array for an iterable
+        from: Prototype JavaScript framework, version 1.5.0_rc2
+ */
+ 
+var $A = function(iterable) {
+  if (!iterable) return [];
+  if (iterable.toArray) {
+    return iterable.toArray();
+  } else {
+    var results = [];
+    for (var i = 0, length = iterable.length; i < length; i++)
+      results.push(iterable[i]);
+    return results;
+  }
+};
+
+
+/**
+        Array.implode()
+        
+        in love with PHPs implode function,
+        opposite to string.split(seperator)
+        
+        @param string seperator
+
+        example:
+          (["1","2","3"]).implode( ", " );
+          > "1, 2, 3"
+ */
+ 
+Array.prototype.implode = function ( _sep )
+{
+    var i = 0;    var _str = this[0];
+    while ( this[i+1] ) _str = _str + _sep + this[++i];
+    return _str;
+};
+
+
+
+/**
+        singleton prototype AppletObjects
+        
+        a wrapper around all AppletObjects, it does:
+        - java detection
+        - handles callbacks from the preloader-applet
+        - maintains access to all appletobjects
+ */
+ 
+AppletObjects =
+{
+    objects : [], // array containing all appletobjects
+    push : function ( _obj )
+    {
+        return this.objects.push(_obj)-1; // return the ID of the object injected
+    },
+    
+    create : function ( opt )
+    {
+        return new AppletObject( opt.code, 
+                                 opt.archives, 
+                                 opt.width, opt.height,
+                                 
+                                 opt.minimumVersionString,
+                                 opt.mayscript,
+                                 opt.codebase,
+                                 opt.params,
+                                 opt.tagType );
+    },
+    
+    // Preloading-applet callbacks
+    //
+    inited : function ( _id )
+    {
+        if ( this.objects[_id] ) this.objects[_id].inited = true;
+    },
+    started : function ( _id )
+    {
+        if ( this.objects[_id] ) this.objects[_id].started = true;
+    },
+    
+    readRegistry : false,
+    useBrutForceDetectionForIE : true,
+    IEDetectUnder13 : true, // see not in getJavaVersionWithBrutForce()
+    debugLevel : 0,
+    
+    JAVA_PLUGIN_MISSING : -1,
+    JAVA_DISABLED : -2,
+    JAVA_PLUGIN_TOO_OLD : -3,
+    hasJava : function ()
+    {
+        // refresh() is not working properly ..
+        //if ( navigator.plugins && navigator.plugins.refresh )
+        //        navigator.plugins.refresh(true);
+        
+        var jMimeType = 'application/x-java-applet';
+        
+        var hasPlugin = false; // true as default for IE
+        
+        // netscape mac seems to wrongly report javaEnabled() as false.
+        // so we take our chances and just assume it's enabled ...
+        //
+        var isEnabled = (navigator.userAgent.toLowerCase().match("netscape")
+                         ? true
+                         : navigator.javaEnabled());
+        
+        // [fjen] i read that actually VBScript is more compatible on IE.
+        //          we should think / talk about switching over to that ...
+        
+        if (    window.ActiveXObject
+             && navigator.plugins.length == 0 ) // msIE
+        {
+            // checks for JavaPlugin versions 1.2.0_00 to 1.6.6_14
+            // IE win only
+            //
+            var vers; var n1 = 12, n2 = 0, n3 = 0;
+            for ( n1 = 12; n1 < 17 && !hasPlugin; n1++ )
+            {
+                for ( n2 = 0; n2 < 7 && !hasPlugin; n2++ )
+                {
+                    for ( n3 = 0; n3 < 15 && !hasPlugin; n3++ )
+                    {
+                        vers = n1+(n2+'_'+(n3<10?'0'+n3:n3));
+                        try {
+                            hasPlugin = new ActiveXObject('JavaPlugin.'+vers);
+                            if ( hasPlugin )
+                            {
+                                var versString = '1.' +
+                                                 (n1 - 10) + '.' +
+                                                 (n2+'_'+(n3<10?'0'+n3:n3));
+                                
+                                this.JREVersion =  
+                                    new AppletObjects.JavaVersion( versString );
+                                
+                                if ( this.debugLevel == 0 ) 
+                                    this.saveJavaVersionToCookie( javaVersion );
+                            }
+                        } catch (e) {}
+                    }
+                }
+            }
+            if ( !hasPlugin ) return AppletObjects.JAVA_PLUGIN_MISSING;
+        }
+        
+        
+        var i, j;
+        for (i = 0;    i < navigator.plugins.length 
+                    && !hasPlugin; i++)
+        {
+            if ( navigator.plugins[i].name.toLowerCase().match("java") )
+            {
+                for (j = 0; j < navigator.plugins[i].length && !hasPlugin; j++)
+                {
+                    hasPlugin = navigator.plugins[i][j].type.match(jMimeType);
+                    //if ( hasPlugin )  alert( navigator.plugins[i][j].type );
+                }
+            }
+        }
+        
+        // [fjen] this is an opera fix, java will not be in plugins[],
+        //          but in mimetypes[]
+        //          sidenote: after deinstalling java on winXP, opera 8.51
+        //          kept the mimetype around.
+        //
+        for (i = 0;    i < navigator.mimeTypes.length 
+                    && !hasPlugin; i++)
+        {
+            hasPlugin = navigator.mimeTypes[i].type.toLowerCase().match(jMimeType);
+            //if ( hasPlugin )  alert( navigator.mimeTypes[i].type );
+        }
+        
+        
+        // [fjen] opera is not registering the java-plugin with 
+        //          navigator.plugins, we try to rely on isEnabled
+        //          for that ...
+        //
+        var returnValue = true;
+        
+        if ( !isEnabled && hasPlugin ) {
+        
+            returnValue = AppletObjects.JAVA_DISABLED;
+            
+        } else if ( !hasPlugin ) {
+        
+            returnValue = AppletObjects.JAVA_PLUGIN_MISSING;
+        }
+
+        return returnValue;
+    },
+    
+    /**
+     *  This code is based on some code posted to the Java Forum. 
+     *  Have another look to find the authors details.
+     *
+     *    http://forum.java.sun.com/thread.jspa?threadID=168544
+     */
+    
+    JREVersion : null,
+    
+    getJavaVersion : function ()
+    {
+        if (this.debugLevel==0)
+        {
+            var JREVersionFromCookie = this.getCookie("JREVersion");
+            if (JREVersionFromCookie)
+            {
+                //alert("from cookie: "+JREVersionFromCookie);
+                this.JREVersion = new AppletObjects.JavaVersion(JREVersionFromCookie);
+                return JREVersionFromCookie;
+            }
+        }
+        if ( this.JREVersion ) return this.JREVersion;
+
+        var javaVersion = new AppletObjects.JavaVersion("0.0.0_0");
+        var agt=navigator.userAgent.toLowerCase();
+        
+        this.browser = agt;
+        
+        var is_major = parseInt(navigator.appVersion);
+    
+        var is_nav = (      (agt.indexOf('mozilla')!=-1)
+                       && (agt.indexOf('spoofer')==-1)
+                       && (agt.indexOf('compatible') == -1) 
+                       && (agt.indexOf('opera')==-1)
+                       && (agt.indexOf('webtv')==-1) 
+                       && (agt.indexOf('hotjava')==-1)  );
+                       
+        var is_nav4up= (is_nav && (is_major >= 4));
+        
+        var is_ie    = ((agt.indexOf("msie") != -1) && (agt.indexOf("opera") == -1));
+        
+        var is_ie5   = (is_ie && (is_major == 4) && (agt.indexOf("msie 5.0") !=-1) );
+        var is_ie5_5 = (is_ie && (is_major == 4) && (agt.indexOf("msie 5.5") !=-1));
+        var is_ie6   = (is_ie && (is_major == 4) && (agt.indexOf("msie 6.0") !=-1));
+        var is_ie7   = (is_ie && (is_major == 4) && (agt.indexOf("msie 7.0") !=-1));
+        var is_ie5up = (is_ie && (is_major == 4) 
+                       && (    (agt.indexOf("msie 5.0")!=-1)
+                            || (agt.indexOf("msie 5.5")!=-1)
+                            || (agt.indexOf("msie 6.0")!=-1) 
+                            || (agt.indexOf("msie 7.0")!=-1) 
+                        ) );
+    
+        var pluginDetected = false;
+        var activeXDisabled = false;
+        
+        // we can check for plugin existence only when browser is 'is_ie5up' or 'is_nav4up'
+        if (is_nav4up)
+        {
+            // Refresh 'navigator.plugins' to get newly installed plugins.
+            // Use 'navigator.plugins.refresh(false)' to refresh plugins
+            // without refreshing open documents (browser windows)
+            //
+            // [fjen] this is actually not working in some cases .. opera i think had problems.
+            //          have to recheck which browsers ignore it though.
+            
+            if (navigator.plugins) 
+            {
+                navigator.plugins.refresh(false);
+            }
+        
+            // check for Java plugin in installed plugins
+            if ( navigator.mimeTypes )
+            {
+                for ( var i=0; i < navigator.mimeTypes.length; i++ )
+                {
+                    mimeType = navigator.mimeTypes[i].type;
+                    
+                    // [fjen]
+                    // ";jpi-version="
+                    // i wonder if all browsers actually report the mimetypes in this format.
+                    // - safari mac will not have jpi-version in mimetype
+                    
+                    if( (mimeType != null)
+                        && (mimeType.indexOf( "application/x-java-applet;jpi-version=") != -1) )
+                    {
+                            var versionIndex = mimeType.indexOf("version=");
+                            var tmpJavaVersion = 
+                                new AppletObjects.JavaVersion(mimeType.substring(versionIndex+8));
+                            if ( tmpJavaVersion.isGreater(javaVersion) )
+                            {
+                                javaVersion = 
+                                new AppletObjects.JavaVersion(mimeType.substring(versionIndex+8));
+                            }
+                            pluginDetected = true;
+                    }
+                }
+            }
+        }
+        else if (is_ie5up)     // [fjen] what about IE 5.2 Mac? came installed until osx 10.3
+        {
+            registryBeenRead = false;
+            if ( this.readRegistry )
+            {
+                /*
+                 * Using the shell causes IE to display a warning that the script
+                 * may not be safe.
+                 *
+                 */
+                var shell;
+                try
+                {
+                    // Create WSH(WindowsScriptHost) shell, available on Windows only
+                    shell = new ActiveXObject("WScript.Shell");
+            
+                    if (shell != null) 
+                    {
+                        // Read JRE version from Window Registry
+                        try
+                        {
+                            javaVersion = 
+                                new AppletObjects.JavaVersion( shell.regRead(
+                                            "HKEY_LOCAL_MACHINE\\Software\\"+
+                                            "JavaSoft\\Java Runtime Environment\\CurrentVersion"));
+                            registryBeenRead = true;
+                            pluginDetected = true;
+                        } catch(e) {
+                            // handle exceptions raised by 'shell.regRead(...)' here
+                            // so that the outer try-catch block would receive only
+                            // exceptions raised by 'shell = new ActiveXObject(...)'
+                        }
+                    } else { 
+                        //alert("Couldn t get shell");
+                    }
+                } catch(e) {
+                    // Creating ActiveX controls thru script is disabled
+                    // in InternetExplorer security options
+                    
+                    // To enable it:
+                    // a. Go to the 'Tools --> Internet Options' menu
+                    // b. Select the 'Security' tab
+                    // c. Select zone (Internet/Intranet)
+                    // d. Click the 'Custom Level..' button which will display the
+                    // 'Security Settings' window.
+                    // e. Enable the option 'Initialize and script ActiveX controls
+                    // not marked as safe'
+                
+                    activeXDisabled = true;
+                }
+            }
+            
+            // so, this is only IE5+ ?
+            
+            if ( !registryBeenRead && this.useBrutForceDetectionForIE )
+            {
+                javaVersion = this.getJavaVersionWithBrutForce( this.minimumVersion ); // where does this arg end up?
+                pluginDetected = javaVersion.isGreater(AppletObjects.JavaVersion("0.0.0_0"));
+            }
+        }
+        if(!pluginDetected){
+        	// if the plugin can't be detected we probably have a script error
+        	// and should just write the applet code to the browser and 
+        	// hope that the version is infact new enough
+			javaVersion = new AppletObjects.JavaVersion("99.99.99_99");
+		}
+		
+        this.JREVersion = javaVersion;
+        if (this.debugLevel==0){
+            this.saveJavaVersionToCookie(javaVersion);
+        }
+        return javaVersion;
+    },
+
+    /**
+     * This function tries to instantiate JavaPlugin.??? objects.
+     * JRE versions 1.1.1_06 through to 1.3.1 installed a JavaSoft.JavaBeansBridge object.
+     */
+     
+    getJavaVersionWithBrutForce: function ()
+    {
+        var javaVersion = new AppletObjects.JavaVersion("0.0.0_0");
+        startOfRegistryClasses = new AppletObjects.JavaVersion("1.3.1_1");
+        try
+        {
+//            if(!this.minimumVersion.isGreater(startOfRegistryClasses)){
+            if (this.IEDetectUnder13)
+            {
+                /* this call caused the java console to load, which takes 1 or two seconds.
+                * If you are going to display an applet anyway this is no problem otherwise
+                * you might want to avoid using it.
+                *
+                * [fjen] so, the java-console will open no matter what?
+                */
+                result = new ActiveXObject("JavaSoft.JavaBeansBridge");
+                if (result)
+                {
+                    javaVersion = new AppletObjects.JavaVersion("1.1.1_06");
+                }
+            }
+        } catch (e) {}
+//        }
+// if I check every time I write an applet 
+// then I can start looking from the supplied min version
+//        major = 10+this.minimumVersion.major;
+
+        major = 13;
+        for (; major <= 16; major++)            //major  1.3 - 1.6
+        {            
+            for (minor=0; minor <= 2; minor++)    //minor 0  - 2;  I have also seen Java version 1.1.4 to 1.1.8
+            {    
+                for (sub=0; sub <= 20; sub++)    //major  0 - 20???
+                {
+                    subVersion = "";
+                    if (sub > 0)
+                    {
+                        subVersion = "_";
+                        if (sub < 10)
+                        {
+                            subVersion = subVersion + "0" + sub;
+                        } 
+                        else
+                        {
+                            subVersion = subVersion + "" + sub;
+                        }
+                    }
+                    regVersion = major+""+minor+subVersion;
+                    if (major==15)
+                    {
+//                        alert(regVersion);
+                    }
+                    try 
+                    {
+                        result = new ActiveXObject("JavaPlugin."+regVersion);
+                        if (result) 
+                        {
+                            var version = ""+(major/10) + "." + minor+subVersion;
+                            javaVersion = new AppletObjects.JavaVersion(version);
+                            
+                            if (this.debugLevel==0) 
+                            {
+                                //alert(regVersion);
+                                javaVersion.show();
+                            }
+                        }
+                    } catch(e) {}
+//                    if(!this.minimumVersion.isGreater(javaVersion)){
+//                        return javaVersion;
+//                    }
+                }
+            }
+        }
+        return javaVersion;
+    },
+    
+    /**
+     *         setCookie(nameOfCookie, value, expireHours);
+     *         
+     *         used to save something in a cookie on the client machine
+     */
+
+    setCookie: function (nameOfCookie, value, expireHours)
+    {
+        var expireDate = new Date ();
+          expireDate.setTime(expireDate.getTime() + (expireHours * 3600 * 1000));
+          document.cookie = nameOfCookie + "=" + escape(value) + "; path=/" + ((expireHours == null) ? "" : "; expires=" + expireDate.toGMTString());
+    },
+
+    /**
+     *         getCookie(nameOfCookie);
+     *         
+     *         used to get something from a cookie on the client machine
+     */
+
+    getCookie: function(nameOfCookie)
+    {
+        if (document.cookie.length > 0)
+        {
+            var begin = document.cookie.indexOf(nameOfCookie+"=");
+            if (begin != -1)
+            {
+                begin += nameOfCookie.length+1; 
+                var end = document.cookie.indexOf(";", begin);
+                if (end == -1)
+                    end = document.cookie.length;
+            
+                return unescape(document.cookie.substring(begin, end));
+            }
+            return null; 
+          }
+        return null; 
+    },
+
+
+    /**
+     *         saveJavaVersionToCookie();
+     *         
+     *         used to save the java version so we don't have to retest it 
+     *         next time the user wants to load an applet.
+     */
+    
+    saveJavaVersionToCookie : function(JREVersion)
+    {
+        var now = new Date();
+
+        userid = this.getCookie("AOUSER_ID");
+        if (userid == null || (userid==""))
+        {
+            var randomnumber = Math.floor(Math.random() * 10000);
+            userid = "aouser_id" + now.getTime() +"r"+ randomnumber
+        };
+        //alert(JREVersion);
+        this.setCookie("AOUSER_ID", userid, 10000);
+        this.setCookie("JREVersion", JREVersion, 10000);
+        userid="";
+        userid=this.getCookie("AOUSER_ID");
+    },
+    
+    TAG_APPLET : 1,
+    TAG_OBJECT : 2,
+    TAG_EMBED  : 4,
+    
+    
+    PRELOAD_TIMEDOUT : -13
+};
+
+
+/**
+        prototype JavaVersion()
+        
+        represents a java version
+ */
+
+AppletObjects.JavaVersion = function (version)
+{
+    this.minor = 0;
+    this.rev = 0;
+    arrVersion = version.split(".");
+    
+    if (arrVersion[2] != null) 
+    {
+        arrMinorAndRev = arrVersion[2].split("_");
+        this.minor = arrMinorAndRev[0] != null ? parseInt(arrMinorAndRev[0]) : 0;
+        
+        if (arrMinorAndRev[1] != null)
+        {
+            if (arrMinorAndRev[1].substring(0,1)=="0")
+            {
+                this.rev = parseInt(arrMinorAndRev[1].substring(1,2));
+            }
+            else
+            {
+                this.rev = parseInt(arrMinorAndRev[1]);
+            }
+        }
+    }
+    
+    this.superMajor = arrVersion[0] != null ? parseInt(arrVersion[0]) : 0;
+    this.major = arrVersion[1] != null ? parseInt(arrVersion[1]) : 0;
+};
+
+
+/**
+        AppletObjects.JavaVersion.isGreater()
+        
+        compare two JavaVersion objects
+ */
+
+AppletObjects.JavaVersion.prototype.isGreater = function (fv)
+{
+    if(this.major < fv.major) return false;
+    if(this.major > fv.major) return true;
+    if(this.minor < fv.minor) return false;
+    if(this.minor > fv.minor) return true;
+    if(this.rev < fv.rev) return false;
+    return true;
+};
+
+
+/**
+        AppletObjects.JavaVersion.show()
+        
+        used for debugging
+ */
+
+AppletObjects.JavaVersion.prototype.show = function ()
+{
+    //alert(this.toString());
+};
+
+
+/**
+        AppletObjects.JavaVersion.toString()
+        
+        return a string representation of this JavaVersion object
+ */
+
+AppletObjects.JavaVersion.prototype.toString = function ()
+{
+    var versionString = ""+this.superMajor+
+            "."+this.major+
+            "."+this.minor;
+
+    if ( this.rev )
+    {
+        if( this.rev >= 10 )
+        {
+            versionString += "_"+this.rev;
+        }
+        else
+        {
+            versionString += "_0"+this.rev;
+        }
+    }
+    return versionString;
+};
+
+
+var AppletObject = 
+/**
+        prototype AppletObject()
+        
+        represents an applet object
+ */
+function AppletObject ( ) 
+{
+    this.code         = arguments[0];
+    
+    this.archives = new Array();
+    if ( arguments[1] )
+    {
+        this.archives     = (arguments[1][0].length > 1)
+                          ? arguments[1]
+                          : arguments[1].split(',');
+    }
+    
+/*ORIGINAL
+    this.width      = arguments[2] > 0 ? arguments[2] : 100; // [fjen] alert? read from element?
+    this.height     = arguments[3] > 0 ? arguments[3] : 100;
+*/
+//MODIFIED
+    this.width      = arguments[2] > 0 ? arguments[2] : '100%'; // [fjen] alert? read from element?
+    this.height     = arguments[3] > 0 ? arguments[3] : '100%';
+
+    var minimumVersionString = arguments[4] ? arguments[4] : 0;
+                      
+    this.mayscript  = arguments[5] ? arguments[5] : 'true';
+    
+    this.codebase   = arguments[6] != '' ? arguments[6] : null;
+    
+    this.params = new Array();
+    if (arguments[7]) {
+        this.addParams(arguments[7]);
+    }
+    
+    this.tagType    = arguments[8] && arguments[8] > 0 && arguments[8] < 5
+                      ? arguments[8]
+                      : AppletObjects.TAG_OBJECT; // [fjen] changed that to object as default
+    
+    this.fallback    = 'To view this content, you need to install '+
+                       'Java from <A HREF="http://java.com">java.com</A>';
+                       
+    this.java_disabled_message = '<p><strong>'+
+                                'Java is disabled in your browsers preferences.<br />'+
+                                'You need to activate it to view this applet.'+
+                                '<'+'/strong><'+'/p>'+
+                                'Reload this page once you enabled Java.';
+                                
+    this.java_plugin_message = '<p><strong>'+
+                                'This browser does not have a Java Plug-in.'+
+                                '<'+'/strong><'+'/p>'+
+                                '<a href="http://java.sun.com/products/plugin/downloads/index.html">'+
+                                'Get the latest Java Plug-in here.'+
+                                '<'+'/a>';
+
+    this.java_version_message = '<p><strong>'+
+                                'This browser does not have a recent enough Java Plug-in.'+
+                                '<'+'/strong><'+'/p>'+
+                                '<a href="http://java.sun.com/products/plugin/downloads/index.html">'+
+                                'Get the latest Java Plug-in here.'+
+                                '<'+'/a>';
+
+    this.loading_message = '<b>Loading applet ...<'+'/'+'b>';
+    
+    this.preload_timedout_message = '<b>Preloading timed out!<'+'/'+'b>';
+    
+    this.currentJar = 0;
+    
+    this.loaded     = false;
+    this.inited     = false;
+    this.started     = false;
+    
+    this.container     = null;
+    this.preloadContainer = null;
+    this.preLoadClass = "de.bezier.js.preloading.Preloading.class";
+    this.preLoadJar   = "wikipathways.jar";
+    this.timeoutFunctionID     = null;
+    this.timeLastPreload = 0;
+    
+    // [fjenett 20070219] 1 minute, timeout if preloader fails (no callbacks)
+    this.preloadTimeout = 1000*60*1;
+    
+    // [fjen] should fork, but 0 would strangle konqeror 3.x
+    this.wait         = 500;
+    this.loadChecks = 0;
+    
+    this.javaCheck = AppletObjects.hasJava();
+    
+    if ( minimumVersionString.length > 0 )
+    {        
+        AppletObjects.getJavaVersion();
+        this.minimumVersion = new AppletObjects.JavaVersion( minimumVersionString );
+        
+        if ( !AppletObjects.JREVersion.isGreater( this.minimumVersion ) )
+        {
+            this.javaCheck = AppletObjects.JAVA_PLUGIN_TOO_OLD;
+        }
+    }
+    
+    this.id = AppletObjects.push(this);
+};
+
+
+/**
+        AppletObject.getContainer()
+        
+        set and return the DOMElement into which the applet will be created
+ */
+
+AppletObject.prototype.getContainer = function (elmID)
+{
+    if (!elmID && this.container) return this.container;
+    if (this.container == null ) this.container = getElement(elmID);
+    return this.container;
+};
+
+
+
+/**
+        AppletObject.alterElement()
+        
+        2007-02-10 17:38:49 - fjenett
+        this is a fix for camino 1.0.3 mac,
+        which will flicker when using Element.innerHTML = ...
+        
+        todo: check element is !null and DOM
+ */
+
+AppletObject.prototype.alterElement = function ( element, html_snip )
+{
+    setTimeout( function(){ element.innerHTML=html_snip; }, 10 );
+};
+
+
+/**
+        default callback from Preloading applet
+        
+        onfail() will be called once if loading fails.
+ */
+
+AppletObject.prototype.onfail = function( err, element_id )
+{
+    switch ( err )
+    {
+        case AppletObjects.PRELOAD_TIMEDOUT:
+            this.alterElement(getElement( this.element_id ), this.preload_timedout_message);
+            break;
+            
+        case AppletObjects.JAVA_DISABLED:
+            this.alterElement(getElement( this.element_id ), this.java_disabled_message);
+            break;
+            
+        case AppletObjects.JAVA_PLUGIN_TOO_OLD:
+            this.alterElement(getElement( this.element_id ), this.java_version_message);
+            break;
+            
+        case AppletObjects.JAVA_PLUGIN_MISSING:
+        default:
+            this.alterElement(getElement( this.element_id ), this.java_plugin_message);
+    }
+};
+
+
+/**
+        default callback from Preloading applet
+        
+        oninit() will be called once just before loading starts.
+ */
+ 
+AppletObject.prototype.oninit = function()
+{
+    this.alterElement( getElement( this.element_id ), this.loading_message);
+};
+
+
+
+/**
+        default callback from Preloading applet
+        
+        onstep() will be called twice per jar.
+ */
+ 
+AppletObject.prototype.onstep = function(perc)
+{
+    this.alterElement( getElement( this.element_id ),
+        '<b>Loading applet:<'+'/b><br /><br />' +
+        '<div style="width:100px"><p style="color:#ffffff;' + 
+                    'background-color:#AAAA99;' + 
+                    'width:' + Math.floor(perc)+'%;' + 
+                    'overflow:hidden;' + 
+                    '">' +
+            perc + "%" +
+        '<'+'/p>'+'<'+'/div>' );
+};
+
+
+
+/**
+        default callback from Preloading applet
+        
+        onload() will be called once when preloading is finished.
+ */
+ 
+AppletObject.prototype.onload = function()
+{
+    //this.debug( this.element_id );
+    this.writeToElement( this.element_id );
+};
+
+
+/**
+        AppletObject._checkNext()
+        
+        check preloading status in preloading loop
+ */
+
+AppletObject.prototype._checkNext = function ()
+{
+    window.clearTimeout(this.timeoutFunctionID);
+    
+    if ( !this.preloadContainer )
+    {
+        this.preloadContainer = document.createElement("div");
+        // opera 9 mac won't load hidden applets, so let it
+        // be very tiny and sit in the upper left corner
+
+        this.preloadContainer.style.position = "absolute";
+        this.preloadContainer.style.top  = '0px';
+        this.preloadContainer.style.left = '0px';
+        this.preloadContainer.style.width  = '1px';
+        this.preloadContainer.style.height = '1px';
+        this.preloadContainer.style.borderWidth = '0px';
+        this.preloadContainer.style.zIndex = 1000;
+        document.body.insertBefore( this.preloadContainer, document.body.lastChild.nextSibling ); // insertAfter
+    }
+    
+    var loadlet = this.preloadContainer.firstChild;
+    
+    var isActive = ( loadlet && document.applets.length > 0
+                       && loadlet == document.applets[document.applets.length-1]
+                       ? true : false );
+    
+    if ( !this.loaded && isActive )
+    {
+        if ( this.currentJar >= this.archives.length )
+        {
+            this.loaded = true;
+            if ( Function.prototype.apply )
+                this.timeoutFunctionID = window.setTimeout(
+                            this._loadCleanup.bind(this), 5000 );
+                            // 5sec, let FF 1.5 have some time to breathe
+            else
+                this._setTimeout( '_loadCleanup()', 1000);
+                
+            return this.onload();
+        }
+                
+        if ( this.inited )
+        {
+            this.inited  = false;
+            this.perc++;
+            this.onstep( (this.perc * this.stepPerc).toFixed(2) );
+        }
+    
+        if ( this.started )
+        {
+            this.started = false;
+            this.perc++;
+            this.onstep( (this.perc * this.stepPerc).toFixed(2) );
+            this._loadNext();
+        }
+        
+        if ( ((new Date()).getTime() - this.timeLastPreload) > this.preloadTimeout )
+        {
+            
+            if ( Function.prototype.apply )
+                this.timeoutFunctionID = window.setTimeout(
+                            this._loadCleanup.bind(this), 5000 );
+            else
+                this._setTimeout( '_loadCleanup()', 1000);
+                
+            this.onfail( AppletObjects.PRELOAD_TIMEDOUT );
+            
+            return;
+        }
+    }
+    else if ( !loadlet )
+    {
+        this._loadNext();
+    }
+    else return alert( 'Error: preloading class is missing.' );
+    
+    if ( Function.prototype.apply ) 
+        this.timeoutFunctionID = window.setTimeout( this._checkNext.bind(this), this.wait);
+    else
+        this._setTimeout( '_checkNext()', 1000);
+};
+
+
+/**
+        AppletObject._setTimeout()
+        
+        internal function to do a bound setTimeout on this AppletObject.
+        this is a fix for win IE 5.01
+ */
+
+AppletObject.prototype._setTimeout = function ( _fnc, delay )
+{
+    // fix win 5.01
+    var __code = 'AppletObjects.objects['+this.id+'].'+_fnc;
+    this.timeoutFunctionID = window.setTimeout( function(){eval(__code);}, delay);
+};
+
+
+/**
+        AppletObject._loadCleanup()
+        
+        internally called to do some cleanup after preloading
+ */
+
+AppletObject.prototype._loadCleanup = function ()
+{
+    window.clearTimeout(this.timeoutFunctionID);
+    this.preloadContainer.style.top  = '-10px';
+    this.preloadContainer.style.left = '-10px';
+    this.preloadContainer.style.display = 'none';
+    this.preloadContainer.parentNode.removeChild(this.preloadContainer.parentNode.lastChild);
+};
+
+
+/**
+        AppletObject._loadNext()
+        
+        internally called to preload one jar
+        
+        todo: maybe change to <object> ?
+ */
+
+AppletObject.prototype._loadNext = function ()
+{
+    this.preloadContainer.archives = this.archives[this.currentJar]+','+this.preLoadJar;
+    this.currentJar++;
+    this.alterElement( this.preloadContainer, 
+					   '<applet '+  'code="'+this.preLoadClass+'" '+
+									 'archive="'+this.preloadContainer.archives+'" '+
+									   ( this.codebase ? 
+									   'codebase="' + this.codebase + '" ' : '' ) +
+									 'width="1"'+
+									 'height="1"'+
+									 'mayscript="true">'+
+							'<param name="AObject" value="'+this.id+'" />'+
+							'<param name="boxbgcolor" value="'+this.getParam('boxbgcolor')+'" />'+
+						'</applet>' 
+						);
+    
+    this.timeLastPreload = (new Date()).getTime();
+    
+    //alert( this.preloadContainer.innerHTML );
+};
+
+
+/**
+        AppletObject.preload()
+        
+        start preloading loop
+ */
+
+AppletObject.prototype.preload = function ( emlID )
+{
+    this.element_id = emlID;
+
+    if (this.javaCheck!=true) { return this.onfail(this.javaCheck); }
+    
+    // no archives, no preload!
+    if ( this.archives.length <= 0 )
+    {
+        this.oninit();
+        this.onload();
+        return;
+    }
+    
+    this.loaded  = false;
+    this.started = false;
+    this.inited  = false;
+    
+    this.oninit();
+    
+    this.currentJar = 0;
+    this.preloadContainer = null;
+    this.stepPerc = (50.0/(this.archives.length-1)); // called twice per jar
+    this.perc = 0;
+    
+    this._checkNext();
+};
+
+
+/**
+        AppletObject.load()
+        
+        create tag, insert into element without preloading
+ */
+
+AppletObject.prototype.load = function ( elementId )
+{
+    this.element_id = elementId;
+
+    if (this.javaCheck!=true) { return this.onfail(this.javaCheck); }
+
+    //this.alterElement( getElement( this.element_id ), '<img src="http://localhost/apache_pb.gif" alt="loading..."/>' );
+    /*this.alterElement( getElement( this.element_id ), 
+                       '<img src="http://ez-applet-html.sourceforge.net/qualiyassurance.php?version=' +
+                       AppletObjects.JREVersion.toString() + '&browser='+this.browser + ' alt="loading..."/>' );*/
+                    
+    this.writeToElement( this.element_id );
+};
+
+
+/**
+        AppletObject.create()
+        
+        called to create an applet tag based on 
+        AppletObject setting tagType
+ */
+    
+AppletObject.prototype.create = function () 
+{
+    var _str = "";
+    switch (this.tagType) {
+        case AppletObjects.TAG_APPLET:
+            _str = this.createTagApplet();
+            break;
+        case AppletObjects.TAG_OBJECT:
+            _str = this.createTagObject();
+            break;
+        case AppletObjects.TAG_EMBED:
+            _str = this.createTagEmbed();
+            break;
+        default:
+            _str = this.createTagApplet();
+    }
+    return _str;
+};
+
+
+/**
+        AppletObject.createTagApplet()
+        
+        create the an applet applet tag
+ */
+
+AppletObject.prototype.createTagApplet = function ()
+{
+	var codebaseString = ( this.codebase )? 'codebase="' + this.codebase+'" ' : '' ;
+	var tag = '<applet code="'      + this.code
+ 				  + '" archive="'   + this.archives.implode(', ')
+            	  + '" ' 			+ codebaseString
+				  + '  width="'     + this.width 
+				  + '" height="'    + this.height
+				  + '" mayscript="' + this.mayscript
+				  + '" >';
+    for(var i = 0; i < this.params.length; i++)
+    {
+        tag += '<param  name="' + this.params[i].name  + '" ' + 
+                      'value="' + this.params[i].value + '" />';
+    }
+    tag += this.fallback;
+    tag += '</applet>';
+    return tag;
+};
+
+
+/**
+        AppletObject.createTagObject()
+        
+        create the an object applet tag,
+        this is the current default
+ */
+ 
+AppletObject.prototype.createTagObject = function ()
+{
+    if ( navigator.userAgent.toLowerCase().match('msie') )
+        return this.createTagObjectIE();
+        
+    var jarchives = this.archives.implode(", ");
+    
+    var tag = '<object classid="java:'+this.code+'.class" '+
+                      'type="application/x-java-applet" '+
+                      'archive="'   + jarchives+'" '+
+                        ( this.codebase 
+                      ? 'codebase="'+ this.codebase+'" ' : '' ) +
+                        'width="'     + this.width +'" '+
+                      'height="'    + this.height +'" '+
+                      'standby="Loading applet ..." '+
+                      '>'+
+                        ( this.codebase ?
+                      '<param name="codebase"   value="'+ this.codebase+'" />' : '' ) +
+                    '<param name="archive"    value="'+jarchives+'" />'+
+                    '<param name="mayscript"  value="'+this.mayscript+'" />'+
+                    '<param name="scriptable" value="'+this.mayscript+'" />';
+    for(var i = 0; i < this.params.length; i++)
+    {
+        tag += '<param  name="' + this.params[i].name  + '" ' + 
+                      'value="' + this.params[i].value +'" />';
+    }
+    tag += this.fallback;
+    tag += '</object>';
+    return tag;
+};
+
+
+/**
+        AppletObject.createTagObjectIE()
+        
+        create the an object applet tag for internet explorer
+ */
+
+// [fjen] this ( clsid / codebase ) needs to play together with the minimumVersion
+//           setting.
+
+AppletObject.prototype.createTagObjectIE = function ()
+{
+    var jarchives = this.archives.implode(", ");
+    
+    var tag = '<object classid="clsid:8AD9C840-044E-11D1-B3E9-00805F499D93" '+
+                      'type="application/x-java-applet" '+
+                      'archive="'   + jarchives+'" '+
+                        'codebase="http://java.sun.com/update/1.4.2/jinstall-1_4_2_09-windows-i586.cab" ' +
+                        'width="'     + this.width +'" '+
+                      'height="'    + this.height +'" '+
+                      'standby="Loading applet ..." '+
+                      '>'+
+                    '<param name="code"       value="'+this.code+'" />'+
+                        ( this.codebase  ?
+                      '<param name="codebase"   value="'+ this.codebase+'" />' : '' ) +
+                    '<param name="archive"    value="'+jarchives+'" />'+
+                    '<param name="mayscript"  value="'+this.mayscript+'" />'+
+                    '<param name="scriptable" value="'+this.mayscript+'" />';
+    for(var i = 0; i < this.params.length; i++)
+    {
+        tag += '<param  name="' + this.params[i].name  + '" ' + 
+                      'value="' + this.params[i].value +'" />';
+    }
+    tag += this.fallback;
+    tag += '</object>';
+    return tag;
+};
+
+
+/**
+        AppletObject.createTagEmbed()
+        
+        create the an embed applet tag
+ */
+
+AppletObject.prototype.createTagEmbed = function ()
+{
+    var jarchives = this.archives.implode(", ");
+    
+    var tag = '<embed code="'       + this.code+'.class" '+
+                      'type="application/x-java-applet" '+
+                      'archive="'   + jarchives+'" '+
+                        ( this.codebase 
+                    ? 'codebase="'  + this.codebase+'" ' : '' ) +
+                        'width="'     + this.width +'" '+
+                      'height="'    + this.height +'" '+
+                      'align="baseline" '+
+                      'pluginspage="http://java.sun.com/products/plugin/downloads/index.html" '+
+                      'mayscript="' +this.mayscript+'" '+
+                      'scriptable="'+this.mayscript+'" ';
+    for(var i = 0; i < this.params.length; i++)
+    {
+        tag += this.params[i].name + '="' + this.params[i].value + '" ';
+    }
+    tag += ' >';
+    tag += '<noembed>' + this.fallback + '</noembed>';
+    tag += '</embed>';
+    return tag;
+};
+
+
+/**
+        AppletObject.writeToElement()
+        
+        create the applet tag and insert it into the given element
+ */
+
+AppletObject.prototype.writeToElement = function ( elementId )
+{
+    this.element_id = elementId;
+    
+    if ( typeof this.getParam("image") == "undefined" ) {
+        //TODO encode the url.
+        //this.addParam("image", 'http://ez-applet-html.sourceforge.net/loading.gif');
+    }
+
+    var tag = this.create();
+    this.alterElement( getElement( this.element_id ), tag );
+    return tag;
+};
+
+
+/**
+        AppletObject.debug()
+        
+        used instead of writeToElement to see the created html source
+ */
+    
+AppletObject.prototype.debug = function ( elementId )
+{
+    this.element_id = elementId;
+    
+    var tag = this.create();
+    this.alterElement( getElement( this.element_id ), '<textarea style="width:400px;height:100%;">' + tag + '</textarea>' );
+    return tag;
+};
+
+
+/**
+        AppletObject.addParam()
+        
+        add one parameter to the AppletObject 
+ */
+    
+AppletObject.prototype.addParam = function ( _name, _value )
+{
+    if ( !_name || !_value ) return;
+    if ( !this.params ) this.params = new Array();
+    this.params.push( {  name  : _name,
+                        value  : _value } );
+// this.params[_name] = { name  : _name,
+//                            value  : _value };
+};
+
+
+/**
+        AppletObject.addParams()
+        
+        add one or more parameters to the AppletObject 
+ */
+ 
+AppletObject.prototype.addParams = function ( )
+{
+    if ( arguments.length <= 0 ) return;
+    for ( var i=0; i < arguments.length; i++ )
+    {
+        this.addParam( arguments[i][0], arguments[i][1] );
+    }
+};
+
+
+/**
+        AppletObject.getParam()
+        
+        return a param from AppletObject by name
+ */
+ 
+AppletObject.prototype.getParam = function ( _name )
+{
+    // return this.params[_name];
+    for( var i = 0; i < this.params.length; i++ )
+    {
+    	if ( this.params[i].name == _name )
+    		return this.params[i].value;
+    }
+    return undefined;
+};
+
+
+/**
+        AppletObject.addLibrary()
+        
+        add one or more libraries to the AppletObject
+        
+        @param: single or multiple strings or one array
+ */
+
+AppletObject.prototype.addLibraries = function ( )
+{
+    if ( arguments.length == 1 )
+    {
+        if ( typeof arguments[0] == 'string' )
+            this.archives[this.archives.length] = arguments[0];
+    
+        else if ( arguments[0].length > 0 ) // array
+        {
+            for ( var i = 0; i < arguments[0].length; i++ )
+            {
+                this.archives[this.archives.length] = arguments[0][i];
+            }
+        }
+    }
+    else if ( arguments.length > 0 )
+    {
+        for ( var i = 0; i < arguments.length; i++ )
+        {
+            if ( typeof arguments[i] == 'string' )
+                this.archives[this.archives.length] = arguments[i];
+        }
+    }
+};
+
+
+
Index: trunk/wikipathways/wpi/js/resize.js
===================================================================
--- trunk/wikipathways/wpi/js/resize.js	(revision 0)
+++ trunk/wikipathways/wpi/js/resize.js	(revision 1110)
@@ -0,0 +1,217 @@
+// Copyright (c) 2005 Thomas Fakes (http://craz8.com)
+// http://blog.craz8.com/articles/2005/12/01/make-your-divs-resizeable
+// 
+// This code is substantially based on code from script.aculo.us which has the 
+// following copyright and permission notice
+//
+// Copyright (c) 2005 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)
+// 
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+var Resizeable = Class.create();
+Resizeable.prototype = {
+  initialize: function(element) {
+    var options = Object.extend({
+      top: 6,
+      bottom: 6,
+      left: 6,
+      right: 6,
+      minHeight: 0,
+      minWidth: 0,
+      zindex: 1000,
+      resize: null
+    }, arguments[1] || {});
+
+    this.element      = $(element);
+    this.handle 	  = this.element;
+
+    Element.makePositioned(this.element); // fix IE    
+
+    this.options      = options;
+
+    this.active       = false;
+    this.resizing     = false;   
+    this.currentDirection = '';
+
+    this.eventMouseDown = this.startResize.bindAsEventListener(this);
+    this.eventMouseUp   = this.endResize.bindAsEventListener(this);
+    this.eventMouseMove = this.update.bindAsEventListener(this);
+    this.eventCursorCheck = this.cursor.bindAsEventListener(this);
+    this.eventKeypress  = this.keyPress.bindAsEventListener(this);
+    
+    this.registerEvents();
+  },
+  destroy: function() {
+    Event.stopObserving(this.handle, "mousedown", this.eventMouseDown);
+    this.unregisterEvents();
+  },
+  registerEvents: function() {
+    Event.observe(document, "mouseup", this.eventMouseUp);
+    Event.observe(document, "mousemove", this.eventMouseMove);
+    Event.observe(document, "keypress", this.eventKeypress);
+    Event.observe(this.handle, "mousedown", this.eventMouseDown);
+    Event.observe(this.element, "mousemove", this.eventCursorCheck);
+  },
+  unregisterEvents: function() {
+    //if(!this.active) return;
+    //Event.stopObserving(document, "mouseup", this.eventMouseUp);
+    //Event.stopObserving(document, "mousemove", this.eventMouseMove);
+    //Event.stopObserving(document, "mousemove", this.eventCursorCheck);
+    //Event.stopObserving(document, "keypress", this.eventKeypress);
+  },
+  startResize: function(event) {
+    if(Event.isLeftClick(event)) {
+      
+      // abort on form elements, fixes a Firefox issue
+      var src = Event.element(event);
+      if(src.tagName && (
+        src.tagName=='INPUT' ||
+        src.tagName=='SELECT' ||
+        src.tagName=='BUTTON' ||
+        src.tagName=='TEXTAREA')) return;
+
+	  var dir = this.directions(event);
+	  if (dir.length > 0) {      
+	      this.active = true;
+    	  var offsets = Position.cumulativeOffset(this.element);
+	      this.startTop = offsets[1];
+	      this.startLeft = offsets[0];
+	      this.startWidth = parseInt(Element.getStyle(this.element, 'width'));
+	      this.startHeight = parseInt(Element.getStyle(this.element, 'height'));
+	      this.startX = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
+	      this.startY = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;
+	      
+	      this.currentDirection = dir;
+	      Event.stop(event);
+	  }
+    }
+  },
+  finishResize: function(event, success) {
+    // this.unregisterEvents();
+
+    this.active = false;
+    this.resizing = false;
+
+    if(this.options.zindex)
+      this.element.style.zIndex = this.originalZ;
+      
+    if (this.options.resize) {
+    	this.options.resize(this.element);
+    }
+  },
+  keyPress: function(event) {
+    if(this.active) {
+      if(event.keyCode==Event.KEY_ESC) {
+        this.finishResize(event, false);
+        Event.stop(event);
+      }
+    }
+  },
+  endResize: function(event) {
+    if(this.active && this.resizing) {
+      this.finishResize(event, true);
+      Event.stop(event);
+    }
+    this.active = false;
+    this.resizing = false;
+  },
+  draw: function(event) {
+    var pointer = [Event.pointerX(event), Event.pointerY(event)];
+    var style = this.element.style;
+    if (this.currentDirection.indexOf('n') != -1) {
+    	var pointerMoved = this.startY - pointer[1];
+    	var margin = Element.getStyle(this.element, 'margin-top') || "0";
+    	var newHeight = this.startHeight + pointerMoved;
+    	if (newHeight > this.options.minHeight) {
+    		style.height = newHeight + "px";
+    		style.top = (this.startTop - pointerMoved - parseInt(margin)) + "px";
+    	}
+    }
+    if (this.currentDirection.indexOf('w') != -1) {
+    	var pointerMoved = this.startX - pointer[0];
+    	var margin = Element.getStyle(this.element, 'margin-left') || "0";
+    	var newWidth = this.startWidth + pointerMoved;
+    	if (newWidth > this.options.minWidth) {
+    		style.left = (this.startLeft - pointerMoved - parseInt(margin))  + "px";
+    		style.width = newWidth + "px";
+    	}
+    }
+    if (this.currentDirection.indexOf('s') != -1) {
+    	var newHeight = this.startHeight + pointer[1] - this.startY;
+    	if (newHeight > this.options.minHeight) {
+    		style.height = newHeight + "px";
+    	}
+    }
+    if (this.currentDirection.indexOf('e') != -1) {
+    	var newWidth = this.startWidth + pointer[0] - this.startX;
+    	if (newWidth > this.options.minWidth) {
+    		style.width = newWidth + "px";
+    	}
+    }
+    if(style.visibility=="hidden") style.visibility = ""; // fix gecko rendering
+  },
+  between: function(val, low, high) {
+  	return (val >= low && val < high);
+  },
+  directions: function(event) {
+    var pointer = [Event.pointerX(event), Event.pointerY(event)];
+    var offsets = Position.cumulativeOffset(this.element);
+    
+	var cursor = '';
+	if (this.between(pointer[1] - offsets[1], 0, this.options.top)) cursor += 'n';
+	if (this.between((offsets[1] + this.element.offsetHeight) - pointer[1], 0, this.options.bottom)) cursor += 's';
+	if (this.between(pointer[0] - offsets[0], 0, this.options.left)) cursor += 'w';
+	if (this.between((offsets[0] + this.element.offsetWidth) - pointer[0], 0, this.options.right)) cursor += 'e';
+
+	return cursor;
+  },
+  cursor: function(event) {
+  	var cursor = this.directions(event);
+	if (cursor.length > 0) {
+		cursor += '-resize';
+	} else {
+		cursor = '';
+	}
+	this.element.style.cursor = cursor;		
+  },
+  update: function(event) {
+   if(this.active) {
+      if(!this.resizing) {
+        var style = this.element.style;
+        this.resizing = true;
+        
+        if(Element.getStyle(this.element,'position')=='') 
+          style.position = "relative";
+        
+        if(this.options.zindex) {
+          this.originalZ = parseInt(Element.getStyle(this.element,'z-index') || 0);
+          style.zIndex = this.options.zindex;
+        }
+      }
+      this.draw(event);
+
+      // fix AppleWebKit rendering
+      if(navigator.appVersion.indexOf('AppleWebKit')>0) window.scrollBy(0,0); 
+      Event.stop(event);
+      return false;
+   }
+  }
+}
+
Index: trunk/wikipathways/LocalSettings.php
===================================================================
--- trunk/wikipathways/LocalSettings.php	(revision 0)
+++ trunk/wikipathways/LocalSettings.php	(revision 1110)
@@ -0,0 +1,238 @@
+<?php
+
+# This file was automatically generated by the MediaWiki installer.
+# If you make manual changes, please keep track in case you need to
+# recreate them later.
+#
+# See includes/DefaultSettings.php for all configurable settings
+# and their default values, but don't forget to make changes in _this_
+# file, not there.
+
+# If you customize your file layout, set $IP to the directory that contains
+# the other MediaWiki files. It will be used as a base to locate files.
+if( defined( 'MW_INSTALL_PATH' ) ) {
+	$IP = MW_INSTALL_PATH;
+} else {
+	$IP = dirname( __FILE__ );
+}
+
+$path = array( $IP, "$IP/includes", "$IP/languages" );
+set_include_path( implode( PATH_SEPARATOR, $path ) . PATH_SEPARATOR . get_include_path() );
+
+require_once( "includes/DefaultSettings.php" );
+
+# If PHP's memory limit is very low, some operations may fail.
+ini_set( 'memory_limit', '20M' );
+
+if ( $wgCommandLineMode ) {
+	if ( isset( $_SERVER ) && array_key_exists( 'REQUEST_METHOD', $_SERVER ) ) {
+		die( "This script must be run from the command line\n" );
+	}
+} elseif ( empty( $wgNoOutputBuffer ) ) {
+	## Compress output if the browser supports it
+	if( !ini_get( 'zlib.output_compression' ) ) @ob_start( 'ob_gzhandler' );
+}
+
+$wgSitename         = "WikiPathways";
+
+## The URL base path to the directory containing the wiki;
+## defaults for all runtime URL paths are based off of this.
+$wgScriptPath       = '';
+
+## For more information on customizing the URLs please see:
+## http://www.mediawiki.org/wiki/Manual:Short_URL
+
+$wgEnableEmail      = true;
+$wgEnableUserEmail  = true;
+
+$wgEmergencyContact = "webmaster@localhost";
+$wgPasswordSender = "webmaster@localhost";
+
+## For a detailed description of the following switches see
+## http://meta.wikimedia.org/Enotif and http://meta.wikimedia.org/Eauthent
+## There are many more options for fine tuning available see
+## /includes/DefaultSettings.php
+## UPO means: this is also a user preference option
+$wgEnotifUserTalk = true; # UPO
+$wgEnotifWatchlist = true; # UPO
+$wgEmailAuthentication = true;
+
+$wgDBtype           = "mysql";
+$wgDBserver         = "localhost";
+$wgDBport           = "5432";
+$wgDBprefix         = "";
+
+# Load passwords/usernames
+require('pass.php');
+
+# Schemas for Postgres
+$wgDBmwschema       = "mediawiki";
+$wgDBts2schema      = "public";
+
+# Experimental charset support for MySQL 4.1/5.0.
+$wgDBmysql5 = false;
+
+## Shared memory settings
+$wgMainCacheType = CACHE_NONE;
+$wgMemCachedServers = array();
+
+## To enable image uploads, make sure the 'images' directory
+## is writable, then set this to true:
+$wgEnableUploads       = true;
+
+##Extensions
+$wgUseImageResize      = true;
+$wgUseImageMagick = true;
+$wgImageMagickConvertCommand = "/usr/bin/convert";
+
+## If you want to use image uploads under safe mode,
+## create the directories images/archive, images/thumb and
+## images/temp, and make them all writable. Then uncomment
+## this, if it's not already uncommented:
+# $wgHashedUploadDirectory = false;
+
+## If you have the appropriate support software installed
+## you can enable inline LaTeX equations:
+$wgUseTeX           = false;
+
+$wgLocalInterwiki   = $wgSitename;
+
+$wgLanguageCode = "en";
+
+$wgProxyKey = "b748562511ea57982358c30cec614e30b52b75119e3df78ac554eec5f69343cf";
+
+## Default skin: you can change the default skin. Use the internal symbolic
+## names, ie 'standard', 'nostalgia', 'cologneblue', 'monobook':
+$wgDefaultSkin = 'wikipathways';
+
+## For attaching licensing metadata to pages, and displaying an
+## appropriate copyright notice / icon. GNU Free Documentation
+## License and Creative Commons licenses are supported so far.
+# $wgEnableCreativeCommonsRdf = true;
+$wgRightsPage = ""; # Set to the title of a wiki page that describes your license/copyright
+$wgRightsUrl = "http://creativecommons.org/licenses/by-nc-sa/3.0/";
+$wgRightsText = "a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 License";
+$wgRightsIcon = "http://creativecommons.org/images/public/somerights20.png";
+# $wgRightsCode = ""; # Not yet used
+
+$wgDiff3 = "/usr/bin/diff3";
+
+# When you make changes to this configuration file, this will make
+# sure that cached pages are cleared.
+$configdate = gmdate( 'YmdHis', @filemtime( __FILE__ ) );
+$wgCacheEpoch = max( $wgCacheEpoch, $configdate );
+
+$wgGroupPermissions['user']['edit'] = true;
+
+$wgGroupPermissions['*'    ]['createaccount']   = true;
+$wgGroupPermissions['*'    ]['read']            = true;
+$wgGroupPermissions['*'    ]['edit']            = false;
+$wgGroupPermissions['*'    ]['createpage']      = false;
+$wgGroupPermissions['*'    ]['createtalk']      = true;
+
+#Non-defaults:
+
+#Allow slow parser functions ({{PAGESINNS:ns}})
+$wgAllowSlowParserFunctions = true;
+
+#Logo
+$wgLogo = "http://www.wikipathways.org/skins/common/images/earth-or-pathway_text2_beta.png";
+
+#Allow gpml extension and larger image files
+$wgFileExtensions = array( 'png', 'gif', 'jpg', 'jpeg', 'svg', 'gpml', 'mapp');
+$wgUploadSizeWarning = 1024 * 1024 * 5;
+
+## Better SVG converter
+/** Pick one of the above */
+$wgSVGConverter = 'inkscape';
+/** If not in the executable PATH, specify */
+#$wgSVGConverterPath = '/var/www/wikipathways/wpi/bin/batik';
+$wgSVGConverters['inkscape'] = '$path/inkscape -z -b white -w $width -f $input -e $output';
+
+##$wgMimeDetectorCommand = "file -bi"; #This doesn't work for svg!!!
+##$wgCheckFileExtensions = false;
+
+##Pathway namespace
+define("NS_PATHWAY", 100);
+define("NS_PATHWAY_TALK", 101);
+define("NS_GPML", 102);
+define("NS_GPML_TALK", 103);
+
+$wgExtraNamespaces =
+	array(	NS_PATHWAY => "Pathway", NS_PATHWAY_TALK => "Pathway_Talk",
+			NS_GPML => "GPML", NS_GPML_TALK => "GPML_Talk");
+$wgNamespacesToBeSearchedDefault += 
+	array( 	NS_PATHWAY => true, NS_PATHWAY_TALK => true,
+			NS_GPML => true, NS_GPML_TALK => false);
+$wgContentNamespaces += array(NS_PATHWAY, NS_PATHWAY_TALK, NS_GPML, NS_GPML_TALK);
+
+##Debug
+$wgDebugLogFile = '/var/www/wikipathways/wpi/tmp/wikipathwaysdebug.txt';
+$wgProfiling = true; //Set to true for debugging info
+
+##Extensions
+require_once('extensions/analytics.php'); //Google Analytics support
+require_once('extensions/inputbox.php');
+require_once('extensions/ParserFunctions.php');
+//require_once('wpi/extensions/redirectImage.php'); //Redirect all image pages to file
+require_once('wpi/extensions/PathwayOfTheDay.php');
+require_once('wpi/extensions/siteStats.php');
+require_once('wpi/extensions/pathwayInfo.php');
+require_once('wpi/extensions/imageSize.php');
+require_once('wpi/extensions/magicWords.php');
+require_once('wpi/extensions/Categories.php');
+require_once('wpi/extensions/PopularPathwaysPage/PopularPathwaysPage.php');
+require_once('wpi/extensions/MostEditedPathwaysPage/MostEditedPathwaysPage.php');
+require_once('wpi/extensions/NewPathwaysPage/NewPathwaysPage.php');
+require_once('wpi/extensions/CreatePathwayPage/CreatePathwayPage.php');
+require_once('wpi/extensions/pathwayHistory.php');
+require_once('wpi/extensions/watchPathways.php');
+require_once('wpi/extensions/DynamicPageList2.php');
+require_once('wpi/extensions/LabeledSectionTransclusion/compat.php');
+require_once('wpi/extensions/LabeledSectionTransclusion/lst.php');
+require_once('wpi/extensions/LabeledSectionTransclusion/lsth.php');
+require_once('wpi/extensions/googleSearch.php');
+require_once('wpi/extensions/button.php');
+require_once('wpi/extensions/pathwayThumb.php');
+require_once('wpi/extensions/BrowsePathwaysPage/BrowsePathwaysPage.php');
+require_once('wpi/extensions/editApplet.php');
+require_once('wpi/extensions/listPathways.php');
+require_once('wpi/extensions/movePathway.php');
+require_once('wpi/batchDownload.php');
+
+/* Biblio extension
+Isbndb account: thomas.kelder@bigcat.unimaas.nl / BigC0w~wiki
+*/
+$isbndb_access_key = 'BR5539IJ'; 
+require_once('extensions/Biblio.php');
+
+/*
+################################################################
+# PageProtection extension
+set_include_path(get_include_path() . PATH_SEPARATOR . realpath('extensions/includes'));
+require_once("extensions/ExtensionFunctions.php");
+
+$wgCachePages   = false;
+$wgCacheEpoch   = 'date +%Y%m%d%H%M%S';
+$wgPEMsize      = 64;                 //default key size
+$wgPEMlite_size = 64;                  //lite key size
+$wgPEMdir       = '/var/www/wikipathways/extensions/PPP/key';  //storage for keys
+$wgPEMfile      = 'default.pem';        //default key's filename
+$wgPEMlite_file = 'lite.pem';           //lite key's filename
+
+$wgPEMold       = 'private.pem';        //old key's pathname (optional)
+                                        //if you've been using PageProtection
+# activate PageProtection extension
+require_once('extensions/PPP/PageProtectionPlus.php');
+*/
+#
+################################################################
+
+
+##Cascading Style Sheets
+#Default is {$wgScriptPath}/skins
+
+$wgShowExceptionDetails = true;
+$wgShowSQLErrors = true;
+
+?>

Property changes on: trunk/wikipathways/LocalSettings.php
___________________________________________________________________
Name: svn:executable
   + *

Index: trunk/wikipathways/includes/SpecialAllpages.php
===================================================================
--- trunk/wikipathways/includes/SpecialAllpages.php	(revision 0)
+++ trunk/wikipathways/includes/SpecialAllpages.php	(revision 1110)
@@ -0,0 +1,439 @@
+<?php
+/**
+ * @package MediaWiki
+ * @subpackage SpecialPage
+ */
+
+/** AP20070419
+ * Added wpi.php to access Pathway class and getAvailableSpecies()
+ */
+require_once('/var/www/wikipathways/wpi/wpi.php');
+
+/**
+ * Entry point : initialise variables and call subfunctions.
+ * @param $par String: becomes "FOO" when called like Special:Allpages/FOO (default NULL)
+ * @param $specialPage @see SpecialPage object.
+ */
+function wfSpecialAllpages( $par=NULL, $specialPage ) {
+	global $wgRequest, $wgOut, $wgContLang;
+
+	# GET values
+/** AP20070419	
+ * Parse species header from 'from' so that prev/next links can work
+ */
+	$from = $wgRequest->getVal( 'from' );
+	$from_pathway = null;
+	if(preg_match('/\:/', $from)){	   
+		$from_pathway = $from;
+		$parts = explode(':', $from);
+        	if(count($parts) < 1) {
+        		     throw new Exception("Invalid pathway article title: $from");
+        	}
+        	$from = array_shift($parts);
+	}
+
+/** AP20070419	
+ *	$namespace = $wgRequest->getInt( 'namespace' );
+ *	
+ *	Set $namespace to equal 100 (Pathway)
+ */
+	$namespace = 100;
+
+	$namespaces = $wgContLang->getNamespaces();
+
+	$indexPage = new SpecialAllpages();
+
+	if( !in_array($namespace, array_keys($namespaces)) )
+		$namespace = 0;
+
+/** AP20070419	
+ *	$wgOut->setPagetitle( $namespace > 0 ?
+ *		wfMsg( 'allinnamespace', str_replace( '_', ' ', $namespaces[$namespace] ) ) :
+ *		wfMsg( 'allarticles' )
+ *		);
+ *
+ *	Set Pagetitle to "Browse Pathways"
+ */
+	$wgOut->setPagetitle("Browse Pathways");
+
+/** AP20070419
+ *	Set default $indexPage to show Human
+ */
+
+	if ( isset($par) ) {
+		$indexPage->showChunk( $namespace, $par, $specialPage->including() );
+	} elseif ( isset($from) ) {
+		$indexPage->showChunk( $namespace, $from, $specialPage->including() );
+	} else {
+		$indexPage->showChunk( $namespace, 'Human',  $specialPage->including() );
+	}
+}
+
+class SpecialAllpages {
+	var $maxPerPage=960;
+	var $topLevelMax=50;
+	var $name='Allpages';
+	# Determines, which message describes the input field 'nsfrom' (->SpecialPrefixindex.php)
+	var $nsfromMsg='allpagesfrom';
+
+/**
+ * HTML for the top form
+ * @param integer $namespace A namespace constant (default NS_PATHWAY).
+ * @param string $from Article name we are starting listing at.
+ */
+function namespaceForm ( $namespace = NS_PATHWAY, $from = '' ) {
+	global $wgScript, $wgContLang;
+	$t = SpecialPage::getTitleFor( $this->name );
+
+/** AP20070419
+ *	$namespaceselect = HTMLnamespaceselector($namespace, null);
+ *
+ *	$frombox = "<input type='text' size='20' name='from' id='nsfrom' value=\""
+ *	            . htmlspecialchars ( $from ) . '"/>';
+ */
+
+                $speciesselect = "\n<select id='nsfrom' name='from' class='namespaceselector'>\n";
+
+		$arr = Pathway::getAvailableSpecies();
+		asort($arr);
+		$selected = $from;
+
+                foreach ($arr as $index) {
+                        if ($index === $selected) {
+                                $speciesselect .= "\t" . Xml::element("option",
+                                                array("value" => $index, "selected" => "selected"), $index) . "\n";
+                        } else {
+                                $speciesselect .= "\t" . Xml::element("option", array("value" => $index), $index) . "\n";
+                        }
+                }
+                $speciesselect .= "</select>\n";
+
+	$submitbutton = '<input type="submit" value="' . wfMsgHtml( 'allpagessubmit' ) . '" />';
+
+	$out = "<div class='namespaceoptions'><form method='get' action='{$wgScript}'>";
+	$out .= '<input type="hidden" name="title" value="'.$t->getPrefixedText().'" />';
+	$out .= "
+<table id='nsselect' class='allpages'>
+	<tr>
+		<td align='right'>Display pathways from:</td>
+		<td align='left'>
+		    $speciesselect $submitbutton
+		</td>
+	</tr>
+</table>
+";
+
+	$out .= '</form></div>';
+		return $out;
+}
+
+/**
+ * @param integer $namespace (default NS_PATHWAY)
+ */
+function showToplevel ( $namespace = NS_PATHWAY, $including = false ) {
+	global $wgOut;
+	$fname = "indexShowToplevel";
+
+	# TODO: Either make this *much* faster or cache the title index points
+	# in the querycache table.
+
+	$dbr =& wfGetDB( DB_SLAVE );
+	$out = "";
+	$where = array( 'page_namespace' => $namespace );
+
+	global $wgMemc;
+	$key = wfMemcKey( 'allpages', 'ns', $namespace );
+	$lines = $wgMemc->get( $key );
+
+	if( !is_array( $lines ) ) {
+		$firstTitle = $dbr->selectField( 'page', 'page_title', $where, $fname, array( 'LIMIT' => 1 ) );
+		$lastTitle = $firstTitle;
+
+		# This array is going to hold the page_titles in order.
+		$lines = array( $firstTitle );
+
+		# If we are going to show n rows, we need n+1 queries to find the relevant titles.
+		$done = false;
+		for( $i = 0; !$done; ++$i ) {
+			// Fetch the last title of this chunk and the first of the next
+			$chunk = is_null( $lastTitle )
+				? ''
+				: 'page_title >= ' . $dbr->addQuotes( $lastTitle );
+			$res = $dbr->select(
+				'page', /* FROM */
+				'page_title', /* WHAT */
+				$where + array( $chunk),
+				$fname,
+				array ('LIMIT' => 2, 'OFFSET' => $this->maxPerPage - 1, 'ORDER BY' => 'page_title') );
+
+			if ( $s = $dbr->fetchObject( $res ) ) {
+				array_push( $lines, $s->page_title );
+			} else {
+				// Final chunk, but ended prematurely. Go back and find the end.
+				$endTitle = $dbr->selectField( 'page', 'MAX(page_title)',
+					array(
+						'page_namespace' => $namespace,
+						$chunk
+					), $fname );
+				array_push( $lines, $endTitle );
+				$done = true;
+			}
+			if( $s = $dbr->fetchObject( $res ) ) {
+				array_push( $lines, $s->page_title );
+				$lastTitle = $s->page_title;
+			} else {
+				// This was a final chunk and ended exactly at the limit.
+				// Rare but convenient!
+				$done = true;
+			}
+			$dbr->freeResult( $res );
+		}
+		$wgMemc->add( $key, $lines, 3600 );
+	}
+
+	// If there are only two or less sections, don't even display them.
+	// Instead, display the first section directly.
+	if( count( $lines ) <= 2 ) {
+		$this->showChunk( $namespace, '', $including );
+		return;
+	}
+
+	# At this point, $lines should contain an even number of elements.
+	$out .= "<table class='allpageslist' style='background: inherit;'>";
+	while ( count ( $lines ) > 0 ) {
+		$inpoint = array_shift ( $lines );
+		$outpoint = array_shift ( $lines );
+		$out .= $this->showline ( $inpoint, $outpoint, $namespace, false );
+	}
+	$out .= '</table>';
+	$nsForm = $this->namespaceForm ( $namespace, '', false );
+
+	# Is there more?
+	if ( $including ) {
+		$out2 = '';
+	} else {
+		$morelinks = '';
+		if ( $morelinks != '' ) {
+			$out2 = '<table style="background: inherit;" width="100%" cellpadding="0" cellspacing="0" border="0">';
+			$out2 .= '<tr valign="top"><td align="left">' . $nsForm;
+			$out2 .= '</td><td align="right" style="font-size: smaller; margin-bottom: 1em;">';
+			$out2 .= $morelinks . '</td></tr></table><hr />';
+		} else {
+			$out2 = $nsForm . '<hr />';
+		}
+	}
+
+	$wgOut->addHtml( $out2 . $out );
+}
+
+/**
+ * @todo Document
+ * @param string $from
+ * @param integer $namespace (Default NS_PATHWAY)
+ */
+function showline( $inpoint, $outpoint, $namespace = NS_PATHWAY ) {
+	$inpointf = htmlspecialchars( str_replace( '_', ' ', $inpoint ) );
+	$outpointf = htmlspecialchars( str_replace( '_', ' ', $outpoint ) );
+	$queryparams = ($namespace ? "namespace=$namespace" : '');
+	$special = SpecialPage::getTitleFor( $this->name, $inpoint );
+	$link = $special->escapeLocalUrl( $queryparams );
+
+	$out = wfMsgHtml(
+		'alphaindexline',
+		"<a href=\"$link\">$inpointf</a></td><td><a href=\"$link\">",
+		"</a></td><td align=\"left\"><a href=\"$link\">$outpointf</a>"
+	);
+	return '<tr><td align="right">'.$out.'</td></tr>';
+}
+
+/**
+ * @param integer $namespace (Default NS_PATHWAY)
+ * @param string $from list all pages from this name (default FALSE)
+ */
+function showChunk( $namespace = NS_PATHWAY, $from, $including = false ) {
+	global $wgOut, $wgUser, $wgContLang;
+
+	$fname = 'indexShowChunk';
+
+	$sk = $wgUser->getSkin();
+
+	$fromList = $this->getNamespaceKeyAndText($namespace, $from);
+	$n = 0;
+        
+	if ( !$fromList ) {
+		$out = wfMsgWikiHtml( 'allpagesbadtitle' );
+	} else {
+		list( $namespace, $fromKey, $from ) = $fromList;
+
+		$dbr =& wfGetDB( DB_SLAVE );
+		$res = $dbr->select( 'page',
+			array( 'page_namespace', 'page_title', 'page_is_redirect' ),
+			array(
+				'page_namespace' => $namespace,
+				'page_title >= ' . $dbr->addQuotes( $fromKey ),
+				'page_is_redirect' => 0
+			),
+			$fname,
+			array(
+				'ORDER BY'  => 'page_title',
+				'LIMIT'     => $this->maxPerPage + 1,
+				'USE INDEX' => 'name_title',
+			)
+		);
+
+		$out = '<table style="background: inherit;" border="0" width="100%"><tr><td valign="top"><table>';
+
+		while( ($n < $this->maxPerPage) && ($s = $dbr->fetchObject( $res )) ) {
+			$t = Title::makeTitle( $s->page_namespace, $s->page_title );
+/** AP20070419
+ *  Added species match if-loop around what is shown.
+ *  The default "from" strategy wasn't sufficient.
+ *  And organize into columns instead of rows for clarity
+ */
+			$parts = explode(':', $s->page_title);
+                	if(count($parts) < 1) {
+                        		 throw new Exception("Invalid pathway article title: $s->page_title");
+                	}
+                	$species = array_shift($parts);
+                        $title_only = array_shift($parts);
+
+			if ($species == $from) {
+
+			if( $t ) {
+				$link = ($s->page_is_redirect ? '<div class="allpagesredirect">' : '' ) .
+					$sk->makeKnownLinkObj( $t, htmlspecialchars( $title_only ), false, false ) .
+					($s->page_is_redirect ? '</div>' : '' );
+			} else {
+				$link = '[[' . htmlspecialchars( $s->page_title ) . ']]';
+			}
+			if( $n % 40 == 0 ) {
+                                $out .= '</table></td><td valign="top"><table>';
+                        }
+                        $out .= "<tr><td>$link</td></tr>";
+                        $n++;
+/**			if( $n % 3 == 0 ) {
+				$out .= '<tr>';
+			}
+			$out .= "<td>$link</td>";
+			$n++;
+			if( $n % 3 == 0 ) {
+				$out .= '</tr>';
+			}
+*/			}			
+		}
+/**		if( ($n % 3) != 0 ) {
+			$out .= '</tr>';
+		}
+*/		$out .= '</table></td></tr></table>';
+	}
+
+	if ( $including ) {
+		$out2 = '';
+	} else {
+
+		# Get the last title from previous chunk
+		$dbr =& wfGetDB( DB_SLAVE );
+		$res_prev = $dbr->select(
+			'page',
+			'page_title',
+			array( 'page_namespace' => $namespace, 'page_title < '.$dbr->addQuotes($from) ),
+			$fname,
+			array( 'ORDER BY' => 'page_title DESC', 'LIMIT' => $this->maxPerPage, 'OFFSET' => ($this->maxPerPage - 1 ) )
+		);
+
+		# Get first title of previous complete chunk
+		if( $dbr->numrows( $res_prev ) >= $this->maxPerPage ) {
+			$pt = $dbr->fetchObject( $res_prev );
+			$prevTitle = Title::makeTitle( $namespace, $pt->page_title );
+		} else {
+		       $prevTitle = null;
+
+/** AP20070420
+ *			# The previous chunk is not complete, need to link to the very first title
+ *			# available in the database
+ *			$reallyFirstPage_title = $dbr->selectField( 'page', 'page_title', array( 'page_namespace' => $namespace ), $fname, array( 'LIMIT' => 1) ); 
+ *
+ *			# Show the previous link if it s not the current requested chunk
+ * 			if ($from != $reallyFirstPage_title) {
+ *				$prevTitle =  Title::makeTitle( $namespace, $reallyFirstPage_title );
+ *			} else {
+ *  				$prevTitle = null;
+ *			}
+ */
+		}
+
+		$nsForm = $this->namespaceForm ( $namespace, $from );
+		$out2 = '<table style="background: inherit;" width="100%" cellpadding="0" cellspacing="0" border="0">';
+		$out2 .= '<tr valign="top"><td align="left">' . $nsForm;
+ 		$out2 .= '</td><td align="right" style="font-size: smaller; margin-bottom: 1em;">';
+/** AP20070420
+ *			      .	$sk->makeKnownLink( $wgContLang->specialPage( "Allpages" ),
+ *					wfMsgHtml ( 'allpages' ) );
+ */
+		$self = SpecialPage::getTitleFor( 'Allpages' );
+
+		# Do we put a previous link ?
+		if( isset( $prevTitle ) &&  $pt = $prevTitle->getText() ) {
+			$q = 'from=' . $prevTitle->getPartialUrl() . ( $namespace ? '&namespace=' . $namespace : '' );
+			$prevLink = $sk->makeKnownLinkObj( $self, wfMsgHTML( 'prevpage', $pt ), $q );
+			$out2 .= $prevLink;
+		}
+
+		if( $n == $this->maxPerPage && $s = $dbr->fetchObject($res) ) {
+			# $s is the first link of the next chunk
+			$t = Title::MakeTitle($namespace, $s->page_title);
+			$q = 'from=' . $t->getPartialUrl() . ( $namespace ? '&namespace=' . $namespace : '' );
+			$nextLink = $sk->makeKnownLinkObj( $self, wfMsgHtml( 'nextpage', $t->getText() ), $q );
+			$out2 .= $nextLink;
+		}
+		$out2 .= "</td></tr></table><hr />";
+	}
+
+	$wgOut->addHtml( $out2 . $out );
+	if( isset($prevLink) or isset($nextLink) ) {
+		$wgOut->addHtml( '<hr/><p style="font-size: smaller; float: right;">' );
+		if( isset( $prevLink ) )
+			$wgOut->addHTML( $prevLink . ' | ');
+		if( isset( $nextLink ) )
+			$wgOut->addHTML( $nextLink );
+		$wgOut->addHTML( '</p>' );
+
+	}
+	
+}
+	
+/**
+ * @param int $ns the namespace of the article
+ * @param string $text the name of the article
+ * @return array( int namespace, string dbkey, string pagename ) or NULL on error
+ * @static (sort of)
+ * @access private
+ */
+function getNamespaceKeyAndText ($ns, $text) {
+	if ( $text == '' )
+		return array( $ns, '', '' ); # shortcut for common case
+	
+/** AP20070420
+ * Use pathway name when passed via prev/next links
+ */
+	if ($from_pathway) { $text = $from_pathway;}
+
+	$t = Title::makeTitleSafe($ns, $text);
+	if ( $t && $t->isLocal() ) {
+		return array( $t->getNamespace(), $t->getDBkey(), $t->getText() );
+	} else if ( $t ) {
+		return NULL;
+	}
+
+	# try again, in case the problem was an empty pagename
+	$text = preg_replace('/(#|$)/', 'X$1', $text);
+	$t = Title::makeTitleSafe($ns, $text);
+	if ( $t && $t->isLocal() ) {
+		return array( $t->getNamespace(), '', '' );
+	} else {
+		return NULL;
+	}
+}
+}
+
+?>
Index: trunk/wikipathways/includes/SpecialRecentchanges.php
===================================================================
--- trunk/wikipathways/includes/SpecialRecentchanges.php	(revision 0)
+++ trunk/wikipathways/includes/SpecialRecentchanges.php	(revision 1110)
@@ -0,0 +1,706 @@
+<?php
+/**
+ *
+ * @package MediaWiki
+ * @subpackage SpecialPage
+ */
+
+/**
+ *
+ */
+require_once( 'ChangesList.php' );
+
+/**
+ * Constructor
+ */
+function wfSpecialRecentchanges( $par, $specialPage ) {
+	global $wgUser, $wgOut, $wgRequest, $wgUseRCPatrol;
+	global $wgRCShowWatchingUsers, $wgShowUpdatedMarker;
+	global $wgAllowCategorizedRecentChanges ;
+	$fname = 'wfSpecialRecentchanges';
+
+	# Get query parameters
+	$feedFormat = $wgRequest->getVal( 'feed' );
+
+	/* Checkbox values can't be true be default, because
+	 * we cannot differentiate between unset and not set at all
+	 */
+	$defaults = array(
+	/* int  */ 'days' => $wgUser->getDefaultOption('rcdays'),
+	/* int  */ 'limit' => $wgUser->getDefaultOption('rclimit'),
+	/* bool */ 'hideminor' => false,
+	/* bool */ 'hidebots' => true,
+	/* bool */ 'hideanons' => false,
+	/* bool */ 'hideliu' => false,
+	/* bool */ 'hidepatrolled' => false,
+	/* bool */ 'hidemyself' => false,
+	/* text */ 'from' => '',
+	/* text */ 'namespace' => null,
+	/* bool */ 'invert' => false,
+	/* bool */ 'categories_any' => false,
+	);
+
+	extract($defaults);
+
+
+	$days = $wgUser->getOption( 'rcdays', $defaults['days']);
+	$days = $wgRequest->getInt( 'days', $days );
+
+	$limit = $wgUser->getOption( 'rclimit', $defaults['limit'] );
+
+	#	list( $limit, $offset ) = wfCheckLimits( 100, 'rclimit' );
+	$limit = $wgRequest->getInt( 'limit', $limit );
+
+	/* order of selection: url > preferences > default */
+	$hideminor = $wgRequest->getBool( 'hideminor', $wgUser->getOption( 'hideminor') ? true : $defaults['hideminor'] );
+	
+	# As a feed, use limited settings only
+	if( $feedFormat ) {
+		global $wgFeedLimit;
+		if( $limit > $wgFeedLimit ) {
+			$options['limit'] = $wgFeedLimit;
+		}
+
+	} else {
+
+		$namespace = $wgRequest->getIntOrNull( 'namespace' );
+		$invert = $wgRequest->getBool( 'invert', $defaults['invert'] );
+		$hidebots = $wgRequest->getBool( 'hidebots', $defaults['hidebots'] );
+		$hideanons = $wgRequest->getBool( 'hideanons', $defaults['hideanons'] );
+		$hideliu = $wgRequest->getBool( 'hideliu', $defaults['hideliu'] );
+		$hidepatrolled = $wgRequest->getBool( 'hidepatrolled', $defaults['hidepatrolled'] );
+		$hidemyself = $wgRequest->getBool ( 'hidemyself', $defaults['hidemyself'] );
+		$from = $wgRequest->getVal( 'from', $defaults['from'] );
+
+		# Get query parameters from path
+		if( $par ) {
+			$bits = preg_split( '/\s*,\s*/', trim( $par ) );
+			foreach ( $bits as $bit ) {
+				if ( 'hidebots' == $bit ) $hidebots = 1;
+				if ( 'bots' == $bit ) $hidebots = 0;
+				if ( 'hideminor' == $bit ) $hideminor = 1;
+				if ( 'minor' == $bit ) $hideminor = 0;
+				if ( 'hideliu' == $bit ) $hideliu = 1;
+				if ( 'hidepatrolled' == $bit ) $hidepatrolled = 1;
+				if ( 'hideanons' == $bit ) $hideanons = 1;
+				if ( 'hidemyself' == $bit ) $hidemyself = 1;
+
+				if ( is_numeric( $bit ) ) {
+					$limit = $bit;
+				}
+				
+				$m = array();
+				if ( preg_match( '/^limit=(\d+)$/', $bit, $m ) ) {
+					$limit = $m[1];
+				}
+
+				if ( preg_match( '/^days=(\d+)$/', $bit, $m ) ) {
+					$days = $m[1];
+				}
+			}
+		}
+	}
+
+	if ( $limit < 0 || $limit > 5000 ) $limit = $defaults['limit'];
+
+
+	# Database connection and caching
+	$dbr =& wfGetDB( DB_SLAVE );
+	list( $recentchanges, $watchlist ) = $dbr->tableNamesN( 'recentchanges', 'watchlist' );
+
+
+	$cutoff_unixtime = time() - ( $days * 86400 );
+	$cutoff_unixtime = $cutoff_unixtime - ($cutoff_unixtime % 86400);
+	$cutoff = $dbr->timestamp( $cutoff_unixtime );
+	if(preg_match('/^[0-9]{14}$/', $from) and $from > wfTimestamp(TS_MW,$cutoff)) {
+		$cutoff = $dbr->timestamp($from);
+	} else {
+		$from = $defaults['from'];
+	}
+
+	# 10 seconds server-side caching max
+	$wgOut->setSquidMaxage( 10 );
+
+	# Get last modified date, for client caching
+	# Don't use this if we are using the patrol feature, patrol changes don't update the timestamp
+	$lastmod = $dbr->selectField( 'recentchanges', 'MAX(rc_timestamp)', false, $fname );
+	if ( $feedFormat || !$wgUseRCPatrol ) {
+		if( $lastmod && $wgOut->checkLastModified( $lastmod ) ){
+			# Client cache fresh and headers sent, nothing more to do.
+			return;
+		}
+	}
+
+	# It makes no sense to hide both anons and logged-in users
+	# Where this occurs, force anons to be shown
+	if( $hideanons && $hideliu )
+		$hideanons = false;
+
+	# Form WHERE fragments for all the options
+	$hidem  = $hideminor ? 'AND rc_minor = 0' : '';
+	$hidem .= $hidebots ? ' AND rc_bot = 0' : '';
+	$hidem .= $hideliu ? ' AND rc_user = 0' : '';
+	$hidem .= ( $wgUseRCPatrol && $hidepatrolled ) ? ' AND rc_patrolled = 0' : '';
+	$hidem .= $hideanons ? ' AND rc_user != 0' : '';
+	
+	if( $hidemyself ) {
+		if( $wgUser->getID() ) {
+			$hidem .= ' AND rc_user != ' . $wgUser->getID();
+		} else {
+			$hidem .= ' AND rc_user_text != ' . $dbr->addQuotes( $wgUser->getName() );
+		}
+	}
+
+	# Namespace filtering
+	$hidem .= is_null( $namespace ) ?  '' : ' AND rc_namespace' . ($invert ? '!=' : '=') . $namespace;
+
+	// This is the big thing!
+
+	$uid = $wgUser->getID();
+
+	// Perform query
+	$forceclause = $dbr->useIndexClause("rc_timestamp");
+	$sql2 = "SELECT * FROM $recentchanges $forceclause".
+	  ($uid ? "LEFT OUTER JOIN $watchlist ON wl_user={$uid} AND wl_title=rc_title AND wl_namespace=rc_namespace " : "") .
+	  "WHERE rc_timestamp >= '{$cutoff}' {$hidem} " .
+	  "ORDER BY rc_timestamp DESC";
+	$sql2 = $dbr->limitResult($sql2, $limit, 0);
+	$res = $dbr->query( $sql2, $fname );
+
+	// Fetch results, prepare a batch link existence check query
+	$rows = array();
+	$batch = new LinkBatch;
+	while( $row = $dbr->fetchObject( $res ) ){
+		$rows[] = $row;
+		if ( !$feedFormat ) {
+			// User page link
+			$title = Title::makeTitleSafe( NS_USER, $row->rc_user_text );
+			$batch->addObj( $title );
+
+			// User talk
+			$title = Title::makeTitleSafe( NS_USER_TALK, $row->rc_user_text );
+			$batch->addObj( $title );
+		}
+
+	}
+	$dbr->freeResult( $res );
+
+	if( $feedFormat ) {
+		rcOutputFeed( $rows, $feedFormat, $limit, $hideminor, $lastmod );
+	} else {
+
+		# Web output...
+
+		// Run existence checks
+		$batch->execute();
+		$any = $wgRequest->getBool( 'categories_any', $defaults['categories_any']);
+
+		// Output header
+		if ( !$specialPage->including() ) {
+			$wgOut->addWikiText( wfMsgForContentNoTrans( "recentchangestext" ) );
+
+			// Dump everything here
+			$nondefaults = array();
+
+			wfAppendToArrayIfNotDefault( 'days', $days, $defaults, $nondefaults);
+			wfAppendToArrayIfNotDefault( 'limit', $limit , $defaults, $nondefaults);
+			wfAppendToArrayIfNotDefault( 'hideminor', $hideminor, $defaults, $nondefaults);
+			wfAppendToArrayIfNotDefault( 'hidebots', $hidebots, $defaults, $nondefaults);
+			wfAppendToArrayIfNotDefault( 'hideanons', $hideanons, $defaults, $nondefaults );
+			wfAppendToArrayIfNotDefault( 'hideliu', $hideliu, $defaults, $nondefaults);
+			wfAppendToArrayIfNotDefault( 'hidepatrolled', $hidepatrolled, $defaults, $nondefaults);
+			wfAppendToArrayIfNotDefault( 'hidemyself', $hidemyself, $defaults, $nondefaults);
+			wfAppendToArrayIfNotDefault( 'from', $from, $defaults, $nondefaults);
+			wfAppendToArrayIfNotDefault( 'namespace', $namespace, $defaults, $nondefaults);
+			wfAppendToArrayIfNotDefault( 'invert', $invert, $defaults, $nondefaults);
+			wfAppendToArrayIfNotDefault( 'categories_any', $any, $defaults, $nondefaults);
+
+			// Add end of the texts
+			$wgOut->addHTML( '<div class="rcoptions">' . rcOptionsPanel( $defaults, $nondefaults ) . "\n" );
+			$wgOut->addHTML( rcNamespaceForm( $namespace, $invert, $nondefaults, $any ) . '</div>'."\n");
+		}
+
+		// And now for the content
+		$wgOut->setSyndicated( true );
+
+		$list = ChangesList::newFromUser( $wgUser );
+		
+		if ( $wgAllowCategorizedRecentChanges ) {
+			$categories = trim ( $wgRequest->getVal ( 'categories' , "" ) ) ;
+			$categories = str_replace ( "|" , "\n" , $categories ) ;
+			$categories = explode ( "\n" , $categories ) ;
+			rcFilterByCategories ( $rows , $categories , $any ) ;
+		}
+
+		$s = $list->beginRecentChangesList();
+		$counter = 1;
+		foreach( $rows as $obj ){
+			if( $limit == 0) {
+				break;
+			}
+
+			if ( ! ( $hideminor     && $obj->rc_minor     ) &&
+			     ! ( $hidepatrolled && $obj->rc_patrolled ) ) {
+				$rc = RecentChange::newFromRow( $obj );
+				$rc->counter = $counter++;
+
+				if ($wgShowUpdatedMarker
+					&& !empty( $obj->wl_notificationtimestamp )
+					&& ($obj->rc_timestamp >= $obj->wl_notificationtimestamp)) {
+						$rc->notificationtimestamp = true;
+				} else {
+					$rc->notificationtimestamp = false;
+				}
+
+				if ($wgRCShowWatchingUsers && $wgUser->getOption( 'shownumberswatching' )) {
+					$sql3 = "SELECT COUNT(*) AS n FROM $watchlist WHERE wl_title='" . $dbr->strencode($obj->rc_title) ."' AND wl_namespace=$obj->rc_namespace" ;
+					$res3 = $dbr->query( $sql3, 'wfSpecialRecentChanges');
+					$x = $dbr->fetchObject( $res3 );
+					$rc->numberofWatchingusers = $x->n;
+				} else {
+					$rc->numberofWatchingusers = 0;
+				}
+				$s .= $list->recentChangesLine( $rc, !empty( $obj->wl_user ) );
+				--$limit;
+			}
+		}
+		$s .= $list->endRecentChangesList();
+		$wgOut->addHTML( $s );
+	}
+}
+
+function rcFilterByCategories ( &$rows , $categories , $any ) {
+	require_once ( 'Categoryfinder.php' ) ;
+	
+	# Filter categories
+	$cats = array () ;
+	foreach ( $categories AS $cat ) {
+		$cat = trim ( $cat ) ;
+		if ( $cat == "" ) continue ;
+		$cats[] = $cat ;
+	}
+	
+	# Filter articles
+	$articles = array () ;
+	$a2r = array () ;
+	foreach ( $rows AS $k => $r ) {
+		$nt = Title::newFromText ( $r->rc_title , $r->rc_namespace ) ;
+		$id = $nt->getArticleID() ;
+		if ( $id == 0 ) continue ; # Page might have been deleted...
+		if ( !in_array ( $id , $articles ) ) {
+			$articles[] = $id ;
+		}
+		if ( !isset ( $a2r[$id] ) ) {
+			$a2r[$id] = array() ;
+		}
+		$a2r[$id][] = $k ;
+	}
+	
+	# Shortcut?
+	if ( count ( $articles ) == 0 OR count ( $cats ) == 0 )
+		return ;
+	
+	# Look up
+	$c = new Categoryfinder ;
+	$c->seed ( $articles , $cats , $any ? "OR" : "AND" ) ;
+	$match = $c->run () ;
+	
+	# Filter
+	$newrows = array () ;
+	foreach ( $match AS $id ) {
+		foreach ( $a2r[$id] AS $rev ) {
+			$k = $rev ;
+			$newrows[$k] = $rows[$k] ;
+		}
+	}
+	$rows = $newrows ;
+}
+
+function rcOutputFeed( $rows, $feedFormat, $limit, $hideminor, $lastmod ) {
+	global $messageMemc, $wgFeedCacheTimeout;
+	global $wgFeedClasses, $wgTitle, $wgSitename, $wgContLanguageCode;
+
+	if( !isset( $wgFeedClasses[$feedFormat] ) ) {
+		wfHttpError( 500, "Internal Server Error", "Unsupported feed type." );
+		return false;
+	}
+
+	$timekey = wfMemcKey( 'rcfeed', $feedFormat, 'timestamp' );
+	$key = wfMemcKey( 'rcfeed', $feedFormat, 'limit', $limit, 'minor', $hideminor );
+
+	$feedTitle = $wgSitename . ' - ' . wfMsgForContent( 'recentchanges' ) .
+		' [' . $wgContLanguageCode . ']';
+	$feed = new $wgFeedClasses[$feedFormat](
+		$feedTitle,
+		htmlspecialchars( wfMsgForContent( 'recentchanges-feed-description' ) ),
+		$wgTitle->getFullUrl() );
+
+	/**
+	 * Bumping around loading up diffs can be pretty slow, so where
+	 * possible we want to cache the feed output so the next visitor
+	 * gets it quick too.
+	 */
+	$cachedFeed = false;
+	if( ( $wgFeedCacheTimeout > 0 ) && ( $feedLastmod = $messageMemc->get( $timekey ) ) ) {
+		/**
+		 * If the cached feed was rendered very recently, we may
+		 * go ahead and use it even if there have been edits made
+		 * since it was rendered. This keeps a swarm of requests
+		 * from being too bad on a super-frequently edited wiki.
+		 */
+		if( time() - wfTimestamp( TS_UNIX, $feedLastmod )
+				< $wgFeedCacheTimeout
+			|| wfTimestamp( TS_UNIX, $feedLastmod )
+				> wfTimestamp( TS_UNIX, $lastmod ) ) {
+			wfDebug( "RC: loading feed from cache ($key; $feedLastmod; $lastmod)...\n" );
+			$cachedFeed = $messageMemc->get( $key );
+		} else {
+			wfDebug( "RC: cached feed timestamp check failed ($feedLastmod; $lastmod)\n" );
+		}
+	}
+	if( is_string( $cachedFeed ) ) {
+		wfDebug( "RC: Outputting cached feed\n" );
+		$feed->httpHeaders();
+		echo $cachedFeed;
+	} else {
+		wfDebug( "RC: rendering new feed and caching it\n" );
+		ob_start();
+		rcDoOutputFeed( $rows, $feed );
+		$cachedFeed = ob_get_contents();
+		ob_end_flush();
+
+		$expire = 3600 * 24; # One day
+		$messageMemc->set( $key, $cachedFeed );
+		$messageMemc->set( $timekey, wfTimestamp( TS_MW ), $expire );
+	}
+	return true;
+}
+
+function rcDoOutputFeed( $rows, &$feed ) {
+	$fname = 'rcDoOutputFeed';
+	wfProfileIn( $fname );
+
+	$feed->outHeader();
+
+	# Merge adjacent edits by one user
+	$sorted = array();
+	$n = 0;
+	foreach( $rows as $obj ) {
+		if( $n > 0 &&
+			$obj->rc_namespace >= 0 &&
+			$obj->rc_cur_id == $sorted[$n-1]->rc_cur_id &&
+			$obj->rc_user_text == $sorted[$n-1]->rc_user_text ) {
+			$sorted[$n-1]->rc_last_oldid = $obj->rc_last_oldid;
+		} else {
+			$sorted[$n] = $obj;
+			$n++;
+		}
+	}
+
+	foreach( $sorted as $obj ) {
+		$title = Title::makeTitle( $obj->rc_namespace, $obj->rc_title );
+		$talkpage = $title->getTalkPage();
+		$item = new FeedItem(
+			$title->getPrefixedText(),
+			rcFormatDiff( $obj ),
+			$title->getFullURL(),
+			$obj->rc_timestamp,
+			$obj->rc_user_text,
+			$talkpage->getFullURL()
+			);
+		$feed->outItem( $item );
+	}
+	$feed->outFooter();
+	wfProfileOut( $fname );
+}
+
+/**
+ *
+ */
+function rcCountLink( $lim, $d, $page='Recentchanges', $more='' ) {
+	global $wgUser, $wgLang, $wgContLang;
+	$sk = $wgUser->getSkin();
+	$s = $sk->makeKnownLink( $wgContLang->specialPage( $page ),
+	  ($lim ? $wgLang->formatNum( "{$lim}" ) : wfMsg( 'recentchangesall' ) ), "{$more}" .
+	  ($d ? "days={$d}&" : '') . 'limit='.$lim );
+	return $s;
+}
+
+/**
+ *
+ */
+function rcDaysLink( $lim, $d, $page='Recentchanges', $more='' ) {
+	global $wgUser, $wgLang, $wgContLang;
+	$sk = $wgUser->getSkin();
+	$s = $sk->makeKnownLink( $wgContLang->specialPage( $page ),
+	  ($d ? $wgLang->formatNum( "{$d}" ) : wfMsg( 'recentchangesall' ) ), $more.'days='.$d .
+	  ($lim ? '&limit='.$lim : '') );
+	return $s;
+}
+
+/**
+ * Used by Recentchangeslinked
+ */
+function rcDayLimitLinks( $days, $limit, $page='Recentchanges', $more='', $doall = false, $minorLink = '',
+	$botLink = '', $liuLink = '', $patrLink = '', $myselfLink = '' ) {
+	if ($more != '') $more .= '&';
+	$cl = rcCountLink( 50, $days, $page, $more ) . ' | ' .
+	  rcCountLink( 100, $days, $page, $more  ) . ' | ' .
+	  rcCountLink( 250, $days, $page, $more  ) . ' | ' .
+	  rcCountLink( 500, $days, $page, $more  ) .
+	  ( $doall ? ( ' | ' . rcCountLink( 0, $days, $page, $more ) ) : '' );
+	$dl = rcDaysLink( $limit, 1, $page, $more  ) . ' | ' .
+	  rcDaysLink( $limit, 3, $page, $more  ) . ' | ' .
+	  rcDaysLink( $limit, 7, $page, $more  ) . ' | ' .
+	  rcDaysLink( $limit, 14, $page, $more  ) . ' | ' .
+	  rcDaysLink( $limit, 30, $page, $more  ) .
+	  ( $doall ? ( ' | ' . rcDaysLink( $limit, 0, $page, $more ) ) : '' );
+	
+	$linkParts = array( 'minorLink' => 'minor', 'botLink' => 'bots', 'liuLink' => 'liu', 'patrLink' => 'patr', 'myselfLink' => 'mine' );
+	foreach( $linkParts as $linkVar => $linkMsg ) {
+		if( $$linkVar != '' )
+			$links[] = wfMsgHtml( 'rcshowhide' . $linkMsg, $$linkVar );
+	}
+	
+	$shm = implode( ' | ', $links );
+	$note = wfMsg( 'rclinks', $cl, $dl, $shm );
+	return $note;
+}
+
+
+/**
+ * Makes change an option link which carries all the other options
+ * @param $title @see Title
+ * @param $override
+ * @param $options
+ */
+function makeOptionsLink( $title, $override, $options ) {
+	global $wgUser, $wgContLang;
+	$sk = $wgUser->getSkin();
+	return $sk->makeKnownLink( $wgContLang->specialPage( 'Recentchanges' ),
+		htmlspecialchars( $title ), wfArrayToCGI( $override, $options ) );
+}
+
+/**
+ * Creates the options panel.
+ * @param $defaults
+ * @param $nondefaults
+ */
+function rcOptionsPanel( $defaults, $nondefaults ) {
+	global $wgLang, $wgUseRCPatrol;
+
+	$options = $nondefaults + $defaults;
+
+	if( $options['from'] )
+		$note = wfMsgExt( 'rcnotefrom', array( 'parseinline' ),
+			$wgLang->formatNum( $options['limit'] ),
+			$wgLang->timeanddate( $options['from'], true ) );
+	else
+		$note = wfMsgExt( 'rcnote', array( 'parseinline' ),
+			$wgLang->formatNum( $options['limit'] ),
+			$wgLang->formatNum( $options['days'] ),
+			$wgLang->timeAndDate( wfTimestampNow(), true ) );
+
+	// limit links
+	$options_limit = array(50, 100, 250, 500);
+	foreach( $options_limit as $value ) {
+		$cl[] = makeOptionsLink( $wgLang->formatNum( $value ),
+			array( 'limit' => $value ), $nondefaults) ;
+	}
+	$cl = implode( ' | ', $cl);
+
+	// day links, reset 'from' to none
+	$options_days = array(1, 3, 7, 14, 30);
+	foreach( $options_days as $value ) {
+		$dl[] = makeOptionsLink( $wgLang->formatNum( $value ),
+			array( 'days' => $value, 'from' => ''  ), $nondefaults) ;
+	}
+	$dl = implode( ' | ', $dl);
+
+
+	// show/hide links
+	$showhide = array( wfMsg( 'show' ), wfMsg( 'hide' ));
+	$minorLink = makeOptionsLink( $showhide[1-$options['hideminor']],
+		array( 'hideminor' => 1-$options['hideminor'] ), $nondefaults);
+	$botLink = makeOptionsLink( $showhide[1-$options['hidebots']],
+		array( 'hidebots' => 1-$options['hidebots'] ), $nondefaults);
+	$anonsLink = makeOptionsLink( $showhide[ 1 - $options['hideanons'] ],
+		array( 'hideanons' => 1 - $options['hideanons'] ), $nondefaults );
+	$liuLink   = makeOptionsLink( $showhide[1-$options['hideliu']],
+		array( 'hideliu' => 1-$options['hideliu'] ), $nondefaults);
+	$patrLink  = makeOptionsLink( $showhide[1-$options['hidepatrolled']],
+		array( 'hidepatrolled' => 1-$options['hidepatrolled'] ), $nondefaults);
+	$myselfLink = makeOptionsLink( $showhide[1-$options['hidemyself']],
+		array( 'hidemyself' => 1-$options['hidemyself'] ), $nondefaults);
+		
+	$links[] = wfMsgHtml( 'rcshowhideminor', $minorLink );
+	$links[] = wfMsgHtml( 'rcshowhidebots', $botLink );
+	$links[] = wfMsgHtml( 'rcshowhideanons', $anonsLink );
+	$links[] = wfMsgHtml( 'rcshowhideliu', $liuLink );
+	if( $wgUseRCPatrol )
+		$links[] = wfMsgHtml( 'rcshowhidepatr', $patrLink );
+	$links[] = wfMsgHtml( 'rcshowhidemine', $myselfLink );
+	$hl = implode( ' | ', $links );
+		
+	// show from this onward link
+	$now = $wgLang->timeanddate( wfTimestampNow(), true );
+	$tl =  makeOptionsLink( $now, array( 'from' => wfTimestampNow()), $nondefaults );
+
+	$rclinks = wfMsgExt( 'rclinks', array( 'parseinline', 'replaceafter'),
+		$cl, $dl, $hl );
+	$rclistfrom = wfMsgExt( 'rclistfrom', array( 'parseinline', 'replaceafter'), $tl );
+	return "$note<br />$rclinks<br />$rclistfrom";
+
+}
+
+/**
+ * Creates the choose namespace selection
+ *
+ * @private
+ *
+ * @param $namespace Mixed: the key of the currently selected namespace, empty string
+ *              if there is none
+ * @param $invert Bool: whether to invert the namespace selection
+ * @param $nondefaults Array: an array of non default options to be remembered
+ * @param $categories_any Bool: Default value for the checkbox
+ *
+ * @return string
+ */
+function rcNamespaceForm( $namespace, $invert, $nondefaults, $categories_any ) {
+	global $wgScript, $wgAllowCategorizedRecentChanges, $wgRequest;
+	$t = SpecialPage::getTitleFor( 'Recentchanges' );
+
+	$namespaceselect = HTMLnamespaceselector($namespace, '');
+	$submitbutton = '<input type="submit" value="' . wfMsgHtml( 'allpagessubmit' ) . "\" />\n";
+	$invertbox = "<input type='checkbox' name='invert' value='1' id='nsinvert'" . ( $invert ? ' checked="checked"' : '' ) . ' />';
+	
+	if ( $wgAllowCategorizedRecentChanges ) {
+		$categories = trim ( $wgRequest->getVal ( 'categories' , "" ) ) ;
+		$cb_arr = array( 'type' => 'checkbox', 'name' => 'categories_any', 'value' => "1" ) ;
+		if ( $categories_any ) $cb_arr['checked'] = "checked" ;
+		$catbox = "<br />" ;
+		$catbox .= wfMsgExt('rc_categories', array('parseinline')) . " ";
+		$catbox .= wfElement('input', array( 'type' => 'text', 'name' => 'categories', 'value' => $categories));
+		$catbox .= " &nbsp;" ;
+		$catbox .= wfElement('input', $cb_arr );
+		$catbox .= wfMsgExt('rc_categories_any', array('parseinline'));
+	} else {
+		$catbox = "" ;
+	}
+	
+	$out = "<div class='namespacesettings'><form method='get' action='{$wgScript}'>\n";
+
+	foreach ( $nondefaults as $key => $value ) {
+		if ($key != 'namespace' && $key != 'invert')
+			$out .= wfElement('input', array( 'type' => 'hidden', 'name' => $key, 'value' => $value));
+	}
+
+	$out .= '<input type="hidden" name="title" value="'.$t->getPrefixedText().'" />';
+	$out .= "
+<div id='nsselect' class='recentchanges'>
+	<label for='namespace'>" . wfMsgHtml('namespace') . "</label>
+	{$namespaceselect}{$submitbutton}{$invertbox} <label for='nsinvert'>" . wfMsgHtml('invert') . "</label>{$catbox}\n</div>";
+	$out .= '</form></div>';
+	return $out;
+}
+
+
+/**
+ * Format a diff for the newsfeed
+ */
+function rcFormatDiff( $row ) {
+	$titleObj = Title::makeTitle( $row->rc_namespace, $row->rc_title );
+	$timestamp = wfTimestamp( TS_MW, $row->rc_timestamp );
+	return rcFormatDiffRow( $titleObj,
+		$row->rc_last_oldid, $row->rc_this_oldid,
+		$timestamp,
+		$row->rc_comment );
+}
+
+function rcFormatDiffRow( $title, $oldid, $newid, $timestamp, $comment ) {
+	global $wgFeedDiffCutoff, $wgContLang, $wgUser;
+	$fname = 'rcFormatDiff';
+	wfProfileIn( $fname );
+
+	$skin = $wgUser->getSkin();
+	$completeText = '<p>' . $skin->formatComment( $comment ) . "</p>\n";
+
+	if( $title->getNamespace() >= 0 ) {
+		if( $oldid ) {
+			wfProfileIn( "$fname-dodiff" );
+
+			$de = new DifferenceEngine( $title, $oldid, $newid );
+			#$diffText = $de->getDiff( wfMsg( 'revisionasof',
+			#	$wgContLang->timeanddate( $timestamp ) ),
+			#	wfMsg( 'currentrev' ) );
+			$diffText = $de->getDiff(
+				wfMsg( 'previousrevision' ), // hack
+				wfMsg( 'revisionasof',
+					$wgContLang->timeanddate( $timestamp ) ) );
+				
+
+			if ( strlen( $diffText ) > $wgFeedDiffCutoff ) {
+				// Omit large diffs
+				$diffLink = $title->escapeFullUrl(
+					'diff=' . $newid .
+					'&oldid=' . $oldid );
+				$diffText = '<a href="' .
+					$diffLink .
+					'">' .
+					htmlspecialchars( wfMsgForContent( 'difference' ) ) .
+					'</a>';
+			} elseif ( $diffText === false ) {
+				// Error in diff engine, probably a missing revision
+				$diffText = "<p>Can't load revision $newid</p>";
+			} else {
+				// Diff output fine, clean up any illegal UTF-8
+				$diffText = UtfNormal::cleanUp( $diffText );
+				$diffText = rcApplyDiffStyle( $diffText );
+			}
+			wfProfileOut( "$fname-dodiff" );
+		} else {
+			$rev = Revision::newFromId( $newid );
+			if( is_null( $rev ) ) {
+				$newtext = '';
+			} else {
+				$newtext = $rev->getText();
+			}
+			$diffText = '<p><b>' . wfMsg( 'newpage' ) . '</b></p>' .
+				'<div>' . nl2br( htmlspecialchars( $newtext ) ) . '</div>';
+		}
+		$completeText .= $diffText;
+	}
+
+	wfProfileOut( $fname );
+	return $completeText;
+}
+
+/**
+ * Hacky application of diff styles for the feeds.
+ * Might be 'cleaner' to use DOM or XSLT or something,
+ * but *gack* it's a pain in the ass.
+ *
+ * @param $text String:
+ * @return string
+ * @private
+ */
+function rcApplyDiffStyle( $text ) {
+	$styles = array(
+		'diff'             => 'background-color: white;',
+		'diff-otitle'      => 'background-color: white;',
+		'diff-ntitle'      => 'background-color: white;',
+		'diff-addedline'   => 'background: #cfc; font-size: smaller;',
+		'diff-deletedline' => 'background: #ffa; font-size: smaller;',
+		'diff-context'     => 'background: #eee; font-size: smaller;',
+		'diffchange'       => 'color: red; font-weight: bold;',
+	);
+	
+	foreach( $styles as $class => $style ) {
+		$text = preg_replace( "/(<[^>]+)class=(['\"])$class\\2([^>]*>)/",
+			"\\1style=\"$style\"\\3", $text );
+	}
+	
+	return $text;
+}
+
+?>
Index: trunk/wikipathways/includes/SpecialListusers.php
===================================================================
--- trunk/wikipathways/includes/SpecialListusers.php	(revision 0)
+++ trunk/wikipathways/includes/SpecialListusers.php	(revision 1110)
@@ -0,0 +1,237 @@
+<?php
+
+# Copyright (C) 2004 Brion Vibber, lcrocker, Tim Starling,
+# Domas Mituzas, Ashar Voultoiz, Jens Frank, Zhengzhu.
+#
+# © 2006 Rob Church <robchur@gmail.com>
+#
+# http://www.mediawiki.org/
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+# http://www.gnu.org/copyleft/gpl.html
+
+/**
+ * This class is used to get a list of user. The ones with specials
+ * rights (sysop, bureaucrat, developer) will have them displayed
+ * next to their names.
+ *
+ * @package MediaWiki
+ * @subpackage SpecialPage
+ */
+class ListUsersPage extends QueryPage {
+	var $requestedGroup = '';
+	var $requestedUser = '';
+
+	function getName() {
+		return 'Listusers';
+	}
+	function isSyndicated() { return false; }
+
+	/**
+	 * Not expensive, this class won't work properly with the caching system anyway
+	 */
+	function isExpensive() {
+		return false;
+	}
+
+	/**
+	 * Fetch user page links and cache their existence
+	 */
+	function preprocessResults( &$db, &$res ) {
+		$batch = new LinkBatch;
+		while ( $row = $db->fetchObject( $res ) ) {
+			$batch->addObj( Title::makeTitleSafe( $row->namespace, $row->title ) );
+		}
+		$batch->execute();
+
+		// Back to start for display
+		if( $db->numRows( $res ) > 0 ) {
+			// If there are no rows we get an error seeking.
+			$db->dataSeek( $res, 0 );
+		}
+	}
+
+	/**
+	 * Show a drop down list to select a group as well as a user name
+	 * search box.
+	 * @todo localize
+	 */
+	function getPageHeader( ) {
+		$self = $this->getTitle();
+
+		# Form tag
+		$out = wfOpenElement( 'form', array( 'method' => 'post', 'action' => $self->getLocalUrl() ) );
+		
+		# Group drop-down list
+		$out .= wfElement( 'label', array( 'for' => 'group' ), wfMsg( 'group' ) ) . ' ';
+		$out .= wfOpenElement( 'select', array( 'name' => 'group' ) );
+		$out .= wfElement( 'option', array( 'value' => '' ), wfMsg( 'group-all' ) ); # Item for "all groups"
+		$groups = User::getAllGroups();
+		foreach( $groups as $group ) {
+			$attribs = array( 'value' => $group );
+			if( $group == $this->requestedGroup )
+				$attribs['selected'] = 'selected';
+			$out .= wfElement( 'option', $attribs, User::getGroupName( $group ) );
+		}
+		$out .= wfCloseElement( 'select' ) . ' ';;# . wfElement( 'br' );
+
+		# Username field
+		$out .= wfElement( 'label', array( 'for' => 'username' ), wfMsg( 'listusersfrom' ) ) . ' ';
+		$out .= wfElement( 'input', array( 'type' => 'text', 'id' => 'username', 'name' => 'username',
+							'value' => $this->requestedUser ) ) . ' ';
+
+		# Preserve offset and limit
+		if( $this->offset )
+			$out .= wfElement( 'input', array( 'type' => 'hidden', 'name' => 'offset', 'value' => $this->offset ) );
+		if( $this->limit )
+			$out .= wfElement( 'input', array( 'type' => 'hidden', 'name' => 'limit', 'value' => $this->limit ) );
+
+		# Submit button and form bottom
+		$out .= wfElement( 'input', array( 'type' => 'submit', 'value' => wfMsg( 'allpagessubmit' ) ) );
+		$out .= wfCloseElement( 'form' );
+
+		return $out;
+	}
+
+	function getSQL() {
+		global $wgDBtype;
+		$dbr =& wfGetDB( DB_SLAVE );
+		$user = $dbr->tableName( 'user' );
+		$user_groups = $dbr->tableName( 'user_groups' );
+		$ip_blocks = $dbr->tablename( 'ipblocks');
+		// We need to get an 'atomic' list of users, so that we
+		// don't break the list half-way through a user's group set
+		// and so that lists by group will show all group memberships.
+		//
+		// On MySQL 4.1 we could use GROUP_CONCAT to grab group
+		// assignments together with users pretty easily. On other
+		// versions, it's not so easy to do it consistently.
+		// For now we'll just grab the number of memberships, so
+		// we can then do targetted checks on those who are in
+		// non-default groups as we go down the list.
+
+		//AP20070717: list is ordered by whichever variable is collected as "value" (e.g., user_id as value)
+
+		$userspace = NS_USER;
+		$sql = "SELECT 'Listusers' as type, $userspace AS namespace, user_name AS title, " .
+			"user_name, user_id as value, user_touched as last, user_email, user_real_name, ipb_timestamp, COUNT(ug_group) as numgroups " .
+			"FROM $user ".
+			"LEFT JOIN $user_groups ON user_id=ug_user " .
+                        "LEFT JOIN $ip_blocks ON user_id=ipb_user " .
+			$this->userQueryWhere( $dbr ) .
+			" GROUP BY user_name ";
+		if ( $wgDBtype != 'mysql' ) {
+			$sql .= ",user_id";
+		}
+
+		return $sql;
+	}
+
+	function userQueryWhere( &$dbr ) {
+		$conds = $this->userQueryConditions( $dbr );
+		return empty( $conds )
+			? ""
+			: "WHERE " . $dbr->makeList( $conds, LIST_AND );
+	}
+
+	function userQueryConditions( $dbr ) {
+		$conds = array();
+		if( $this->requestedGroup != '' ) {
+			$conds['ug_group'] = $this->requestedGroup;
+		}
+		if( $this->requestedUser != '' ) {
+			$conds[] = 'user_name >= ' . $dbr->addQuotes( $this->requestedUser );
+		}
+		return $conds;
+	}
+
+	function linkParameters() {
+		$conds = array();
+		if( $this->requestedGroup != '' ) {
+			$conds['group'] = $this->requestedGroup;
+		}
+		if( $this->requestedUser != '' ) {
+			$conds['username'] = $this->requestedUser;
+		}
+		return $conds;
+	}
+
+	function sortDescending() {
+		return false;
+	}
+
+	function formatResult( $skin, $result ) {
+		$userPage = Title::makeTitle( $result->namespace, $result->title );
+		$name = $skin->makeLinkObj( $userPage, htmlspecialchars( $userPage->getText() ) );
+		//AP20070717 - new information added to output list
+		$name .= " - ".$result->last." - ".$result->user_real_name." - ".$result->user_email." ";
+		if ($result->ipb_timestamp){
+			$name .= "-> BLOCKED on ".$result->ipb_timestamp. " ";
+		}
+		$groups = null;
+
+		if( !isset( $result->numgroups ) || $result->numgroups > 0 ) {
+			$dbr =& wfGetDB( DB_SLAVE );
+			$result = $dbr->select( 'user_groups',
+				array( 'ug_group' ),
+				array( 'ug_user' => $result->value ),
+				'ListUsersPage::formatResult' );
+			$groups = array();
+			while( $row = $dbr->fetchObject( $result ) ) {
+				$groups[$row->ug_group] = User::getGroupMember( $row->ug_group );
+			}
+			$dbr->freeResult( $result );
+
+			if( count( $groups ) > 0 ) {
+				foreach( $groups as $group => $desc ) {
+					$list[] = User::makeGroupLinkHTML( $group, $desc );
+				}
+				$groups = implode( ', ', $list );
+			} else {
+				$groups = '';
+			}
+
+		}
+
+		return wfSpecialList( $name, $groups );
+	}
+}
+
+/**
+ * constructor
+ * $par string (optional) A group to list users from
+ */
+function wfSpecialListusers( $par = null ) {
+	global $wgRequest;
+
+	list( $limit, $offset ) = wfCheckLimits();
+
+	$slu = new ListUsersPage();
+
+	/**
+	 * Get some parameters
+	 */
+	$groupTarget = isset($par) ? $par : $wgRequest->getVal( 'group' );
+	$slu->requestedGroup = $groupTarget;
+
+	# 'Validate' the username first
+	$username = $wgRequest->getText( 'username', '' );
+	$user = User::newFromName( $username );
+	$slu->requestedUser = is_object( $user ) ? $user->getName() : '';
+
+	return $slu->doQuery( $offset, $limit );
+}
+
+?>
Index: trunk/wikipathways/includes/Linker.php
===================================================================
--- trunk/wikipathways/includes/Linker.php	(revision 0)
+++ trunk/wikipathways/includes/Linker.php	(revision 1110)
@@ -0,0 +1,1226 @@
+<?php
+/**
+ * Split off some of the internal bits from Skin.php.
+ * These functions are used for primarily page content:
+ * links, embedded images, table of contents. Links are
+ * also used in the skin.
+ * @package MediaWiki
+ */
+
+/**
+ * For the moment, Skin is a descendent class of Linker.
+ * In the future, it should probably be further split
+ * so that ever other bit of the wiki doesn't have to
+ * go loading up Skin to get at it.
+ *
+ * @package MediaWiki
+ */
+class Linker {
+	function Linker() {}
+
+	/**
+	 * @deprecated
+	 */
+	function postParseLinkColour( $s = NULL ) {
+		return NULL;
+	}
+
+	/** @todo document */
+	function getExternalLinkAttributes( $link, $text, $class='' ) {
+		/**AP20070417
+	        *Added support for opening external links as new page 
+	       	* Usage: [http://www.genmapp.org|_new Link]
+		*/
+               $targ = "";
+               $pos  = strpos( $link, '|' );
+               if ( $pos !== false ) {
+                       $targ = " target='" . substr ( $link, $pos + 1 ) . "'";
+                       $link = substr ( $link, 0, $pos );
+               }
+
+		$link = htmlspecialchars( $link );
+
+		$r = ($class != '') ? " class=\"$class\"" : " class=\"external\"";
+
+		$r .= $targ . " title=\"{$link}\"";
+		return $r;
+	}
+
+	function getInterwikiLinkAttributes( $link, $text, $class='' ) {
+		global $wgContLang;
+
+		$link = urldecode( $link );
+		$link = $wgContLang->checkTitleEncoding( $link );
+		$link = preg_replace( '/[\\x00-\\x1f]/', ' ', $link );
+		$link = htmlspecialchars( $link );
+
+		$r = ($class != '') ? " class=\"$class\"" : " class=\"external\"";
+
+		$r .= " title=\"{$link}\"";
+		return $r;
+	}
+
+	/** @todo document */
+	function getInternalLinkAttributes( $link, $text, $broken = false ) {
+		$link = urldecode( $link );
+		$link = str_replace( '_', ' ', $link );
+		$link = htmlspecialchars( $link );
+
+		if( $broken == 'stub' ) {
+			$r = ' class="stub"';
+		} else if ( $broken == 'yes' ) {
+			$r = ' class="new"';
+		} else {
+			$r = '';
+		}
+
+		$r .= " title=\"{$link}\"";
+		return $r;
+	}
+
+	/**
+	 * @param $nt Title object.
+	 * @param $text String: FIXME
+	 * @param $broken Boolean: FIXME, default 'false'.
+	 */
+	function getInternalLinkAttributesObj( &$nt, $text, $broken = false ) {
+		if( $broken == 'stub' ) {
+			$r = ' class="stub"';
+		} else if ( $broken == 'yes' ) {
+			$r = ' class="new"';
+		} else {
+			$r = '';
+		}
+
+		$r .= ' title="' . $nt->getEscapedText() . '"';
+		return $r;
+	}
+
+	/**
+	 * This function is a shortcut to makeLinkObj(Title::newFromText($title),...). Do not call
+	 * it if you already have a title object handy. See makeLinkObj for further documentation.
+	 *
+	 * @param $title String: the text of the title
+	 * @param $text  String: link text
+	 * @param $query String: optional query part
+	 * @param $trail String: optional trail. Alphabetic characters at the start of this string will
+	 *                      be included in the link text. Other characters will be appended after
+	 *                      the end of the link.
+	 */
+	function makeLink( $title, $text = '', $query = '', $trail = '' ) {
+		wfProfileIn( 'Linker::makeLink' );
+	 	$nt = Title::newFromText( $title );
+		if ($nt) {
+			$result = $this->makeLinkObj( Title::newFromText( $title ), $text, $query, $trail );
+		} else {
+			wfDebug( 'Invalid title passed to Linker::makeLink(): "'.$title."\"\n" );
+			$result = $text == "" ? $title : $text;
+		}
+
+		wfProfileOut( 'Linker::makeLink' );
+		return $result;
+	}
+
+	/**
+	 * This function is a shortcut to makeKnownLinkObj(Title::newFromText($title),...). Do not call
+	 * it if you already have a title object handy. See makeKnownLinkObj for further documentation.
+	 * 
+	 * @param $title String: the text of the title
+	 * @param $text  String: link text
+	 * @param $query String: optional query part
+	 * @param $trail String: optional trail. Alphabetic characters at the start of this string will
+	 *                      be included in the link text. Other characters will be appended after
+	 *                      the end of the link.
+	 */
+	function makeKnownLink( $title, $text = '', $query = '', $trail = '', $prefix = '',$aprops = '') {
+		$nt = Title::newFromText( $title );
+		if ($nt) {
+			return $this->makeKnownLinkObj( Title::newFromText( $title ), $text, $query, $trail, $prefix , $aprops );
+		} else {
+			wfDebug( 'Invalid title passed to Linker::makeKnownLink(): "'.$title."\"\n" );
+			return $text == '' ? $title : $text;
+		}
+	}
+
+	/**
+	 * This function is a shortcut to makeBrokenLinkObj(Title::newFromText($title),...). Do not call
+	 * it if you already have a title object handy. See makeBrokenLinkObj for further documentation.
+	 * 
+	 * @param string $title The text of the title
+	 * @param string $text Link text
+	 * @param string $query Optional query part
+	 * @param string $trail Optional trail. Alphabetic characters at the start of this string will
+	 *                      be included in the link text. Other characters will be appended after
+	 *                      the end of the link.
+	 */
+	function makeBrokenLink( $title, $text = '', $query = '', $trail = '' ) {
+		$nt = Title::newFromText( $title );
+		if ($nt) {
+			return $this->makeBrokenLinkObj( Title::newFromText( $title ), $text, $query, $trail );
+		} else {
+			wfDebug( 'Invalid title passed to Linker::makeBrokenLink(): "'.$title."\"\n" );
+			return $text == '' ? $title : $text;
+		}
+	}
+
+	/**
+	 * This function is a shortcut to makeStubLinkObj(Title::newFromText($title),...). Do not call
+	 * it if you already have a title object handy. See makeStubLinkObj for further documentation.
+	 * 
+	 * @param $title String: the text of the title
+	 * @param $text  String: link text
+	 * @param $query String: optional query part
+	 * @param $trail String: optional trail. Alphabetic characters at the start of this string will
+	 *                      be included in the link text. Other characters will be appended after
+	 *                      the end of the link.
+	 */
+	function makeStubLink( $title, $text = '', $query = '', $trail = '' ) {
+		$nt = Title::newFromText( $title );
+		if ($nt) {
+			return $this->makeStubLinkObj( Title::newFromText( $title ), $text, $query, $trail );
+		} else {
+			wfDebug( 'Invalid title passed to Linker::makeStubLink(): "'.$title."\"\n" );
+			return $text == '' ? $title : $text;
+		}
+	}
+
+	/**
+	 * Make a link for a title which may or may not be in the database. If you need to
+	 * call this lots of times, pre-fill the link cache with a LinkBatch, otherwise each
+	 * call to this will result in a DB query.
+	 * 
+	 * @param $nt     Title: the title object to make the link from, e.g. from
+	 *                      Title::newFromText.
+	 * @param $text  String: link text
+	 * @param $query String: optional query part
+	 * @param $trail String: optional trail. Alphabetic characters at the start of this string will
+	 *                      be included in the link text. Other characters will be appended after
+	 *                      the end of the link.
+	 * @param $prefix String: optional prefix. As trail, only before instead of after.
+	 */
+	function makeLinkObj( $nt, $text= '', $query = '', $trail = '', $prefix = '' ) {
+		global $wgUser;
+		$fname = 'Linker::makeLinkObj';
+		wfProfileIn( $fname );
+
+		# Fail gracefully
+		if ( ! is_object($nt) ) {
+			# throw new MWException();
+			wfProfileOut( $fname );
+			return "<!-- ERROR -->{$prefix}{$text}{$trail}";
+		}
+
+		if ( $nt->isExternal() ) {
+			$u = $nt->getFullURL();
+			$link = $nt->getPrefixedURL();
+			if ( '' == $text ) { $text = $nt->getPrefixedText(); }
+			$style = $this->getInterwikiLinkAttributes( $link, $text, 'extiw' );
+
+			$inside = '';
+			if ( '' != $trail ) {
+				$m = array();
+				if ( preg_match( '/^([a-z]+)(.*)$$/sD', $trail, $m ) ) {
+					$inside = $m[1];
+					$trail = $m[2];
+				}
+			}
+			$t = "<a href=\"{$u}\"{$style}>{$text}{$inside}</a>";
+
+			wfProfileOut( $fname );
+			return $t;
+		} elseif ( $nt->isAlwaysKnown() ) {
+			# Image links, special page links and self-links with fragements are always known.
+			$retVal = $this->makeKnownLinkObj( $nt, $text, $query, $trail, $prefix );
+		} else {
+			wfProfileIn( $fname.'-immediate' );
+			# Work out link colour immediately
+			$aid = $nt->getArticleID() ;
+			if ( 0 == $aid ) {
+				$retVal = $this->makeBrokenLinkObj( $nt, $text, $query, $trail, $prefix );
+			} else {
+				$threshold = $wgUser->getOption('stubthreshold') ;
+				if ( $threshold > 0 ) {
+					$dbr =& wfGetDB( DB_SLAVE );
+					$s = $dbr->selectRow(
+						array( 'page' ),
+						array( 'page_len',
+							'page_namespace',
+							'page_is_redirect' ),
+						array( 'page_id' => $aid ), $fname ) ;
+					if ( $s !== false ) {
+						$size = $s->page_len;
+						if ( $s->page_is_redirect OR $s->page_namespace != NS_MAIN ) {
+							$size = $threshold*2 ; # Really big
+						}
+					} else {
+						$size = $threshold*2 ; # Really big
+					}
+				} else {
+					$size = 1 ;
+				}
+				if ( $size < $threshold ) {
+					$retVal = $this->makeStubLinkObj( $nt, $text, $query, $trail, $prefix );
+				} else {
+					$retVal = $this->makeKnownLinkObj( $nt, $text, $query, $trail, $prefix );
+				}
+			}
+			wfProfileOut( $fname.'-immediate' );
+		}
+		wfProfileOut( $fname );
+		return $retVal;
+	}
+
+	/**
+	 * Make a link for a title which definitely exists. This is faster than makeLinkObj because
+	 * it doesn't have to do a database query. It's also valid for interwiki titles and special
+	 * pages.
+	 *
+	 * @param $nt Title object of target page
+	 * @param $text   String: text to replace the title
+	 * @param $query  String: link target
+	 * @param $trail  String: text after link
+	 * @param $prefix String: text before link text
+	 * @param $aprops String: extra attributes to the a-element
+	 * @param $style  String: style to apply - if empty, use getInternalLinkAttributesObj instead
+	 * @return the a-element
+	 */
+	function makeKnownLinkObj( $nt, $text = '', $query = '', $trail = '', $prefix = '' , $aprops = '', $style = '' ) {
+
+		$fname = 'Linker::makeKnownLinkObj';
+		wfProfileIn( $fname );
+
+		if ( !is_object( $nt ) ) {
+			wfProfileOut( $fname );
+			return $text;
+		}
+
+		$u = $nt->escapeLocalURL( $query );
+		if ( $nt->getFragment() != '' ) {
+			if( $nt->getPrefixedDbkey() == '' ) {
+				$u = '';
+				if ( '' == $text ) {
+					$text = htmlspecialchars( $nt->getFragment() );
+				}
+			}
+			$u .= $nt->getFragmentForURL();
+		}
+		if ( $text == '' ) {
+			$text = htmlspecialchars( $nt->getPrefixedText() );
+		}
+		if ( $style == '' ) {
+			$style = $this->getInternalLinkAttributesObj( $nt, $text );
+		}
+
+		if ( $aprops !== '' ) $aprops = ' ' . $aprops;
+
+		list( $inside, $trail ) = Linker::splitTrail( $trail );
+		$r = "<a href=\"{$u}\"{$style}{$aprops}>{$prefix}{$text}{$inside}</a>{$trail}";
+		wfProfileOut( $fname );
+		return $r;
+	}
+
+	/**
+	 * Make a red link to the edit page of a given title.
+	 * 
+	 * @param $title String: The text of the title
+	 * @param $text  String: Link text
+	 * @param $query String: Optional query part
+	 * @param $trail String: Optional trail. Alphabetic characters at the start of this string will
+	 *                      be included in the link text. Other characters will be appended after
+	 *                      the end of the link.
+	 */
+	function makeBrokenLinkObj( $nt, $text = '', $query = '', $trail = '', $prefix = '' ) {
+		# Fail gracefully
+		if ( ! isset($nt) ) {
+			# throw new MWException();
+			return "<!-- ERROR -->{$prefix}{$text}{$trail}";
+		}
+
+		$fname = 'Linker::makeBrokenLinkObj';
+		wfProfileIn( $fname );
+
+		if ( '' == $query ) {
+			$q = 'action=edit';
+		} else {
+			$q = 'action=edit&'.$query;
+		}
+		$u = $nt->escapeLocalURL( $q );
+
+		if ( '' == $text ) {
+			$text = htmlspecialchars( $nt->getPrefixedText() );
+		}
+		$style = $this->getInternalLinkAttributesObj( $nt, $text, "yes" );
+
+		list( $inside, $trail ) = Linker::splitTrail( $trail );
+		$s = "<a href=\"{$u}\"{$style}>{$prefix}{$text}{$inside}</a>{$trail}";
+
+		wfProfileOut( $fname );
+		return $s;
+	}
+
+	/**
+	 * Make a brown link to a short article.
+	 * 
+	 * @param $title String: the text of the title
+	 * @param $text  String: link text
+	 * @param $query String: optional query part
+	 * @param $trail String: optional trail. Alphabetic characters at the start of this string will
+	 *                      be included in the link text. Other characters will be appended after
+	 *                      the end of the link.
+	 */
+	function makeStubLinkObj( $nt, $text = '', $query = '', $trail = '', $prefix = '' ) {
+		$u = $nt->escapeLocalURL( $query );
+
+		if ( '' == $text ) {
+			$text = htmlspecialchars( $nt->getPrefixedText() );
+		}
+		$style = $this->getInternalLinkAttributesObj( $nt, $text, 'stub' );
+
+		list( $inside, $trail ) = Linker::splitTrail( $trail );
+		$s = "<a href=\"{$u}\"{$style}>{$prefix}{$text}{$inside}</a>{$trail}";
+		return $s;
+	}
+
+	/**
+	 * Generate either a normal exists-style link or a stub link, depending
+	 * on the given page size.
+	 *
+ 	 * @param $size Integer
+ 	 * @param $nt Title object.
+ 	 * @param $text String
+ 	 * @param $query String
+ 	 * @param $trail String
+ 	 * @param $prefix String
+ 	 * @return string HTML of link
+	 */
+	function makeSizeLinkObj( $size, $nt, $text = '', $query = '', $trail = '', $prefix = '' ) {
+		global $wgUser;
+		$threshold = intval( $wgUser->getOption( 'stubthreshold' ) );
+		if( $size < $threshold ) {
+			return $this->makeStubLinkObj( $nt, $text, $query, $trail, $prefix );
+		} else {
+			return $this->makeKnownLinkObj( $nt, $text, $query, $trail, $prefix );
+		}
+	}
+
+	/** 
+	 * Make appropriate markup for a link to the current article. This is currently rendered
+	 * as the bold link text. The calling sequence is the same as the other make*LinkObj functions,
+	 * despite $query not being used.
+	 */
+	function makeSelfLinkObj( $nt, $text = '', $query = '', $trail = '', $prefix = '' ) {
+		if ( '' == $text ) {
+			$text = htmlspecialchars( $nt->getPrefixedText() );
+		}
+		list( $inside, $trail ) = Linker::splitTrail( $trail );
+		return "<strong class=\"selflink\">{$prefix}{$text}{$inside}</strong>{$trail}";
+	}
+
+	/** @todo document */
+	function fnamePart( $url ) {
+		$basename = strrchr( $url, '/' );
+		if ( false === $basename ) {
+			$basename = $url;
+		} else {
+			$basename = substr( $basename, 1 );
+		}
+		return htmlspecialchars( $basename );
+	}
+
+	/** Obsolete alias */
+	function makeImage( $url, $alt = '' ) {
+		return $this->makeExternalImage( $url, $alt );
+	}
+
+	/** @todo document */
+	function makeExternalImage( $url, $alt = '' ) {
+		if ( '' == $alt ) {
+			$alt = $this->fnamePart( $url );
+		}
+		$s = '<img src="'.$url.'" alt="'.$alt.'" />';
+		return $s;
+	}
+
+	/** @todo document */
+	function makeImageLinkObj( $nt, $label, $alt, $align = '', $width = false, $height = false, $framed = false,
+	  $thumb = false, $manual_thumb = '', $page = null )
+	{
+		global $wgContLang, $wgUser, $wgThumbLimits, $wgGenerateThumbnailOnParse;
+
+		$img   = new Image( $nt );
+
+		if ( ! is_null( $page ) ) {
+			$img->selectPage( $page );
+		}
+
+		if ( !$img->allowInlineDisplay() && $img->exists() ) {
+			return $this->makeKnownLinkObj( $nt );
+		}
+
+		$url   = $img->getViewURL();
+		$error = $prefix = $postfix = '';
+
+		wfDebug( "makeImageLinkObj: '$width'x'$height', \"$label\"\n" );
+
+		if ( 'center' == $align )
+		{
+			$prefix  = '<div class="center">';
+			$postfix = '</div>';
+			$align   = 'none';
+		}
+
+		if ( $thumb || $framed ) {
+
+			# Create a thumbnail. Alignment depends on language
+			# writing direction, # right aligned for left-to-right-
+			# languages ("Western languages"), left-aligned
+			# for right-to-left-languages ("Semitic languages")
+			#
+			# If  thumbnail width has not been provided, it is set
+			# to the default user option as specified in Language*.php
+			if ( $align == '' ) {
+				$align = $wgContLang->isRTL() ? 'left' : 'right';
+			}
+
+
+			if ( $width === false ) {
+				$wopt = $wgUser->getOption( 'thumbsize' );
+
+				if( !isset( $wgThumbLimits[$wopt] ) ) {
+					 $wopt = User::getDefaultOption( 'thumbsize' );
+				}
+
+				$width = min( $img->getWidth(), $wgThumbLimits[$wopt] );
+			}
+
+			return $prefix.$this->makeThumbLinkObj( $img, $label, $alt, $align, $width, $height, $framed, $manual_thumb ).$postfix;
+		}
+
+		if ( $width && $img->exists() ) {
+
+			# Create a resized image, without the additional thumbnail
+			# features
+
+			if ( $height == false )
+				$height = -1;
+			if ( $manual_thumb == '') {
+				$thumb = $img->getThumbnail( $width, $height, $wgGenerateThumbnailOnParse );
+				if ( $thumb ) {
+					// In most cases, $width = $thumb->width or $height = $thumb->height.
+					// If not, we're scaling the image larger than it can be scaled,
+					// so we send to the browser a smaller thumbnail, and let the client do the scaling.
+
+					if ($height != -1 && $width > $thumb->width * $height / $thumb->height) {
+						// $height is the limiting factor, not $width
+						// set $width to the largest it can be, such that the resulting
+						// scaled height is at most $height
+						$width = floor($thumb->width * $height / $thumb->height);
+					}
+					$height = round($thumb->height * $width / $thumb->width);
+
+					wfDebug( "makeImageLinkObj: client-size set to '$width x $height'\n" );
+					$url = $thumb->getUrl();
+				} else {
+					$error = htmlspecialchars( $img->getLastError() );
+					// Do client-side scaling...
+					$height = intval( $img->getHeight() * $width / $img->getWidth() );
+				}
+			}
+		} else {
+			$width = $img->width;
+			$height = $img->height;
+		}
+
+		wfDebug( "makeImageLinkObj2: '$width'x'$height'\n" );
+		$u = $nt->escapeLocalURL();
+		if ( $error ) {
+			$s = $error;
+		} elseif ( $url == '' ) {
+			$s = $this->makeBrokenImageLinkObj( $img->getTitle() );
+			//$s .= "<br />{$alt}<br />{$url}<br />\n";
+		} else {
+			$s = '<a href="'.$u.'" class="image" title="'.$alt.'">' .
+				 '<img src="'.$url.'" alt="'.$alt.'" ' .
+				 ( $width
+				 	? ( 'width="'.$width.'" height="'.$height.'" ' )
+				 	: '' ) .
+				 'longdesc="'.$u.'" /></a>';
+		}
+		if ( '' != $align ) {
+			$s = "<div class=\"float{$align}\"><span>{$s}</span></div>";
+		}
+		return str_replace("\n", ' ',$prefix.$s.$postfix);
+	}
+
+	/**
+	 * Make HTML for a thumbnail including image, border and caption
+	 * $img is an Image object
+	 */
+	function makeThumbLinkObj( $img, $label = '', $alt, $align = 'right', $boxwidth = 180, $boxheight=false, $framed=false , $manual_thumb = "" ) {
+		global $wgStylePath, $wgContLang, $wgGenerateThumbnailOnParse;
+		$thumbUrl = '';
+		$error = '';
+
+		$width = $height = 0;
+		if ( $img->exists() ) {
+			$width  = $img->getWidth();
+			$height = $img->getHeight();
+		}
+		if ( 0 == $width || 0 == $height ) {
+			$width = $height = 180;
+		}
+		if ( $boxwidth == 0 ) {
+			$boxwidth = 180;
+		}
+		if ( $framed ) {
+			// Use image dimensions, don't scale
+			$boxwidth  = $width;
+			$boxheight = $height;
+			$thumbUrl  = $img->getViewURL();
+		} else {
+			if ( $boxheight === false )
+				$boxheight = -1;
+			if ( '' == $manual_thumb ) {
+				$thumb = $img->getThumbnail( $boxwidth, $boxheight, $wgGenerateThumbnailOnParse );
+				if ( $thumb ) {
+					$thumbUrl = $thumb->getUrl();
+					$boxwidth = $thumb->width;
+					$boxheight = $thumb->height;
+				} else {
+					$error = $img->getLastError();
+				}
+			}
+		}
+		$oboxwidth = $boxwidth + 2;
+
+		if ( $manual_thumb != '' ) # Use manually specified thumbnail
+		{
+			$manual_title = Title::makeTitleSafe( NS_IMAGE, $manual_thumb ); #new Title ( $manual_thumb ) ;
+			if( $manual_title ) {
+				$manual_img = new Image( $manual_title );
+				$thumbUrl = $manual_img->getViewURL();
+				if ( $manual_img->exists() )
+				{
+					$width  = $manual_img->getWidth();
+					$height = $manual_img->getHeight();
+					$boxwidth = $width ;
+					$boxheight = $height ;
+					$oboxwidth = $boxwidth + 2 ;
+				}
+			}
+		}
+
+		$u = $img->getEscapeLocalURL();
+
+		$more = htmlspecialchars( wfMsg( 'thumbnail-more' ) );
+		$magnifyalign = $wgContLang->isRTL() ? 'left' : 'right';
+		$textalign = $wgContLang->isRTL() ? ' style="text-align:right"' : '';
+
+		$s = "<div class=\"thumb t{$align}\"><div class=\"thumbinner\" style=\"width:{$oboxwidth}px;\">";
+		if( $thumbUrl == '' ) {
+			// Couldn't generate thumbnail? Scale the image client-side.
+			$thumbUrl = $img->getViewURL();
+			if( $boxheight == -1 ) {
+				// Approximate...
+				$boxheight = intval( $height * $boxwidth / $width );
+			}
+		}
+		if ( $error ) {
+			$s .= htmlspecialchars( $error );
+			$zoomicon = '';
+		} elseif( !$img->exists() ) {
+			$s .= $this->makeBrokenImageLinkObj( $img->getTitle() );
+			$zoomicon = '';
+		} else {
+			$s .= '<a href="'.$u.'" class="internal" title="'.$alt.'">'.
+				'<img src="'.$thumbUrl.'" alt="'.$alt.'" ' .
+				'width="'.$boxwidth.'" height="'.$boxheight.'" ' .
+				'longdesc="'.$u.'" class="thumbimage" /></a>';
+			if ( $framed ) {
+				$zoomicon="";
+			} else {
+				$zoomicon =  '<div class="magnify" style="float:'.$magnifyalign.'">'.
+					'<a href="'.$u.'" class="internal" title="'.$more.'">'.
+					'<img src="'.$wgStylePath.'/common/images/magnify-clip.png" ' .
+					'width="15" height="11" alt="" /></a></div>';
+			}
+		}
+		$s .= '  <div class="thumbcaption"'.$textalign.'>'.$zoomicon.$label."</div></div></div>";
+		return str_replace("\n", ' ', $s);
+	}
+
+	/**
+	 * Pass a title object, not a title string
+	 */
+	function makeBrokenImageLinkObj( $nt, $text = '', $query = '', $trail = '', $prefix = '' ) {
+		# Fail gracefully
+		if ( ! isset($nt) ) {
+			# throw new MWException();
+			return "<!-- ERROR -->{$prefix}{$text}{$trail}";
+		}
+
+		$fname = 'Linker::makeBrokenImageLinkObj';
+		wfProfileIn( $fname );
+
+		$q = 'wpDestFile=' . urlencode( $nt->getDBkey() );
+		if ( '' != $query ) {
+			$q .= "&$query";
+		}
+		$uploadTitle = SpecialPage::getTitleFor( 'Upload' );
+		$url = $uploadTitle->escapeLocalURL( $q );
+
+		if ( '' == $text ) {
+			$text = htmlspecialchars( $nt->getPrefixedText() );
+		}
+		$style = $this->getInternalLinkAttributesObj( $nt, $text, "yes" );
+		list( $inside, $trail ) = Linker::splitTrail( $trail );
+		$s = "<a href=\"{$url}\"{$style}>{$prefix}{$text}{$inside}</a>{$trail}";
+
+		wfProfileOut( $fname );
+		return $s;
+	}
+
+	/** @todo document */
+	function makeMediaLink( $name, /* wtf?! */ $url, $alt = '' ) {
+		$nt = Title::makeTitleSafe( NS_IMAGE, $name );
+		return $this->makeMediaLinkObj( $nt, $alt );
+	}
+
+	/**
+	 * Create a direct link to a given uploaded file.
+	 *
+	 * @param $title Title object.
+	 * @param $text  String: pre-sanitized HTML
+	 * @param $nourl Boolean: Mask absolute URLs, so the parser doesn't
+	 *                       linkify them (it is currently not context-aware)
+	 * @return string HTML
+	 *
+	 * @public
+	 * @todo Handle invalid or missing images better.
+	 */
+	function makeMediaLinkObj( $title, $text = '' ) {
+		if( is_null( $title ) ) {
+			### HOTFIX. Instead of breaking, return empty string.
+			return $text;
+		} else {
+			$img  = new Image( $title );
+			if( $img->exists() ) {
+				$url  = $img->getURL();
+				$class = 'internal';
+			} else {
+				$upload = SpecialPage::getTitleFor( 'Upload' );
+				$url = $upload->getLocalUrl( 'wpDestFile=' . urlencode( $img->getName() ) );
+				$class = 'new';
+			}
+			$alt = htmlspecialchars( $title->getText() );
+			if( $text == '' ) {
+				$text = $alt;
+			}
+			$u = htmlspecialchars( $url );
+			return "<a href=\"{$u}\" class=\"$class\" title=\"{$alt}\">{$text}</a>";
+		}
+	}
+
+	/** @todo document */
+	function specialLink( $name, $key = '' ) {
+		global $wgContLang;
+
+		if ( '' == $key ) { $key = strtolower( $name ); }
+		$pn = $wgContLang->ucfirst( $name );
+		return $this->makeKnownLink( $wgContLang->specialPage( $pn ),
+		  wfMsg( $key ) );
+	}
+
+	/** @todo document */
+	function makeExternalLink( $url, $text, $escape = true, $linktype = '', $ns = null ) {
+		$style = $this->getExternalLinkAttributes( $url, $text, 'external ' . $linktype );
+		global $wgNoFollowLinks, $wgNoFollowNsExceptions;
+		if( $wgNoFollowLinks && !(isset($ns) && in_array($ns, $wgNoFollowNsExceptions)) ) {
+			$style .= ' rel="nofollow"';
+		}
+		/**AP20070417
+		* Added support for opening external links as new page 
+	       	* Usage: [http://www.genmapp.org|_new Link]
+		*/
+		$pos = strpos( $url, '|' );
+               	if ( $pos !== false ) {
+                          $url = substr ( $url, 0, $pos );
+               	}
+		$url = htmlspecialchars( $url );
+		if( $escape ) {
+			$text = htmlspecialchars( $text );
+		}
+		return '<a href="'.$url.'"'.$style.'>'.$text.'</a>';
+	}
+
+	/**
+	 * Make user link (or user contributions for unregistered users)
+	 * @param $userId   Integer: user id in database.
+	 * @param $userText String: user name in database
+	 * @return string HTML fragment
+	 * @private
+	 */
+	function userLink( $userId, $userText ) {
+		$encName = htmlspecialchars( $userText );
+		if( $userId == 0 ) {
+			$contribsPage = SpecialPage::getTitleFor( 'Contributions', $userText );
+			return $this->makeKnownLinkObj( $contribsPage,
+				$encName);
+		} else {
+			$userPage = Title::makeTitle( NS_USER, $userText );
+			return $this->makeLinkObj( $userPage, $encName );
+		}
+	}
+
+	/**
+	 * @param $userId Integer: user id in database.
+	 * @param $userText String: user name in database.
+	 * @return string HTML fragment with talk and/or block links
+	 * @private
+	 */
+	function userToolLinks( $userId, $userText ) {
+		global $wgUser, $wgDisableAnonTalk, $wgSysopUserBans;
+		$talkable = !( $wgDisableAnonTalk && 0 == $userId );
+		$blockable = ( $wgSysopUserBans || 0 == $userId );
+
+		$items = array();
+		if( $talkable ) {
+			$items[] = $this->userTalkLink( $userId, $userText );
+		}
+		if( $userId ) {
+			$contribsPage = SpecialPage::getTitleFor( 'Contributions', $userText );
+			$items[] = $this->makeKnownLinkObj( $contribsPage ,
+				wfMsgHtml( 'contribslink' ) );
+		}
+		if( $blockable && $wgUser->isAllowed( 'block' ) ) {
+			$items[] = $this->blockLink( $userId, $userText );
+		}
+
+		if( $items ) {
+			return ' (' . implode( ' | ', $items ) . ')';
+		} else {
+			return '';
+		}
+	}
+
+	/**
+	 * @param $userId Integer: user id in database.
+	 * @param $userText String: user name in database.
+	 * @return string HTML fragment with user talk link
+	 * @private
+	 */
+	function userTalkLink( $userId, $userText ) {
+		global $wgLang;
+		$talkname = $wgLang->getNsText( NS_TALK ); # use the shorter name
+
+		$userTalkPage = Title::makeTitle( NS_USER_TALK, $userText );
+		$userTalkLink = $this->makeLinkObj( $userTalkPage, $talkname );
+		return $userTalkLink;
+	}
+
+	/**
+	 * @param $userId Integer: userid
+	 * @param $userText String: user name in database.
+	 * @return string HTML fragment with block link
+	 * @private
+	 */
+	function blockLink( $userId, $userText ) {
+		$blockPage = SpecialPage::getTitleFor( 'Blockip', $userText );
+		$blockLink = $this->makeKnownLinkObj( $blockPage,
+			wfMsgHtml( 'blocklink' ) );
+		return $blockLink;
+	}
+	
+	/**
+	 * Generate a user link if the current user is allowed to view it
+	 * @param $rev Revision object.
+	 * @return string HTML
+	 */
+	function revUserLink( $rev ) {
+		if( $rev->userCan( Revision::DELETED_USER ) ) {
+			$link = $this->userLink( $rev->getRawUser(), $rev->getRawUserText() );
+		} else {
+			$link = wfMsgHtml( 'rev-deleted-user' );
+		}
+		if( $rev->isDeleted( Revision::DELETED_USER ) ) {
+			return '<span class="history-deleted">' . $link . '</span>';
+		}
+		return $link;
+	}
+
+	/**
+	 * Generate a user tool link cluster if the current user is allowed to view it
+	 * @param $rev Revision object.
+	 * @return string HTML
+	 */
+	function revUserTools( $rev ) {
+		if( $rev->userCan( Revision::DELETED_USER ) ) {
+			$link = $this->userLink( $rev->getRawUser(), $rev->getRawUserText() ) .
+				' ' .
+				$this->userToolLinks( $rev->getRawUser(), $rev->getRawUserText() );
+		} else {
+			$link = wfMsgHtml( 'rev-deleted-user' );
+		}
+		if( $rev->isDeleted( Revision::DELETED_USER ) ) {
+			return '<span class="history-deleted">' . $link . '</span>';
+		}
+		return $link;
+	}
+	
+	/**
+	 * This function is called by all recent changes variants, by the page history,
+	 * and by the user contributions list. It is responsible for formatting edit
+	 * comments. It escapes any HTML in the comment, but adds some CSS to format
+	 * auto-generated comments (from section editing) and formats [[wikilinks]].
+	 *
+	 * @author Erik Moeller <moeller@scireview.de>
+	 *
+	 * Note: there's not always a title to pass to this function.
+	 * Since you can't set a default parameter for a reference, I've turned it
+	 * temporarily to a value pass. Should be adjusted further. --brion
+	 *
+	 * $param string $comment
+	 * @param mixed $title Title object (to generate link to the section in autocomment) or null
+	 * @param bool $local Whether section links should refer to local page
+	 */
+	function formatComment($comment, $title = NULL, $local = false) {
+		wfProfileIn( __METHOD__ );
+
+		global $wgContLang;
+		$comment = str_replace( "\n", " ", $comment );
+		$comment = htmlspecialchars( $comment );
+
+		# The pattern for autogen comments is / * foo * /, which makes for
+		# some nasty regex.
+		# We look for all comments, match any text before and after the comment,
+		# add a separator where needed and format the comment itself with CSS
+		$match = array();
+		while (preg_match('/(.*)\/\*\s*(.*?)\s*\*\/(.*)/', $comment,$match)) {
+			$pre=$match[1];
+			$auto=$match[2];
+			$post=$match[3];
+			$link='';
+			if( $title ) {
+				$section = $auto;
+
+				# Generate a valid anchor name from the section title.
+				# Hackish, but should generally work - we strip wiki
+				# syntax, including the magic [[: that is used to
+				# "link rather than show" in case of images and
+				# interlanguage links.
+				$section = str_replace( '[[:', '', $section );
+				$section = str_replace( '[[', '', $section );
+				$section = str_replace( ']]', '', $section );
+				if ( $local ) {
+					$sectionTitle = Title::newFromText( '#' . $section);
+				} else {
+					$sectionTitle = wfClone( $title );
+					$sectionTitle->mFragment = $section;
+				}
+				$link = $this->makeKnownLinkObj( $sectionTitle, wfMsg( 'sectionlink' ) );
+			}
+			$sep='-';
+			$auto=$link.$auto;
+			if($pre) { $auto = $sep.' '.$auto; }
+			if($post) { $auto .= ' '.$sep; }
+			$auto='<span class="autocomment">'.$auto.'</span>';
+			$comment=$pre.$auto.$post;
+		}
+
+		# format regular and media links - all other wiki formatting
+		# is ignored
+		$medians = '(?:' . preg_quote( Namespace::getCanonicalName( NS_MEDIA ), '/' ) . '|';
+		$medians .= preg_quote( $wgContLang->getNsText( NS_MEDIA ), '/' ) . '):';
+		while(preg_match('/\[\[:?(.*?)(\|(.*?))*\]\](.*)$/',$comment,$match)) {
+			# Handle link renaming [[foo|text]] will show link as "text"
+			if( "" != $match[3] ) {
+				$text = $match[3];
+			} else {
+				$text = $match[1];
+			}
+			$submatch = array();
+			if( preg_match( '/^' . $medians . '(.*)$/i', $match[1], $submatch ) ) {
+				# Media link; trail not supported.
+				$linkRegexp = '/\[\[(.*?)\]\]/';
+				$thelink = $this->makeMediaLink( $submatch[1], "", $text );
+			} else {
+				# Other kind of link
+				if( preg_match( $wgContLang->linkTrail(), $match[4], $submatch ) ) {
+					$trail = $submatch[1];
+				} else {
+					$trail = "";
+				}
+				$linkRegexp = '/\[\[(.*?)\]\]' . preg_quote( $trail, '/' ) . '/';
+				if (isset($match[1][0]) && $match[1][0] == ':')
+					$match[1] = substr($match[1], 1);
+				$thelink = $this->makeLink( $match[1], $text, "", $trail );
+			}
+			$comment = preg_replace( $linkRegexp, StringUtils::escapeRegexReplacement( $thelink ), $comment, 1 );
+		}
+		wfProfileOut( __METHOD__ );
+		return $comment;
+	}
+
+	/**
+	 * Wrap a comment in standard punctuation and formatting if
+	 * it's non-empty, otherwise return empty string.
+	 *
+	 * @param string $comment
+	 * @param mixed $title Title object (to generate link to section in autocomment) or null
+	 * @param bool $local Whether section links should refer to local page
+	 *
+	 * @return string
+	 */
+	function commentBlock( $comment, $title = NULL, $local = false ) {
+		// '*' used to be the comment inserted by the software way back
+		// in antiquity in case none was provided, here for backwards
+		// compatability, acc. to brion -ævar
+		if( $comment == '' || $comment == '*' ) {
+			return '';
+		} else {
+			$formatted = $this->formatComment( $comment, $title, $local );
+			return " <span class=\"comment\">($formatted)</span>";
+		}
+	}
+	
+	/**
+	 * Wrap and format the given revision's comment block, if the current
+	 * user is allowed to view it.
+	 *
+	 * @param Revision $rev
+	 * @param bool $local Whether section links should refer to local page
+	 * @return string HTML
+	 */
+	function revComment( Revision $rev, $local = false ) {
+		if( $rev->userCan( Revision::DELETED_COMMENT ) ) {
+			$block = $this->commentBlock( $rev->getRawComment(), $rev->getTitle(), $local );
+		} else {
+			$block = " <span class=\"comment\">" .
+				wfMsgHtml( 'rev-deleted-comment' ) . "</span>";
+		}
+		if( $rev->isDeleted( Revision::DELETED_COMMENT ) ) {
+			return " <span class=\"history-deleted\">$block</span>";
+		}
+		return $block;
+	}
+
+	/** @todo document */
+	function tocIndent() {
+		return "\n<ul>";
+	}
+
+	/** @todo document */
+	function tocUnindent($level) {
+		return "</li>\n" . str_repeat( "</ul>\n</li>\n", $level>0 ? $level : 0 );
+	}
+
+	/**
+	 * parameter level defines if we are on an indentation level
+	 */
+	function tocLine( $anchor, $tocline, $tocnumber, $level ) {
+		return "\n<li class=\"toclevel-$level\"><a href=\"#" .
+			$anchor . '"><span class="tocnumber">' .
+			$tocnumber . '</span> <span class="toctext">' .
+			$tocline . '</span></a>';
+	}
+
+	/** @todo document */
+	function tocLineEnd() {
+		return "</li>\n";
+ 	}
+
+	/** @todo document */
+	function tocList($toc) {
+		global $wgJsMimeType;
+		$title =  wfMsgForContent('toc') ;
+		return
+		   '<table id="toc" class="toc" summary="' . $title .'"><tr><td>'
+		 . '<div id="toctitle"><h2>' . $title . "</h2></div>\n"
+		 . $toc
+		 # no trailing newline, script should not be wrapped in a
+		 # paragraph
+		 . "</ul>\n</td></tr></table>"
+		 . '<script type="' . $wgJsMimeType . '">'
+		 . ' if (window.showTocToggle) {'
+		 . ' var tocShowText = "' . wfEscapeJsString( wfMsgForContent('showtoc') ) . '";'
+		 . ' var tocHideText = "' . wfEscapeJsString( wfMsgForContent('hidetoc') ) . '";'
+		 . ' showTocToggle();'
+		 . ' } '
+		 . "</script>\n";
+	}
+
+	/** @todo document */
+	public function editSectionLinkForOther( $title, $section ) {
+		global $wgContLang;
+
+		$title = Title::newFromText( $title );
+		$editurl = '&section='.$section;
+		$url = $this->makeKnownLinkObj( $title, wfMsg('editsection'), 'action=edit'.$editurl );
+
+		return "<span class=\"editsection\">[".$url."]</span>";
+
+	}
+
+	/**
+	 * @param $title Title object.
+	 * @param $section Integer: section number.
+	 * @param $hint Link String: title, or default if omitted or empty
+	 */
+	public function editSectionLink( $nt, $section, $hint='' ) {
+		global $wgContLang;
+
+		$editurl = '&section='.$section;
+		$hint = ( $hint=='' ) ? '' : ' title="' . wfMsgHtml( 'editsectionhint', htmlspecialchars( $hint ) ) . '"';
+		$url = $this->makeKnownLinkObj( $nt, wfMsg('editsection'), 'action=edit'.$editurl, '', '', '',  $hint );
+
+		return "<span class=\"editsection\">[".$url."]</span>";
+	}
+
+	/**
+	 * Create a headline for content
+	 *
+	 * @param int    $level   The level of the headline (1-6)
+	 * @param string $attribs Any attributes for the headline, starting with a space and ending with '>'
+	 *                        This *must* be at least '>' for no attribs
+	 * @param string $anchor  The anchor to give the headline (the bit after the #)
+	 * @param string $text    The text of the header
+	 * @param string $link    HTML to add for the section edit link
+	 *
+	 * @return string HTML headline
+	 */
+	public function makeHeadline( $level, $attribs, $anchor, $text, $link ) {
+		return "<a name=\"$anchor\"></a><h$level$attribs$link <span class=\"mw-headline\">$text</span></h$level>";
+	}
+
+	/**
+	 * Split a link trail, return the "inside" portion and the remainder of the trail
+	 * as a two-element array
+	 *
+	 * @static
+	 */
+	static function splitTrail( $trail ) {
+		static $regex = false;
+		if ( $regex === false ) {
+			global $wgContLang;
+			$regex = $wgContLang->linkTrail();
+		}
+		$inside = '';
+		if ( '' != $trail ) {
+			$m = array();
+			if ( preg_match( $regex, $trail, $m ) ) {
+				$inside = $m[1];
+				$trail = $m[2];
+			}
+		}
+		return array( $inside, $trail );
+	}
+
+	/**
+	 * Generate a rollback link for a given revision.  Currently it's the
+	 * caller's responsibility to ensure that the revision is the top one. If
+	 * it's not, of course, the user will get an error message.
+	 *
+	 * If the calling page is called with the parameter &bot=1, all rollback
+	 * links also get that parameter. It causes the edit itself and the rollback
+	 * to be marked as "bot" edits. Bot edits are hidden by default from recent
+	 * changes, so this allows sysops to combat a busy vandal without bothering
+	 * other users.
+	 *
+	 * @param Revision $rev
+	 */
+	function generateRollback( $rev ) {
+		global $wgUser, $wgRequest;
+		$title = $rev->getTitle();
+
+		$extraRollback = $wgRequest->getBool( 'bot' ) ? '&bot=1' : '';
+		$extraRollback .= '&token=' . urlencode(
+			$wgUser->editToken( array( $title->getPrefixedText(), $rev->getUserText() ) ) );
+		return '<span class="mw-rollback-link">['. $this->makeKnownLinkObj( $title,
+		  	wfMsg('rollbacklink'),
+		  	'action=rollback&from=' . urlencode( $rev->getUserText() ) . $extraRollback ) .']</span>';
+	}
+
+	/**
+	 * Returns HTML for the "templates used on this page" list.
+	 *
+	 * @param array $templates Array of templates from Article::getUsedTemplate
+	 * or similar
+	 * @param bool $preview Whether this is for a preview
+	 * @param bool $section Whether this is for a section edit
+	 * @return string HTML output
+	 */
+	public function formatTemplates( $templates, $preview = false, $section = false) {
+		global $wgUser;
+		wfProfileIn( __METHOD__ );
+
+		$sk =& $wgUser->getSkin();
+
+		$outText = '';
+		if ( count( $templates ) > 0 ) {
+			# Do a batch existence check
+			$batch = new LinkBatch;
+			foreach( $templates as $title ) {
+				$batch->addObj( $title );
+			}
+			$batch->execute();
+
+			# Construct the HTML
+			$outText = '<div class="mw-templatesUsedExplanation">';
+			if ( $preview ) {
+				$outText .= wfMsgExt( 'templatesusedpreview', array( 'parse' ) );
+			} elseif ( $section ) {
+				$outText .= wfMsgExt( 'templatesusedsection', array( 'parse' ) );
+			} else {
+				$outText .= wfMsgExt( 'templatesused', array( 'parse' ) );
+			}
+			$outText .= '</div><ul>';
+
+			foreach ( $templates as $titleObj ) {
+				$r = $titleObj->getRestrictions( 'edit' );
+				if ( in_array( 'sysop', $r ) ) { 
+					$protected = wfMsgExt( 'template-protected', array( 'parseinline' ) );
+				} elseif ( in_array( 'autoconfirmed', $r ) ) {
+					$protected = wfMsgExt( 'template-semiprotected', array( 'parseinline' ) );
+				} else {
+					$protected = '';
+				}
+				$outText .= '<li>' . $sk->makeLinkObj( $titleObj ) . ' ' . $protected . '</li>';
+			}
+			$outText .= '</ul>';
+		}
+		wfProfileOut( __METHOD__  );
+		return $outText;
+	}
+	
+	/**
+	 * Format a size in bytes for output, using an appropriate
+	 * unit (B, KB, MB or GB) according to the magnitude in question
+	 *
+	 * @param $size Size to format
+	 * @return string
+	 */
+	public function formatSize( $size ) {
+		global $wgLang;
+		if( $size > 1024 ) {
+			$size = $size / 1024;
+			if( $size > 1024 ) {
+				$size = $size / 1024;
+				if( $size > 1024 ) {
+					$size = $size / 1024;
+					$msg = 'size-gigabytes';
+				} else {
+					$msg = 'size-megabytes';
+				}
+			} else {
+				$msg = 'size-kilobytes';
+			}
+		} else {
+			$msg = 'size-bytes';
+		}
+		$size = round( $size, 0 );
+		return wfMsgHtml( $msg, $wgLang->formatNum( $size ) );
+	}
+	
+}
+
+?>
Index: trunk/wikipathways/includes/SpecialSearch.php
===================================================================
--- trunk/wikipathways/includes/SpecialSearch.php	(revision 0)
+++ trunk/wikipathways/includes/SpecialSearch.php	(revision 1110)
@@ -0,0 +1,430 @@
+<?php
+# Copyright (C) 2004 Brion Vibber <brion@pobox.com>
+# http://www.mediawiki.org/
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+# http://www.gnu.org/copyleft/gpl.html
+
+/**
+ * Run text & title search and display the output
+ * @package MediaWiki
+ * @subpackage SpecialPage
+ */
+
+/**
+ * Entry point
+ *
+ * @param $par String: (default '')
+ */
+function wfSpecialSearch( $par = '' ) {
+	global $wgRequest, $wgUser;
+
+	$search = $wgRequest->getText( 'search', $par );
+	$searchPage = new SpecialSearch( $wgRequest, $wgUser );
+	if( $wgRequest->getVal( 'fulltext' ) ||
+		!is_null( $wgRequest->getVal( 'offset' ) ) ||
+		!is_null ($wgRequest->getVal( 'searchx' ) ) ) {
+		$searchPage->showResults( $search );
+	} else {
+		
+/** Don't call 'Go' results; only 'Search' results 
+		
+		$searchPage->goResult( $search );  */
+		$searchPage->showResults( $search);
+	}
+}
+
+/**
+ * @todo document
+ * @package MediaWiki
+ * @subpackage SpecialPage
+ */
+class SpecialSearch {
+
+	/**
+	 * Set up basic search parameters from the request and user settings.
+	 * Typically you'll pass $wgRequest and $wgUser.
+	 *
+	 * @param WebRequest $request
+	 * @param User $user
+	 * @public
+	 */
+	function SpecialSearch( &$request, &$user ) {
+		list( $this->limit, $this->offset ) = $request->getLimitOffset( 20, 'searchlimit' );
+
+		if( $request->getCheck( 'searchx' ) ) {
+			$this->namespaces = $this->powerSearch( $request );
+		} else {
+			$this->namespaces = $this->userNamespaces( $user );
+		}
+
+		$this->searchRedirects = $request->getcheck( 'redirs' ) ? true : false;
+	}
+
+	/**
+	 * If an exact title match can be found, jump straight ahead to it.
+	 * @param string $term
+	 * @public
+	 */
+	function goResult( $term ) {
+		global $wgOut;
+		global $wgGoToEdit;
+
+		$this->setupPage( $term );
+
+/** AP20070421
+ * Add 'Pathway:' to search terms to support exact matches in this namespace
+ */
+		# Try to go to page as entered.
+		$term = 'Pathway:' . $term;
+		$t = Title::newFromText( $term );
+
+		# If the string cannot be used to create a title
+		if( is_null( $t ) ){
+		    	$parts = explode(':', $term, 2);
+			$term = $parts[1];
+			return $this->showResults( $term );
+		}
+
+		# If there's an exact or very near match, jump right there.
+		$t = SearchEngine::getNearMatch( $term );
+		if( !is_null( $t ) ) {
+			$wgOut->redirect( $t->getFullURL() );
+			return;
+		}
+
+		# No match, generate an edit URL
+		$t = Title::newFromText( $term );
+		if( ! is_null( $t ) ) {
+			wfRunHooks( 'SpecialSearchNogomatch', array( &$t ) );
+			# If the feature is enabled, go straight to the edit page
+			if ( $wgGoToEdit ) {
+				$wgOut->redirect( $t->getFullURL( 'action=edit' ) );
+				return;
+			} 
+		}
+		$wgOut->addWikiText( wfMsg( 'noexactmatch', wfEscapeWikiText( $term ) ) );
+
+		return $this->showResults( $term );
+	}
+
+	/**
+	 * @param string $term
+	 * @public
+	 */
+	function showResults( $term ) {
+		$fname = 'SpecialSearch::showResults';
+		wfProfileIn( $fname );
+
+		$this->setupPage( $term );
+
+		global $wgOut;
+		$wgOut->addWikiText( wfMsg( 'searchresulttext' ) );
+
+		#if ( !$this->parseQuery() ) {
+		if( '' === trim( $term ) ) {
+			$wgOut->setSubtitle( '' );
+			$wgOut->addHTML( $this->powerSearchBox( $term ) );
+			wfProfileOut( $fname );
+			return;
+		}
+
+		global $wgDisableTextSearch;
+		if ( $wgDisableTextSearch ) {
+			global $wgForwardSearchUrl;
+			if( $wgForwardSearchUrl ) {
+				$url = str_replace( '$1', urlencode( $term ), $wgForwardSearchUrl );
+				$wgOut->redirect( $url );
+				return;
+			}
+			global $wgInputEncoding;
+			$wgOut->addHTML( wfMsg( 'searchdisabled' ) );
+			$wgOut->addHTML(
+				wfMsg( 'googlesearch',
+					htmlspecialchars( $term ),
+					htmlspecialchars( $wgInputEncoding ),
+					htmlspecialchars( wfMsg( 'searchbutton' ) )
+				)
+			);
+			wfProfileOut( $fname );
+			return;
+		}
+
+		$search = SearchEngine::create();
+		$search->setLimitOffset( $this->limit, $this->offset );
+		$search->setNamespaces( $this->namespaces );
+		$search->showRedirects = $this->searchRedirects;
+		$titleMatches = $search->searchTitle( $term );
+		$textMatches = $search->searchText( $term );
+
+		$num = ( $titleMatches ? $titleMatches->numRows() : 0 )
+			+ ( $textMatches ? $textMatches->numRows() : 0);
+		if ( $num >= $this->limit ) {
+			$top = wfShowingResults( $this->offset, $this->limit );
+		} else {
+			$top = wfShowingResultsNum( $this->offset, $this->limit, $num );
+		}
+		$wgOut->addHTML( "<p>{$top}</p>\n" );
+
+		if( $num || $this->offset ) {
+			$prevnext = wfViewPrevNext( $this->offset, $this->limit,
+				SpecialPage::getTitleFor( 'Search' ),
+				wfArrayToCGI(
+					$this->powerSearchOptions(),
+					array( 'search' => $term ) ) );
+			$wgOut->addHTML( "<br />{$prevnext}\n" );
+		}
+
+		if( $titleMatches ) {
+			if( $titleMatches->numRows() ) {
+				$wgOut->addWikiText( '==' . wfMsg( 'titlematches' ) . "==\n" );
+				$wgOut->addHTML( $this->showMatches( $titleMatches ) );
+			} else {
+				$wgOut->addWikiText( '==' . wfMsg( 'notitlematches' ) . "==\n" );
+			}
+		}
+
+		if( $textMatches ) {
+			if( $textMatches->numRows() ) {
+				$wgOut->addWikiText( '==' . wfMsg( 'textmatches' ) . "==\n" );
+				$wgOut->addHTML( $this->showMatches( $textMatches ) );
+			} elseif( $num == 0 ) {
+				# Don't show the 'no text matches' if we received title matches
+				$wgOut->addWikiText( '==' . wfMsg( 'notextmatches' ) . "==\n" );
+			}
+		}
+
+		if ( $num == 0 ) {
+			$wgOut->addWikiText( wfMsg( 'nonefound' ) );
+		}
+		if( $num || $this->offset ) {
+			$wgOut->addHTML( "<p>{$prevnext}</p>\n" );
+		}
+		$wgOut->addHTML( $this->powerSearchBox( $term ) );
+		wfProfileOut( $fname );
+
+		$wgOut->addHTML('
+<!-- Google Search Result Snippet Begins -->
+  <div id="results_002915365922082279465:6qd0wwvwtwu"></div>
+  <script type="text/javascript">
+    var googleSearchIframeName = "results_002915365922082279465:6qd0wwvwtwu";
+    var googleSearchFormName = "searchbox_002915365922082279465:6qd0wwvwtwu";
+    var googleSearchFrameWidth = 600;
+    var googleSearchFrameborder = 0;
+    var googleSearchDomain = "www.google.com";
+    var googleSearchPath = "/cse";
+  </script>
+  <script type="text/javascript" src="http://www.google.com/afsonline/show_afs_search.js"></script>
+<!-- Google Search Result Snippet Ends -->
+		');
+	}
+
+	#------------------------------------------------------------------
+	# Private methods below this line
+
+	/**
+	 *
+	 */
+	function setupPage( $term ) {
+		global $wgOut;
+		$wgOut->setPageTitle( wfMsg( 'searchresults' ) );
+		$subtitlemsg = ( Title::newFromText($term) ? 'searchsubtitle' : 'searchsubtitleinvalid' );
+		$wgOut->setSubtitle( $wgOut->parse( wfMsg( $subtitlemsg, wfEscapeWikiText($term) ) ) );
+		$wgOut->setArticleRelated( false );
+		$wgOut->setRobotpolicy( 'noindex,nofollow' );
+	}
+
+	/**
+	 * Extract default namespaces to search from the given user's
+	 * settings, returning a list of index numbers.
+	 *
+	 * @param User $user
+	 * @return array
+	 * @private
+	 */
+	function userNamespaces( &$user ) {
+		$arr = array();
+		foreach( SearchEngine::searchableNamespaces() as $ns => $name ) {
+			if( $user->getOption( 'searchNs' . $ns ) ) {
+				$arr[] = $ns;
+			}
+		}
+		return $arr;
+	}
+
+	/**
+	 * Extract "power search" namespace settings from the request object,
+	 * returning a list of index numbers to search.
+	 *
+	 * @param WebRequest $request
+	 * @return array
+	 * @private
+	 */
+	function powerSearch( &$request ) {
+		$arr = array();
+		foreach( SearchEngine::searchableNamespaces() as $ns => $name ) {
+			if( $request->getCheck( 'ns' . $ns ) ) {
+				$arr[] = $ns;
+			}
+		}
+		return $arr;
+	}
+
+	/**
+	 * Reconstruct the 'power search' options for links
+	 * @return array
+	 * @private
+	 */
+	function powerSearchOptions() {
+		$opt = array();
+		foreach( $this->namespaces as $n ) {
+			$opt['ns' . $n] = 1;
+		}
+		$opt['redirs'] = $this->searchRedirects ? 1 : 0;
+		$opt['searchx'] = 1;
+		return $opt;
+	}
+
+	/**
+	 * @param SearchResultSet $matches
+	 * @param string $terms partial regexp for highlighting terms
+	 */
+	function showMatches( &$matches ) {
+		$fname = 'SpecialSearch::showMatches';
+		wfProfileIn( $fname );
+
+		global $wgContLang;
+		$tm = $wgContLang->convertForSearchResult( $matches->termMatches() );
+		$terms = implode( '|', $tm );
+
+		$off = $this->offset + 1;
+		$out = "<ol start='{$off}'>\n";
+
+		while( $result = $matches->next() ) {
+			$out .= $this->showHit( $result, $terms );
+		}
+		$out .= "</ol>\n";
+
+		// convert the whole thing to desired language variant
+		global $wgContLang;
+		$out = $wgContLang->convert( $out );
+		wfProfileOut( $fname );
+		return $out;
+	}
+
+	/**
+	 * Format a single hit result
+	 * @param SearchResult $result
+	 * @param string $terms partial regexp for highlighting terms
+	 */
+	function showHit( $result, $terms ) {
+		$fname = 'SpecialSearch::showHit';
+		wfProfileIn( $fname );
+		global $wgUser, $wgContLang, $wgLang;
+
+		$t = $result->getTitle();
+		if( is_null( $t ) ) {
+			wfProfileOut( $fname );
+			return "<!-- Broken link in search result -->\n";
+		}
+		$sk =& $wgUser->getSkin();
+		$contextlines = $wgUser->getOption( 'contextlines',  5 );
+		$contextchars = $wgUser->getOption( 'contextchars', 50 );
+
+		$link = $sk->makeKnownLinkObj( $t );
+		$revision = Revision::newFromTitle( $t );
+		$text = $revision->getText();
+		$size = wfMsgExt( 'nbytes', array( 'parsemag', 'escape'),
+			$wgLang->formatNum( strlen( $text ) ) );
+
+		$lines = explode( "\n", $text );
+
+		$max = intval( $contextchars ) + 1;
+		$pat1 = "/(.*)($terms)(.{0,$max})/i";
+
+		$lineno = 0;
+
+		$extract = '';
+		wfProfileIn( "$fname-extract" );
+		foreach ( $lines as $line ) {
+			if ( 0 == $contextlines ) {
+				break;
+			}
+			++$lineno;
+			$m = array();
+			if ( ! preg_match( $pat1, $line, $m ) ) {
+				continue;
+			}
+			--$contextlines;
+			$pre = $wgContLang->truncate( $m[1], -$contextchars, '...' );
+
+			if ( count( $m ) < 3 ) {
+				$post = '';
+			} else {
+				$post = $wgContLang->truncate( $m[3], $contextchars, '...' );
+			}
+
+			$found = $m[2];
+
+			$line = htmlspecialchars( $pre . $found . $post );
+			$pat2 = '/(' . $terms . ")/i";
+			$line = preg_replace( $pat2,
+			  "<span class='searchmatch'>\\1</span>", $line );
+
+			$extract .= "<br /><small>{$lineno}: {$line}</small>\n";
+		}
+		wfProfileOut( "$fname-extract" );
+		wfProfileOut( $fname );
+		return "<li>{$link} ({$size}){$extract}</li>\n";
+	}
+
+	function powerSearchBox( $term ) {
+		$namespaces = '';
+		foreach( SearchEngine::searchableNamespaces() as $ns => $name ) {
+			$checked = in_array( $ns, $this->namespaces )
+				? ' checked="checked"'
+				: '';
+			$name = str_replace( '_', ' ', $name );
+			if( '' == $name ) {
+				$name = wfMsg( 'blanknamespace' );
+			}
+			$namespaces .= " <label><input type='checkbox' value=\"1\" name=\"" .
+			  "ns{$ns}\"{$checked} />{$name}</label>\n";
+		}
+
+		$checked = $this->searchRedirects
+			? ' checked="checked"'
+			: '';
+		$redirect = "<input type='checkbox' value='1' name=\"redirs\"{$checked} />\n";
+
+		$searchField = '<input type="text" name="search" value="' .
+			htmlspecialchars( $term ) ."\" size=\"16\" />\n";
+
+		$searchButton = '<input type="submit" name="searchx" value="' .
+		  htmlspecialchars( wfMsg('powersearch') ) . "\" />\n";
+
+		$ret = wfMsg( 'powersearchtext',
+			$namespaces, $redirect, $searchField,
+			'', '', '', '', '', # Dummy placeholders
+			$searchButton );
+
+		$title = SpecialPage::getTitleFor( 'Search' );
+		$action = $title->escapeLocalURL();
+		return "<br /><br />\n<form id=\"powersearch\" method=\"get\" " .
+		  "action=\"$action\">\n{$ret}\n</form>\n";
+	}
+}
+
+?>
Index: trunk/wikipathways/skins/wikipathways/Opera6Fixes.css
===================================================================
--- trunk/wikipathways/skins/wikipathways/Opera6Fixes.css	(revision 0)
+++ trunk/wikipathways/skins/wikipathways/Opera6Fixes.css	(revision 1110)
@@ -0,0 +1,14 @@
+/* opera 6 fixes */
+#column-one {
+	position: relative;
+	max-width: 11.7em;
+}
+#p-personal {
+	width: 45em;
+	margin-left: 8.6em;
+	right: 0;
+}
+#bodyContent a.external {
+	background: url(external.png) center right no-repeat;
+	padding-right: 13px;
+}
Index: trunk/wikipathways/skins/wikipathways/user.gif
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/wikipathways/skins/wikipathways/user.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: trunk/wikipathways/skins/wikipathways/Opera7Fixes.css
===================================================================
--- trunk/wikipathways/skins/wikipathways/Opera7Fixes.css	(revision 0)
+++ trunk/wikipathways/skins/wikipathways/Opera7Fixes.css	(revision 1110)
@@ -0,0 +1,11 @@
+/* small tweaks for opera seven */
+#p-cactions {
+	margin-top: .1em;
+}
+#p-cactions li a {
+	top: 2px;
+}
+#bodyContent a.external {
+	background: url(external.png) center right no-repeat;
+	padding-right: 13px;
+}
Index: trunk/wikipathways/skins/wikipathways/audio.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/wikipathways/skins/wikipathways/audio.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: trunk/wikipathways/skins/wikipathways/required.gif
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/wikipathways/skins/wikipathways/required.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: trunk/wikipathways/skins/wikipathways/wiki.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/wikipathways/skins/wikipathways/wiki.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: trunk/wikipathways/skins/wikipathways/IE50Fixes.css
===================================================================
--- trunk/wikipathways/skins/wikipathways/IE50Fixes.css	(revision 0)
+++ trunk/wikipathways/skins/wikipathways/IE50Fixes.css	(revision 1110)
@@ -0,0 +1,67 @@
+/*
+** IE5.0 Fix Stylesheet
+*/
+
+#column-content {
+	margin: 0 !important;
+	float: none;
+}
+#column-content #content { 
+	margin-top: 3em; 
+	height: 1%;
+}
+#column-one {
+	position: absolute;
+	overflow: visible;
+	top: 0;
+	left: 0;
+	z-index: 3;
+}
+#footer {
+	margin: 0 0 0 13.6em;
+}
+
+/* IE 5 & 5.5 interpret keyword sizes one off */
+body { font-size: xx-small; }
+/*
+** the edit tabs
+*/
+#p-cactions li {
+	float: left;
+	padding-top: 0;
+	padding-bottom: 0 !important;
+	height: 0.9em;
+}
+#p-cactions li a {
+	display: block;
+	padding-bottom: 0.045em;
+}
+#p-cactions li.selected a {
+	padding-bottom: 0.17em;
+}
+#p-cactions li a:hover {
+	padding-bottom: 0.17em;
+}
+/* 5.0 doesn't like the background icon for external links and user */
+.link-external,
+.external {
+	background: none;
+	padding: 0;
+}
+#p-personal ul { float: right }
+#p-personal li { float: left }
+li#pt-userpage,
+li#pt-anonuserpage,
+li#pt-login,
+li#pt-logout {
+	background: none;
+	padding-left: none;
+}
+.visualClear {
+	width: 100%;
+	height: 0px;
+	padding:0;
+	margin: 0;
+}
+.firstHeading { margin-bottom: .3em; }
+/*div{ border:1px solid Red !important;}*/
Index: trunk/wikipathways/skins/wikipathways/rtl.css
===================================================================
--- trunk/wikipathways/skins/wikipathways/rtl.css	(revision 0)
+++ trunk/wikipathways/skins/wikipathways/rtl.css	(revision 1110)
@@ -0,0 +1,216 @@
+/*
+Right-to-left fixes for MonoBook.
+Places sidebar on right, tweaks various alignment issues.
+
+Works mostly ok nicely on Safari 1.2.1; fine in Mozilla.
+
+Safari bugs (1.2.1):
+* Tabs are still appearing in left-to-right order. (Try after localizing)
+
+Opera bugs (7.23 linux):
+* Some bits of ltr text (sidebar box titles) have forward and backward versions overlapping each other
+
+IE/mac bugs:
+* The thing barfs on Hebrew and Arabic anyway, so no point testing.
+
+Missing features due to lack of support:
+* external link icons
+
+To test:
+* Opera6
+* IE 5.0
+* etc
+
+*/
+body {
+	direction: rtl;
+/*    unicode-bidi: bidi-override;*/
+	unicode-bidi: embed;
+}
+#column-content {
+	margin: 0 -12.2em 0 0;
+	float: left;
+}
+#column-content #content{
+	margin-left: 0;
+	margin-right: 12.2em;
+	border-right: 1px solid #aaaaaa;
+	border-left: none;
+}
+html>body .portlet {
+	float: right;
+	clear: right;
+}
+.editsection {
+	float: left;
+	margin-right: 5px;
+}
+/* recover IEMac (might be fine with the float, but usually it's close to IE */
+*>body .portlet {
+	float: none;
+	clear: none;
+}
+.pBody {
+	padding-right: 0.8em;
+	padding-left: 0.5em;
+}
+
+/* Fix alignment */
+.documentByLine,
+.portletDetails,
+.portletMore,
+#p-personal {
+	text-align: left;
+}
+
+div div.thumbcaption {
+	text-align: right;
+}
+
+div.magnify,
+#div.townBox,
+#p-logo {
+	left: auto;
+	right: 0;
+}
+#p-personal {
+	left: auto;
+	right: 0;
+}
+
+#p-cactions {
+	left: auto;
+	right: 11.5em;
+	padding-left: 0;
+	padding-right: 1em;
+}
+#p-cactions li {
+	margin-left: 0.3em;
+	margin-right: 0;
+	float: right;
+}
+* html #p-cactions li a {
+	display: block;
+	padding-bottom: 0;
+}
+* html #p-cactions li a:hover {
+	padding-bottom: 0.2em;
+}
+/* offsets to distinguish the tab groups */
+li#ca-talk {
+	margin-right: auto;
+	margin-left: 1.6em;
+}
+li#ca-watch,li#ca-unwatch {
+	margin-right: 1.6em !important;
+}
+
+/* Fix margins for non-css2 browsers */
+/* top right bottom left */
+
+ul {
+	margin-left: 0;
+	margin-right: 1.5em;
+}
+ol {
+	margin-left: 0;
+	margin-right: 2.4em;
+}
+dd {
+	margin-left: 0;
+	margin-right: 1.6em;
+}
+#contentSub {
+	margin-right: 1em;
+	margin-left: 0;
+}
+.tocindent {
+	margin-left: 0;
+	margin-right: 2em;
+}
+div.tright, div.floatright, table.floatright {
+	clear: none;
+}
+div.tleft, div.floatleft, table.floatleft {
+	clear: left;
+}
+div.townBox {
+	margin-left: 0;
+	margin-right: 1em;
+}
+div.townBox dl dd {
+	margin-left: 0;
+	margin-right: 1.1em;
+}
+#p-personal li {
+	margin-left: 0;
+	margin-right: 1em;
+}
+
+li#ca-talk,
+li#ca-watch {
+	margin-right: auto;
+	margin-left: 1.6em;
+}
+
+#p-personal li {
+	float: left;
+}
+/* Fix link icons */
+.external {
+	padding: 0 !important;
+	background: none !important;
+}
+#footer {
+	clear: both;
+}
+* html #footer {
+	margin-left: 0;
+	margin-right: 13.6em;
+	border-left: 0;
+	border-right: 1px solid #fabd23;
+} 
+* html #column-content { 
+	float: none;
+	margin-left: 0;
+	margin-right: 0;
+}
+* html #column-content #content {
+	margin-left: 0;
+	margin-top: 3em;
+}
+* html #column-one { right: 0; }
+
+/* js pref toc */
+
+#preftoc {
+	margin-right: 1em;
+}
+
+.errorbox, .successbox, #preftoc li, .prefsection fieldset {
+	float: right;
+}
+
+.prefsection {
+	padding-right: 2em;
+}
+
+/* workaround for moz bug, displayed bullets on left side */
+
+#toc ul {
+	text-align: right;
+}
+
+#toc ul ul {
+	margin: 0 2em 0 0;
+}
+
+input#wpSave, input#wpDiff {
+	margin-right: 0;
+	margin-left: .33em;
+}
+
+#userlogin {
+	float: right;
+	margin: 0 0 1em 3em;
+}
Index: trunk/wikipathways/skins/wikipathways/headbg.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/wikipathways/skins/wikipathways/headbg.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: trunk/wikipathways/skins/wikipathways/IE60Fixes.css
===================================================================
--- trunk/wikipathways/skins/wikipathways/IE60Fixes.css	(revision 0)
+++ trunk/wikipathways/skins/wikipathways/IE60Fixes.css	(revision 1110)
@@ -0,0 +1,84 @@
+/* 6.0 - only fixes */
+/* content area */ 
+/* workaround for various ie float bugs */
+#column-content { 
+	float: none; 
+	margin-left: 0;
+	height: 1%;
+}
+#column-content #content {
+	margin-left: 12.2em;
+	margin-top: 3em;
+	height: 1%;
+}
+#column-one {
+	position: absolute;
+	top: 0;
+	left: 0;
+	z-index: 4;
+}
+#footer {
+	margin-left: 13.6em;
+	border-left: 1px solid #fabd23;
+}
+
+/* the tabs */
+
+#p-cactions {
+	z-index: 3;
+}
+
+#p-cactions li {
+	padding-bottom: 0 !important;
+	border: none;
+	background-color: transparent;
+	cursor: default;
+	float: none !important;
+}
+#p-cactions li a {
+	display: inline-block !important;
+	vertical-align: top;
+	padding-bottom: 0;
+	border: solid #aaa;
+	border-width: 1px 1px 0;
+}
+#p-cactions li.selected a {
+	border-color: #fabd23;
+	padding-bottom: 0.17em;
+}
+#p-cactions li a:hover {
+	padding-bottom: 0.17em;
+}
+#p-navigation a {
+	display: inline-block;
+	width: 100%;
+}
+#portal-personaltools {
+	padding-bottom: 0.1em;
+}
+#bodyContent a.external {
+	background: url(external.png) center right no-repeat;
+	padding-right: 13px;
+}
+
+/* show the hand */
+#p-logo a,
+#p-logo a:hover {
+	cursor: pointer;
+}
+div.visualClear {
+	width:100%;
+	line-height: 0;
+}
+textarea {
+	width: 96%;
+}
+
+div.editsection,
+#catlinks,
+div.tright,
+div.tleft {
+	position: relative;
+}
+/*{ border:1px solid Red !important;}*/
+
Index: trunk/wikipathways/skins/wikipathways/video.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/wikipathways/skins/wikipathways/video.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: trunk/wikipathways/skins/wikipathways/IE70Fixes.css
===================================================================
--- trunk/wikipathways/skins/wikipathways/IE70Fixes.css	(revision 0)
+++ trunk/wikipathways/skins/wikipathways/IE70Fixes.css	(revision 1110)
@@ -0,0 +1,74 @@
+/* 7.0 - only fixes */
+/* content area */ 
+/* workaround for various ie float bugs */
+
+/* This bit is needed to make links clickable... WTF */
+#column-content #content {
+	margin-left: 12.2em;
+	margin-top: 3em;
+	height: 1%;
+}
+
+.rtl #column-one {
+	/* For some reason it tries to inherit the padding-top into every div,
+	 * and I can't figure out how to get it back off.
+	 * Margin works correctly for this use, though.
+	 */
+	padding-top: 0;
+	margin-top: 160px;
+}
+
+/* the tabs */
+
+#p-cactions {
+	z-index: 3;
+}
+
+
+#p-cactions li {
+	padding-bottom: 0 !important;
+	border: none;
+	background-color: transparent;
+	cursor: default;
+	float: none !important;
+}
+
+#p-cactions li a {
+	display: inline-block !important;
+	vertical-align: top;
+	padding-bottom: 0;
+	border: solid #aaa;
+	border-width: 1px 1px 0;
+}
+#p-cactions li.selected a {
+	border-color: #fabd23;
+	padding-bottom: 0.17em;
+}
+#p-cactions li a:hover {
+	padding-bottom: 0.17em;
+}
+#p-navigation a {
+	display: inline-block;
+	width: 100%;
+}
+#portal-personaltools {
+	padding-bottom: 0.1em;
+}
+textarea {
+	width: 96%;
+}
+
+/*
+div.editsection,
+#catlinks,
+div.tright,
+div.tleft {
+	position: relative;
+}
+*/
+
+
+#footer li {
+	/* Work around bug with inline <li> tags with right margins and nowrap */
+	margin-right: 0;
+}
Index: trunk/wikipathways/skins/wikipathways/file_icon.gif
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/wikipathways/skins/wikipathways/file_icon.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: trunk/wikipathways/skins/wikipathways/bullet.gif
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/wikipathways/skins/wikipathways/bullet.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: trunk/wikipathways/skins/wikipathways/IE55Fixes.css
===================================================================
--- trunk/wikipathways/skins/wikipathways/IE55Fixes.css	(revision 0)
+++ trunk/wikipathways/skins/wikipathways/IE55Fixes.css	(revision 1110)
@@ -0,0 +1,85 @@
+/* IE5.5/win- only fixes */
+
+#column-content { 
+	float: none; 
+	margin-left: 0;
+	height: 1%;
+}
+#column-content #content {
+	position: relative;
+	z-index: 5;
+	margin-left: 12.2em;
+	margin-top: 3em;
+	height: 1%;
+}
+#column-one {
+	position: absolute;
+	top: 0;
+	left: 0;
+	z-index: 4;
+	width: 100%;
+}
+#footer {
+	margin-left: 13.6em;
+	border-left: 1px solid #fabd23;
+}
+
+/*#bodyContent div,
+#bodyContent pre { overflow: auto; }*/
+
+#p-personal { padding-bottom: .1em; }
+
+body { font-size: xx-small; }
+
+#p-cactions {
+	width: 76% !important;
+	z-index: 3 !important;
+	float: none;
+}
+#p-cactions li {
+	padding-bottom: 0 !important;
+	border: none;
+	background-color: transparent;
+	cursor: default;
+	float: none !important;
+}
+#p-cactions li a {
+	display: inline-block !important;
+	vertical-align: top;
+	padding-bottom: 0;
+	border: solid #aaa;
+	border-width: 1px 1px 0;
+}
+#p-cactions li.selected a {
+	border-color: #fabd23;
+	padding-bottom: 0.17em;
+}
+#p-cactions li a:hover {
+	padding-bottom: 0.17em;
+}
+#p-navigation a {
+	display: inline-block;
+	width: 100%;
+}
+.portlet {
+	overflow: hidden;
+}
+#bodyContent a.external {
+	background: url(external.png) center right no-repeat;
+	padding-right: 13px;
+}
+/* show the hand */
+#p-logo a,
+#p-logo a:hover {
+	cursor: pointer;
+}
+.visualClear {
+	width: 90%;
+	height: 1px;
+	padding: 0;
+	margin: 0;
+}
+
+#editform {
+	width: 100%;
+}
Index: trunk/wikipathways/skins/wikipathways/handheld.css
===================================================================
--- trunk/wikipathways/skins/wikipathways/handheld.css	(revision 0)
+++ trunk/wikipathways/skins/wikipathways/handheld.css	(revision 1110)
@@ -0,0 +1,1337 @@
+/*
+** MediaWiki 'monobook' style sheet for CSS2-capable browsers.
+** Copyright Gabriel Wicke - http://wikidev.net/
+** License: GPL (http://www.gnu.org/copyleft/gpl.html)
+**
+** Loosely based on http://www.positioniseverything.net/ordered-floats.html by Big John
+** and the Plone 2.0 styles, see http://plone.org/ (Alexander Limi,Joe Geldart & Tom Croucher,
+** Michael Zeltner and Geir Bækholt)
+** All you guys rock :)
+*/
+
+/**
+ * Stylesheet for handhelds.  All rules not marked media-specific are shared
+ * with main.css and should be updated in tandem.  The rules can't be in the
+ * same file because old browsers like IE5 won't obey @media rules.
+ *
+ * Rules that are handheld-specific are given @media rules in case old browsers
+ * don't recognize the media attribute and load this file anyway.
+ */
+
+#content {
+	background: white;
+	color: black;
+	border: 1px solid #aaa;
+	border-right: none;
+	line-height: 1.5em;
+}
+/* the left column width is specified in class .portlet */
+
+/* Font size:
+** We take advantage of keyword scaling- browsers won't go below 9px
+** More at http://www.w3.org/2003/07/30-font-size
+** http://style.cleverchimp.com/font_size_intervals/altintervals.html
+*/
+
+body {
+	font: x-small sans-serif;
+	background: #f9f9f9 url(headbg.jpg) 0 0 no-repeat;
+	color: black;
+	margin: 0;
+	padding: 0;
+}
+
+/* scale back up to a sane default */
+#globalWrapper {
+	font-size: 127%;
+	width: 100%;
+	margin: 0;
+	padding: 0;
+}
+.visualClear {
+	clear: both;
+}
+
+/* general styles */
+
+table {
+	font-size: 100%;
+	color: black;
+	/* we don't want the bottom borders of <h2>s to be visible through
+	   floated tables */
+	background-color: white;
+}
+a {
+	text-decoration: none;
+	color: #002bb8;
+	background: none;
+}
+a:visited {
+	color: #5a3696;
+}
+a:active {
+	color: #faa700;
+}
+a:hover {
+	text-decoration: underline;
+}
+a.stub {
+	color: #772233;
+}
+a.new, #p-personal a.new {
+	color: #ba0000;
+}
+a.new:visited, #p-personal a.new:visited {
+	color: #a55858;
+}
+
+img {
+	border: none;
+	vertical-align: middle;
+}
+p img {
+	margin: 0;
+}
+
+hr {
+	height: 1px;
+	color: #aaa;
+	background-color: #aaa;
+	border: 0;
+	margin: .2em 0 .2em 0;
+}
+
+h1, h2, h3, h4, h5, h6 {
+	color: black;
+	background: none;
+	font-weight: normal;
+	margin: 0;
+	padding-top: .5em;
+	padding-bottom: .17em;
+	border-bottom: 1px solid #aaa;
+}
+h1 { font-size: 188%; }
+h1 .editsection { font-size: 53%; }
+h2 { font-size: 150%; }
+h2 .editsection { font-size: 67%; }
+h3, h4, h5, h6 {
+	border-bottom: none;
+	font-weight: bold;
+}
+h3 { font-size: 132%; }
+h3 .editsection { font-size: 76%; font-weight: normal; }
+h4 { font-size: 116%; }
+h4 .editsection { font-size: 86%; font-weight: normal; }
+h5 { font-size: 100%; }
+h5 .editsection { font-weight: normal; }
+h6 { font-size: 80%;  }
+h6 .editsection { font-size: 125%; font-weight: normal; }
+
+.editsection {
+	float: right;
+	margin-left: 5px;
+}
+
+ul {
+	line-height: 1.5em;
+	list-style-type: square;
+	margin: .3em 0 0 1.5em;
+	padding: 0;
+	list-style-image: url(bullet.gif);
+}
+ol {
+	line-height: 1.5em;
+	margin: .3em 0 0 3.2em;
+	padding: 0;
+	list-style-image: none;
+}
+li {
+	margin-bottom: .1em;
+}
+dt {
+	font-weight: bold;
+	margin-bottom: .1em;
+}
+dl {
+	margin-top: .2em;
+	margin-bottom: .5em;
+}
+dd {
+	line-height: 1.5em;
+	margin-left: 2em;
+	margin-bottom: .1em;
+}
+
+fieldset {
+	border: 1px solid #2f6fab;
+	margin: 1em 0 1em 0;
+	padding: 0 1em 1em;
+	line-height: 1.5em;
+}
+legend {
+	padding: .5em;
+	font-size: 95%;
+}
+form {
+	border: none;
+	margin: 0;
+}
+
+textarea {
+	width: 100%;
+	padding: .1em;
+}
+
+input.historysubmit {
+	padding: 0 .3em .3em .3em !important;
+	font-size: 94%;
+	cursor: pointer;
+	height: 1.7em !important;
+	margin-left: 1.6em;
+}
+select {
+	vertical-align: top;
+}
+abbr, acronym, .explain {
+	border-bottom: 1px dotted black;
+	color: black;
+	background: none;
+	cursor: help;
+}
+q {
+	font-family: Times, "Times New Roman", serif;
+	font-style: italic;
+}
+/* disabled for now
+blockquote {
+	font-family: Times, "Times New Roman", serif;
+	font-style: italic;
+}*/
+code {
+	background-color: #f9f9f9;
+}
+pre {
+	padding: 1em;
+	border: 1px dashed #2f6fab;
+	color: black;
+	background-color: #f9f9f9;
+	line-height: 1.1em;
+}
+
+/*
+** the main content area
+*/
+
+#contentSub, #contentSub2 {
+	font-size: 84%;
+	line-height: 1.2em;
+	margin: 0 0 1.4em 1em;
+	color: #7d7d7d;
+	width: auto;
+}
+span.subpages {
+	display: block;
+}
+
+/* Some space under the headers in the content area */
+#bodyContent h1, #bodyContent h2 {
+	margin-bottom: .6em;
+}
+#bodyContent h3, #bodyContent h4, #bodyContent h5 {
+	margin-bottom: .3em;
+}
+.firstHeading {
+	margin-bottom: .1em;
+}
+
+/* user notification thing */
+.usermessage {
+	background-color: #ffce7b;
+	border: 1px solid #ffa500;
+	color: black;
+	font-weight: bold;
+	margin: 2em 0 1em;
+	padding: .5em 1em;
+	vertical-align: middle;
+}
+#siteNotice {
+	text-align: center;
+	font-size: 95%;
+	padding: 0 .9em;
+}
+#siteNotice p {
+	margin: 0;
+	padding: 0;
+}
+.error {
+	color: red;
+	font-size: larger;
+}
+.errorbox, .successbox {
+	font-size: larger;
+	border: 2px solid;
+	padding: .5em 1em;
+	float: left;
+	margin-bottom: 2em;
+	color: #000;
+}
+.errorbox {
+	border-color: red;
+	background-color: #fff2f2;
+}
+.successbox {
+	border-color: green;
+	background-color: #dfd;
+}
+.errorbox h2, .successbox h2 {
+	font-size: 1em;
+	font-weight: bold;
+	display: inline;
+	margin: 0 .5em 0 0;
+	border: none;
+}
+
+#catlinks {
+	border: 1px solid #aaa;
+	background-color: #f9f9f9;
+	padding: 5px;
+	margin-top: 1em;
+	clear: both;
+}
+/* currently unused, intended to be used by a metadata box
+in the bottom-right corner of the content area */
+.documentDescription {
+	/* The summary text describing the document */
+	font-weight: bold;
+	display: block;
+	margin: 1em 0;
+	line-height: 1.5em;
+}
+.documentByLine {
+	text-align: right;
+	font-size: 90%;
+	clear: both;
+	font-weight: normal;
+	color: #76797c;
+}
+
+/* emulate center */
+.center {
+	width: 100%;
+	text-align: center;
+}
+*.center * {
+	margin-left: auto;
+	margin-right: auto;
+}
+/* small for tables and similar */
+.small, .small * {
+	font-size: 94%;
+}
+table.small {
+	font-size: 100%;
+}
+
+/*
+** content styles
+*/
+
+#toc,
+.toc,
+.mw-warning {
+	border: 1px solid #aaa;
+	background-color: #f9f9f9;
+	padding: 5px;
+	font-size: 95%;
+}
+#toc h2,
+.toc h2 {
+	display: inline;
+	border: none;
+	padding: 0;
+	font-size: 100%;
+	font-weight: bold;
+}
+#toc #toctitle,
+.toc #toctitle,
+#toc .toctitle,
+.toc .toctitle {
+	text-align: center;
+}
+#toc ul,
+.toc ul {
+	list-style-type: none;
+	list-style-image: none;
+	margin-left: 0;
+	padding-left: 0;
+	text-align: left;
+}
+#toc ul ul,
+.toc ul ul {
+	margin: 0 0 0 2em;
+}
+#toc .toctoggle,
+.toc .toctoggle {
+	font-size: 94%;
+}
+
+.mw-warning {
+	margin-left: 50px;
+	margin-right: 50px;
+	text-align: center;
+}
+
+/* images */
+div.floatright, table.floatright {
+	clear: right;
+	float: right;
+	position: relative;
+	margin: 0 0 .5em .5em;
+	border: 0;
+/*
+	border: .5em solid white;
+	border-width: .5em 0 .8em 1.4em;
+*/
+}
+div.floatright p { font-style: italic; }
+div.floatleft, table.floatleft {
+	float: left;
+	clear: left;
+	position: relative;
+	margin: 0 .5em .5em 0;
+	border: 0;
+/*
+	margin: .3em .5em .5em 0;
+	border: .5em solid white;
+	border-width: .5em 1.4em .8em 0;
+*/
+}
+div.floatleft p { font-style: italic; }
+/* thumbnails */
+div.thumb {
+	margin-bottom: .5em;
+	border-style: solid;
+	border-color: white;
+	width: auto;
+}
+div.thumbinner {
+	border: 1px solid #ccc;
+	padding: 3px !important;
+	background-color: #f9f9f9;
+	font-size: 94%;
+	text-align: center;
+	overflow: hidden;
+}
+html .thumbimage {
+	border: 1px solid #ccc;
+}
+html .thumbcaption {
+	border: none;
+	text-align: left;
+	line-height: 1.4em;
+	padding: 3px !important;
+	font-size: 94%;
+}
+div.magnify {
+	float: right;
+	border: none !important;
+	background: none !important;
+}
+div.magnify a, div.magnify img {
+	display: block;
+	border: none !important;
+	background: none !important;
+}
+div.tright {
+	clear: right;
+	float: right;
+	border-width: .5em 0 .8em 1.4em;
+}
+div.tleft {
+	float: left;
+	clear: left;
+	margin-right: .5em;
+	border-width: .5em 1.4em .8em 0;
+}
+
+.hiddenStructure {
+	display: none;
+	speak: none;
+}
+img.tex {
+	vertical-align: middle;
+}
+span.texhtml {
+	font-family: serif;
+}
+
+/*
+** classes for special content elements like town boxes
+** intended to be referenced directly from the wiki src
+*/
+
+/*
+** User styles
+*/
+/* table standards */
+table.rimage {
+	float: right;
+	position: relative;
+	margin-left: 1em;
+	margin-bottom: 1em;
+	text-align: center;
+}
+.toccolours {
+	border: 1px solid #aaa;
+	background-color: #f9f9f9;
+	padding: 5px;
+	font-size: 95%;
+}
+div.townBox {
+	position: relative;
+	float: right;
+	background: white;
+	margin-left: 1em;
+	border: 1px solid gray;
+	padding: .3em;
+	width: 200px;
+	overflow: hidden;
+	clear: right;
+}
+div.townBox dl {
+	padding: 0;
+	margin: 0 0 .3em;
+	font-size: 96%;
+}
+div.townBox dl dt {
+	background: none;
+	margin: .4em 0 0;
+}
+div.townBox dl dd {
+	margin: .1em 0 0 1.1em;
+	background-color: #f3f3f3;
+}
+
+/*
+** edit views etc
+*/
+.special li {
+	line-height: 1.4em;
+	margin: 0;
+	padding: 0;
+}
+
+/* Page history styling */
+/* the auto-generated edit comments */
+.autocomment {
+	color: gray;
+}
+#pagehistory span.user {
+	margin-left: 1.4em;
+	margin-right: .4em;
+}
+#pagehistory span.minor {
+	font-weight: bold;
+}
+#pagehistory li {
+	border: 1px solid white;
+}
+#pagehistory li.selected {
+	background-color: #f9f9f9;
+	border: 1px dashed #aaa;
+}
+
+/*
+** Diff rendering
+*/
+table.diff, td.diff-otitle, td.diff-ntitle {
+	background-color: white;
+}
+td.diff-addedline {
+	background: #cfc;
+	font-size: smaller;
+}
+td.diff-deletedline {
+	background: #ffa;
+	font-size: smaller;
+}
+td.diff-context {
+	background: #eee;
+	font-size: smaller;
+}
+span.diffchange {
+	color: red;
+	font-weight: bold;
+}
+
+/*
+** keep the whitespace in front of the ^=, hides rule from konqueror
+** this is css3, the validator doesn't like it when validating as css2
+*/
+#bodyContent a.external,
+#bodyContent a[href ^="gopher://"] {
+	background: url(external.png) center right no-repeat;
+	padding-right: 13px;
+}
+#bodyContent a[href ^="https://"],
+.link-https {
+	background: url(lock_icon.gif) center right no-repeat;
+	padding-right: 16px;
+}
+#bodyContent a[href ^="mailto:"],
+.link-mailto {
+	background: url(mail_icon.gif) center right no-repeat;
+	padding-right: 18px;
+}
+#bodyContent a[href ^="news://"] {
+	background: url(news_icon.png) center right no-repeat;
+	padding-right: 18px;
+}
+#bodyContent a[href ^="ftp://"],
+.link-ftp {
+	background: url(file_icon.gif) center right no-repeat;
+	padding-right: 18px;
+}
+#bodyContent a[href ^="irc://"],
+.link-irc {
+	background: url(discussionitem_icon.gif) center right no-repeat;
+	padding-right: 18px;
+}
+#bodyContent a.external[href $=".ogg"], #bodyContent a.external[href $=".OGG"],
+#bodyContent a.external[href $=".mid"], #bodyContent a.external[href $=".MID"],
+#bodyContent a.external[href $=".midi"], #bodyContent a.external[href $=".MIDI"],
+#bodyContent a.external[href $=".mp3"], #bodyContent a.external[href $=".MP3"],
+#bodyContent a.external[href $=".wav"], #bodyContent a.external[href $=".WAV"],
+#bodyContent a.external[href $=".wma"], #bodyContent a.external[href $=".WMA"],
+.link-audio {
+	background: url("audio.png") center right no-repeat;
+	padding-right: 13px;
+}
+#bodyContent a.external[href $=".ogm"], #bodyContent a.external[href $=".OGM"],
+#bodyContent a.external[href $=".avi"], #bodyContent a.external[href $=".AVI"],
+#bodyContent a.external[href $=".mpeg"], #bodyContent a.external[href $=".MPEG"],
+#bodyContent a.external[href $=".mpg"], #bodyContent a.external[href $=".MPG"],
+.link-video {
+	background: url("video.png") center right no-repeat;
+	padding-right: 13px;
+}
+#bodyContent a.external[href $=".pdf"], #bodyContent a.external[href $=".PDF"],
+#bodyContent a.external[href *=".pdf#"], #bodyContent a.external[href *=".PDF#"],
+#bodyContent a.external[href *=".pdf?"], #bodyContent a.external[href *=".PDF?"],
+.link-document {
+	background: url("document.png") center right no-repeat;
+	padding-right: 12px;
+}
+
+/* disable interwiki styling */
+#bodyContent a.extiw,
+#bodyContent a.extiw:active {
+	color: #36b;
+	background: none;
+	padding: 0;
+}
+#bodyContent a.external {
+	color: #36b;
+}
+/* this can be used in the content area to switch off
+special external link styling */
+#bodyContent .plainlinks a {
+	background: none !important;
+	padding: 0 !important;
+}
+/*
+** Structural Elements
+*/
+
+/*
+** general portlet styles (elements in the quickbar)
+*/
+.portlet {
+	border: none;
+	margin: 0 0 .5em;
+	padding: 0;
+	float: none;
+	width: 11.6em;
+	overflow: hidden;
+}
+.portlet h4 {
+	font-size: 95%;
+	font-weight: normal;
+	white-space: nowrap;
+}
+.portlet h5 {
+	background: transparent;
+	padding: 0 1em 0 .5em;
+	display: inline;
+	height: 1em;
+	text-transform: lowercase;
+	font-size: 91%;
+	font-weight: normal;
+	white-space: nowrap;
+}
+.portlet h6 {
+	background: #ffae2e;
+	border: 1px solid #2f6fab;
+	border-style: solid solid none solid;
+	padding: 0 1em 0 1em;
+	text-transform: lowercase;
+	display: block;
+	font-size: 1em;
+	height: 1.2em;
+	font-weight: normal;
+	white-space: nowrap;
+}
+.pBody {
+	font-size: 95%;
+	background-color: white;
+	color: black;
+	border-collapse: collapse;
+	border: 1px solid #aaa;
+	padding: 0 .8em .3em .5em;
+}
+.portlet h1,
+.portlet h2,
+.portlet h3,
+.portlet h4 {
+	margin: 0;
+	padding: 0;
+}
+.portlet ul {
+	line-height: 1.5em;
+	list-style-type: square;
+	list-style-image: url(bullet.gif);
+	font-size: 95%;
+}
+.portlet li {
+	padding: 0;
+	margin: 0;
+}
+
+/*
+** Logo properties
+*/
+
+@media handheld {
+	#p-logo { display: none }
+}
+
+/*
+** the navigation portlet
+*/
+
+#p-navigation .pBody {
+	padding-right: 0;
+}
+
+#p-navigation li.active a, #p-navigation li.active a:hover {
+	text-decoration: none;
+	font-weight: bold;
+}
+
+
+/*
+** Search portlet
+*/
+input.searchButton {
+	margin-top: 1px;
+	font-size: 95%;
+}
+#searchGoButton {
+	padding-left: .5em;
+	padding-right: .5em;
+	font-weight: bold;
+}
+#searchInput {
+	width: 10.9em;
+	margin: 0;
+	font-size: 95%;
+}
+#p-search .pBody {
+	padding: .5em .4em .4em .4em;
+	text-align: center;
+}
+
+/*
+** the personal toolbar
+*/
+#p-personal ul {
+	text-transform: lowercase;
+}
+#p-personal li.active {
+	font-weight: bold;
+}
+/*
+** the page-related actions- page/talk, edit etc
+*/
+#p-cactions .hiddenStructure {
+	display: none;
+}
+#p-cactions li a {
+	text-transform: lowercase;
+}
+
+/* TODO: #t-iscite is only used by the Cite extension, come up with some
+ * system which allows extensions to add to this file on the fly
+ */
+#t-ispermalink, #t-iscite {
+	color: #999;
+}
+/*
+** footer
+*/
+#footer {
+	background-color: white;
+	border-top: 1px solid #fabd23;
+	border-bottom: 1px solid #fabd23;
+	margin: .6em 0 1em 0;
+	padding: .4em 0 1.2em 0;
+	text-align: center;
+	font-size: 90%;
+}
+#footer li {
+	display: inline;
+	margin: 0 1.3em;
+}
+/* hide from incapable browsers */
+head:first-child+body #footer li { white-space: nowrap; }
+#f-poweredbyico, #f-copyrightico {
+	margin: 0 8px;
+	position: relative;
+	top: -2px; /* Bump it up just a tad */
+}
+#f-poweredbyico {
+	float: right;
+	height: 1%;
+}
+#f-copyrightico {
+	float: left;
+	height: 1%;
+}
+
+/* js pref toc */
+#preftoc {
+	margin: 0;
+	padding: 0;
+	width: 100%;
+	clear: both;
+}
+#preftoc li {
+	background-color: #f0f0f0;
+	color: #000;
+}
+#preftoc li.selected {
+	font-weight: bold;
+	background-color: #f9f9f9;
+	border: 1px solid #aaa;
+	border-bottom: none;
+	cursor: default;
+	top: 1px;
+	padding-top: 2px;
+	margin-right: -3px;
+}
+#preftoc > li.selected {
+	top: 2px;
+}
+#preftoc a,
+#preftoc a:active {
+	display: block;
+	color: #000;
+	padding: 0 .7em;
+	position: relative;
+	text-decoration: none;
+}
+#preftoc li.selected a {
+	cursor: default;
+	text-decoration: none;
+}
+#prefcontrol {
+	padding-top: 2em;
+	clear: both;
+}
+#preferences {
+	margin: 0;
+	border: 1px solid #aaa;
+	clear: both;
+	padding: 1.5em;
+	background-color: #F9F9F9;
+}
+.prefsection {
+	border: none;
+	padding: 0;
+	margin: 0;
+}
+.prefsection fieldset {
+	border: 1px solid #aaa;
+	float: left;
+	margin-right: 2em;
+}
+.prefsection legend {
+	font-weight: bold;   
+}
+.prefsection table, .prefsection legend {
+	background-color: #F9F9F9;
+}
+div.prefsectiontip {
+	font-size: 95%;
+	margin-top: 0;
+	background-color: #FFC1C1;
+	padding: .2em .7em;
+	clear: both;
+}
+.btnSavePrefs {
+	font-weight: bold;
+	padding-left: .3em;
+	padding-right: .3em;
+}
+
+.preferences-login {
+	clear: both;
+	margin-bottom: 1.5em;
+}
+
+.prefcache {
+	font-size: 90%;
+	margin-top: 2em;
+}
+
+div#userloginForm form,
+div#userlogin form#userlogin2 {
+	margin: 0 3em 1em 0;
+	border: 1px solid #aaa;
+	clear: both;
+	padding: 1.5em 2em;
+	background-color: #f9f9f9;
+	float: left;
+}
+
+div#userloginForm table,
+div#userlogin form#userlogin2 table {
+	background-color: #f9f9f9;
+}
+
+div#userloginForm h2,
+div#userlogin form#userlogin2 h2 {
+	padding-top: 0;
+}
+
+div#userlogin .captcha {
+	border: 1px solid #bbb;
+	padding: 1.5em 2em;
+	width: 400px;
+	background-color: white;
+}
+
+
+#userloginprompt, #languagelinks {
+	font-size: 85%;
+}
+
+#login-sectiontip {
+	font-size: 85%;
+	line-height: 1.2;
+	padding-top: 2em;
+}
+
+#userlogin .loginText, #userlogin .loginPassword {
+	width: 12em;
+}
+
+#userloginlink a, #wpLoginattempt, #wpCreateaccount {
+	font-weight: bold;
+}
+
+/* more IE fixes */
+/* float/negative margin brokenness */
+* html #footer {margin-top: 0;}
+* html #column-content {
+	display: inline;
+	margin-bottom: 0;
+}
+* html div.editsection { font-size: smaller; }
+#pagehistory li.selected { position: relative; }
+
+/* Mac IE 5.0 fix; floated content turns invisible */
+* > html #column-content {
+	float: none;
+}
+* > html #column-one {
+	position: absolute;
+	left: 0;
+	top: 0;
+}
+* > html #footer {
+	margin-left: 13.2em;
+}
+.redirectText {
+	font-size: 150%;
+	margin: 5px;
+}
+
+.printfooter {
+	display: none;
+}
+
+.not-patrolled {
+	background-color: #ffa;
+}
+div.patrollink {
+	font-size: 75%;
+	text-align: right;
+}
+span.newpage, span.minor, span.searchmatch, span.bot {
+	font-weight: bold;
+}
+span.unpatrolled {
+	font-weight: bold;
+	color: red;
+}
+
+span.searchmatch {
+	color: red;
+}
+.sharedUploadNotice {
+	font-style: italic;
+}
+
+span.updatedmarker {
+	color: black;
+	background-color: #0f0;
+}
+span.newpageletter {
+	font-weight: bold;
+	color: black;
+	background-color: yellow;
+}
+span.minoreditletter {
+	color: black;
+	background-color: #c5ffe6;
+}
+
+table.gallery {
+	border: 1px solid #ccc;
+	margin: 2px;
+	padding: 2px;
+	background-color: white;
+}
+
+table.gallery tr {
+	vertical-align: top;
+}
+
+table.gallery td {
+	vertical-align: top;
+	background-color: #f9f9f9;
+	border: solid 2px white;
+}
+
+table.gallery td.galleryheader {
+	text-align: center;
+	font-weight: bold;
+}
+
+div.gallerybox {
+	margin: 2px;
+	width:  150px;
+}
+
+div.gallerybox div.thumb {
+	text-align: center;
+	border: 1px solid #ccc;
+	margin: 2px;
+}
+
+div.gallerytext {
+	font-size: 94%;
+	padding: 2px 4px;
+}
+
+span.comment {
+	font-style: italic;
+}
+
+span.changedby {
+	font-size: 95%;
+}
+
+.previewnote {
+	text-indent: 3em;
+	color: #c00;
+	border-bottom: 1px solid #aaa;
+	padding-bottom: 1em;
+	margin-bottom: 1em;
+}
+
+.previewnote p {
+	margin: 0;
+	padding: 0;
+}
+
+.editExternally {
+	border: 1px solid gray;
+	background-color: #ffffff;
+	padding: 3px;
+	margin-top: 0.5em;
+	float: left;
+	font-size: small;
+	text-align: center;
+}
+.editExternallyHelp {
+	font-style: italic;
+	color: gray;
+}
+
+li span.deleted, span.history-deleted {
+	text-decoration: line-through;
+	color: #888;
+	font-style: italic;
+}
+
+.toggle {
+	margin-left: 2em;
+	text-indent: -2em;
+}
+
+/* Classes for EXIF data display */
+table.mw_metadata {
+	font-size: 0.8em;
+	margin-left: 0.5em;
+	margin-bottom: 0.5em;
+	width: 300px;
+}
+
+table.mw_metadata caption {
+	font-weight: bold;
+}
+
+table.mw_metadata th {
+	font-weight: normal;
+}
+
+table.mw_metadata td {
+	padding: 0.1em;
+}
+
+table.mw_metadata {
+	border: none;
+	border-collapse: collapse;
+}
+
+table.mw_metadata td, table.mw_metadata th {
+	text-align: center;
+	border: 1px solid #aaaaaa;
+	padding-left: 0.1em;
+	padding-right: 0.1em;
+}
+
+table.mw_metadata th {
+	background-color: #f9f9f9;
+}
+
+table.mw_metadata td {
+	background-color: #fcfcfc;
+}
+
+table.collapsed tr.collapsable {
+	display: none;
+}
+
+
+/* filetoc */
+ul#filetoc {
+	text-align: center;
+	border: 1px solid #aaaaaa;
+	background-color: #f9f9f9;
+	padding: 5px;
+	font-size: 95%;
+	margin-bottom: 0.5em;
+	margin-left: 0;
+	margin-right: 0;
+}
+
+#filetoc li {
+	display: inline;
+	list-style-type: none;
+	padding-right: 2em;
+}
+
+input#wpSummary {
+	width: 80%;
+}
+
+/* @bug 1714 */
+input#wpSave, input#wpDiff {
+	margin-right: 0.33em;
+}
+
+#editform .editOptions {
+	display: inline;
+}
+
+#wpSave {
+	font-weight: bold;
+}
+
+/* Classes for article validation */
+
+table.revisionform_default {
+	border: 1px solid #000000;
+}
+
+table.revisionform_focus {
+	border: 1px solid #000000;
+	background-color:#00BBFF;
+}
+
+tr.revision_tr_default {
+	background-color:#EEEEEE;
+}
+
+tr.revision_tr_first {
+	background-color:#DDDDDD;
+}
+
+p.revision_saved {
+	color: green;
+	font-weight:bold;
+}
+
+#mw_trackbacks {
+	border: solid 1px #bbbbff;
+	background-color: #eeeeff;
+	padding: 0.2em;
+}
+
+
+/* Allmessages table */
+
+#allmessagestable th {
+	background-color: #b2b2ff;
+}
+
+#allmessagestable tr.orig {
+	background-color: #ffe2e2;
+}
+
+#allmessagestable tr.new {
+	background-color: #e2ffe2;
+}
+
+#allmessagestable tr.def {
+	background-color: #f0f0ff;
+}
+
+
+/* noarticletext */
+div.noarticletext {
+	border: 1px solid #ccc;
+	background: #fff;
+	padding: .2em 1em;
+	color: #000;
+}
+
+div#searchTargetContainer {
+	left:       10px;
+	top:        10px;
+	width:      90%;
+	background: white;
+}
+
+div#searchTarget {
+	padding:    3px;
+	margin:     5px;
+	background: #F0F0F0;
+	border:     solid 1px blue;
+}
+
+div#searchTarget ul li {
+	list-style: none;
+}
+
+div#searchTarget ul li:before {
+	color: orange;
+	content: "\00BB \0020";
+}
+
+div.multipageimagenavbox {
+   border: solid 1px silver;
+   padding: 4px;
+   margin: 1em;
+   -moz-border-radius: 6px;
+   background: #f0f0f0;
+}
+
+div.multipageimagenavbox div.thumb {
+   border: none;
+   margin-left: 2em;
+   margin-right: 2em;
+}
+
+div.multipageimagenavbox hr {
+   margin: 6px;
+}
+
+table.multipageimage td {
+   text-align: center;
+}
+
+/** Special:Version */
+
+table#sv-ext, table#sv-hooks {
+	margin: 1em;
+	padding:0em;
+}
+
+#sv-ext td, #sv-hooks td,
+#sv-ext th, #sv-hooks th {
+	border: 1px solid #A0A0A0;
+	padding: 0 0.15em 0 0.15em;
+}
+#sv-ext th, #sv-hooks th {
+	background-color: #F0F0F0;
+	color: black;
+	padding: 0 0.15em 0 0.15em;
+}
+tr.sv-space{
+	height: 0.8em;
+	border:none;
+}
+tr.sv-space td { display: none; }
+
+/*
+  Table pager (e.g. Special:Imagelist)
+  - remove underlines from the navigation link
+  - collapse borders
+  - set the borders to outsets (similar to Special:Allmessages)
+  - remove line wrapping for all td and th, set background color
+  - restore line wrapping for the last two table cells (description and size)
+*/
+.TablePager_nav a { text-decoration: none; }
+.TablePager { border-collapse: collapse; }
+.TablePager, .TablePager td, .TablePager th { 
+	border: 0.15em solid #777777;
+	padding: 0 0.15em 0 0.15em;
+}
+.TablePager th { background-color: #eeeeff }
+.TablePager td { background-color: #ffffff }
+.TablePager tr:hover td { background-color: #eeeeff }
+
+.imagelist td, .imagelist th { white-space: nowrap }
+.imagelist .TablePager_col_links { background-color: #eeeeff }
+.imagelist .TablePager_col_img_description { white-space: normal }
+.imagelist th.TablePager_sort { background-color: #ccccff }
+
+.templatesUsed { margin-top: 1.5em; }
+
+.mw-summary-preview {
+	margin: 0.1em 0;
+}
+#toolbar { clear: both; }
+
+.mw-plusminus-null { color: #aaa; }
+
+@media handheld {
+	.nonessential {
+		/* Kill big bulky stuff that will clog up the screen */
+		display: none;
+	}
+}
\ No newline at end of file
Index: trunk/wikipathways/skins/wikipathways/mail_icon.gif
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/wikipathways/skins/wikipathways/mail_icon.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: trunk/wikipathways/skins/wikipathways/document.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/wikipathways/skins/wikipathways/document.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: trunk/wikipathways/skins/wikipathways/magnify-clip.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/wikipathways/skins/wikipathways/magnify-clip.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: trunk/wikipathways/skins/wikipathways/IEMacFixes.css
===================================================================
--- trunk/wikipathways/skins/wikipathways/IEMacFixes.css	(revision 0)
+++ trunk/wikipathways/skins/wikipathways/IEMacFixes.css	(revision 1110)
@@ -0,0 +1,44 @@
+/* IE/Mac only fix stylesheet, imported from main.css */
+#portal-column-content {
+	margin: 0 0 4.8em 0;
+	float: none;
+}
+#portal-column-content #content {
+	z-index: 0;
+}
+#portal-column-one {
+	position: absolute;
+	top: 0;
+	left: 0;
+	z-index: 3;
+}
+#portal-footer {
+	margin-left: 12em; 
+}
+/*
+#portlet-contentViews {
+	top: 0.6em !important;
+	left: 14.5em !important;
+}
+*/
+#portlet-contentViews li,
+#portlet-contentViews .selected {
+	border: none !important;
+}
+#portlet-contentViews li a   {
+	border: 1px solid #aaaaaa;
+	border-bottom: none;
+}
+#portlet-contentViews li.selected a {
+	border: 1px solid #fabd23;
+	border-bottom: none;
+}
+/* no background images */
+li#personaltools-userpage,
+li#personaltools-login/* */ {
+	background: none;
+	padding-left: none;
+}
+#mactest {
+	color: green;
+}
Index: trunk/wikipathways/skins/wikipathways/lock_icon.gif
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/wikipathways/skins/wikipathways/lock_icon.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: trunk/wikipathways/skins/wikipathways/wiki-indexed.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/wikipathways/skins/wikipathways/wiki-indexed.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: trunk/wikipathways/skins/wikipathways/external.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/wikipathways/skins/wikipathways/external.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: trunk/wikipathways/skins/wikipathways/KHTMLFixes.css
===================================================================
--- trunk/wikipathways/skins/wikipathways/KHTMLFixes.css	(revision 0)
+++ trunk/wikipathways/skins/wikipathways/KHTMLFixes.css	(revision 1110)
@@ -0,0 +1,3 @@
+/* KHTML fix stylesheet */
+/* work around the horizontal scrollbars */
+#column-content { margin-left: 0; }
Index: trunk/wikipathways/skins/wikipathways/news_icon.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/wikipathways/skins/wikipathways/news_icon.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: trunk/wikipathways/skins/wikipathways/link_icon.gif
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/wikipathways/skins/wikipathways/link_icon.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: trunk/wikipathways/skins/wikipathways/main.css
===================================================================
--- trunk/wikipathways/skins/wikipathways/main.css	(revision 0)
+++ trunk/wikipathways/skins/wikipathways/main.css	(revision 1110)
@@ -0,0 +1,1617 @@
+/*
+** MediaWiki 'monobook' style sheet for CSS2-capable browsers.
+** Copyright Gabriel Wicke - http://wikidev.net/
+** License: GPL (http://www.gnu.org/copyleft/gpl.html)
+**
+** Loosely based on http://www.positioniseverything.net/ordered-floats.html by Big John
+** and the Plone 2.0 styles, see http://plone.org/ (Alexander Limi,Joe Geldart & Tom Croucher,
+** Michael Zeltner and Geir Bækholt)
+** All you guys rock :)
+*/
+
+/**
+ * Stylesheet for screen/projection.  All rules not marked media-specific are
+ * shared with handheld.css and should be updated in tandem.  The rules can't
+ * be in the same file because old browsers like IE5 won't obey @media rules.
+ *
+ * Rules that are screen/projection-specific are marked with commented-out
+ * @media rules and indentation.
+ */
+
+/* @media screen, projection { */
+	#column-content {
+		width: 100%;
+		float: right;
+		margin: 0 0 .6em -12.3em;
+		padding: 0;
+	}
+	#content {
+		margin: 2.8em 0 0 12.3em;
+		padding: 0 1em 1.5em 1em;
+		position: relative;
+		z-index: 2;
+	}
+	#column-one {
+		padding-top: 160px;
+	}
+/* } */
+#content {
+	background: white;
+	color: black;
+	border: 1px solid #aaa;
+	border-right: none;
+	line-height: 1.5em;
+}
+/* the left column width is specified in class .portlet */
+
+/* Font size:
+** We take advantage of keyword scaling- browsers won't go below 9px
+** More at http://www.w3.org/2003/07/30-font-size
+** http://style.cleverchimp.com/font_size_intervals/altintervals.html
+*/
+
+body {
+	font: x-small sans-serif;
+	background: #f9f9f9 url(headbg_blue.jpg) 0 0 no-repeat;
+	color: black;
+	margin: 0;
+	padding: 0;
+}
+
+/* scale back up to a sane default */
+#globalWrapper {
+	font-size: 127%;
+	width: 100%;
+	margin: 0;
+	padding: 0;
+}
+.visualClear {
+	clear: both;
+}
+
+/* general styles */
+
+table {
+	font-size: 100%;
+	color: black;
+	/* we don't want the bottom borders of <h2>s to be visible through
+	   floated tables */
+	background-color: white;
+}
+a {
+	text-decoration: none;
+	color: #002bb8;
+	background: none;
+}
+a:visited {
+	color: #5a3696;
+}
+a:active {
+	color: #faa700;
+}
+a:hover {
+	text-decoration: underline;
+}
+a.stub {
+	color: #772233;
+}
+a.new, #p-personal a.new {
+	color: #ba0000;
+}
+a.new:visited, #p-personal a.new:visited {
+	color: #a55858;
+}
+
+img {
+	border: none;
+	vertical-align: middle;
+}
+/* @media screen, projection { */
+	p {
+		margin: .4em 0 .5em 0;
+		line-height: 1.5em;
+	}
+/* } */
+p img {
+	margin: 0;
+}
+
+hr {
+	height: 1px;
+	color: #aaa;
+	background-color: #aaa;
+	border: 0;
+	margin: .2em 0 .2em 0;
+}
+
+h1, h2, h3, h4, h5, h6 {
+	color: black;
+	background: none;
+	font-weight: normal;
+	margin: 0;
+	padding-top: .5em;
+	padding-bottom: .17em;
+	border-bottom: 1px solid #aaa;
+}
+h1 { font-size: 188%; }
+h1 .editsection { font-size: 53%; }
+h2 { font-size: 150%; }
+h2 .editsection { font-size: 67%; }
+h3, h4, h5, h6 {
+	border-bottom: none;
+	font-weight: bold;
+}
+h3 { font-size: 132%; }
+h3 .editsection { font-size: 76%; font-weight: normal; }
+h4 { font-size: 116%; }
+h4 .editsection { font-size: 86%; font-weight: normal; }
+h5 { font-size: 100%; }
+h5 .editsection { font-weight: normal; }
+h6 { font-size: 80%;  }
+h6 .editsection { font-size: 125%; font-weight: normal; }
+
+.editsection {
+	float: right;
+	margin-left: 5px;
+}
+
+ul {
+	line-height: 1.5em;
+	list-style-type: square;
+	margin: .3em 0 0 1.5em;
+	padding: 0;
+	list-style-image: url(bullet.gif);
+}
+ol {
+	line-height: 1.5em;
+	margin: .3em 0 0 3.2em;
+	padding: 0;
+	list-style-image: none;
+}
+li {
+	margin-bottom: .1em;
+}
+dt {
+	font-weight: bold;
+	margin-bottom: .1em;
+}
+dl {
+	margin-top: .2em;
+	margin-bottom: .5em;
+}
+dd {
+	line-height: 1.5em;
+	margin-left: 2em;
+	margin-bottom: .1em;
+}
+
+fieldset {
+	border: 1px solid #2f6fab;
+	margin: 1em 0 1em 0;
+	padding: 0 1em 1em;
+	line-height: 1.5em;
+}
+legend {
+	padding: .5em;
+	font-size: 95%;
+}
+form {
+	border: none;
+	margin: 0;
+}
+
+textarea {
+	width: 100%;
+	padding: .1em;
+}
+
+input.historysubmit {
+	padding: 0 .3em .3em .3em !important;
+	font-size: 94%;
+	cursor: pointer;
+	height: 1.7em !important;
+	margin-left: 1.6em;
+}
+select {
+	vertical-align: top;
+}
+abbr, acronym, .explain {
+	border-bottom: 1px dotted black;
+	color: black;
+	background: none;
+	cursor: help;
+}
+q {
+	font-family: Times, "Times New Roman", serif;
+	font-style: italic;
+}
+/* disabled for now
+blockquote {
+	font-family: Times, "Times New Roman", serif;
+	font-style: italic;
+}*/
+code {
+	background-color: #f9f9f9;
+}
+pre {
+	padding: 1em;
+	border: 1px dashed #2f6fab;
+	color: black;
+	background-color: #f9f9f9;
+	line-height: 1.1em;
+}
+
+/*
+** the main content area
+*/
+
+/* @media screen, projection { */
+	#siteSub {
+		display: none;
+	}
+	#jump-to-nav {
+		display: none;
+	}
+/* } */
+
+#contentSub, #contentSub2 {
+	font-size: 84%;
+	line-height: 1.2em;
+	margin: 0 0 1.4em 1em;
+	color: #7d7d7d;
+	width: auto;
+}
+span.subpages {
+	display: block;
+}
+
+/* Some space under the headers in the content area */
+#bodyContent h1, #bodyContent h2 {
+	margin-bottom: .6em;
+}
+#bodyContent h3, #bodyContent h4, #bodyContent h5 {
+	margin-bottom: .3em;
+}
+.firstHeading {
+	margin-bottom: .1em;
+}
+
+/* user notification thing */
+.usermessage {
+	background-color: #ffce7b;
+	border: 1px solid #ffa500;
+	color: black;
+	font-weight: bold;
+	margin: 2em 0 1em;
+	padding: .5em 1em;
+	vertical-align: middle;
+}
+#siteNotice {
+	text-align: center;
+	font-size: 95%;
+	padding: 0 .9em;
+}
+#siteNotice p {
+	margin: 0;
+	padding: 0;
+}
+.error {
+	color: red;
+	font-size: larger;
+}
+.errorbox, .successbox {
+	font-size: larger;
+	border: 2px solid;
+	padding: .5em 1em;
+	float: left;
+	margin-bottom: 2em;
+	color: #000;
+}
+.errorbox {
+	border-color: red;
+	background-color: #fff2f2;
+}
+.successbox {
+	border-color: green;
+	background-color: #dfd;
+}
+.errorbox h2, .successbox h2 {
+	font-size: 1em;
+	font-weight: bold;
+	display: inline;
+	margin: 0 .5em 0 0;
+	border: none;
+}
+
+#catlinks {
+	border: 1px solid #aaa;
+	background-color: #f9f9f9;
+	padding: 5px;
+	margin-top: 1em;
+	clear: both;
+}
+/* currently unused, intended to be used by a metadata box
+in the bottom-right corner of the content area */
+.documentDescription {
+	/* The summary text describing the document */
+	font-weight: bold;
+	display: block;
+	margin: 1em 0;
+	line-height: 1.5em;
+}
+.documentByLine {
+	text-align: right;
+	font-size: 90%;
+	clear: both;
+	font-weight: normal;
+	color: #76797c;
+}
+
+/* emulate center */
+.center {
+	width: 100%;
+	text-align: center;
+}
+*.center * {
+	margin-left: auto;
+	margin-right: auto;
+}
+/* small for tables and similar */
+.small, .small * {
+	font-size: 94%;
+}
+table.small {
+	font-size: 100%;
+}
+
+/*
+** content styles
+*/
+
+#toc,
+.toc,
+.mw-warning {
+	border: 1px solid #aaa;
+	background-color: #f9f9f9;
+	padding: 5px;
+	font-size: 95%;
+}
+#toc h2,
+.toc h2 {
+	display: inline;
+	border: none;
+	padding: 0;
+	font-size: 100%;
+	font-weight: bold;
+}
+#toc #toctitle,
+.toc #toctitle,
+#toc .toctitle,
+.toc .toctitle {
+	text-align: center;
+}
+#toc ul,
+.toc ul {
+	list-style-type: none;
+	list-style-image: none;
+	margin-left: 0;
+	padding-left: 0;
+	text-align: left;
+}
+#toc ul ul,
+.toc ul ul {
+	margin: 0 0 0 2em;
+}
+#toc .toctoggle,
+.toc .toctoggle {
+	font-size: 94%;
+}
+
+.mw-warning {
+	margin-left: 50px;
+	margin-right: 50px;
+	text-align: center;
+}
+
+/* images */
+div.floatright, table.floatright {
+	clear: right;
+	float: right;
+	position: relative;
+	margin: 0 0 .5em .5em;
+	border: 0;
+/*
+	border: .5em solid white;
+	border-width: .5em 0 .8em 1.4em;
+*/
+}
+div.floatright p { font-style: italic; }
+div.floatleft, table.floatleft {
+	float: left;
+	clear: left;
+	position: relative;
+	margin: 0 .5em .5em 0;
+	border: 0;
+/*
+	margin: .3em .5em .5em 0;
+	border: .5em solid white;
+	border-width: .5em 1.4em .8em 0;
+*/
+}
+div.floatleft p { font-style: italic; }
+/* thumbnails */
+div.thumb {
+	margin-bottom: .5em;
+	border-style: solid;
+	border-color: white;
+	width: auto;
+}
+div.thumbinner {
+	border: 1px solid #ccc;
+	padding: 3px !important;
+	background-color: #f9f9f9;
+	font-size: 94%;
+	text-align: center;
+	overflow: hidden;
+}
+html .thumbimage {
+	border: 1px solid #ccc;
+}
+html .thumbcaption {
+	border: none;
+	text-align: left;
+	line-height: 1.4em;
+	padding: 3px !important;
+	font-size: 94%;
+}
+div.magnify {
+	float: right;
+	border: none !important;
+	background: none !important;
+}
+div.magnify a, div.magnify img {
+	display: block;
+	border: none !important;
+	background: none !important;
+}
+div.tright {
+	clear: right;
+	float: right;
+	border-width: .5em 0 .8em 1.4em;
+}
+div.tleft {
+	float: left;
+	clear: left;
+	margin-right: .5em;
+	border-width: .5em 1.4em .8em 0;
+}
+
+.hiddenStructure {
+	display: none;
+	speak: none;
+}
+img.tex {
+	vertical-align: middle;
+}
+span.texhtml {
+	font-family: serif;
+}
+
+/*
+** classes for special content elements like town boxes
+** intended to be referenced directly from the wiki src
+*/
+
+/*
+** User styles
+*/
+/* table standards */
+table.rimage {
+	float: right;
+	position: relative;
+	margin-left: 1em;
+	margin-bottom: 1em;
+	text-align: center;
+}
+.toccolours {
+	border: 1px solid #aaa;
+	background-color: #f9f9f9;
+	padding: 5px;
+	font-size: 95%;
+}
+div.townBox {
+	position: relative;
+	float: right;
+	background: white;
+	margin-left: 1em;
+	border: 1px solid gray;
+	padding: .3em;
+	width: 200px;
+	overflow: hidden;
+	clear: right;
+}
+div.townBox dl {
+	padding: 0;
+	margin: 0 0 .3em;
+	font-size: 96%;
+}
+div.townBox dl dt {
+	background: none;
+	margin: .4em 0 0;
+}
+div.townBox dl dd {
+	margin: .1em 0 0 1.1em;
+	background-color: #f3f3f3;
+}
+
+/*
+** edit views etc
+*/
+.special li {
+	line-height: 1.4em;
+	margin: 0;
+	padding: 0;
+}
+
+/* Page history styling */
+/* the auto-generated edit comments */
+.autocomment {
+	color: gray;
+}
+#pagehistory span.user {
+	margin-left: 1.4em;
+	margin-right: .4em;
+}
+#pagehistory span.minor {
+	font-weight: bold;
+}
+#pagehistory li {
+	border: 1px solid white;
+}
+#pagehistory li.selected {
+	background-color: #f9f9f9;
+	border: 1px dashed #aaa;
+}
+
+/*
+** Diff rendering
+*/
+table.diff, td.diff-otitle, td.diff-ntitle {
+	background-color: white;
+}
+td.diff-addedline {
+	background: #cfc;
+	font-size: smaller;
+}
+td.diff-deletedline {
+	background: #ffa;
+	font-size: smaller;
+}
+td.diff-context {
+	background: #eee;
+	font-size: smaller;
+}
+span.diffchange {
+	color: red;
+	font-weight: bold;
+}
+
+/*
+** keep the whitespace in front of the ^=, hides rule from konqueror
+** this is css3, the validator doesn't like it when validating as css2
+*/
+#bodyContent a.external,
+#bodyContent a[href ^="gopher://"] {
+	background: url(external.png) center right no-repeat;
+	padding-right: 13px;
+}
+#bodyContent a[href ^="https://"],
+.link-https {
+	background: url(lock_icon.gif) center right no-repeat;
+	padding-right: 16px;
+}
+#bodyContent a[href ^="mailto:"],
+.link-mailto {
+	background: url(mail_icon.gif) center right no-repeat;
+	padding-right: 18px;
+}
+#bodyContent a[href ^="news://"] {
+	background: url(news_icon.png) center right no-repeat;
+	padding-right: 18px;
+}
+#bodyContent a[href ^="ftp://"],
+.link-ftp {
+	background: url(file_icon.gif) center right no-repeat;
+	padding-right: 18px;
+}
+#bodyContent a[href ^="irc://"],
+.link-irc {
+	background: url(discussionitem_icon.gif) center right no-repeat;
+	padding-right: 18px;
+}
+#bodyContent a.external[href $=".ogg"], #bodyContent a.external[href $=".OGG"],
+#bodyContent a.external[href $=".mid"], #bodyContent a.external[href $=".MID"],
+#bodyContent a.external[href $=".midi"], #bodyContent a.external[href $=".MIDI"],
+#bodyContent a.external[href $=".mp3"], #bodyContent a.external[href $=".MP3"],
+#bodyContent a.external[href $=".wav"], #bodyContent a.external[href $=".WAV"],
+#bodyContent a.external[href $=".wma"], #bodyContent a.external[href $=".WMA"],
+.link-audio {
+	background: url("audio.png") center right no-repeat;
+	padding-right: 13px;
+}
+#bodyContent a.external[href $=".ogm"], #bodyContent a.external[href $=".OGM"],
+#bodyContent a.external[href $=".avi"], #bodyContent a.external[href $=".AVI"],
+#bodyContent a.external[href $=".mpeg"], #bodyContent a.external[href $=".MPEG"],
+#bodyContent a.external[href $=".mpg"], #bodyContent a.external[href $=".MPG"],
+.link-video {
+	background: url("video.png") center right no-repeat;
+	padding-right: 13px;
+}
+#bodyContent a.external[href $=".pdf"], #bodyContent a.external[href $=".PDF"],
+#bodyContent a.external[href *=".pdf#"], #bodyContent a.external[href *=".PDF#"],
+#bodyContent a.external[href *=".pdf?"], #bodyContent a.external[href *=".PDF?"],
+.link-document {
+	background: url("document.png") center right no-repeat;
+	padding-right: 12px;
+}
+
+/* disable interwiki styling */
+#bodyContent a.extiw,
+#bodyContent a.extiw:active {
+	color: #36b;
+	background: none;
+	padding: 0;
+}
+#bodyContent a.external {
+	color: #36b;
+}
+/* this can be used in the content area to switch off
+special external link styling */
+#bodyContent .plainlinks a {
+	background: none !important;
+	padding: 0 !important;
+}
+/*
+** Structural Elements
+*/
+
+/*
+** general portlet styles (elements in the quickbar)
+*/
+.portlet {
+	border: none;
+	margin: 0 0 .5em;
+	padding: 0;
+	float: none;
+	width: 11.7em;
+	overflow: hidden;
+}
+.portlet h4 {
+	font-size: 95%;
+	font-weight: normal;
+	white-space: nowrap;
+}
+.portlet h5 {
+	background: transparent;
+	padding: 0 1em 0 .5em;
+	display: inline;
+	height: 1em;
+	text-transform: lowercase;
+	font-size: 91%;
+	font-weight: normal;
+	white-space: nowrap;
+}
+.portlet h6 {
+	background: #ffae2e;
+	border: 1px solid #2f6fab;
+	border-style: solid solid none solid;
+	padding: 0 1em 0 1em;
+	text-transform: lowercase;
+	display: block;
+	font-size: 1em;
+	height: 1.2em;
+	font-weight: normal;
+	white-space: nowrap;
+}
+.pBody {
+	font-size: 95%;
+	background-color: white;
+	color: black;
+	border-collapse: collapse;
+	border: 1px solid #aaa;
+	padding: 0 .8em .3em .5em;
+}
+.portlet h1,
+.portlet h2,
+.portlet h3,
+.portlet h4 {
+	margin: 0;
+	padding: 0;
+}
+.portlet ul {
+	line-height: 1.5em;
+	list-style-type: square;
+	list-style-image: url(bullet.gif);
+	font-size: 95%;
+}
+.portlet li {
+	padding: 0;
+	margin: 0;
+}
+
+/*
+** Logo properties
+*/
+
+/* @media screen, projection { */
+	#p-logo {
+		top: 0;
+		left: 0;
+		position: absolute; /*needed to use z-index */
+		z-index: 3;
+		height: 155px;
+		width: 12em;
+		overflow: visible;
+	}
+	#p-logo h5 {
+		display: none;
+	}
+	#p-logo a,
+	#p-logo a:hover {
+		display: block;
+		height: 155px;
+		width: 12.2em;
+		background-repeat: no-repeat;
+		background-position: 35% 50% !important;
+		text-decoration: none;
+	}
+/* } */
+/*
+** the navigation portlet
+*/
+
+/* @media screen, projection { */
+	#p-navigation {
+		position: relative;
+		z-index: 3;
+	}
+	#p-navigation a {
+		display: block;
+	}
+	#p-navigation li.active a, #p-navigation li.active a:hover {
+		display: inline;
+	}
+/* } */
+
+#p-navigation .pBody {
+	padding-right: 0;
+}
+
+#p-navigation li.active a, #p-navigation li.active a:hover {
+	text-decoration: none;
+	font-weight: bold;
+}
+
+
+/*
+** Search portlet
+*/
+/* @media screen, projection { */
+	#p-search {
+		position: relative;
+		z-index: 3;
+	}
+/* } */
+input.searchButton {
+	margin-top: 1px;
+	font-size: 95%;
+}
+#searchGoButton {
+	padding-left: .5em;
+	padding-right: .5em;
+	font-weight: bold;
+}
+
+#searchInput {
+	width: 10.9em;
+	margin: 0;
+	font-size: 95%;
+}
+#p-search .pBody {
+	padding: .5em .4em .4em .4em;
+	text-align: center;
+}
+
+/*
+** the personal toolbar
+*/
+/* @media screen, projection { */
+	#p-personal {
+		position: absolute;
+		left: 0;
+		top: 0;
+		z-index: 0;
+	}
+	#p-personal {
+		width: 100%;
+		white-space: nowrap;
+		padding: 0;
+		margin: 0;
+		border: none;
+		background: none;
+		overflow: visible;
+		line-height: 1.2em;
+	}
+	#p-personal h5 {
+		display: none;
+	}
+	#p-personal .portlet,
+	#p-personal .pBody {
+		z-index: 0;
+		padding: 0;
+		margin: 0;
+		border: none;
+		overflow: visible;
+		background: none;
+	}
+/* this is the ul contained in the portlet */
+	#p-personal ul {
+		border: none;
+		line-height: 1.4em;
+		color: #2f6fab;
+		padding: 0 2em 0 3em;
+		margin: 0;
+		text-align: right;
+		list-style: none;
+		z-index: 0;
+		background: none;
+		cursor: default;
+	}
+	#p-personal li {
+		z-index: 0;
+		border: none;
+		padding: 0;
+		display: inline;
+		color: #2f6fab;
+		margin-left: 1em;
+		line-height: 1.2em;
+		background: none;
+	}
+	#p-personal li a {
+		text-decoration: none;
+		color: #005896;
+		padding-bottom: .2em;
+		background: none;
+	}
+	#p-personal li a:hover {
+		background-color: white;
+		padding-bottom: .2em;
+		text-decoration: none;
+	}
+	#p-personal li.active a:hover {
+		background-color: transparent;
+	}
+	/* the icon in front of the user name, single quotes
+	in bg url to hide it from iemac */
+	li#pt-userpage,
+	li#pt-anonuserpage,
+	li#pt-login {
+		background: url(user.gif) top left no-repeat;
+		padding-left: 20px;
+		text-transform: none;
+	}
+/* } */
+#p-personal ul {
+	text-transform: lowercase;
+}
+#p-personal li.active {
+	font-weight: bold;
+}
+/*
+** the page-related actions- page/talk, edit etc
+*/
+/* @media screen, projection { */
+	#p-cactions {
+		position: absolute;
+		top: 1.3em;
+		left: 11.5em;
+		margin: 0;
+		white-space: nowrap;
+		width: 76%;
+		line-height: 1.1em;
+		overflow: visible;
+		background: none;
+		border-collapse: collapse;
+		padding-left: 1em;
+		list-style: none;
+		font-size: 95%;
+	}
+	#p-cactions ul {
+		list-style: none;
+	}
+	#p-cactions li {
+		display: inline;
+		border: 1px solid #aaa;
+		border-bottom: none;
+		padding: 0 0 .1em 0;
+		margin: 0 .3em 0 0;
+		overflow: visible;
+		background: white;
+	}
+	#p-cactions li.selected {
+		border-color: #fabd23;
+		padding: 0 0 .2em 0;
+		font-weight: bold;
+	}
+	#p-cactions li a {
+		background-color: #fbfbfb;
+		color: #002bb8;
+		border: none;
+		padding: 0 .8em .3em;
+		position: relative;
+		z-index: 0;
+		margin: 0;
+		text-decoration: none;
+	}
+	#p-cactions li.selected a {
+		z-index: 3;
+		padding: 0 1em .2em!important;
+		background-color: white;
+	}
+	#p-cactions .new a {
+		color: #ba0000;
+	}
+	#p-cactions li a:hover {
+		z-index: 3;
+		text-decoration: none;
+		background-color: white;
+	}
+	#p-cactions h5 {
+		display: none;
+	}
+	#p-cactions li.istalk {
+		margin-right: 0;
+	}
+	#p-cactions li.istalk a {
+		padding-right: .5em;
+	}
+	#p-cactions #ca-addsection a {
+		padding-left: .4em;
+		padding-right: .4em;
+	}
+	/* offsets to distinguish the tab groups */
+	li#ca-talk {
+		margin-right: 1.6em;
+	}
+	li#ca-watch, li#ca-unwatch, li#ca-varlang-0, li#ca-print {
+		margin-left: 1.6em;
+	}
+	#p-cactions .pBody {
+		font-size: 1em;
+		background-color: transparent;
+		color: inherit;
+		border-collapse: inherit;
+		border: 0;
+		padding: 0;
+	}
+/* } */
+#p-cactions .hiddenStructure {
+	display: none;
+}
+#p-cactions li a {
+	text-transform: lowercase;
+}
+
+/*
+** the remaining portlets
+*/
+/* @media screen, projection { */
+	#p-tbx,
+	#p-lang {
+		position: relative;
+		z-index: 3;
+	}
+/* } */
+
+/* TODO: #t-iscite is only used by the Cite extension, come up with some
+ * system which allows extensions to add to this file on the fly
+ */
+#t-ispermalink, #t-iscite {
+	color: #999;
+}
+/*
+** footer
+*/
+#footer {
+	background-color: white;
+	border-top: 1px solid #fabd23;
+	border-bottom: 1px solid #fabd23;
+	margin: .6em 0 1em 0;
+	padding: .4em 0 1.2em 0;
+	text-align: center;
+	font-size: 90%;
+}
+#footer li {
+	display: inline;
+	margin: 0 1.3em;
+}
+/* hide from incapable browsers */
+head:first-child+body #footer li { white-space: nowrap; }
+#f-poweredbyico, #f-copyrightico {
+	margin: 0 8px;
+	position: relative;
+	top: -2px; /* Bump it up just a tad */
+}
+#f-poweredbyico {
+	float: right;
+	height: 1%;
+}
+#f-copyrightico {
+	float: left;
+	height: 1%;
+}
+
+/* js pref toc */
+#preftoc {
+	margin: 0;
+	padding: 0;
+	width: 100%;
+	clear: both;
+}
+#preftoc li {
+	background-color: #f0f0f0;
+	color: #000;
+}
+/* @media screen, projection { */
+	#preftoc li {
+		margin: 1px -2px 1px 2px;
+		float: left;
+		padding: 2px 0 3px 0;
+		border: 1px solid #fff;
+		border-right-color: #716f64;
+		border-bottom: 0;
+		position: relative;
+		white-space: nowrap;
+		list-style-type: none;
+		list-style-image: none;
+		z-index: 3;
+	}
+/* } */
+#preftoc li.selected {
+	font-weight: bold;
+	background-color: #f9f9f9;
+	border: 1px solid #aaa;
+	border-bottom: none;
+	cursor: default;
+	top: 1px;
+	padding-top: 2px;
+	margin-right: -3px;
+}
+#preftoc > li.selected {
+	top: 2px;
+}
+#preftoc a,
+#preftoc a:active {
+	display: block;
+	color: #000;
+	padding: 0 .7em;
+	position: relative;
+	text-decoration: none;
+}
+#preftoc li.selected a {
+	cursor: default;
+	text-decoration: none;
+}
+#prefcontrol {
+	padding-top: 2em;
+	clear: both;
+}
+#preferences {
+	margin: 0;
+	border: 1px solid #aaa;
+	clear: both;
+	padding: 1.5em;
+	background-color: #F9F9F9;
+}
+.prefsection {
+	border: none;
+	padding: 0;
+	margin: 0;
+}
+.prefsection fieldset {
+	border: 1px solid #aaa;
+	float: left;
+	margin-right: 2em;
+}
+.prefsection legend {
+	font-weight: bold;   
+}
+.prefsection table, .prefsection legend {
+	background-color: #F9F9F9;
+}
+/* @media screen, projection { */
+	.mainLegend {
+		display: none;
+	}
+/* } */
+div.prefsectiontip {
+	font-size: 95%;
+	margin-top: 0;
+	background-color: #FFC1C1;
+	padding: .2em .7em;
+	clear: both;
+}
+.btnSavePrefs {
+	font-weight: bold;
+	padding-left: .3em;
+	padding-right: .3em;
+}
+
+.preferences-login {
+	clear: both;
+	margin-bottom: 1.5em;
+}
+
+.prefcache {
+	font-size: 90%;
+	margin-top: 2em;
+}
+
+div#userloginForm form,
+div#userlogin form#userlogin2 {
+	margin: 0 3em 1em 0;
+	border: 1px solid #aaa;
+	clear: both;
+	padding: 1.5em 2em;
+	background-color: #f9f9f9;
+	float: left;
+}
+
+div#userloginForm table,
+div#userlogin form#userlogin2 table {
+	background-color: #f9f9f9;
+}
+
+div#userloginForm h2,
+div#userlogin form#userlogin2 h2 {
+	padding-top: 0;
+}
+
+div#userlogin .captcha {
+	border: 1px solid #bbb;
+	padding: 1.5em 2em;
+	width: 400px;
+	background-color: white;
+}
+
+
+#userloginprompt, #languagelinks {
+	font-size: 85%;
+}
+
+#login-sectiontip {
+	font-size: 85%;
+	line-height: 1.2;
+	padding-top: 2em;
+}
+
+#userlogin .loginText, #userlogin .loginPassword {
+	width: 12em;
+}
+
+#userloginlink a, #wpLoginattempt, #wpCreateaccount {
+	font-weight: bold;
+}
+
+/* @media screen, projection { */
+	/*
+	** IE/Mac fixes, hope to find a validating way to move this
+	** to a separate stylesheet. This would work but doesn't validate:
+	** @import("IEMacFixes.css");
+	*/
+	/* tabs: border on the a, not the div */
+	* > html #p-cactions li { border: none; }
+	* > html #p-cactions li a {
+		border: 1px solid #aaa;
+		border-bottom: none;
+	}
+	* > html #p-cactions li.selected a { border-color: #fabd23; }
+	/* footer icons need a fixed width */
+	* > html #f-poweredbyico,
+	* > html #f-copyrightico { width: 88px; }
+	* > html #bodyContent,
+	* > html #bodyContent pre {
+		overflow-x: auto;
+		width: 100%;
+		padding-bottom: 25px;
+	}
+/* } */
+
+/* more IE fixes */
+/* float/negative margin brokenness */
+* html #footer {margin-top: 0;}
+* html #column-content {
+	display: inline;
+	margin-bottom: 0;
+}
+* html div.editsection { font-size: smaller; }
+#pagehistory li.selected { position: relative; }
+
+/* Mac IE 5.0 fix; floated content turns invisible */
+* > html #column-content {
+	float: none;
+}
+* > html #column-one {
+	position: absolute;
+	left: 0;
+	top: 0;
+}
+* > html #footer {
+	margin-left: 13.2em;
+}
+.redirectText {
+	font-size: 150%;
+	margin: 5px;
+}
+
+.printfooter {
+	display: none;
+}
+
+.not-patrolled {
+	background-color: #ffa;
+}
+div.patrollink {
+	font-size: 75%;
+	text-align: right;
+}
+span.newpage, span.minor, span.searchmatch, span.bot {
+	font-weight: bold;
+}
+span.unpatrolled {
+	font-weight: bold;
+	color: red;
+}
+
+span.searchmatch {
+	color: red;
+}
+.sharedUploadNotice {
+	font-style: italic;
+}
+
+span.updatedmarker {
+	color: black;
+	background-color: #0f0;
+}
+span.newpageletter {
+	font-weight: bold;
+	color: black;
+	background-color: yellow;
+}
+span.minoreditletter {
+	color: black;
+	background-color: #c5ffe6;
+}
+
+table.gallery {
+	border: 1px solid #ccc;
+	margin: 2px;
+	padding: 2px;
+	background-color: white;
+}
+
+table.gallery tr {
+	vertical-align: top;
+}
+
+table.gallery td {
+	vertical-align: top;
+	background-color: #f9f9f9;
+	border: solid 2px white;
+}
+
+table.gallery td.galleryheader {
+	text-align: center;
+	font-weight: bold;
+}
+
+div.gallerybox {
+	margin: 2px;
+	width:  150px;
+}
+
+div.gallerybox div.thumb {
+	text-align: center;
+	border: 1px solid #ccc;
+	margin: 2px;
+}
+
+div.gallerytext {
+	font-size: 94%;
+	padding: 2px 4px;
+}
+
+span.comment {
+	font-style: italic;
+}
+
+span.changedby {
+	font-size: 95%;
+}
+
+.previewnote {
+	text-indent: 3em;
+	color: #c00;
+	border-bottom: 1px solid #aaa;
+	padding-bottom: 1em;
+	margin-bottom: 1em;
+}
+
+.previewnote p {
+	margin: 0;
+	padding: 0;
+}
+
+.editExternally {
+	border: 1px solid gray;
+	background-color: #ffffff;
+	padding: 3px;
+	margin-top: 0.5em;
+	float: left;
+	font-size: small;
+	text-align: center;
+}
+.editExternallyHelp {
+	font-style: italic;
+	color: gray;
+}
+
+li span.deleted, span.history-deleted {
+	text-decoration: line-through;
+	color: #888;
+	font-style: italic;
+}
+
+.toggle {
+	margin-left: 2em;
+	text-indent: -2em;
+}
+
+/* Classes for EXIF data display */
+table.mw_metadata {
+	font-size: 0.8em;
+	margin-left: 0.5em;
+	margin-bottom: 0.5em;
+	width: 300px;
+}
+
+table.mw_metadata caption {
+	font-weight: bold;
+}
+
+table.mw_metadata th {
+	font-weight: normal;
+}
+
+table.mw_metadata td {
+	padding: 0.1em;
+}
+
+table.mw_metadata {
+	border: none;
+	border-collapse: collapse;
+}
+
+table.mw_metadata td, table.mw_metadata th {
+	text-align: center;
+	border: 1px solid #aaaaaa;
+	padding-left: 0.1em;
+	padding-right: 0.1em;
+}
+
+table.mw_metadata th {
+	background-color: #f9f9f9;
+}
+
+table.mw_metadata td {
+	background-color: #fcfcfc;
+}
+
+table.collapsed tr.collapsable {
+	display: none;
+}
+
+
+/* filetoc */
+ul#filetoc {
+	text-align: center;
+	border: 1px solid #aaaaaa;
+	background-color: #f9f9f9;
+	padding: 5px;
+	font-size: 95%;
+	margin-bottom: 0.5em;
+	margin-left: 0;
+	margin-right: 0;
+}
+
+#filetoc li {
+	display: inline;
+	list-style-type: none;
+	padding-right: 2em;
+}
+
+input#wpSummary {
+	width: 80%;
+}
+
+/* @bug 1714 */
+input#wpSave, input#wpDiff {
+	margin-right: 0.33em;
+}
+
+#editform .editOptions {
+	display: inline;
+}
+
+#wpSave {
+	font-weight: bold;
+}
+
+/* Classes for article validation */
+
+table.revisionform_default {
+	border: 1px solid #000000;
+}
+
+table.revisionform_focus {
+	border: 1px solid #000000;
+	background-color:#00BBFF;
+}
+
+tr.revision_tr_default {
+	background-color:#EEEEEE;
+}
+
+tr.revision_tr_first {
+	background-color:#DDDDDD;
+}
+
+p.revision_saved {
+	color: green;
+	font-weight:bold;
+}
+
+#mw_trackbacks {
+	border: solid 1px #bbbbff;
+	background-color: #eeeeff;
+	padding: 0.2em;
+}
+
+
+/* Allmessages table */
+
+#allmessagestable th {
+	background-color: #b2b2ff;
+}
+
+#allmessagestable tr.orig {
+	background-color: #ffe2e2;
+}
+
+#allmessagestable tr.new {
+	background-color: #e2ffe2;
+}
+
+#allmessagestable tr.def {
+	background-color: #f0f0ff;
+}
+
+
+/* noarticletext */
+div.noarticletext {
+	border: 1px solid #ccc;
+	background: #fff;
+	padding: .2em 1em;
+	color: #000;
+}
+
+div#searchTargetContainer {
+	left:       10px;
+	top:        10px;
+	width:      90%;
+	background: white;
+}
+
+div#searchTarget {
+	padding:    3px;
+	margin:     5px;
+	background: #F0F0F0;
+	border:     solid 1px blue;
+}
+
+div#searchTarget ul li {
+	list-style: none;
+}
+
+div#searchTarget ul li:before {
+	color: orange;
+	content: "\00BB \0020";
+}
+
+div.multipageimagenavbox {
+   border: solid 1px silver;
+   padding: 4px;
+   margin: 1em;
+   -moz-border-radius: 6px;
+   background: #f0f0f0;
+}
+
+div.multipageimagenavbox div.thumb {
+   border: none;
+   margin-left: 2em;
+   margin-right: 2em;
+}
+
+div.multipageimagenavbox hr {
+   margin: 6px;
+}
+
+table.multipageimage td {
+   text-align: center;
+}
+
+/** Special:Version */
+
+table#sv-ext, table#sv-hooks {
+	margin: 1em;
+	padding:0em;
+}
+
+#sv-ext td, #sv-hooks td,
+#sv-ext th, #sv-hooks th {
+	border: 1px solid #A0A0A0;
+	padding: 0 0.15em 0 0.15em;
+}
+#sv-ext th, #sv-hooks th {
+	background-color: #F0F0F0;
+	color: black;
+	padding: 0 0.15em 0 0.15em;
+}
+tr.sv-space{
+	height: 0.8em;
+	border:none;
+}
+tr.sv-space td { display: none; }
+
+/*
+  Table pager (e.g. Special:Imagelist)
+  - remove underlines from the navigation link
+  - collapse borders
+  - set the borders to outsets (similar to Special:Allmessages)
+  - remove line wrapping for all td and th, set background color
+  - restore line wrapping for the last two table cells (description and size)
+*/
+.TablePager_nav a { text-decoration: none; }
+.TablePager { border-collapse: collapse; }
+.TablePager, .TablePager td, .TablePager th { 
+	border: 0.15em solid #777777;
+	padding: 0 0.15em 0 0.15em;
+}
+.TablePager th { background-color: #eeeeff }
+.TablePager td { background-color: #ffffff }
+.TablePager tr:hover td { background-color: #eeeeff }
+
+.imagelist td, .imagelist th { white-space: nowrap }
+.imagelist .TablePager_col_links { background-color: #eeeeff }
+.imagelist .TablePager_col_img_description { white-space: normal }
+.imagelist th.TablePager_sort { background-color: #ccccff }
+
+.templatesUsed { margin-top: 1.5em; }
+
+.mw-summary-preview {
+	margin: 0.1em 0;
+}
+#toolbar { clear: both; }
+
+.mw-plusminus-null { color: #aaa; }
Index: trunk/wikipathways/skins/wikipathways/discussionitem_icon.gif
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/wikipathways/skins/wikipathways/discussionitem_icon.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: trunk/wikipathways/skins/common/images/custom_button_edit_v1_mp.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/wikipathways/skins/common/images/custom_button_edit_v1_mp.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream
Name: svn:executable
   + *

Index: trunk/wikipathways/skins/common/images/custom_button_history_v1.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/wikipathways/skins/common/images/custom_button_history_v1.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream
Name: svn:executable
   + *

Index: trunk/wikipathways/skins/common/images/custom_button_edit_v1.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/wikipathways/skins/common/images/custom_button_edit_v1.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream
Name: svn:executable
   + *

Index: trunk/wikipathways/skins/common/images/resize.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/wikipathways/skins/common/images/resize.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: trunk/wikipathways/skins/common/images/custom_button_edit_v1_mo.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk/wikipathways/skins/common/images/custom_button_edit_v1_mo.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream
Name: svn:executable
   + *

Index: trunk/wikipathways/skins/WikiPathways.php
===================================================================
--- trunk/wikipathways/skins/WikiPathways.php	(revision 0)
+++ trunk/wikipathways/skins/WikiPathways.php	(revision 1110)
@@ -0,0 +1,334 @@
+<?php
+/**
+ * MonoBook nouveau
+ *
+ * Translated from gwicke's previous TAL template version to remove
+ * dependency on PHPTAL.
+ *
+ * @todo document
+ * @package MediaWiki
+ * @subpackage Skins
+ */
+
+if( !defined( 'MEDIAWIKI' ) )
+	die( -1 );
+
+/** */
+require_once('includes/SkinTemplate.php');
+
+/**
+ * Inherit main code from SkinTemplate, set the CSS and template filter.
+ * @todo document
+ * @package MediaWiki
+ * @subpackage Skins
+ */
+class SkinWikiPathways extends SkinTemplate {
+	/** Using monobook. */
+	function initPage( &$out ) {
+		SkinTemplate::initPage( $out );
+		$this->skinname  = 'wikipathways';
+		$this->stylename = 'wikipathways';
+		$this->template  = 'WikipathwaysTemplate';
+	}
+}
+
+/**
+ * @todo document
+ * @package MediaWiki
+ * @subpackage Skins
+ */
+class WikiPathwaysTemplate extends QuickTemplate {
+	/**
+	 * Template filter callback for MonoBook skin.
+	 * Takes an associative array of data set from a SkinTemplate-based
+	 * class, and a wrapper for MediaWiki's localization database, and
+	 * outputs a formatted page.
+	 *
+	 * @access private
+	 */
+	function execute() {
+		global $wgTitle, $wgUser;
+		// Suppress warnings to prevent notices about missing indexes in $this->data
+		wfSuppressWarnings();
+
+/** AP20070421
+ *		//Remove edit tab for pathways
+ *		if($wgTitle->getNameSpace() == 100) {
+ *			$actions = $this->data['content_actions'];
+ *			unset($actions['edit']);
+ *			$this->data['content_actions'] = $actions;
+ *		}
+ */
+              //Remove edit tab on all pages except User(2), User_talk(3), and Pathway_talk(101)
+//AP20070423 Don't remove edit buttons for sysops (sysops can protect)
+		$ns = $wgTitle->getNameSpace();
+		if(!array_search('sysop', $wgUser->getGroups())) {
+			if($ns != NS_USER && $ns != NS_USER_TALK &&  $ns != NS_PATHWAY_TALK) {
+	                        $actions = $this->data['content_actions'];
+	                        unset($actions['edit']);
+	                        $this->data['content_actions'] = $actions;
+			}
+			//If not sysop, remove move button on pathway/gpml/image pages
+			if($ns == NS_PATHWAY || $ns == NS_GPML || $ns == NS_IMAGE || $ns == NS_PATHWAY_TALK) {
+				unset($actions['move']);
+			}
+		}
+		if($wgTitle->getNameSpace() == NS_PATHWAY || NS_PATHWAY_TALK || NS_IMAGE) {
+			$actions = $this->data['content_actions'];
+			$this->data['content_actions'] = $actions;
+		}
+?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="<?php $this->text('xhtmldefaultnamespace') ?>" <?php 
+	foreach($this->data['xhtmlnamespaces'] as $tag => $ns) {
+		?>xmlns:<?php echo "{$tag}=\"{$ns}\" ";
+	} ?>xml:lang="<?php $this->text('lang') ?>" lang="<?php $this->text('lang') ?>" dir="<?php $this->text('dir') ?>">
+	<head>
+		<meta http-equiv="Content-Type" content="<?php $this->text('mimetype') ?>; charset=<?php $this->text('charset') ?>" />
+		<?php $this->html('headlinks') ?>
+		<title><?php $this->text('pagetitle') ?></title>
+		<style type="text/css" media="screen,projection">/*<![CDATA[*/ @import "<?php $this->text('stylepath') ?>/<?php $this->text('stylename') ?>/main.css?<?php echo $GLOBALS['wgStyleVersion'] ?>"; /*]]>*/</style>
+		<link rel="stylesheet" type="text/css" <?php if(empty($this->data['printable']) ) { ?>media="print"<?php } ?> href="<?php $this->text('stylepath') ?>/common/commonPrint.css?<?php echo $GLOBALS['wgStyleVersion'] ?>" />
+		<link rel="stylesheet" type="text/css" media="handheld" href="<?php $this->text('stylepath') ?>/<?php $this->text('stylename') ?>/handheld.css?<?php echo $GLOBALS['wgStyleVersion'] ?>" />
+		<!--[if lt IE 5.5000]><style type="text/css">@import "<?php $this->text('stylepath') ?>/<?php $this->text('stylename') ?>/IE50Fixes.css?<?php echo $GLOBALS['wgStyleVersion'] ?>";</style><![endif]-->
+		<!--[if IE 5.5000]><style type="text/css">@import "<?php $this->text('stylepath') ?>/<?php $this->text('stylename') ?>/IE55Fixes.css?<?php echo $GLOBALS['wgStyleVersion'] ?>";</style><![endif]-->
+		<!--[if IE 6]><style type="text/css">@import "<?php $this->text('stylepath') ?>/<?php $this->text('stylename') ?>/IE60Fixes.css?<?php echo $GLOBALS['wgStyleVersion'] ?>";</style><![endif]-->
+		<!--[if IE 7]><style type="text/css">@import "<?php $this->text('stylepath') ?>/<?php $this->text('stylename') ?>/IE70Fixes.css?<?php echo $GLOBALS['wgStyleVersion'] ?>";</style><![endif]-->
+		<!--[if lt IE 7]><script type="<?php $this->text('jsmimetype') ?>" src="<?php $this->text('stylepath') ?>/common/IEFixes.js?<?php echo $GLOBALS['wgStyleVersion'] ?>"></script>
+		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
+		
+		<?php print Skin::makeGlobalVariablesScript( $this->data ); ?>
+                
+		<script type="<?php $this->text('jsmimetype') ?>" src="<?php $this->text('stylepath' ) ?>/common/wikibits.js?<?php echo $GLOBALS['wgStyleVersion'] ?>"><!-- wikibits js --></script>
+<?php	if($this->data['jsvarurl'  ]) { ?>
+		<script type="<?php $this->text('jsmimetype') ?>" src="<?php $this->text('jsvarurl'  ) ?>"><!-- site js --></script>
+<?php	} ?>
+<?php	if($this->data['pagecss'   ]) { ?>
+		<style type="text/css"><?php $this->html('pagecss'   ) ?></style>
+<?php	}
+		if($this->data['usercss'   ]) { ?>
+		<style type="text/css"><?php $this->html('usercss'   ) ?></style>
+<?php	}
+		if($this->data['userjs'    ]) { ?>
+		<script type="<?php $this->text('jsmimetype') ?>" src="<?php $this->text('userjs' ) ?>"></script>
+<?php	}
+		if($this->data['userjsprev']) { ?>
+		<script type="<?php $this->text('jsmimetype') ?>"><?php $this->html('userjsprev') ?></script>
+<?php	}
+		if($this->data['trackbackhtml']) print $this->data['trackbackhtml']; ?>
+		<!-- Head Scripts -->
+		<?php $this->html('headscripts') ?>
+	</head>
+<body <?php if($this->data['body_ondblclick']) { ?>ondblclick="<?php $this->text('body_ondblclick') ?>"<?php } ?>
+<?php if($this->data['body_onload'    ]) { ?>onload="<?php     $this->text('body_onload')     ?>"<?php } ?>
+ class="mediawiki <?php $this->text('nsclass') ?> <?php $this->text('dir') ?> <?php $this->text('pageclass') ?>">
+	<div id="globalWrapper">
+		<div id="column-content">
+	<div id="content">
+		<a name="top" id="top"></a>
+		<?php if($this->data['sitenotice']) { ?><div id="siteNotice"><?php $this->html('sitenotice') ?></div><?php } ?>
+		<h1 class="firstHeading"><?php $this->data['displaytitle']!=""?$this->html('title'):$this->text('title') ?></h1>
+		<div id="bodyContent">
+			<h3 id="siteSub"><?php $this->msg('tagline') ?></h3>
+			<div id="contentSub"><?php $this->html('subtitle') ?></div>
+			<?php if($this->data['undelete']) { ?><div id="contentSub2"><?php     $this->html('undelete') ?></div><?php } ?>
+			<?php if($this->data['newtalk'] ) { ?><div class="usermessage"><?php $this->html('newtalk')  ?></div><?php } ?>
+			<?php if($this->data['showjumplinks']) { ?><div id="jump-to-nav"><?php $this->msg('jumpto') ?> <a href="#column-one"><?php $this->msg('jumptonavigation') ?></a>, <a href="#searchInput"><?php $this->msg('jumptosearch') ?></a></div><?php } ?>
+			<!-- start content -->
+			<?php $this->html('bodytext') ?>
+			<?php if($this->data['catlinks']) { ?><div id="catlinks"><?php       $this->html('catlinks') ?></div><?php } ?>
+			<!-- end content -->
+			<div class="visualClear"></div>
+		</div>
+	</div>
+		</div>
+		<div id="column-one">
+	<div id="p-cactions" class="portlet">
+		<h5><?php $this->msg('views') ?></h5>
+		<div class="pBody">
+			<ul>
+	<?php			foreach($this->data['content_actions'] as $key => $tab) { ?>
+					 <li id="ca-<?php echo Sanitizer::escapeId($key) ?>"<?php
+					 	if($tab['class']) { ?> class="<?php echo htmlspecialchars($tab['class']) ?>"<?php }
+					 ?>><a href="<?php echo htmlspecialchars($tab['href']) ?>"><?php
+					 echo htmlspecialchars($tab['text']) ?></a></li>
+	<?php			 } ?>
+			</ul>
+		</div>
+	</div>
+	<div class="portlet" id="p-personal">
+		<h5><?php $this->msg('personaltools') ?></h5>
+		<div class="pBody">
+			<ul>
+<?php 			foreach($this->data['personal_urls'] as $key => $item) { ?>
+				<li id="pt-<?php echo Sanitizer::escapeId($key) ?>"<?php
+					if ($item['active']) { ?> class="active"<?php } ?>><a href="<?php
+				echo htmlspecialchars($item['href']) ?>"<?php
+				if(!empty($item['class'])) { ?> class="<?php
+				echo htmlspecialchars($item['class']) ?>"<?php } ?>><?php
+				echo htmlspecialchars($item['text']) ?></a></li>
+<?php			} ?>
+			</ul>
+		</div>
+	</div>
+	<div class="portlet" id="p-logo">
+		<a style="background-image: url(<?php $this->text('logopath') ?>);" <?php
+			?>href="<?php echo htmlspecialchars($this->data['nav_urls']['mainpage']['href'])?>" <?php
+			?>title="<?php $this->msg('mainpage') ?>"></a>
+	</div>
+	<script type="<?php $this->text('jsmimetype') ?>"> if (window.isMSIE55) fixalpha(); </script>
+	<?php foreach ($this->data['sidebar'] as $bar => $cont) { ?>
+	<div class='portlet' id='p-<?php echo Sanitizer::escapeId($bar) ?>'>
+		<h5><?php $out = wfMsg( $bar ); if (wfEmptyMsg($bar, $out)) echo $bar; else echo $out; ?></h5>
+		<div class='pBody'>
+			<ul>
+<?php 			foreach($cont as $key => $val) { ?>
+				<li id="<?php echo Sanitizer::escapeId($val['id']) ?>"<?php
+					if ( $val['active'] ) { ?> class="active" <?php }
+				?>><a href="<?php echo htmlspecialchars($val['href']) ?>"><?php echo htmlspecialchars($val['text']) ?></a></li>
+<?php			} ?>
+			</ul>
+		</div>
+	</div>
+	<?php } ?>
+
+<!-- AP20070723 Hide old search
+ 	<div id="p-search" class="portlet">
+		<h5><label for="searchInput">Pathway search</label></h5>
+		<div id="searchBody" class="pBody">
+ 			<form action="<?php $this->text('searchaction') ?>" id="searchform"><div>
+ 				<input id="searchInput" name="search" type="text" <?php
+ 					if($this->haveMsg('accesskey-search')) {
+ 						?>accesskey="<?php $this->msg('accesskey-search') ?>"<?php }
+ 					if( isset( $this->data['search'] ) ) {
+ 						?> value="<?php $this->text('search') ?>"<?php } ?> />
+ 				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="<?php $this->msg('searchbutton') ?>" />
+ 			</div></form>
+ 		</div>
+ 	</div>
+ -->
+	<div id="p-search" class="portlet">
+		<h5><label for="searchInput">search</label></h5>
+		<div id="googleSearch" class="pBody">
+			<!-- Google CSE Search Box Begins -->
+		  <form id="searchbox_002915365922082279465:6qd0wwvwtwu" action="http://www.wikipathways.org/index.php/WikiPathways:GoogleSearch"><div>
+		    <input type="hidden" name="cx" value="002915365922082279465:6qd0wwvwtwu" />
+		    <input type="hidden" name="cof" value="FORID:11" />
+	    	    <input type="hidden" name="filter" value="0" /> <!--set filter=0 to disable omitting similiar hits-->
+		    <input name="q" type="text" size="15%"/>
+		    <input type="submit" name="sa" value="Search" />
+		  </div></form>
+		  <script type="text/javascript" src="http://www.google.com/coop/cse/brand?form=searchbox_002915365922082279465%3A6qd0wwvwtwu"></script>
+<!-- Google CSE Search Box Ends -->
+		</div>
+	</div>
+	<div class="portlet" id="p-tb">
+		<h5><?php $this->msg('toolbox') ?></h5>
+		<div class="pBody">
+			<ul>
+<?php
+		if($this->data['notspecialpage']) { ?>
+				<li id="t-whatlinkshere"><a href="<?php
+				echo htmlspecialchars($this->data['nav_urls']['whatlinkshere']['href'])
+				?>"><?php $this->msg('whatlinkshere') ?></a></li>
+<?php
+			if( $this->data['nav_urls']['recentchangeslinked'] ) { ?>
+				<li id="t-recentchangeslinked"><a href="<?php
+				echo htmlspecialchars($this->data['nav_urls']['recentchangeslinked']['href'])
+				?>"><?php $this->msg('recentchangeslinked') ?></a></li>
+<?php 		}
+		}
+		if(isset($this->data['nav_urls']['trackbacklink'])) { ?>
+			<li id="t-trackbacklink"><a href="<?php
+				echo htmlspecialchars($this->data['nav_urls']['trackbacklink']['href'])
+				?>"><?php $this->msg('trackbacklink') ?></a></li>
+<?php 	}
+		if($this->data['feeds']) { ?>
+			<li id="feedlinks"><?php foreach($this->data['feeds'] as $key => $feed) {
+					?><span id="feed-<?php echo Sanitizer::escapeId($key) ?>"><a href="<?php
+					echo htmlspecialchars($feed['href']) ?>"><?php echo htmlspecialchars($feed['text'])?></a>&nbsp;</span>
+					<?php } ?></li><?php
+		}
+		
+		//APR20072504 -> removed 'upload' element from array
+		foreach( array('contributions', 'blockip', 'emailuser', 'specialpages') as $special ) {
+
+			if($this->data['nav_urls'][$special]) {
+				?><li id="t-<?php echo $special ?>"><a href="<?php echo htmlspecialchars($this->data['nav_urls'][$special]['href'])
+				?>"><?php $this->msg($special) ?></a></li>
+<?php		}
+		}
+
+		if(!empty($this->data['nav_urls']['print']['href'])) { ?>
+				<li id="t-print"><a href="<?php echo htmlspecialchars($this->data['nav_urls']['print']['href'])
+				?>"><?php $this->msg('printableversion') ?></a></li><?php
+		}
+
+		if(!empty($this->data['nav_urls']['permalink']['href'])) { ?>
+				<li id="t-permalink"><a href="<?php echo htmlspecialchars($this->data['nav_urls']['permalink']['href'])
+				?>"><?php $this->msg('permalink') ?></a></li><?php
+		} elseif ($this->data['nav_urls']['permalink']['href'] === '') { ?>
+				<li id="t-ispermalink"><?php $this->msg('permalink') ?></li><?php
+		}
+
+		wfRunHooks( 'WikiPathwaysTemplateToolboxEnd', array( &$this ) );
+?>
+			</ul>
+		</div>
+	</div>
+<?php
+		if( $this->data['language_urls'] ) { ?>
+	<div id="p-lang" class="portlet">
+		<h5><?php $this->msg('otherlanguages') ?></h5>
+		<div class="pBody">
+			<ul>
+<?php		foreach($this->data['language_urls'] as $langlink) { ?>
+				<li class="<?php echo htmlspecialchars($langlink['class'])?>"><?php
+				?><a href="<?php echo htmlspecialchars($langlink['href']) ?>"><?php echo $langlink['text'] ?></a></li>
+<?php		} ?>
+			</ul>
+		</div>
+	</div>
+<?php	} ?>
+		</div><!-- end of the left (by default at least) column -->
+			<div class="visualClear"></div>
+			<div id="footer">
+<?php
+		if($this->data['poweredbyico']) { ?>
+				<div id="f-poweredbyico"><?php $this->html('poweredbyico') ?></div>
+<?php 	}
+		if($this->data['copyrightico']) { ?>
+				<div id="f-copyrightico"><?php $this->html('copyrightico') ?></div>
+<?php	}
+
+		// Generate additional footer links
+?>
+			<ul id="f-list">
+<?php
+		$footerlinks = array(
+			'lastmod', 'viewcount', 'numberofwatchingusers', 'credits', 'copyright',
+			'privacy', 'about', 'disclaimer', 'tagline',
+		);
+		foreach( $footerlinks as $aLink ) {
+			if( isset( $this->data[$aLink] ) && $this->data[$aLink] ) {
+?>				<li id="<?php echo$aLink?>"><?php $this->html($aLink) ?></li>
+<?php 		}
+		}
+?>
+			</ul>
+		</div>
+		
+	<?php $this->html('bottomscripts'); /* JS call to runBodyOnloadHook */ ?>
+</div>
+<?php $this->html('reporttime') ?>
+<?php if ( $this->data['debug'] ): ?>
+<!-- Debug output:
+<?php $this->text( 'debug' ); ?>
+
+-->
+<?php endif; ?>
+</body></html>
+<?php
+	wfRestoreWarnings();
+	} // end of execute() method
+} // end of class
+?>
